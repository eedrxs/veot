import BigNumber$1 from 'https://unpkg.com/bignumber.js@9.0.2/bignumber.mjs';

class Key$1 {}

/**
 * @typedef {import("./PrivateKey.js").default} PrivateKey
 * @typedef {import("./Ed25519PrivateKey.js").default} Ed25519PrivateKey
 * @typedef {import("./EcdsaPrivateKey.js").default} EcdsaPrivateKey
 */

const CACHE$1 = {
    /** @type {((key: Ed25519PrivateKey | EcdsaPrivateKey) => PrivateKey) | null} */
    privateKeyConstructor: null,

    /** @type {((bytes: Uint8Array) => PrivateKey) | null} */
    privateKeyFromBytes: null,
};

/**
 * Signals that a key could not be realized from the input.
 */
class BadKeyError extends Error {
    /**
     * @param {Error | string} messageOrCause
     */
    constructor(messageOrCause) {
        super(
            messageOrCause instanceof Error
                ? messageOrCause.message
                : messageOrCause
        );

        this.name = "BadKeyError";

        if (messageOrCause instanceof Error) {
            /** @type {Error=} */
            this.cause = messageOrCause;
            this.stack = messageOrCause.stack;
        }
    }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromNamespaceIfPresent$1 (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

function commonjsRequire (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var naclFast = {exports: {}};

var _nodeResolve_empty = {};

var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _nodeResolve_empty
});

var require$$0$1 = /*@__PURE__*/getDefaultExportFromNamespaceIfPresent$1(_nodeResolve_empty$1);

(function (module) {
(function(nacl) {

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (typeof commonjsRequire !== 'undefined') {
    // Node.js.
    crypto = require$$0$1;
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})(module.exports ? module.exports : (self.nacl = self.nacl || {}));
}(naclFast));

var nacl = naclFast.exports;

/**
 * @param {Uint8Array} array1
 * @param {Uint8Array} array2
 * @returns {boolean}
 */
function arrayEqual$1(array1, array2) {
    if (array1 === array2) {
        return true;
    }

    if (array1.byteLength !== array2.byteLength) {
        return false;
    }

    const view1 = new DataView(
        array1.buffer,
        array1.byteOffset,
        array1.byteLength
    );
    const view2 = new DataView(
        array2.buffer,
        array2.byteOffset,
        array2.byteLength
    );

    let i = array1.byteLength;

    while (i--) {
        if (view1.getUint8(i) !== view2.getUint8(i)) {
            return false;
        }
    }

    return true;
}

/**
 * @param {Uint8Array} array
 * @param {Uint8Array} arrayPrefix
 * @returns {boolean}
 */
function arrayStartsWith(array, arrayPrefix) {
    if (array.byteLength < arrayPrefix.byteLength) {
        return false;
    }

    let i = arrayPrefix.byteLength;

    while (i--) {
        if (array[i] !== arrayPrefix[i]) {
            return false;
        }
    }

    return true;
}

/**
 * @type {string[]}
 */
const byteToHex$1 = [];

for (let n = 0; n <= 0xff; n += 1) {
    byteToHex$1.push(n.toString(16).padStart(2, "0"));
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
function encode$3(data) {
    let string = "";

    for (const byte of data) {
        string += byteToHex$1[byte];
    }

    return string;
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
function decode$5(text) {
    const str = text.startsWith("0x") ? text.substring(2) : text;
    const result = str.match(/.{1,2}/gu);

    return new Uint8Array(
        (result == null ? [] : result).map((byte) => parseInt(byte, 16))
    );
}

const derPrefix$3 = "302a300506032b6570032100";
const derPrefixBytes$3 = decode$5(derPrefix$3);

/**
 * An public key on the Hedera network.
 */
class Ed25519PublicKey extends Key$1 {
    /**
     * @internal
     * @hideconstructor
     * @param {Uint8Array} keyData
     */
    constructor(keyData) {
        super();

        /**
         * @type {Uint8Array}
         * @private
         * @readonly
         */
        this._keyData = keyData;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return "ED25519";
    }

    /**
     * @param {Uint8Array} data
     * @returns {Ed25519PublicKey}
     */
    static fromBytes(data) {
        switch (data.length) {
            case 32:
                return Ed25519PublicKey.fromBytesRaw(data);
            case 44:
                return Ed25519PublicKey.fromBytesDer(data);
            default:
                throw new BadKeyError(
                    `invalid public key length: ${data.length} bytes`
                );
        }
    }

    /**
     * @param {Uint8Array} data
     * @returns {Ed25519PublicKey}
     */
    static fromBytesDer(data) {
        if (data.length != 44 || !arrayStartsWith(data, derPrefixBytes$3)) {
            throw new BadKeyError(
                `invalid public key length: ${data.length} bytes`
            );
        }

        return new Ed25519PublicKey(data.subarray(12));
    }

    /**
     * @param {Uint8Array} data
     * @returns {Ed25519PublicKey}
     */
    static fromBytesRaw(data) {
        if (data.length != 32) {
            throw new BadKeyError(
                `invalid public key length: ${data.length} bytes`
            );
        }

        return new Ed25519PublicKey(data);
    }

    /**
     * Parse a public key from a string of hexadecimal digits.
     *
     * The public key may optionally be prefixed with
     * the DER header.
     *
     * @param {string} text
     * @returns {Ed25519PublicKey}
     */
    static fromString(text) {
        return Ed25519PublicKey.fromBytes(decode$5(text));
    }

    /**
     * Verify a signature on a message with this public key.
     *
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {boolean}
     */
    verify(message, signature) {
        return nacl.sign.detached.verify(message, signature, this._keyData);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        const bytes = new Uint8Array(derPrefixBytes$3.length + 32);

        bytes.set(derPrefixBytes$3, 0);
        bytes.set(this._keyData.subarray(0, 32), derPrefixBytes$3.length);

        return bytes;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._keyData.slice();
    }

    /**
     * @param {Ed25519PublicKey} other
     * @returns {boolean}
     */
    equals(other) {
        return arrayEqual$1(this._keyData, other._keyData);
    }
}

/**
 * @param {number} count
 * @returns {Uint8Array}
 */
function bytes(count) {
    return nacl.randomBytes(count);
}

/**
 * @param {number} count
 * @returns {Promise<Uint8Array>}
 */
function bytesAsync(count) {
    return Promise.resolve(nacl.randomBytes(count));
}

const derPrefix$2 = "302e020100300506032b657004220420";
const derPrefixBytes$2 = decode$5(derPrefix$2);

class Ed25519PrivateKey {
    /**
     * @hideconstructor
     * @internal
     * @param {nacl.SignKeyPair | Uint8Array} keyPair
     * @param {Uint8Array=} chainCode
     */
    constructor(keyPair, chainCode) {
        /**
         * @type {nacl.SignKeyPair}
         * @readonly
         * @private
         */
        this._keyPair =
            keyPair instanceof Uint8Array
                ? nacl.sign.keyPair.fromSeed(keyPair)
                : keyPair;

        /**
         * @type {?Uint8Array}
         * @readonly
         */
        this._chainCode = chainCode != null ? chainCode : null;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return "ED25519";
    }

    /**
     * Generate a random Ed25519 private key.
     *
     * @returns {Ed25519PrivateKey}
     */
    static generate() {
        // 32 bytes for the secret key
        // 32 bytes for the chain code (to support derivation)
        const entropy = bytes(64);

        return new Ed25519PrivateKey(
            nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
            entropy.subarray(32)
        );
    }

    /**
     * Generate a random Ed25519 private key.
     *
     * @returns {Promise<Ed25519PrivateKey>}
     */
    static async generateAsync() {
        // 32 bytes for the secret key
        // 32 bytes for the chain code (to support derivation)
        const entropy = await bytesAsync(64);

        return new Ed25519PrivateKey(
            nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
            entropy.subarray(32)
        );
    }

    /**
     * Construct a private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {Ed25519PrivateKey}
     */
    static fromBytes(data) {
        switch (data.length) {
            case 48:
                return Ed25519PrivateKey.fromBytesDer(data);
            case 32:
            case 64:
                return Ed25519PrivateKey.fromBytesRaw(data);
            default:
                throw new BadKeyError(
                    `invalid private key length: ${data.length} bytes`
                );
        }
    }

    /**
     * Construct a private key from bytes with DER header.
     *
     * @param {Uint8Array} data
     * @returns {Ed25519PrivateKey}
     */
    static fromBytesDer(data) {
        if (data.length != 48 || !arrayStartsWith(data, derPrefixBytes$2)) {
            throw new BadKeyError(
                `invalid private key length: ${data.length} bytes`
            );
        }

        const keyPair = nacl.sign.keyPair.fromSeed(data.subarray(16));

        return new Ed25519PrivateKey(keyPair);
    }

    /**
     * Construct a private key from bytes without DER header.
     *
     * @param {Uint8Array} data
     * @returns {Ed25519PrivateKey}
     */
    static fromBytesRaw(data) {
        switch (data.length) {
            case 32:
                return new Ed25519PrivateKey(nacl.sign.keyPair.fromSeed(data));

            case 64:
                // priv + pub key
                return new Ed25519PrivateKey(
                    nacl.sign.keyPair.fromSecretKey(data)
                );
        }

        throw new BadKeyError(
            `invalid private key length: ${data.length} bytes`
        );
    }

    /**
     * Construct a private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {Ed25519PrivateKey}
     */
    static fromString(text) {
        return Ed25519PrivateKey.fromBytes(decode$5(text));
    }

    /**
     * Construct a private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {Ed25519PrivateKey}
     */
    static fromStringDer(text) {
        return Ed25519PrivateKey.fromBytesDer(decode$5(text));
    }

    /**
     * Construct a private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {Ed25519PrivateKey}
     */
    static fromStringRaw(text) {
        return Ed25519PrivateKey.fromBytesRaw(decode$5(text));
    }

    /**
     * Get the public key associated with this private key.
     *
     * The public key can be freely given and used by other parties to verify
     * the signatures generated by this private key.
     *
     * @returns {Ed25519PublicKey}
     */
    get publicKey() {
        return new Ed25519PublicKey(this._keyPair.publicKey);
    }

    /**
     * Sign a message with this private key.
     *
     * @param {Uint8Array} bytes
     * @returns {Uint8Array} - The signature bytes without the message
     */
    sign(bytes) {
        return nacl.sign.detached(bytes, this._keyPair.secretKey);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        const bytes = new Uint8Array(derPrefixBytes$2.length + 32);

        bytes.set(derPrefixBytes$2, 0);
        bytes.set(
            this._keyPair.secretKey.subarray(0, 32),
            derPrefixBytes$2.length
        );

        return bytes;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        // copy the bytes so they can't be modified accidentally
        return this._keyPair.secretKey.slice(0, 32);
    }
}

/**
 * Possible statuses for {@link Mnemonic#validate()}.
 *
 * @readonly
 * @enum {string}
 */
const BadMnemonicReason = Object.freeze({
    /**
     * The mnemonic did not have a supported number of words (12 or 24 for regular and 22 for legacy).
     */
    BadLength: "BadLength",

    /**
     * The mnemonic contained words which were not found in the word list.
     */
    UnknownWords: "UnknownWords",

    /**
     * The checksum encoded in the mnemonic did not match the checksum we just calculated for
     * that mnemonic.
     *
     * 24-word mnemonics have an 8-bit checksum that is appended to the 32 bytes of source entropy
     * after being calculated from it, before being encoded into words.
     *
     * This could happen if two or more of the words were entered out of the original order or
     * replaced with another from the standard word list (as this is only returned if all the words
     * exist in the word list).
     */
    ChecksumMismatch: "ChecksumMismatch",
});

/** @typedef {import("./Mnemonic.js").default} Mnemonic */

class BadMnemonicError extends Error {
    /**
     * @param {Mnemonic} mnemonic
     * @param {string} reason
     * @param {number[]} unknownWordIndices
     * @hideconstructor
     */
    constructor(mnemonic, reason, unknownWordIndices) {
        let reasonMessage;

        switch (reason) {
            case BadMnemonicReason.BadLength:
                reasonMessage = "mnemonic is of an unexpected number of words";
                break;

            case BadMnemonicReason.ChecksumMismatch:
                reasonMessage =
                    "checksum byte in mnemonic did not match the rest of the mnemonic";
                break;

            case BadMnemonicReason.UnknownWords:
                reasonMessage =
                    "mnemonic contained words that are not in the standard word list";
                break;

            default:
                throw new Error(
                    `unexpected value ${reason.toString()} for 'reason'`
                );
        }

        super(`invalid mnemonic: ${reasonMessage}`);

        if (typeof Error.captureStackTrace !== "undefined") {
            Error.captureStackTrace(this, BadMnemonicError);
        }

        this.name = "BadMnemonicError";

        /** The reason for which the mnemonic failed validation. */
        this.reason = reason;

        /** The mnemonic that failed validation. */
        this.mnemonic = mnemonic;

        /**
         * The indices in the mnemonic that were not found in the BIP-39
         * standard English word list.
         */
        this.unknownWordIndices = unknownWordIndices;
    }
}

var legacyWords = [
    "aback",
    "abbey",
    "abbot",
    "abide",
    "ablaze",
    "able",
    "aboard",
    "abode",
    "abort",
    "abound",
    "about",
    "above",
    "abroad",
    "abrupt",
    "absent",
    "absorb",
    "absurd",
    "abuse",
    "accent",
    "accept",
    "access",
    "accord",
    "accuse",
    "ace",
    "ache",
    "aching",
    "acid",
    "acidic",
    "acorn",
    "acre",
    "across",
    "act",
    "action",
    "active",
    "actor",
    "actual",
    "acute",
    "adam",
    "adapt",
    "add",
    "added",
    "addict",
    "adept",
    "adhere",
    "adjust",
    "admire",
    "admit",
    "adobe",
    "adopt",
    "adrift",
    "adult",
    "adverb",
    "advice",
    "aerial",
    "afar",
    "affair",
    "affect",
    "afford",
    "afghan",
    "afield",
    "afloat",
    "afraid",
    "afresh",
    "after",
    "again",
    "age",
    "agency",
    "agenda",
    "agent",
    "aghast",
    "agile",
    "ago",
    "agony",
    "agree",
    "agreed",
    "ahead",
    "aid",
    "aide",
    "aim",
    "air",
    "airman",
    "airy",
    "akin",
    "alarm",
    "alaska",
    "albeit",
    "album",
    "ale",
    "alert",
    "alibi",
    "alice",
    "alien",
    "alight",
    "align",
    "alike",
    "alive",
    "alkali",
    "all",
    "alley",
    "allied",
    "allow",
    "alloy",
    "ally",
    "almond",
    "almost",
    "aloft",
    "alone",
    "along",
    "aloof",
    "aloud",
    "alpha",
    "alpine",
    "also",
    "altar",
    "alter",
    "always",
    "amaze",
    "amazon",
    "amber",
    "ambush",
    "amen",
    "amend",
    "amid",
    "amidst",
    "amiss",
    "among",
    "amount",
    "ample",
    "amuse",
    "anchor",
    "and",
    "andrew",
    "anew",
    "angel",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "annoy",
    "annual",
    "answer",
    "anthem",
    "any",
    "anyhow",
    "anyway",
    "apart",
    "apathy",
    "apex",
    "apiece",
    "appeal",
    "appear",
    "apple",
    "apply",
    "april",
    "apron",
    "arab",
    "arcade",
    "arcane",
    "arch",
    "arctic",
    "ardent",
    "are",
    "area",
    "argue",
    "arid",
    "arise",
    "ark",
    "arm",
    "armful",
    "army",
    "aroma",
    "around",
    "arouse",
    "array",
    "arrest",
    "arrive",
    "arrow",
    "arson",
    "art",
    "artery",
    "artful",
    "artist",
    "ascent",
    "ash",
    "ashen",
    "ashore",
    "aside",
    "ask",
    "asleep",
    "aspect",
    "assay",
    "assent",
    "assert",
    "assess",
    "asset",
    "assign",
    "assist",
    "assume",
    "assure",
    "asthma",
    "astute",
    "asylum",
    "ate",
    "athens",
    "atlas",
    "atom",
    "atomic",
    "attach",
    "attack",
    "attain",
    "attend",
    "attic",
    "auburn",
    "audio",
    "audit",
    "august",
    "aunt",
    "auntie",
    "aura",
    "austin",
    "author",
    "auto",
    "autumn",
    "avail",
    "avenge",
    "avenue",
    "avert",
    "avid",
    "avoid",
    "await",
    "awake",
    "awaken",
    "award",
    "aware",
    "awash",
    "away",
    "awful",
    "awhile",
    "axe",
    "axes",
    "axiom",
    "axis",
    "axle",
    "aye",
    "babe",
    "baby",
    "bach",
    "back",
    "backup",
    "bacon",
    "bad",
    "badge",
    "badly",
    "bag",
    "baggy",
    "bail",
    "bait",
    "bake",
    "baker",
    "bakery",
    "bald",
    "ball",
    "ballad",
    "ballet",
    "ballot",
    "baltic",
    "bamboo",
    "ban",
    "banal",
    "banana",
    "band",
    "bang",
    "bank",
    "bar",
    "barber",
    "bare",
    "barely",
    "barge",
    "bark",
    "barley",
    "barn",
    "baron",
    "barrel",
    "barren",
    "basalt",
    "base",
    "basic",
    "basil",
    "basin",
    "basis",
    "basket",
    "bass",
    "bat",
    "batch",
    "bath",
    "baton",
    "battle",
    "bay",
    "beach",
    "beacon",
    "beak",
    "beam",
    "bean",
    "bear",
    "beard",
    "beast",
    "beat",
    "beauty",
    "become",
    "bed",
    "beech",
    "beef",
    "beefy",
    "beep",
    "beer",
    "beet",
    "beetle",
    "before",
    "beg",
    "beggar",
    "begin",
    "behalf",
    "behave",
    "behind",
    "beige",
    "being",
    "belief",
    "bell",
    "belly",
    "belong",
    "below",
    "belt",
    "bench",
    "bend",
    "benign",
    "bent",
    "berlin",
    "berry",
    "berth",
    "beset",
    "beside",
    "best",
    "bestow",
    "bet",
    "beta",
    "betray",
    "better",
    "beware",
    "beyond",
    "bias",
    "biceps",
    "bicker",
    "bid",
    "big",
    "bigger",
    "bike",
    "bile",
    "bill",
    "bin",
    "binary",
    "bind",
    "biopsy",
    "birch",
    "bird",
    "birdie",
    "birth",
    "bishop",
    "bit",
    "bitch",
    "bite",
    "bitter",
    "black",
    "blade",
    "blame",
    "bland",
    "blast",
    "blaze",
    "bleak",
    "blend",
    "bless",
    "blew",
    "blind",
    "blink",
    "blip",
    "bliss",
    "blitz",
    "block",
    "blond",
    "blood",
    "bloody",
    "bloom",
    "blot",
    "blouse",
    "blow",
    "blue",
    "bluff",
    "blunt",
    "blur",
    "blush",
    "boar",
    "board",
    "boast",
    "boat",
    "bob",
    "bodily",
    "body",
    "bogus",
    "boil",
    "bold",
    "bolt",
    "bomb",
    "bombay",
    "bond",
    "bone",
    "bonn",
    "bonnet",
    "bonus",
    "bony",
    "book",
    "boom",
    "boost",
    "boot",
    "booth",
    "booze",
    "border",
    "bore",
    "borrow",
    "bosom",
    "boss",
    "boston",
    "both",
    "bother",
    "bottle",
    "bottom",
    "bought",
    "bounce",
    "bound",
    "bounty",
    "bout",
    "bovine",
    "bow",
    "bowel",
    "bowl",
    "box",
    "boy",
    "boyish",
    "brace",
    "brain",
    "brainy",
    "brake",
    "bran",
    "branch",
    "brand",
    "brandy",
    "brass",
    "brave",
    "bravo",
    "brazil",
    "breach",
    "bread",
    "break",
    "breast",
    "breath",
    "bred",
    "breed",
    "breeze",
    "brew",
    "bribe",
    "brick",
    "bride",
    "bridge",
    "brief",
    "bright",
    "brim",
    "brine",
    "bring",
    "brink",
    "brisk",
    "broad",
    "broke",
    "broken",
    "bronze",
    "brook",
    "broom",
    "brown",
    "bruise",
    "brush",
    "brutal",
    "brute",
    "bubble",
    "buck",
    "bucket",
    "buckle",
    "budget",
    "buffet",
    "buggy",
    "build",
    "bulb",
    "bulge",
    "bulk",
    "bulky",
    "bull",
    "bullet",
    "bully",
    "bump",
    "bumpy",
    "bunch",
    "bundle",
    "bunk",
    "bunny",
    "burden",
    "bureau",
    "burial",
    "buried",
    "burly",
    "burn",
    "burnt",
    "burrow",
    "burst",
    "bury",
    "bus",
    "bush",
    "bust",
    "bustle",
    "busy",
    "but",
    "butler",
    "butt",
    "butter",
    "button",
    "buy",
    "buyer",
    "buzz",
    "bye",
    "byte",
    "cab",
    "cabin",
    "cable",
    "cache",
    "cactus",
    "caesar",
    "cage",
    "cairo",
    "cajun",
    "cajole",
    "cake",
    "calf",
    "call",
    "caller",
    "calm",
    "calmly",
    "came",
    "camel",
    "camera",
    "camp",
    "campus",
    "can",
    "canada",
    "canal",
    "canary",
    "cancel",
    "cancer",
    "candid",
    "candle",
    "candy",
    "cane",
    "canine",
    "canoe",
    "canopy",
    "canvas",
    "canyon",
    "cap",
    "cape",
    "car",
    "carbon",
    "card",
    "care",
    "career",
    "caress",
    "cargo",
    "carl",
    "carnal",
    "carol",
    "carp",
    "carpet",
    "carrot",
    "carry",
    "cart",
    "cartel",
    "case",
    "cash",
    "cask",
    "cast",
    "castle",
    "casual",
    "cat",
    "catch",
    "cater",
    "cattle",
    "caught",
    "causal",
    "cause",
    "cave",
    "cease",
    "celery",
    "cell",
    "cellar",
    "celtic",
    "cement",
    "censor",
    "census",
    "cent",
    "cereal",
    "chain",
    "chair",
    "chalk",
    "chalky",
    "champ",
    "chance",
    "change",
    "chant",
    "chaos",
    "chap",
    "chapel",
    "charge",
    "charm",
    "chart",
    "chase",
    "chat",
    "cheap",
    "cheat",
    "check",
    "cheek",
    "cheeky",
    "cheer",
    "cheery",
    "cheese",
    "chef",
    "cheque",
    "cherry",
    "chess",
    "chest",
    "chew",
    "chic",
    "chick",
    "chief",
    "child",
    "chile",
    "chill",
    "chilly",
    "chin",
    "china",
    "chip",
    "choice",
    "choir",
    "choose",
    "chop",
    "choppy",
    "chord",
    "chorus",
    "chose",
    "chosen",
    "chris",
    "chrome",
    "chunk",
    "chunky",
    "church",
    "cider",
    "cigar",
    "cinema",
    "circa",
    "circle",
    "circus",
    "cite",
    "city",
    "civic",
    "civil",
    "clad",
    "claim",
    "clammy",
    "clan",
    "clap",
    "clash",
    "clasp",
    "class",
    "clause",
    "claw",
    "clay",
    "clean",
    "clear",
    "clergy",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climax",
    "climb",
    "clinch",
    "cling",
    "clinic",
    "clip",
    "cloak",
    "clock",
    "clone",
    "close",
    "closer",
    "closet",
    "cloth",
    "cloud",
    "cloudy",
    "clout",
    "clown",
    "club",
    "clue",
    "clumsy",
    "clung",
    "clutch",
    "coach",
    "coal",
    "coarse",
    "coast",
    "coat",
    "coax",
    "cobalt",
    "cobra",
    "coca",
    "cock",
    "cocoa",
    "code",
    "coffee",
    "coffin",
    "cohort",
    "coil",
    "coin",
    "coke",
    "cold",
    "collar",
    "colon",
    "colony",
    "colt",
    "column",
    "comb",
    "combat",
    "come",
    "comedy",
    "comic",
    "commit",
    "common",
    "compel",
    "comply",
    "concur",
    "cone",
    "confer",
    "congo",
    "consul",
    "convex",
    "convey",
    "convoy",
    "cook",
    "cool",
    "cope",
    "copper",
    "copy",
    "coral",
    "cord",
    "core",
    "cork",
    "corn",
    "corner",
    "corps",
    "corpse",
    "corpus",
    "cortex",
    "cosmic",
    "cosmos",
    "cost",
    "costly",
    "cotton",
    "couch",
    "cough",
    "could",
    "count",
    "county",
    "coup",
    "couple",
    "coupon",
    "course",
    "court",
    "cousin",
    "cove",
    "cover",
    "covert",
    "cow",
    "coward",
    "cowboy",
    "cozy",
    "crab",
    "crack",
    "cradle",
    "craft",
    "crafty",
    "crag",
    "crane",
    "crash",
    "crate",
    "crater",
    "crawl",
    "crazy",
    "creak",
    "cream",
    "creamy",
    "create",
    "credit",
    "creed",
    "creek",
    "creep",
    "creepy",
    "crept",
    "crest",
    "crew",
    "cried",
    "crime",
    "crisis",
    "crisp",
    "critic",
    "crook",
    "crop",
    "cross",
    "crow",
    "crowd",
    "crown",
    "crude",
    "cruel",
    "cruise",
    "crunch",
    "crush",
    "crust",
    "crux",
    "cry",
    "crypt",
    "cuba",
    "cube",
    "cubic",
    "cuckoo",
    "cuff",
    "cult",
    "cup",
    "curb",
    "cure",
    "curfew",
    "curl",
    "curry",
    "curse",
    "cursor",
    "curve",
    "cuss",
    "custom",
    "cut",
    "cute",
    "cycle",
    "cyclic",
    "cynic",
    "czech",
    "dad",
    "daddy",
    "dagger",
    "daily",
    "dairy",
    "daisy",
    "dale",
    "dam",
    "damage",
    "damp",
    "dampen",
    "dance",
    "danger",
    "danish",
    "dare",
    "dark",
    "darken",
    "darn",
    "dart",
    "dash",
    "data",
    "date",
    "david",
    "dawn",
    "day",
    "dead",
    "deadly",
    "deaf",
    "deal",
    "dealer",
    "dean",
    "dear",
    "death",
    "debate",
    "debit",
    "debris",
    "debt",
    "debtor",
    "decade",
    "decay",
    "decent",
    "decide",
    "deck",
    "decor",
    "decree",
    "deduce",
    "deed",
    "deep",
    "deeply",
    "deer",
    "defeat",
    "defect",
    "defend",
    "defer",
    "define",
    "defy",
    "degree",
    "deity",
    "delay",
    "delete",
    "delhi",
    "delta",
    "demand",
    "demise",
    "demo",
    "demure",
    "denial",
    "denote",
    "dense",
    "dental",
    "deny",
    "depart",
    "depend",
    "depict",
    "deploy",
    "depot",
    "depth",
    "deputy",
    "derive",
    "desert",
    "design",
    "desire",
    "desist",
    "desk",
    "detail",
    "detect",
    "deter",
    "detest",
    "detour",
    "device",
    "devise",
    "devoid",
    "devote",
    "devour",
    "dial",
    "diana",
    "diary",
    "dice",
    "dictum",
    "did",
    "die",
    "diesel",
    "diet",
    "differ",
    "dig",
    "digest",
    "digit",
    "dine",
    "dinghy",
    "dinner",
    "diode",
    "dip",
    "dire",
    "direct",
    "dirt",
    "dirty",
    "disc",
    "disco",
    "dish",
    "disk",
    "dismal",
    "dispel",
    "ditch",
    "dive",
    "divert",
    "divide",
    "divine",
    "dizzy",
    "docile",
    "dock",
    "doctor",
    "dog",
    "dogma",
    "dole",
    "doll",
    "dollar",
    "dolly",
    "domain",
    "dome",
    "domino",
    "donate",
    "done",
    "donkey",
    "donor",
    "doom",
    "door",
    "dorsal",
    "dose",
    "dot",
    "double",
    "doubt",
    "dough",
    "dour",
    "dove",
    "down",
    "dozen",
    "draft",
    "drag",
    "dragon",
    "drain",
    "drama",
    "drank",
    "draw",
    "drawer",
    "dread",
    "dream",
    "dreary",
    "dress",
    "drew",
    "dried",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "driver",
    "drop",
    "drove",
    "drown",
    "drug",
    "drum",
    "drunk",
    "dry",
    "dual",
    "duck",
    "duct",
    "due",
    "duel",
    "duet",
    "duke",
    "dull",
    "duly",
    "dumb",
    "dummy",
    "dump",
    "dune",
    "dung",
    "duress",
    "during",
    "dusk",
    "dust",
    "dusty",
    "dutch",
    "duty",
    "dwarf",
    "dwell",
    "dyer",
    "dying",
    "dynamo",
    "each",
    "eager",
    "eagle",
    "ear",
    "earl",
    "early",
    "earn",
    "earth",
    "ease",
    "easel",
    "easily",
    "east",
    "easter",
    "easy",
    "eat",
    "eaten",
    "eater",
    "echo",
    "eddy",
    "eden",
    "edge",
    "edible",
    "edict",
    "edit",
    "editor",
    "eel",
    "eerie",
    "eerily",
    "effect",
    "effort",
    "egg",
    "ego",
    "eight",
    "eighth",
    "eighty",
    "either",
    "elbow",
    "elder",
    "eldest",
    "elect",
    "eleven",
    "elicit",
    "elite",
    "else",
    "elude",
    "elves",
    "embark",
    "emblem",
    "embryo",
    "emerge",
    "emit",
    "empire",
    "employ",
    "empty",
    "enable",
    "enamel",
    "end",
    "endure",
    "enemy",
    "energy",
    "engage",
    "engine",
    "enjoy",
    "enlist",
    "enough",
    "ensure",
    "entail",
    "enter",
    "entire",
    "entry",
    "envoy",
    "envy",
    "enzyme",
    "epic",
    "epoch",
    "equal",
    "equate",
    "equip",
    "equity",
    "era",
    "erect",
    "eric",
    "erode",
    "erotic",
    "errant",
    "error",
    "escape",
    "escort",
    "essay",
    "essex",
    "estate",
    "esteem",
    "ethic",
    "ethnic",
    "europe",
    "evade",
    "eve",
    "even",
    "event",
    "ever",
    "every",
    "evict",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "exam",
    "exceed",
    "excel",
    "except",
    "excess",
    "excise",
    "excite",
    "excuse",
    "exempt",
    "exert",
    "exile",
    "exist",
    "exit",
    "exodus",
    "exotic",
    "expand",
    "expect",
    "expert",
    "expire",
    "export",
    "expose",
    "extend",
    "extra",
    "eye",
    "eyed",
    "fabric",
    "face",
    "facial",
    "fact",
    "factor",
    "fade",
    "fail",
    "faint",
    "fair",
    "fairly",
    "fairy",
    "faith",
    "fake",
    "falcon",
    "fall",
    "false",
    "falter",
    "fame",
    "family",
    "famine",
    "famous",
    "fan",
    "fancy",
    "far",
    "farce",
    "fare",
    "farm",
    "farmer",
    "fast",
    "fasten",
    "faster",
    "fat",
    "fatal",
    "fate",
    "father",
    "fatty",
    "fault",
    "faulty",
    "fauna",
    "fear",
    "feast",
    "feat",
    "fed",
    "fee",
    "feeble",
    "feed",
    "feel",
    "feet",
    "fell",
    "fellow",
    "felt",
    "female",
    "fence",
    "fend",
    "ferry",
    "fetal",
    "fetch",
    "feudal",
    "fever",
    "few",
    "fewer",
    "fiasco",
    "fiddle",
    "field",
    "fiend",
    "fierce",
    "fiery",
    "fifth",
    "fifty",
    "fig",
    "fight",
    "figure",
    "file",
    "fill",
    "filled",
    "filler",
    "film",
    "filter",
    "filth",
    "filthy",
    "final",
    "finale",
    "find",
    "fine",
    "finery",
    "finger",
    "finish",
    "finite",
    "fire",
    "firm",
    "firmly",
    "first",
    "fiscal",
    "fish",
    "fisher",
    "fist",
    "fit",
    "fitful",
    "five",
    "fix",
    "flag",
    "flair",
    "flak",
    "flame",
    "flank",
    "flap",
    "flare",
    "flash",
    "flask",
    "flat",
    "flavor",
    "flaw",
    "fled",
    "flee",
    "fleece",
    "fleet",
    "flesh",
    "fleshy",
    "flew",
    "flick",
    "flight",
    "flimsy",
    "flint",
    "flirt",
    "float",
    "flock",
    "flood",
    "floor",
    "floppy",
    "flora",
    "floral",
    "flour",
    "flow",
    "flower",
    "fluent",
    "fluffy",
    "fluid",
    "flung",
    "flurry",
    "flush",
    "flute",
    "flux",
    "fly",
    "flyer",
    "foal",
    "foam",
    "focal",
    "focus",
    "fog",
    "foil",
    "fold",
    "folk",
    "follow",
    "folly",
    "fond",
    "fondly",
    "font",
    "food",
    "fool",
    "foot",
    "for",
    "forbid",
    "force",
    "ford",
    "forest",
    "forge",
    "forget",
    "fork",
    "form",
    "formal",
    "format",
    "former",
    "fort",
    "forth",
    "forty",
    "forum",
    "fossil",
    "foster",
    "foul",
    "found",
    "four",
    "fourth",
    "fox",
    "foyer",
    "frail",
    "frame",
    "franc",
    "france",
    "frank",
    "fraud",
    "fred",
    "free",
    "freed",
    "freely",
    "freeze",
    "french",
    "frenzy",
    "fresh",
    "friar",
    "friday",
    "fridge",
    "fried",
    "friend",
    "fright",
    "fringe",
    "frock",
    "frog",
    "from",
    "front",
    "frost",
    "frosty",
    "frown",
    "frozen",
    "frugal",
    "fruit",
    "fry",
    "fudge",
    "fuel",
    "full",
    "fully",
    "fumes",
    "fun",
    "fund",
    "funny",
    "fur",
    "furry",
    "fury",
    "fuse",
    "fusion",
    "fuss",
    "fussy",
    "futile",
    "future",
    "fuzzy",
    "gadget",
    "gain",
    "gala",
    "galaxy",
    "gale",
    "gall",
    "galley",
    "gallon",
    "gallop",
    "gamble",
    "game",
    "gamma",
    "gandhi",
    "gang",
    "gap",
    "garage",
    "garden",
    "garlic",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaunt",
    "gave",
    "gaze",
    "gear",
    "geese",
    "gem",
    "gemini",
    "gender",
    "gene",
    "geneva",
    "genial",
    "genius",
    "genre",
    "gentle",
    "gently",
    "gentry",
    "genus",
    "george",
    "germ",
    "get",
    "ghetto",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "gill",
    "gilt",
    "ginger",
    "girl",
    "give",
    "given",
    "glad",
    "glade",
    "glance",
    "gland",
    "glare",
    "glass",
    "glassy",
    "gleam",
    "glee",
    "glide",
    "global",
    "globe",
    "gloom",
    "gloomy",
    "gloria",
    "glory",
    "gloss",
    "glossy",
    "glove",
    "glow",
    "glue",
    "gnat",
    "gnu",
    "goal",
    "goat",
    "gold",
    "golden",
    "golf",
    "gone",
    "gong",
    "goo",
    "good",
    "goose",
    "gore",
    "gorge",
    "gory",
    "gosh",
    "gospel",
    "gossip",
    "got",
    "gothic",
    "govern",
    "gown",
    "grab",
    "grace",
    "grade",
    "grail",
    "grain",
    "grand",
    "grant",
    "grape",
    "graph",
    "grasp",
    "grass",
    "grassy",
    "grate",
    "grave",
    "gravel",
    "gravy",
    "grease",
    "greasy",
    "great",
    "greece",
    "greed",
    "greedy",
    "greek",
    "green",
    "greet",
    "grew",
    "grey",
    "grid",
    "grief",
    "grill",
    "grim",
    "grin",
    "grind",
    "grip",
    "grit",
    "gritty",
    "groan",
    "groin",
    "groom",
    "groove",
    "gross",
    "ground",
    "group",
    "grove",
    "grow",
    "grown",
    "growth",
    "grudge",
    "grunt",
    "guard",
    "guess",
    "guest",
    "guide",
    "guild",
    "guilt",
    "guilty",
    "guise",
    "guitar",
    "gulf",
    "gully",
    "gun",
    "gunman",
    "guru",
    "gut",
    "guy",
    "gypsy",
    "habit",
    "hack",
    "had",
    "hail",
    "hair",
    "hairy",
    "haiti",
    "hale",
    "half",
    "hall",
    "halt",
    "hamlet",
    "hammer",
    "hand",
    "handle",
    "handy",
    "hang",
    "hangar",
    "hanoi",
    "happen",
    "happy",
    "harass",
    "harbor",
    "hard",
    "harder",
    "hardly",
    "hare",
    "harem",
    "harm",
    "harp",
    "harry",
    "harsh",
    "has",
    "hash",
    "hassle",
    "haste",
    "hasten",
    "hasty",
    "hat",
    "hatch",
    "hate",
    "haul",
    "haunt",
    "havana",
    "have",
    "haven",
    "havoc",
    "hawaii",
    "hawk",
    "hay",
    "hazard",
    "haze",
    "hazel",
    "hazy",
    "head",
    "heal",
    "health",
    "heap",
    "hear",
    "heard",
    "heart",
    "hearth",
    "hearty",
    "heat",
    "heater",
    "heaven",
    "heavy",
    "hebrew",
    "heck",
    "hectic",
    "hedge",
    "heel",
    "hefty",
    "height",
    "heir",
    "held",
    "helium",
    "helix",
    "hell",
    "hello",
    "helm",
    "helmet",
    "help",
    "hemp",
    "hence",
    "henry",
    "her",
    "herald",
    "herb",
    "herd",
    "here",
    "hereby",
    "hermes",
    "hernia",
    "hero",
    "heroic",
    "heroin",
    "hey",
    "heyday",
    "hick",
    "hidden",
    "hide",
    "high",
    "higher",
    "highly",
    "hill",
    "him",
    "hind",
    "hinder",
    "hint",
    "hippie",
    "hire",
    "his",
    "hiss",
    "hit",
    "hive",
    "hoard",
    "hoarse",
    "hobby",
    "hockey",
    "hold",
    "holder",
    "hole",
    "hollow",
    "holly",
    "holy",
    "home",
    "honest",
    "honey",
    "hood",
    "hook",
    "hope",
    "horn",
    "horrid",
    "horror",
    "horse",
    "hose",
    "host",
    "hot",
    "hotel",
    "hound",
    "hour",
    "house",
    "hover",
    "how",
    "huge",
    "hull",
    "human",
    "humane",
    "humble",
    "humid",
    "hung",
    "hunger",
    "hungry",
    "hunt",
    "hurdle",
    "hurl",
    "hurry",
    "hurt",
    "hush",
    "hut",
    "hybrid",
    "hymn",
    "hyphen",
    "ice",
    "icing",
    "icon",
    "idaho",
    "idea",
    "ideal",
    "idiom",
    "idiot",
    "idle",
    "idly",
    "idol",
    "ignite",
    "ignore",
    "ill",
    "image",
    "immune",
    "impact",
    "imply",
    "import",
    "impose",
    "inca",
    "incest",
    "inch",
    "income",
    "incur",
    "indeed",
    "index",
    "india",
    "indian",
    "indoor",
    "induce",
    "inept",
    "inert",
    "infant",
    "infect",
    "infer",
    "influx",
    "inform",
    "inject",
    "injure",
    "injury",
    "ink",
    "inlaid",
    "inland",
    "inlet",
    "inmate",
    "inn",
    "innate",
    "inner",
    "input",
    "insane",
    "insect",
    "insert",
    "inset",
    "inside",
    "insist",
    "insult",
    "insure",
    "intact",
    "intake",
    "intend",
    "inter",
    "into",
    "invade",
    "invent",
    "invest",
    "invite",
    "invoke",
    "inward",
    "iowa",
    "iran",
    "iraq",
    "irish",
    "iron",
    "ironic",
    "irony",
    "isaac",
    "isabel",
    "island",
    "isle",
    "israel",
    "issue",
    "italy",
    "itch",
    "item",
    "itself",
    "ivan",
    "ivory",
    "jack",
    "jacket",
    "jacob",
    "jade",
    "jaguar",
    "jail",
    "james",
    "jane",
    "japan",
    "jargon",
    "java",
    "jaw",
    "jazz",
    "jeep",
    "jelly",
    "jerky",
    "jest",
    "jet",
    "jewel",
    "jewish",
    "jim",
    "job",
    "jock",
    "jockey",
    "joe",
    "john",
    "join",
    "joint",
    "joke",
    "jolly",
    "jolt",
    "jordan",
    "joseph",
    "joy",
    "joyful",
    "joyous",
    "judge",
    "judy",
    "juice",
    "juicy",
    "july",
    "jumble",
    "jumbo",
    "jump",
    "june",
    "jungle",
    "junior",
    "junk",
    "junta",
    "jury",
    "just",
    "kansas",
    "karate",
    "karl",
    "keel",
    "keen",
    "keep",
    "keeper",
    "kenya",
    "kept",
    "kernel",
    "kettle",
    "key",
    "khaki",
    "kick",
    "kid",
    "kidnap",
    "kidney",
    "kill",
    "killer",
    "kin",
    "kind",
    "kindly",
    "king",
    "kiss",
    "kite",
    "kitten",
    "knack",
    "knee",
    "kneel",
    "knew",
    "knife",
    "knight",
    "knit",
    "knob",
    "knock",
    "knot",
    "know",
    "known",
    "koran",
    "korea",
    "kuwait",
    "label",
    "lace",
    "lack",
    "lad",
    "ladder",
    "laden",
    "lady",
    "lagoon",
    "laity",
    "lake",
    "lamb",
    "lame",
    "lamp",
    "lance",
    "land",
    "lane",
    "lap",
    "lapse",
    "large",
    "larval",
    "laser",
    "last",
    "latch",
    "late",
    "lately",
    "latent",
    "later",
    "latest",
    "latin",
    "latter",
    "laugh",
    "launch",
    "lava",
    "lavish",
    "law",
    "lawful",
    "lawn",
    "lawyer",
    "lay",
    "layer",
    "layman",
    "lazy",
    "lead",
    "leader",
    "leaf",
    "leafy",
    "league",
    "leak",
    "leaky",
    "lean",
    "leap",
    "learn",
    "lease",
    "leash",
    "least",
    "leave",
    "led",
    "ledge",
    "left",
    "leg",
    "legacy",
    "legal",
    "legend",
    "legion",
    "lemon",
    "lend",
    "length",
    "lens",
    "lent",
    "leo",
    "leper",
    "lesion",
    "less",
    "lessen",
    "lesser",
    "lesson",
    "lest",
    "let",
    "lethal",
    "letter",
    "level",
    "lever",
    "levy",
    "lewis",
    "liable",
    "liar",
    "libel",
    "libya",
    "lice",
    "lick",
    "lid",
    "lie",
    "lied",
    "lier",
    "life",
    "lift",
    "light",
    "like",
    "likely",
    "limb",
    "lime",
    "limit",
    "limp",
    "line",
    "linear",
    "linen",
    "linger",
    "link",
    "lint",
    "lion",
    "lip",
    "liquid",
    "liquor",
    "list",
    "listen",
    "lit",
    "live",
    "lively",
    "liver",
    "liz",
    "lizard",
    "load",
    "loaf",
    "loan",
    "lobby",
    "lobe",
    "local",
    "locate",
    "lock",
    "locus",
    "lodge",
    "loft",
    "lofty",
    "log",
    "logic",
    "logo",
    "london",
    "lone",
    "lonely",
    "long",
    "longer",
    "look",
    "loop",
    "loose",
    "loosen",
    "loot",
    "lord",
    "lorry",
    "lose",
    "loss",
    "lost",
    "lot",
    "lotion",
    "lotus",
    "loud",
    "loudly",
    "lounge",
    "lousy",
    "love",
    "lovely",
    "lover",
    "low",
    "lower",
    "lowest",
    "loyal",
    "lucid",
    "luck",
    "lucky",
    "lucy",
    "lull",
    "lump",
    "lumpy",
    "lunacy",
    "lunar",
    "lunch",
    "lung",
    "lure",
    "lurid",
    "lush",
    "lust",
    "lute",
    "luther",
    "luxury",
    "lying",
    "lymph",
    "lynch",
    "lyric",
    "macho",
    "macro",
    "mad",
    "madam",
    "made",
    "mafia",
    "magic",
    "magma",
    "magnet",
    "magnum",
    "magpie",
    "maid",
    "maiden",
    "mail",
    "main",
    "mainly",
    "major",
    "make",
    "maker",
    "male",
    "malice",
    "mall",
    "malt",
    "mammal",
    "manage",
    "mane",
    "mania",
    "manic",
    "manner",
    "manor",
    "mantle",
    "manual",
    "manure",
    "many",
    "map",
    "maple",
    "marble",
    "march",
    "mare",
    "margin",
    "maria",
    "marina",
    "mark",
    "market",
    "marry",
    "mars",
    "marsh",
    "martin",
    "martyr",
    "mary",
    "mask",
    "mason",
    "mass",
    "mast",
    "master",
    "mat",
    "match",
    "mate",
    "matrix",
    "matter",
    "mature",
    "maxim",
    "may",
    "maybe",
    "mayor",
    "maze",
    "mead",
    "meadow",
    "meal",
    "mean",
    "meant",
    "meat",
    "medal",
    "media",
    "median",
    "medic",
    "medium",
    "meet",
    "mellow",
    "melody",
    "melon",
    "melt",
    "member",
    "memo",
    "memory",
    "menace",
    "mend",
    "mental",
    "mentor",
    "menu",
    "mercy",
    "mere",
    "merely",
    "merge",
    "merger",
    "merit",
    "merry",
    "mesh",
    "mess",
    "messy",
    "met",
    "metal",
    "meter",
    "method",
    "methyl",
    "metric",
    "metro",
    "mexico",
    "miami",
    "mickey",
    "mid",
    "midday",
    "middle",
    "midst",
    "midway",
    "might",
    "mighty",
    "mild",
    "mildew",
    "mile",
    "milk",
    "milky",
    "mill",
    "mimic",
    "mince",
    "mind",
    "mine",
    "mini",
    "mink",
    "minor",
    "mint",
    "minus",
    "minute",
    "mire",
    "mirror",
    "mirth",
    "misery",
    "miss",
    "mist",
    "misty",
    "mite",
    "mix",
    "moan",
    "moat",
    "mob",
    "mobile",
    "mock",
    "mode",
    "model",
    "modem",
    "modern",
    "modest",
    "modify",
    "module",
    "moist",
    "molar",
    "mold",
    "mole",
    "molten",
    "moment",
    "monday",
    "money",
    "monk",
    "monkey",
    "month",
    "mood",
    "moody",
    "moon",
    "moor",
    "moral",
    "morale",
    "morbid",
    "more",
    "morgue",
    "mortal",
    "mortar",
    "mosaic",
    "moscow",
    "moses",
    "mosque",
    "moss",
    "most",
    "mostly",
    "moth",
    "mother",
    "motion",
    "motive",
    "motor",
    "mount",
    "mourn",
    "mouse",
    "mouth",
    "move",
    "movie",
    "mrs",
    "much",
    "muck",
    "mucus",
    "mud",
    "muddle",
    "muddy",
    "mule",
    "mummy",
    "munich",
    "murder",
    "murky",
    "murmur",
    "muscle",
    "museum",
    "music",
    "mussel",
    "must",
    "mutant",
    "mute",
    "mutiny",
    "mutter",
    "mutton",
    "mutual",
    "muzzle",
    "myopic",
    "myriad",
    "myself",
    "mystic",
    "myth",
    "nadir",
    "nail",
    "naked",
    "name",
    "namely",
    "nape",
    "napkin",
    "naples",
    "narrow",
    "nasal",
    "nasty",
    "nathan",
    "nation",
    "native",
    "nature",
    "nausea",
    "naval",
    "nave",
    "navy",
    "near",
    "nearer",
    "nearly",
    "neat",
    "neatly",
    "neck",
    "need",
    "needle",
    "needy",
    "negate",
    "neon",
    "nepal",
    "nephew",
    "nerve",
    "nest",
    "net",
    "neural",
    "never",
    "newly",
    "next",
    "nice",
    "nicely",
    "niche",
    "nickel",
    "niece",
    "night",
    "nile",
    "nimble",
    "nine",
    "ninety",
    "ninth",
    "nobel",
    "noble",
    "nobody",
    "node",
    "noise",
    "noisy",
    "none",
    "noon",
    "nor",
    "norm",
    "normal",
    "north",
    "norway",
    "nose",
    "nosy",
    "not",
    "note",
    "notice",
    "notify",
    "notion",
    "noun",
    "novel",
    "novice",
    "now",
    "nozzle",
    "null",
    "numb",
    "number",
    "nurse",
    "nut",
    "nylon",
    "nymph",
    "oak",
    "oar",
    "oasis",
    "oath",
    "obese",
    "obey",
    "object",
    "oblige",
    "oboe",
    "obtain",
    "obtuse",
    "occult",
    "occupy",
    "occur",
    "ocean",
    "octave",
    "odd",
    "off",
    "offend",
    "offer",
    "office",
    "offset",
    "often",
    "ohio",
    "oil",
    "oily",
    "okay",
    "old",
    "older",
    "oldest",
    "olive",
    "omega",
    "omen",
    "omit",
    "once",
    "one",
    "onion",
    "only",
    "onset",
    "onto",
    "onus",
    "onward",
    "opaque",
    "open",
    "openly",
    "opera",
    "opium",
    "oppose",
    "optic",
    "option",
    "oracle",
    "oral",
    "orange",
    "orbit",
    "orchid",
    "ordeal",
    "order",
    "organ",
    "orgasm",
    "orient",
    "origin",
    "ornate",
    "orphan",
    "oscar",
    "other",
    "otter",
    "ought",
    "ounce",
    "our",
    "out",
    "outer",
    "output",
    "outset",
    "oval",
    "oven",
    "over",
    "overt",
    "owe",
    "owing",
    "owl",
    "own",
    "owner",
    "oxford",
    "oxide",
    "oxygen",
    "oyster",
    "ozone",
    "pace",
    "pack",
    "packet",
    "pact",
    "pad",
    "paddle",
    "paddy",
    "pagan",
    "page",
    "paid",
    "pain",
    "paint",
    "pair",
    "palace",
    "pale",
    "palm",
    "pan",
    "panama",
    "panel",
    "panic",
    "papa",
    "papal",
    "paper",
    "parade",
    "parcel",
    "pardon",
    "parent",
    "paris",
    "parish",
    "park",
    "parody",
    "parrot",
    "part",
    "partly",
    "party",
    "pascal",
    "pass",
    "past",
    "paste",
    "pastel",
    "pastor",
    "pastry",
    "pat",
    "patch",
    "patent",
    "path",
    "patio",
    "patrol",
    "patron",
    "paul",
    "pause",
    "pave",
    "paw",
    "pawn",
    "pay",
    "peace",
    "peach",
    "peak",
    "pear",
    "pearl",
    "pedal",
    "peel",
    "peer",
    "peking",
    "pelvic",
    "pelvis",
    "pen",
    "penal",
    "pence",
    "pencil",
    "penny",
    "people",
    "pepper",
    "per",
    "perch",
    "peril",
    "period",
    "perish",
    "permit",
    "person",
    "peru",
    "pest",
    "pet",
    "peter",
    "petite",
    "petrol",
    "petty",
    "phase",
    "philip",
    "phone",
    "photo",
    "phrase",
    "piano",
    "pick",
    "picket",
    "picnic",
    "pie",
    "piece",
    "pier",
    "pierce",
    "piety",
    "pig",
    "pigeon",
    "piggy",
    "pike",
    "pile",
    "pill",
    "pillar",
    "pillow",
    "pilot",
    "pin",
    "pinch",
    "pine",
    "pink",
    "pint",
    "pious",
    "pipe",
    "pirate",
    "piss",
    "pistol",
    "piston",
    "pit",
    "pitch",
    "pity",
    "pivot",
    "pixel",
    "pizza",
    "place",
    "placid",
    "plague",
    "plain",
    "plan",
    "plane",
    "planet",
    "plank",
    "plant",
    "plasma",
    "plate",
    "play",
    "player",
    "plea",
    "plead",
    "please",
    "pledge",
    "plenty",
    "plight",
    "plot",
    "plough",
    "ploy",
    "plug",
    "plum",
    "plump",
    "plunge",
    "plural",
    "plus",
    "plush",
    "pocket",
    "poem",
    "poet",
    "poetic",
    "poetry",
    "point",
    "poison",
    "poland",
    "polar",
    "pole",
    "police",
    "policy",
    "polish",
    "polite",
    "poll",
    "pollen",
    "polo",
    "pond",
    "ponder",
    "pony",
    "pool",
    "poor",
    "poorly",
    "pop",
    "poppy",
    "pore",
    "pork",
    "port",
    "portal",
    "pose",
    "posh",
    "post",
    "postal",
    "pot",
    "potato",
    "potent",
    "pouch",
    "pound",
    "pour",
    "powder",
    "power",
    "praise",
    "pray",
    "prayer",
    "preach",
    "prefer",
    "prefix",
    "press",
    "pretty",
    "price",
    "pride",
    "priest",
    "primal",
    "prime",
    "prince",
    "print",
    "prior",
    "prism",
    "prison",
    "privy",
    "prize",
    "probe",
    "profit",
    "prompt",
    "prone",
    "proof",
    "propel",
    "proper",
    "prose",
    "proton",
    "proud",
    "prove",
    "proven",
    "proxy",
    "prune",
    "pry",
    "psalm",
    "pseudo",
    "psyche",
    "pub",
    "public",
    "puff",
    "pull",
    "pulp",
    "pulpit",
    "pulsar",
    "pulse",
    "pump",
    "punch",
    "punish",
    "punk",
    "pupil",
    "puppet",
    "puppy",
    "pure",
    "purely",
    "purge",
    "purify",
    "purple",
    "purse",
    "pursue",
    "push",
    "pushy",
    "put",
    "putt",
    "puzzle",
    "quaint",
    "quake",
    "quarry",
    "quart",
    "quartz",
    "quebec",
    "queen",
    "queer",
    "query",
    "quest",
    "queue",
    "quick",
    "quid",
    "quiet",
    "quilt",
    "quirk",
    "quit",
    "quite",
    "quiver",
    "quiz",
    "quota",
    "quote",
    "rabbit",
    "race",
    "racial",
    "racism",
    "rack",
    "racket",
    "radar",
    "radio",
    "radish",
    "radius",
    "raffle",
    "raft",
    "rage",
    "raid",
    "rail",
    "rain",
    "rainy",
    "raise",
    "rake",
    "rally",
    "ramp",
    "random",
    "range",
    "rank",
    "ransom",
    "rape",
    "rapid",
    "rare",
    "rarely",
    "rarity",
    "rash",
    "rat",
    "rate",
    "rather",
    "ratify",
    "ratio",
    "rattle",
    "rave",
    "raven",
    "raw",
    "ray",
    "razor",
    "reach",
    "react",
    "read",
    "reader",
    "ready",
    "real",
    "really",
    "realm",
    "reap",
    "rear",
    "reason",
    "rebel",
    "recall",
    "recent",
    "recess",
    "recipe",
    "reckon",
    "record",
    "recoup",
    "rector",
    "red",
    "redeem",
    "redo",
    "reduce",
    "reed",
    "reef",
    "reek",
    "refer",
    "reform",
    "refuge",
    "refuse",
    "regal",
    "regard",
    "regent",
    "regime",
    "region",
    "regret",
    "reign",
    "reject",
    "relate",
    "relax",
    "relay",
    "relic",
    "relief",
    "relish",
    "rely",
    "remain",
    "remark",
    "remedy",
    "remind",
    "remit",
    "remote",
    "remove",
    "renal",
    "render",
    "rent",
    "rental",
    "repair",
    "repeal",
    "repeat",
    "repent",
    "reply",
    "report",
    "rescue",
    "resent",
    "reside",
    "resign",
    "resin",
    "resist",
    "resort",
    "rest",
    "result",
    "resume",
    "retail",
    "retain",
    "retina",
    "retire",
    "return",
    "reveal",
    "review",
    "revise",
    "revive",
    "revolt",
    "reward",
    "rex",
    "rhine",
    "rhino",
    "rhyme",
    "rhythm",
    "ribbon",
    "rice",
    "rich",
    "rick",
    "rid",
    "ride",
    "rider",
    "ridge",
    "rife",
    "rifle",
    "rift",
    "right",
    "rigid",
    "rile",
    "rim",
    "ring",
    "rinse",
    "riot",
    "ripe",
    "ripen",
    "ripple",
    "rise",
    "risk",
    "risky",
    "rite",
    "ritual",
    "ritz",
    "rival",
    "river",
    "road",
    "roar",
    "roast",
    "rob",
    "robe",
    "robert",
    "robin",
    "robot",
    "robust",
    "rock",
    "rocket",
    "rocky",
    "rod",
    "rode",
    "rodent",
    "rogue",
    "role",
    "roll",
    "roman",
    "rome",
    "roof",
    "room",
    "root",
    "rope",
    "rose",
    "rosy",
    "rot",
    "rotate",
    "rotor",
    "rotten",
    "rouge",
    "rough",
    "round",
    "route",
    "rover",
    "row",
    "royal",
    "rub",
    "rubber",
    "rubble",
    "ruby",
    "rudder",
    "rude",
    "rug",
    "rugby",
    "ruin",
    "rule",
    "ruler",
    "rumble",
    "rump",
    "run",
    "rune",
    "rung",
    "runway",
    "rural",
    "rush",
    "russia",
    "rust",
    "rustic",
    "rusty",
    "sack",
    "sacred",
    "sad",
    "saddle",
    "sadism",
    "sadly",
    "safari",
    "safe",
    "safely",
    "safer",
    "safety",
    "saga",
    "sage",
    "sahara",
    "said",
    "sail",
    "sailor",
    "saint",
    "sake",
    "salad",
    "salary",
    "sale",
    "saline",
    "saliva",
    "salmon",
    "saloon",
    "salt",
    "salty",
    "salute",
    "sam",
    "same",
    "sample",
    "sand",
    "sandy",
    "sane",
    "sash",
    "satin",
    "satire",
    "saturn",
    "sauce",
    "saucer",
    "saudi",
    "sauna",
    "savage",
    "save",
    "saw",
    "say",
    "scale",
    "scalp",
    "scan",
    "scant",
    "scar",
    "scarce",
    "scare",
    "scarf",
    "scary",
    "scene",
    "scenic",
    "scent",
    "school",
    "scold",
    "scope",
    "score",
    "scorn",
    "scotch",
    "scott",
    "scout",
    "scrap",
    "scrape",
    "scream",
    "screen",
    "screw",
    "script",
    "scroll",
    "scrub",
    "scum",
    "sea",
    "seal",
    "seam",
    "seaman",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "sect",
    "sector",
    "secure",
    "see",
    "seed",
    "seeing",
    "seek",
    "seem",
    "seize",
    "seldom",
    "select",
    "self",
    "sell",
    "seller",
    "semi",
    "senate",
    "send",
    "senile",
    "senior",
    "sense",
    "sensor",
    "sent",
    "sentry",
    "seoul",
    "sequel",
    "serene",
    "serial",
    "series",
    "sermon",
    "serum",
    "serve",
    "server",
    "set",
    "settle",
    "seven",
    "severe",
    "sew",
    "sewage",
    "shabby",
    "shade",
    "shadow",
    "shady",
    "shaft",
    "shaggy",
    "shah",
    "shake",
    "shaky",
    "shall",
    "sham",
    "shame",
    "shape",
    "share",
    "shark",
    "sharp",
    "shawl",
    "she",
    "shear",
    "sheen",
    "sheep",
    "sheer",
    "sheet",
    "shelf",
    "shell",
    "sherry",
    "shield",
    "shift",
    "shine",
    "shiny",
    "ship",
    "shire",
    "shirk",
    "shirt",
    "shiver",
    "shock",
    "shoe",
    "shook",
    "shoot",
    "shop",
    "shore",
    "short",
    "shot",
    "should",
    "shout",
    "show",
    "shower",
    "shrank",
    "shrewd",
    "shrill",
    "shrimp",
    "shrine",
    "shrink",
    "shrub",
    "shrug",
    "shut",
    "shy",
    "shyly",
    "sick",
    "side",
    "siege",
    "sigh",
    "sight",
    "sigma",
    "sign",
    "signal",
    "silent",
    "silk",
    "silken",
    "silky",
    "sill",
    "silly",
    "silo",
    "silver",
    "simple",
    "simply",
    "since",
    "sinful",
    "sing",
    "singer",
    "single",
    "sink",
    "sir",
    "sire",
    "siren",
    "sister",
    "sit",
    "site",
    "sitter",
    "six",
    "sixth",
    "sixty",
    "size",
    "sketch",
    "skill",
    "skin",
    "skinny",
    "skip",
    "skirt",
    "skull",
    "sky",
    "slab",
    "slack",
    "slain",
    "slam",
    "slang",
    "slap",
    "slat",
    "slate",
    "slave",
    "sleek",
    "sleep",
    "sleepy",
    "sleeve",
    "slice",
    "slick",
    "slid",
    "slide",
    "slight",
    "slim",
    "slimy",
    "sling",
    "slip",
    "slit",
    "slogan",
    "slope",
    "sloppy",
    "slot",
    "slow",
    "slowly",
    "slug",
    "slum",
    "slump",
    "smack",
    "small",
    "smart",
    "smash",
    "smear",
    "smell",
    "smelly",
    "smelt",
    "smile",
    "smite",
    "smoke",
    "smoky",
    "smooth",
    "smug",
    "snack",
    "snail",
    "snake",
    "snap",
    "snatch",
    "sneak",
    "snow",
    "snowy",
    "snug",
    "soak",
    "soap",
    "sober",
    "soccer",
    "social",
    "sock",
    "socket",
    "socks",
    "soda",
    "sodden",
    "sodium",
    "sofa",
    "soft",
    "soften",
    "softly",
    "soggy",
    "soil",
    "solar",
    "sold",
    "sole",
    "solely",
    "solemn",
    "solid",
    "solo",
    "solve",
    "some",
    "son",
    "sonar",
    "sonata",
    "song",
    "sonic",
    "sony",
    "soon",
    "sooner",
    "soot",
    "soothe",
    "sordid",
    "sore",
    "sorrow",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "sour",
    "source",
    "soviet",
    "sow",
    "space",
    "spade",
    "spain",
    "span",
    "spare",
    "spark",
    "sparse",
    "spasm",
    "spat",
    "spate",
    "speak",
    "spear",
    "speech",
    "speed",
    "speedy",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spicy",
    "spider",
    "spiky",
    "spill",
    "spin",
    "spinal",
    "spine",
    "spiral",
    "spirit",
    "spit",
    "spite",
    "splash",
    "split",
    "spoil",
    "spoke",
    "sponge",
    "spoon",
    "sport",
    "spot",
    "spouse",
    "spray",
    "spread",
    "spree",
    "spring",
    "sprint",
    "spur",
    "squad",
    "square",
    "squash",
    "squat",
    "squid",
    "stab",
    "stable",
    "stack",
    "staff",
    "stage",
    "stain",
    "stair",
    "stairs",
    "stake",
    "stale",
    "stall",
    "stamp",
    "stance",
    "stand",
    "staple",
    "star",
    "starch",
    "stare",
    "stark",
    "start",
    "starve",
    "state",
    "static",
    "statue",
    "status",
    "stay",
    "stead",
    "steady",
    "steak",
    "steal",
    "steam",
    "steel",
    "steep",
    "steer",
    "stem",
    "stench",
    "step",
    "stereo",
    "stern",
    "stew",
    "stick",
    "sticky",
    "stiff",
    "stifle",
    "stigma",
    "still",
    "sting",
    "stint",
    "stir",
    "stitch",
    "stock",
    "stocky",
    "stone",
    "stony",
    "stool",
    "stop",
    "store",
    "storm",
    "stormy",
    "story",
    "stout",
    "stove",
    "stow",
    "strain",
    "strait",
    "strand",
    "strap",
    "strata",
    "straw",
    "stray",
    "streak",
    "stream",
    "street",
    "stress",
    "strict",
    "stride",
    "strife",
    "strike",
    "string",
    "strip",
    "stripe",
    "strive",
    "stroke",
    "stroll",
    "strong",
    "stud",
    "studio",
    "study",
    "stuff",
    "stuffy",
    "stunt",
    "stupid",
    "sturdy",
    "style",
    "submit",
    "subtle",
    "subtly",
    "suburb",
    "such",
    "sudden",
    "sue",
    "suez",
    "suffer",
    "sugar",
    "suit",
    "suite",
    "suitor",
    "sullen",
    "sultan",
    "sum",
    "summer",
    "summit",
    "summon",
    "sun",
    "sunday",
    "sunny",
    "sunset",
    "super",
    "superb",
    "supper",
    "supple",
    "supply",
    "sure",
    "surely",
    "surf",
    "surge",
    "survey",
    "suture",
    "swamp",
    "swan",
    "swap",
    "swarm",
    "sway",
    "swear",
    "sweat",
    "sweaty",
    "sweden",
    "sweep",
    "sweet",
    "swell",
    "swift",
    "swim",
    "swine",
    "swing",
    "swirl",
    "swiss",
    "switch",
    "sword",
    "swore",
    "sydney",
    "symbol",
    "synod",
    "syntax",
    "syria",
    "syrup",
    "system",
    "table",
    "tablet",
    "taboo",
    "tacit",
    "tackle",
    "tact",
    "tactic",
    "tail",
    "tailor",
    "taiwan",
    "take",
    "tale",
    "talent",
    "talk",
    "tall",
    "tally",
    "tame",
    "tampa",
    "tan",
    "tandem",
    "tangle",
    "tank",
    "tap",
    "tape",
    "target",
    "tariff",
    "tarp",
    "tart",
    "tarzan",
    "task",
    "taste",
    "tasty",
    "tattoo",
    "taurus",
    "taut",
    "tavern",
    "tax",
    "taxi",
    "tea",
    "teach",
    "teak",
    "team",
    "tear",
    "tease",
    "tech",
    "teeth",
    "tell",
    "temper",
    "temple",
    "tempo",
    "tempt",
    "ten",
    "tenant",
    "tend",
    "tender",
    "tendon",
    "tennis",
    "tenor",
    "tense",
    "tent",
    "tenth",
    "tenure",
    "teresa",
    "term",
    "terror",
    "terse",
    "test",
    "texas",
    "text",
    "thank",
    "thaw",
    "them",
    "theme",
    "thence",
    "theory",
    "there",
    "these",
    "thesis",
    "they",
    "thick",
    "thief",
    "thigh",
    "thin",
    "thing",
    "think",
    "third",
    "thirst",
    "thirty",
    "this",
    "thomas",
    "thorn",
    "those",
    "though",
    "thread",
    "threat",
    "three",
    "thrill",
    "thrive",
    "throat",
    "throne",
    "throng",
    "throw",
    "thrust",
    "thud",
    "thug",
    "thumb",
    "thus",
    "thyme",
    "tibet",
    "tick",
    "ticket",
    "tidal",
    "tide",
    "tidy",
    "tie",
    "tier",
    "tiger",
    "tight",
    "tile",
    "till",
    "tilt",
    "timber",
    "time",
    "timid",
    "tin",
    "tiny",
    "tip",
    "tire",
    "tissue",
    "title",
    "toad",
    "toast",
    "today",
    "toe",
    "toilet",
    "token",
    "tokyo",
    "told",
    "toll",
    "tom",
    "tomato",
    "tomb",
    "tonal",
    "tone",
    "tongue",
    "tonic",
    "too",
    "took",
    "tool",
    "tooth",
    "top",
    "topaz",
    "topic",
    "torch",
    "torque",
    "torso",
    "tort",
    "toss",
    "total",
    "touch",
    "tough",
    "tour",
    "toward",
    "towel",
    "tower",
    "town",
    "toxic",
    "toxin",
    "toy",
    "trace",
    "track",
    "tract",
    "trade",
    "tragic",
    "trail",
    "train",
    "trait",
    "tram",
    "trance",
    "trap",
    "trauma",
    "travel",
    "tray",
    "tread",
    "treat",
    "treaty",
    "treble",
    "tree",
    "trek",
    "tremor",
    "trench",
    "trend",
    "trendy",
    "trial",
    "tribal",
    "tribe",
    "trick",
    "tricky",
    "tried",
    "trifle",
    "trim",
    "trio",
    "trip",
    "triple",
    "troop",
    "trophy",
    "trot",
    "trough",
    "trout",
    "truce",
    "truck",
    "true",
    "truly",
    "trunk",
    "trust",
    "truth",
    "try",
    "tube",
    "tumble",
    "tuna",
    "tundra",
    "tune",
    "tunic",
    "tunnel",
    "turban",
    "turf",
    "turk",
    "turkey",
    "turn",
    "turtle",
    "tutor",
    "tweed",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "tycoon",
    "tying",
    "type",
    "tyrant",
    "ugly",
    "ulcer",
    "ultra",
    "umpire",
    "unable",
    "uncle",
    "under",
    "uneasy",
    "unfair",
    "unify",
    "union",
    "unique",
    "unit",
    "unite",
    "unity",
    "unlike",
    "unrest",
    "unruly",
    "until",
    "update",
    "upheld",
    "uphill",
    "uphold",
    "upon",
    "upper",
    "uproar",
    "upset",
    "upshot",
    "uptake",
    "upturn",
    "upward",
    "urban",
    "urge",
    "urgent",
    "urging",
    "urine",
    "usable",
    "usage",
    "use",
    "useful",
    "user",
    "usual",
    "utmost",
    "utter",
    "vacant",
    "vacuum",
    "vague",
    "vain",
    "valet",
    "valid",
    "valley",
    "value",
    "valve",
    "van",
    "vanish",
    "vanity",
    "vary",
    "vase",
    "vast",
    "vat",
    "vault",
    "vector",
    "veil",
    "vein",
    "velvet",
    "vendor",
    "veneer",
    "venice",
    "venom",
    "vent",
    "venue",
    "venus",
    "verb",
    "verbal",
    "verge",
    "verify",
    "verity",
    "verse",
    "versus",
    "very",
    "vessel",
    "vest",
    "vet",
    "veto",
    "via",
    "viable",
    "vicar",
    "vice",
    "victim",
    "victor",
    "video",
    "vienna",
    "view",
    "vigil",
    "viking",
    "vile",
    "villa",
    "vine",
    "vinyl",
    "viola",
    "violet",
    "violin",
    "viral",
    "virgo",
    "virtue",
    "virus",
    "visa",
    "vision",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "vodka",
    "vogue",
    "voice",
    "void",
    "volley",
    "volume",
    "vote",
    "vowel",
    "voyage",
    "vulgar",
    "wade",
    "wage",
    "waist",
    "wait",
    "waiter",
    "wake",
    "walk",
    "walker",
    "wall",
    "wallet",
    "walnut",
    "wander",
    "want",
    "war",
    "warden",
    "warm",
    "warmth",
    "warn",
    "warp",
    "warsaw",
    "wary",
    "was",
    "wash",
    "wasp",
    "waste",
    "watch",
    "water",
    "watery",
    "wave",
    "wax",
    "way",
    "weak",
    "weaken",
    "wealth",
    "weapon",
    "wear",
    "weary",
    "weave",
    "wedge",
    "wee",
    "weed",
    "week",
    "weekly",
    "weep",
    "weigh",
    "weight",
    "weird",
    "well",
    "were",
    "west",
    "wet",
    "whale",
    "wharf",
    "what",
    "wheat",
    "wheel",
    "when",
    "whence",
    "where",
    "which",
    "whiff",
    "while",
    "whim",
    "whip",
    "whisky",
    "white",
    "who",
    "whole",
    "wholly",
    "whom",
    "whose",
    "why",
    "wicked",
    "wide",
    "widely",
    "widen",
    "wider",
    "widow",
    "width",
    "wife",
    "wig",
    "wild",
    "wildly",
    "will",
    "willow",
    "wily",
    "win",
    "wind",
    "window",
    "windy",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wipe",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "wit",
    "witch",
    "with",
    "within",
    "witty",
    "wizard",
    "woke",
    "wolf",
    "wolves",
    "woman",
    "womb",
    "won",
    "wonder",
    "wood",
    "wooden",
    "woods",
    "woody",
    "wool",
    "word",
    "work",
    "worker",
    "world",
    "worm",
    "worry",
    "worse",
    "worst",
    "worth",
    "worthy",
    "would",
    "wound",
    "wrap",
    "wrath",
    "wreath",
    "wreck",
    "wring",
    "wrist",
    "writ",
    "write",
    "writer",
    "wrong",
    "xerox",
    "yacht",
    "yale",
    "yard",
    "yarn",
    "yeah",
    "year",
    "yeard",
    "yeast",
    "yellow",
    "yet",
    "yield",
    "yogurt",
    "yolk",
    "you",
    "young",
    "your",
    "youth",
    "zaire",
    "zeal",
    "zebra",
    "zenith",
    "zero",
    "zeus",
    "zigzag",
    "zinc",
    "zombie",
    "zone",
];

var bip39Words = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo",
];

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
async function digest$1(data) {
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
    return new Uint8Array(await crypto.subtle.digest("SHA-256", data));
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
function decode$4(data) {
    // eslint-disable-next-line node/no-unsupported-features/node-builtins
    return new TextDecoder().decode(data);
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
function encode$2(text) {
    // eslint-disable-next-line node/no-unsupported-features/node-builtins
    return new TextEncoder().encode(text);
}

/**
 * @typedef {import("./hmac.js").HashAlgorithm} HashAlgorithm
 */

/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} password
 * @param {Uint8Array | string} salt
 * @param {number} iterations
 * @param {number} length
 * @returns {Promise<Uint8Array>}
 */
async function deriveKey(algorithm, password, salt, iterations, length) {
    const pass =
        typeof password === "string"
            ? // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8
              // should be fine if only valid ASCII characters are used in the password
              encode$2(password)
            : password;

    const nacl = typeof salt === "string" ? encode$2(salt) : salt;

    try {
        const key = await window.crypto.subtle.importKey(
            "raw",
            pass,
            {
                name: "PBKDF2",
                hash: algorithm,
            },
            false,
            ["deriveBits"]
        );

        return new Uint8Array(
            await window.crypto.subtle.deriveBits(
                {
                    name: "PBKDF2",
                    hash: algorithm,
                    salt: nacl,
                    iterations,
                },
                key,
                length << 3
            )
        );
    } catch {
        throw new Error("(BUG) Non-Exhaustive switch statement for algorithms");
    }
}

/**
 * @enum {string}
 */
const HashAlgorithm = {
    Sha256: "SHA-256",
    Sha384: "SHA-384",
    Sha512: "SHA-512",
};

/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} secretKey
 * @param {Uint8Array | string} data
 * @returns {Promise<Uint8Array>}
 */
async function hash$3(algorithm, secretKey, data) {
    const key =
        typeof secretKey === "string" ? encode$2(secretKey) : secretKey;
    const value = typeof data === "string" ? encode$2(data) : data;

    try {
        const key_ = await window.crypto.subtle.importKey(
            "raw",
            key,
            {
                name: "HMAC",
                hash: algorithm,
            },
            false,
            ["sign"]
        );

        return new Uint8Array(
            await window.crypto.subtle.sign("HMAC", key_, value)
        );
    } catch {
        throw new Error("Fallback if SubtleCrypto fails is not implemented");
    }
}

/**
 * @param {Uint8Array} parentKey
 * @param {Uint8Array} chainCode
 * @param {number} index
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
async function derive(parentKey, chainCode, index) {
    const input = new Uint8Array(37);

    // 0x00 + parentKey + index(BE)
    input[0] = 0;
    input.set(parentKey, 1);
    new DataView(input.buffer, input.byteOffset, input.byteLength).setUint32(
        33,
        index,
        false
    );

    // set the index to hardened
    input[33] |= 128;

    const digest = await hash$3(HashAlgorithm.Sha512, chainCode, input);

    return { keyData: digest.subarray(0, 32), chainCode: digest.subarray(32) };
}

/**
 * @param {string[]} words
 * @param {string[]} wordlist
 * @returns {[Uint8Array, number]}
 */
function legacy1(words, wordlist) {
    const indicies = words.map((word) => wordlist.indexOf(word.toLowerCase()));

    const data = convertRadix(indicies, wordlist.length, 256, 33);
    const checksum = data[data.length - 1];
    const result = new Uint8Array(data.length - 1);

    for (let i = 0; i < data.length - 1; i += 1) {
        result[i] = data[i] ^ checksum;
    }

    return [result, checksum];
}

/**
 * @param {string[]} words
 * @param {string[]} wordlist
 * @returns {Promise<Uint8Array>}
 */
async function legacy2(words, wordlist) {
    const concatBitsLen = words.length * 11;
    /** @type {boolean[]} */
    const concatBits = [];
    concatBits.fill(false, 0, concatBitsLen);

    for (const [wordIndex, word] of words.entries()) {
        const index = wordlist.indexOf(word.toLowerCase());

        if (index < 0) {
            throw new Error(`Word not found in wordlist: ${word}`);
        }

        for (let i = 0; i < 11; i += 1) {
            concatBits[wordIndex * 11 + i] = (index & (1 << (10 - i))) !== 0;
        }
    }

    const checksumBitsLen = concatBitsLen / 33;
    const entropyBitsLen = concatBitsLen - checksumBitsLen;
    const entropy = new Uint8Array(entropyBitsLen / 8);

    for (let i = 0; i < entropy.length; i += 1) {
        for (let j = 0; j < 8; j += 1) {
            if (concatBits[i * 8 + j]) {
                entropy[i] |= 1 << (7 - j);
            }
        }
    }

    // Checksum validation
    const hash = await digest$1(entropy);
    const hashBits = bytesToBits(hash);

    for (let i = 0; i < checksumBitsLen; i += 1) {
        if (concatBits[entropyBitsLen + i] !== hashBits[i]) {
            throw new Error("Checksum mismatch");
        }
    }

    return entropy;
}

/**
 * @param {Uint8Array} data
 * @returns {number}
 */
function crc8(data) {
    let crc = 0xff;

    for (let i = 0; i < data.length - 1; i += 1) {
        crc ^= data[i];
        for (let j = 0; j < 8; j += 1) {
            crc = (crc >>> 1) ^ ((crc & 1) === 0 ? 0 : 0xb2);
        }
    }

    return crc ^ 0xff;
}

/**
 * @param {number[]} nums
 * @param {number} fromRadix
 * @param {number} toRadix
 * @param {number} toLength
 * @returns {Uint8Array}
 */
function convertRadix(nums, fromRadix, toRadix, toLength) {
    let num = new BigNumber$1(0);

    for (const element of nums) {
        num = num.times(fromRadix);
        num = num.plus(element);
    }

    const result = new Uint8Array(toLength);

    for (let i = toLength - 1; i >= 0; i -= 1) {
        const tem = num.dividedToIntegerBy(toRadix);
        const rem = num.modulo(toRadix);
        num = tem;
        result[i] = rem.toNumber();
    }

    return result;
}

/**
 * @param {Uint8Array} data
 * @returns {boolean[]}
 */
function bytesToBits(data) {
    /** @type {boolean[]} */
    const bits = [];
    bits.fill(false, 0, data.length * 8);

    for (let i = 0; i < data.length; i += 1) {
        for (let j = 0; j < 8; j += 1) {
            bits[i * 8 + j] = (data[i] & (1 << (7 - j))) !== 0;
        }
    }

    return bits;
}

/**
 * @typedef {import("./PrivateKey.js").default} PrivateKey
 */

/**
 * Multi-word mnemonic phrase (BIP-39).
 *
 * Compatible with the official Hedera mobile
 * wallets (24-words or 22-words) and BRD (12-words).
 */
class Mnemonic$1 {
    /**
     * @param {Object} props
     * @param {string[]} props.words
     * @param {boolean} props.legacy
     * @throws {BadMnemonicError}
     * @hideconstructor
     * @private
     */
    constructor({ words, legacy }) {
        this.words = words;
        this._isLegacy = legacy;
    }

    /**
     * Returns a new random 24-word mnemonic from the BIP-39
     * standard English word list.
     *
     * @returns {Promise<Mnemonic>}
     */
    static generate() {
        return Mnemonic$1._generate(24);
    }

    /**
     * Returns a new random 12-word mnemonic from the BIP-39
     * standard English word list.
     *
     * @returns {Promise<Mnemonic>}
     */
    static generate12() {
        return Mnemonic$1._generate(12);
    }

    /**
     * @param {number} length
     * @returns {Promise<Mnemonic>}
     */
    static async _generate(length) {
        // only 12-word or 24-word lengths are supported
        let neededEntropy;

        if (length === 12) neededEntropy = 16;
        else if (length === 24) neededEntropy = 32;
        else {
            throw new Error(
                `unsupported phrase length ${length}, only 12 or 24 are supported`
            );
        }

        // inlined from (ISC) with heavy alternations for modern crypto
        // https://github.com/bitcoinjs/bip39/blob/8461e83677a1d2c685d0d5a9ba2a76bd228f74c6/ts_src/index.ts#L125
        const seed = await bytesAsync(neededEntropy);
        const entropyBits = bytesToBinary(Array.from(seed));
        const checksumBits = await deriveChecksumBits(seed);
        const bits = entropyBits + checksumBits;
        const chunks = bits.match(/(.{1,11})/g);

        const words = (chunks != null ? chunks : []).map(
            (binary) => bip39Words[binaryToByte(binary)]
        );

        return new Mnemonic$1({ words, legacy: false });
    }

    /**
     * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
     *
     * An exception of BadMnemonicError will be thrown if the mnemonic
     * contains unknown words or fails the checksum. An invalid mnemonic
     * can still be used to create private keys, the exception will
     * contain the failing mnemonic in case you wish to ignore the
     * validation error and continue.
     *
     * @param {string[]} words
     * @throws {BadMnemonicError}
     * @returns {Promise<Mnemonic>}
     */
    static async fromWords(words) {
        return await new Mnemonic$1({
            words,
            legacy: words.length === 22,
        })._validate();
    }

    /**
     * Recover a private key from this mnemonic phrase, with an
     * optional passphrase.
     *
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    async toPrivateKey(passphrase = "") {
        if (this._isLegacy) {
            if (passphrase.length > 0) {
                throw new Error(
                    "legacy 22-word mnemonics do not support passphrases"
                );
            }

            return this.toLegacyPrivateKey();
        }

        return await this._toPrivateKey(passphrase);
    }

    // /**
    //  * Recover an ecdsa private key from this mnemonic phrase, with an
    //  * optional passphrase.
    //  *
    //  * @param {string} [passphrase]
    //  * @returns {Promise<EcdsaPrivateKey>}
    //  */
    //      async toEcdsaPrivateKey(passphrase = "") {
    //         if (this._isLegacy) {
    //             if (passphrase.length > 0) {
    //                 throw new Error(
    //                     "legacy 22-word mnemonics do not support passphrases"
    //                 );
    //             }

    //             return this.toLegacyPrivateKey();
    //         }

    //         return await this._toEcdsaPrivateKey(passphrase);
    //     }

    /**
     * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
     *
     * @param {string} mnemonic
     * @returns {Promise<Mnemonic>}
     */
    static async fromString(mnemonic) {
        return Mnemonic$1.fromWords(mnemonic.split(/\s|,/));
    }

    /**
     * @returns {Promise<Mnemonic>}
     * @private
     */
    async _validate() {
        // Validate that this is a valid BIP-39 mnemonic
        // as generated by BIP-39's rules.

        // Technically, invalid mnemonics can still be used to generate valid private keys,
        // but if they became invalid due to user error then it will be difficult for the user
        // to tell the difference unless they compare the generated keys.

        // During validation, the following conditions are checked in order

        //  1)) 24 or 12 words

        //  2) All strings in {@link this.words} exist in the BIP-39
        //     standard English word list (no normalization is done)

        //  3) The calculated checksum for the mnemonic equals the
        //     checksum encoded in the mnemonic

        if (this._isLegacy) {
            if (this.words.length !== 22) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.BadLength,
                    []
                );
            }

            const unknownWordIndices = this.words.reduce(
                (/** @type {number[]} */ unknowns, word, index) =>
                    legacyWords.includes(word.toLowerCase())
                        ? unknowns
                        : [...unknowns, index],
                []
            );

            if (unknownWordIndices.length > 0) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.UnknownWords,
                    unknownWordIndices
                );
            }

            const [seed, checksum] = legacy1(this.words, legacyWords);
            const newChecksum = crc8(seed);

            if (checksum !== newChecksum) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.ChecksumMismatch,
                    []
                );
            }
        } else {
            if (!(this.words.length === 12 || this.words.length === 24)) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.BadLength,
                    []
                );
            }

            const unknownWordIndices = this.words.reduce(
                (/** @type {number[]} */ unknowns, word, index) =>
                    bip39Words.includes(word) ? unknowns : [...unknowns, index],
                []
            );

            if (unknownWordIndices.length > 0) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.UnknownWords,
                    unknownWordIndices
                );
            }

            // FIXME: calculate checksum and compare
            // https://github.com/bitcoinjs/bip39/blob/master/ts_src/index.ts#L112

            const bits = this.words
                .map((word) => {
                    return bip39Words
                        .indexOf(word)
                        .toString(2)
                        .padStart(11, "0");
                })
                .join("");

            const dividerIndex = Math.floor(bits.length / 33) * 32;
            const entropyBits = bits.slice(0, dividerIndex);
            const checksumBits = bits.slice(dividerIndex);
            const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);
            const entropyBytes = /** @type {RegExpMatchArray} */ (
                entropyBitsRegex
            ).map(binaryToByte);

            const newChecksum = await deriveChecksumBits(
                Uint8Array.from(entropyBytes)
            );

            if (newChecksum !== checksumBits) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.ChecksumMismatch,
                    []
                );
            }
        }

        return this;
    }

    /**
     * @private
     * @param {string} passphrase
     * @returns {Promise<PrivateKey>}
     */
    async _toPrivateKey(passphrase = "") {
        const input = this.words.join(" ");
        const salt = `mnemonic${passphrase}`;

        const seed = await deriveKey(
            HashAlgorithm.Sha512,
            input,
            salt,
            2048,
            64
        );

        const digest = await hash$3(
            HashAlgorithm.Sha512,
            "ed25519 seed",
            seed
        );

        let keyData = digest.subarray(0, 32);
        let chainCode = digest.subarray(32);

        for (const index of [44, 3030, 0, 0]) {
            ({ keyData, chainCode } = await derive(
                keyData,
                chainCode,
                index
            ));
        }

        const keyPair = nacl.sign.keyPair.fromSeed(keyData);

        if (CACHE$1.privateKeyConstructor == null) {
            throw new Error("PrivateKey not found in cache");
        }

        return CACHE$1.privateKeyConstructor(
            new Ed25519PrivateKey(keyPair, chainCode)
        );
    }

    /**
     * @returns {Promise<PrivateKey>}
     */
    async toLegacyPrivateKey() {
        let seed;
        if (this._isLegacy) {
            [seed] = legacy1(this.words, legacyWords);
        } else {
            seed = await legacy2(this.words, bip39Words);
        }

        if (CACHE$1.privateKeyFromBytes == null) {
            throw new Error("PrivateKey not found in cache");
        }

        return CACHE$1.privateKeyFromBytes(seed);
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.words.join(" ");
    }
}

/**
 * @param {string} bin
 * @returns {number}
 */
function binaryToByte(bin) {
    return parseInt(bin, 2);
}

/**
 * @param {number[]} bytes
 * @returns {string}
 */
function bytesToBinary(bytes) {
    return bytes.map((x) => x.toString(2).padStart(8, "0")).join("");
}

/**
 * @param {Uint8Array} entropyBuffer
 * @returns {Promise<string>}
 */
async function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = await digest$1(entropyBuffer);

    return bytesToBinary(Array.from(hash)).slice(0, CS);
}

// Originally sourced from:
// https://github.com/MaiaVictor/eth-lib/blob/da0971f5b09964d9c8449975fa87933f0c9fef35/src/hash.js
//  - added type declarations
//  - switched to es6 module syntax
//
// Disable linting for entire file because it's nearly all pure JS
// eslint-disable

const HEX_CHARS$1 = "0123456789abcdef".split("");
const KECCAK_PADDING$1 = [1, 256, 65536, 16777216];
const SHIFT$1 = [0, 8, 16, 24];
const RC$1 = [
    1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
    2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0,
    2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
    2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0,
    2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648,
    2147483649, 0, 2147516424, 2147483648,
];

/**
 * @typedef {object} KeccakT
 * @property {number[]} blocks
 * @property {number} blockCount
 * @property {number} outputBlocks
 * @property {number[]} s
 * @property {number} start
 * @property {number} block
 * @property {boolean} reset
 * @property {number=} lastByteIndex
 */

/** @type {(bits: number) => KeccakT} */
const Keccak$1 = (bits) => ({
    blocks: [],
    reset: true,
    block: 0,
    start: 0,
    blockCount: (1600 - (bits << 1)) >> 5,
    outputBlocks: bits >> 5,
    // @ts-ignore
    s: ((s) => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
});

/** @type {(state: KeccakT, message: string | number[]) => string} */
const update$1 = (state, /** @type {string | number[]} */ message) => {
    var length = message.length,
        blocks = state.blocks,
        byteCount = state.blockCount << 2,
        blockCount = state.blockCount,
        outputBlocks = state.outputBlocks,
        s = state.s,
        index = 0,
        i,
        code;

    // update
    while (index < length) {
        if (state.reset) {
            state.reset = false;
            blocks[0] = state.block;
            for (i = 1; i < blockCount + 1; ++i) {
                blocks[i] = 0;
            }
        }
        if (typeof message !== "string") {
            for (i = state.start; index < length && i < byteCount; ++index) {
                blocks[i >> 2] |= message[index] << SHIFT$1[i++ & 3];
            }
        } else {
            for (i = state.start; index < length && i < byteCount; ++index) {
                code = message.charCodeAt(index);
                if (code < 0x80) {
                    blocks[i >> 2] |= code << SHIFT$1[i++ & 3];
                } else if (code < 0x800) {
                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT$1[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT$1[i++ & 3];
                } else if (code < 0xd800 || code >= 0xe000) {
                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT$1[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 6) & 0x3f)) << SHIFT$1[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT$1[i++ & 3];
                } else {
                    code =
                        0x10000 +
                        (((code & 0x3ff) << 10) |
                            (message.charCodeAt(++index) & 0x3ff));
                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT$1[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 12) & 0x3f)) << SHIFT$1[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 6) & 0x3f)) << SHIFT$1[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT$1[i++ & 3];
                }
            }
        }
        state.lastByteIndex = i;
        if (i >= byteCount) {
            state.start = i - byteCount;
            state.block = blocks[blockCount];
            for (i = 0; i < blockCount; ++i) {
                s[i] ^= blocks[i];
            }
            f$2(s);
            state.reset = true;
        } else {
            state.start = i;
        }
    }

    // finalize
    i = state.lastByteIndex;
    // @ts-ignore
    blocks[i >> 2] |= KECCAK_PADDING$1[i & 3];
    if (state.lastByteIndex === byteCount) {
        blocks[0] = blocks[blockCount];
        for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
        }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
    }
    f$2(s);

    // toString
    var hex = "";
    var block;
    var j = 0;
    i = 0;
    while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
            block = s[i];
            hex +=
                HEX_CHARS$1[(block >> 4) & 0x0f] +
                HEX_CHARS$1[block & 0x0f] +
                HEX_CHARS$1[(block >> 12) & 0x0f] +
                HEX_CHARS$1[(block >> 8) & 0x0f] +
                HEX_CHARS$1[(block >> 20) & 0x0f] +
                HEX_CHARS$1[(block >> 16) & 0x0f] +
                HEX_CHARS$1[(block >> 28) & 0x0f] +
                HEX_CHARS$1[(block >> 24) & 0x0f];
        }
        if (j % blockCount === 0) {
            f$2(s);
            i = 0;
        }
    }
    // @ts-ignore
    return "0x" + hex;
};

/** @type {(s: number[]) => void} */
const f$2 = (s) => {
    var h,
        l,
        n,
        c0,
        c1,
        c2,
        c3,
        c4,
        c5,
        c6,
        c7,
        c8,
        c9,
        b0,
        b1,
        b2,
        b3,
        b4,
        b5,
        b6,
        b7,
        b8,
        b9,
        b10,
        b11,
        b12,
        b13,
        b14,
        b15,
        b16,
        b17,
        b18,
        b19,
        b20,
        b21,
        b22,
        b23,
        b24,
        b25,
        b26,
        b27,
        b28,
        b29,
        b30,
        b31,
        b32,
        b33,
        b34,
        b35,
        b36,
        b37,
        b38,
        b39,
        b40,
        b41,
        b42,
        b43,
        b44,
        b45,
        b46,
        b47,
        b48,
        b49;

    for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

        h = c8 ^ ((c2 << 1) | (c3 >>> 31));
        l = c9 ^ ((c3 << 1) | (c2 >>> 31));
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ ((c4 << 1) | (c5 >>> 31));
        l = c1 ^ ((c5 << 1) | (c4 >>> 31));
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ ((c6 << 1) | (c7 >>> 31));
        l = c3 ^ ((c7 << 1) | (c6 >>> 31));
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ ((c8 << 1) | (c9 >>> 31));
        l = c5 ^ ((c9 << 1) | (c8 >>> 31));
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ ((c0 << 1) | (c1 >>> 31));
        l = c7 ^ ((c1 << 1) | (c0 >>> 31));
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;

        b0 = s[0];
        b1 = s[1];
        b32 = (s[11] << 4) | (s[10] >>> 28);
        b33 = (s[10] << 4) | (s[11] >>> 28);
        b14 = (s[20] << 3) | (s[21] >>> 29);
        b15 = (s[21] << 3) | (s[20] >>> 29);
        b46 = (s[31] << 9) | (s[30] >>> 23);
        b47 = (s[30] << 9) | (s[31] >>> 23);
        b28 = (s[40] << 18) | (s[41] >>> 14);
        b29 = (s[41] << 18) | (s[40] >>> 14);
        b20 = (s[2] << 1) | (s[3] >>> 31);
        b21 = (s[3] << 1) | (s[2] >>> 31);
        b2 = (s[13] << 12) | (s[12] >>> 20);
        b3 = (s[12] << 12) | (s[13] >>> 20);
        b34 = (s[22] << 10) | (s[23] >>> 22);
        b35 = (s[23] << 10) | (s[22] >>> 22);
        b16 = (s[33] << 13) | (s[32] >>> 19);
        b17 = (s[32] << 13) | (s[33] >>> 19);
        b48 = (s[42] << 2) | (s[43] >>> 30);
        b49 = (s[43] << 2) | (s[42] >>> 30);
        b40 = (s[5] << 30) | (s[4] >>> 2);
        b41 = (s[4] << 30) | (s[5] >>> 2);
        b22 = (s[14] << 6) | (s[15] >>> 26);
        b23 = (s[15] << 6) | (s[14] >>> 26);
        b4 = (s[25] << 11) | (s[24] >>> 21);
        b5 = (s[24] << 11) | (s[25] >>> 21);
        b36 = (s[34] << 15) | (s[35] >>> 17);
        b37 = (s[35] << 15) | (s[34] >>> 17);
        b18 = (s[45] << 29) | (s[44] >>> 3);
        b19 = (s[44] << 29) | (s[45] >>> 3);
        b10 = (s[6] << 28) | (s[7] >>> 4);
        b11 = (s[7] << 28) | (s[6] >>> 4);
        b42 = (s[17] << 23) | (s[16] >>> 9);
        b43 = (s[16] << 23) | (s[17] >>> 9);
        b24 = (s[26] << 25) | (s[27] >>> 7);
        b25 = (s[27] << 25) | (s[26] >>> 7);
        b6 = (s[36] << 21) | (s[37] >>> 11);
        b7 = (s[37] << 21) | (s[36] >>> 11);
        b38 = (s[47] << 24) | (s[46] >>> 8);
        b39 = (s[46] << 24) | (s[47] >>> 8);
        b30 = (s[8] << 27) | (s[9] >>> 5);
        b31 = (s[9] << 27) | (s[8] >>> 5);
        b12 = (s[18] << 20) | (s[19] >>> 12);
        b13 = (s[19] << 20) | (s[18] >>> 12);
        b44 = (s[29] << 7) | (s[28] >>> 25);
        b45 = (s[28] << 7) | (s[29] >>> 25);
        b26 = (s[38] << 8) | (s[39] >>> 24);
        b27 = (s[39] << 8) | (s[38] >>> 24);
        b8 = (s[48] << 14) | (s[49] >>> 18);
        b9 = (s[49] << 14) | (s[48] >>> 18);

        s[0] = b0 ^ (~b2 & b4);
        s[1] = b1 ^ (~b3 & b5);
        s[10] = b10 ^ (~b12 & b14);
        s[11] = b11 ^ (~b13 & b15);
        s[20] = b20 ^ (~b22 & b24);
        s[21] = b21 ^ (~b23 & b25);
        s[30] = b30 ^ (~b32 & b34);
        s[31] = b31 ^ (~b33 & b35);
        s[40] = b40 ^ (~b42 & b44);
        s[41] = b41 ^ (~b43 & b45);
        s[2] = b2 ^ (~b4 & b6);
        s[3] = b3 ^ (~b5 & b7);
        s[12] = b12 ^ (~b14 & b16);
        s[13] = b13 ^ (~b15 & b17);
        s[22] = b22 ^ (~b24 & b26);
        s[23] = b23 ^ (~b25 & b27);
        s[32] = b32 ^ (~b34 & b36);
        s[33] = b33 ^ (~b35 & b37);
        s[42] = b42 ^ (~b44 & b46);
        s[43] = b43 ^ (~b45 & b47);
        s[4] = b4 ^ (~b6 & b8);
        s[5] = b5 ^ (~b7 & b9);
        s[14] = b14 ^ (~b16 & b18);
        s[15] = b15 ^ (~b17 & b19);
        s[24] = b24 ^ (~b26 & b28);
        s[25] = b25 ^ (~b27 & b29);
        s[34] = b34 ^ (~b36 & b38);
        s[35] = b35 ^ (~b37 & b39);
        s[44] = b44 ^ (~b46 & b48);
        s[45] = b45 ^ (~b47 & b49);
        s[6] = b6 ^ (~b8 & b0);
        s[7] = b7 ^ (~b9 & b1);
        s[16] = b16 ^ (~b18 & b10);
        s[17] = b17 ^ (~b19 & b11);
        s[26] = b26 ^ (~b28 & b20);
        s[27] = b27 ^ (~b29 & b21);
        s[36] = b36 ^ (~b38 & b30);
        s[37] = b37 ^ (~b39 & b31);
        s[46] = b46 ^ (~b48 & b40);
        s[47] = b47 ^ (~b49 & b41);
        s[8] = b8 ^ (~b0 & b2);
        s[9] = b9 ^ (~b1 & b3);
        s[18] = b18 ^ (~b10 & b12);
        s[19] = b19 ^ (~b11 & b13);
        s[28] = b28 ^ (~b20 & b22);
        s[29] = b29 ^ (~b21 & b23);
        s[38] = b38 ^ (~b30 & b32);
        s[39] = b39 ^ (~b31 & b33);
        s[48] = b48 ^ (~b40 & b42);
        s[49] = b49 ^ (~b41 & b43);

        s[0] ^= RC$1[n];
        s[1] ^= RC$1[n + 1];
    }
};

const keccak$1 = (/** @type {number} */ bits) => (/** @type {string} */ str) => {
    var msg;
    if (str.slice(0, 2) === "0x") {
        msg = [];
        for (var i = 2, l = str.length; i < l; i += 2)
            msg.push(parseInt(str.slice(i, i + 2), 16));
    } else {
        msg = str;
    }
    // @ts-ignore
    return update$1(Keccak$1(bits), msg);
};

/**
 * @type {(message: string) => string}
 */
const keccak256$2 = keccak$1(256);

var elliptic = {};

var name = "elliptic";
var version$8 = "6.5.4";
var description = "EC cryptography";
var main = "lib/elliptic.js";
var files = [
	"lib"
];
var scripts = {
	lint: "eslint lib test",
	"lint:fix": "npm run lint -- --fix",
	unit: "istanbul test _mocha --reporter=spec test/index.js",
	test: "npm run lint && npm run unit",
	version: "grunt dist && git add dist/"
};
var repository = {
	type: "git",
	url: "git@github.com:indutny/elliptic"
};
var keywords = [
	"EC",
	"Elliptic",
	"curve",
	"Cryptography"
];
var author = "Fedor Indutny <fedor@indutny.com>";
var license = "MIT";
var bugs = {
	url: "https://github.com/indutny/elliptic/issues"
};
var homepage = "https://github.com/indutny/elliptic";
var devDependencies = {
	brfs: "^2.0.2",
	coveralls: "^3.1.0",
	eslint: "^7.6.0",
	grunt: "^1.2.1",
	"grunt-browserify": "^5.3.0",
	"grunt-cli": "^1.3.2",
	"grunt-contrib-connect": "^3.0.0",
	"grunt-contrib-copy": "^1.0.0",
	"grunt-contrib-uglify": "^5.0.0",
	"grunt-mocha-istanbul": "^5.0.2",
	"grunt-saucelabs": "^9.0.1",
	istanbul: "^0.4.5",
	mocha: "^8.0.1"
};
var dependencies = {
	"bn.js": "^4.11.9",
	brorand: "^1.1.0",
	"hash.js": "^1.0.0",
	"hmac-drbg": "^1.0.1",
	inherits: "^2.0.4",
	"minimalistic-assert": "^1.0.1",
	"minimalistic-crypto-utils": "^1.0.1"
};
var require$$0 = {
	name: name,
	version: version$8,
	description: description,
	main: main,
	files: files,
	scripts: scripts,
	repository: repository,
	keywords: keywords,
	author: author,
	license: license,
	bugs: bugs,
	homepage: homepage,
	devDependencies: devDependencies,
	dependencies: dependencies
};

var utils$m = {};

var bn = {exports: {}};

(function (module) {
(function (module, exports) {

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) ; else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(module, commonjsGlobal);
}(bn));

var _BN = bn.exports;

var minimalisticAssert = assert$f;

function assert$f(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert$f.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var utils$l = {};

(function (exports) {

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};
}(utils$l));

(function (exports) {

var utils = exports;
var BN = bn.exports;
var minAssert = minimalisticAssert;
var minUtils = utils$l;

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;
}(utils$m));

var brorand = {exports: {}};

var r$1;

brorand.exports = function rand(len) {
  if (!r$1)
    r$1 = new Rand(null);

  return r$1.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
brorand.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto$1 = require('crypto');
    if (typeof crypto$1.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto$1.randomBytes(n);
    };
  } catch (e) {
  }
}

var curve = {};

var BN$8 = bn.exports;
var utils$k = utils$m;
var getNAF = utils$k.getNAF;
var getJSF = utils$k.getJSF;
var assert$e = utils$k.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$8(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN$8.red(conf.prime) : BN$8.mont(this.p);

  // Useful for many curves
  this.zero = new BN$8(0).toRed(this.red);
  this.one = new BN$8(1).toRed(this.red);
  this.two = new BN$8(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN$8(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$e(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert$e(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils$k.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert$e(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert$e(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils$k.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

var inherits_browser = {exports: {}};

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

var utils$j = utils$m;
var BN$7 = bn.exports;
var inherits$4 = inherits_browser.exports;
var Base$2 = base;

var assert$d = utils$j.assert;

function ShortCurve(conf) {
  Base$2.call(this, 'short', conf);

  this.a = new BN$7(conf.a, 16).toRed(this.red);
  this.b = new BN$7(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$2);
var short = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$7(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$7(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$d(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$7(vec.a, 16),
        b: new BN$7(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN$7.mont(num);
  var tinv = new BN$7(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN$7(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN$7(1);
  var y1 = new BN$7(0);
  var x2 = new BN$7(0);
  var y2 = new BN$7(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$7(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point$2(curve, x, y, isRed) {
  Base$2.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$7(x, 16);
    this.y = new BN$7(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits$4(Point$2, Base$2.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point$2(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point$2.fromJSON(this, obj, red);
};

Point$2.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point$2.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point$2.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point$2.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point$2.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point$2.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point$2.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point$2.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point$2.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point$2.prototype.mul = function mul(k) {
  k = new BN$7(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point$2.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point$2.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point$2.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base$2.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$7(0);
  } else {
    this.x = new BN$7(x, 16);
    this.y = new BN$7(y, 16);
    this.z = new BN$7(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$2.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN$7(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

var BN$6 = bn.exports;
var inherits$3 = inherits_browser.exports;
var Base$1 = base;

var utils$i = utils$m;

function MontCurve(conf) {
  Base$1.call(this, 'mont', conf);

  this.a = new BN$6(conf.a, 16).toRed(this.red);
  this.b = new BN$6(conf.b, 16).toRed(this.red);
  this.i4 = new BN$6(4).toRed(this.red).redInvm();
  this.two = new BN$6(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$1);
var mont = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point$1(curve, x, z) {
  Base$1.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN$6(x, 16);
    this.z = new BN$6(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits$3(Point$1, Base$1.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils$i.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point$1(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point$1.fromJSON(this, obj);
};

Point$1.prototype.precompute = function precompute() {
  // No-op
};

Point$1.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point$1.fromJSON = function fromJSON(curve, obj) {
  return new Point$1(curve, obj[0], obj[1] || curve.one);
};

Point$1.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point$1.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point$1.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point$1.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point$1.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point$1.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point$1.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point$1.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point$1.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point$1.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point$1.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

var utils$h = utils$m;
var BN$5 = bn.exports;
var inherits$2 = inherits_browser.exports;
var Base = base;

var assert$c = utils$h.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN$5(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN$5(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN$5(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base);
var edwards = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$5(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN$5(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN$5(x, 16);
    this.y = new BN$5(y, 16);
    this.z = z ? new BN$5(z, 16) : this.curve.one;
    this.t = t && new BN$5(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits$2(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

(function (exports) {

var curve = exports;

curve.base = base;
curve.short = short;
curve.mont = mont;
curve.edwards = edwards;
}(curve));

var curves$2 = {};

var hash$2 = {};

var utils$g = {};

var assert$b = minimalisticAssert;
var inherits$1 = inherits_browser.exports;

utils$g.inherits = inherits$1;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils$g.toArray = toArray;

function toHex$1(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils$g.toHex = toHex$1;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils$g.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils$g.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils$g.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils$g.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert$b(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils$g.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils$g.split32 = split32;

function rotr32$1(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils$g.rotr32 = rotr32$1;

function rotl32$2(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils$g.rotl32 = rotl32$2;

function sum32$3(a, b) {
  return (a + b) >>> 0;
}
utils$g.sum32 = sum32$3;

function sum32_3$1(a, b, c) {
  return (a + b + c) >>> 0;
}
utils$g.sum32_3 = sum32_3$1;

function sum32_4$2(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils$g.sum32_4 = sum32_4$2;

function sum32_5$2(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils$g.sum32_5 = sum32_5$2;

function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$g.sum64 = sum64$1;

function sum64_hi$1(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$g.sum64_hi = sum64_hi$1;

function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$g.sum64_lo = sum64_lo$1;

function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
utils$g.sum64_4_hi = sum64_4_hi$1;

function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$g.sum64_4_lo = sum64_4_lo$1;

function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
utils$g.sum64_5_hi = sum64_5_hi$1;

function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
utils$g.sum64_5_lo = sum64_5_lo$1;

function rotr64_hi$1(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
utils$g.rotr64_hi = rotr64_hi$1;

function rotr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
utils$g.rotr64_lo = rotr64_lo$1;

function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$g.shr64_hi = shr64_hi$1;

function shr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
utils$g.shr64_lo = shr64_lo$1;

var common$5 = {};

var utils$f = utils$g;
var assert$a = minimalisticAssert;

function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;

BlockHash$4.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils$f.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils$f.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$a(this.pending === null);

  return this._digest(enc);
};

BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

var sha = {};

var common$4 = {};

var utils$e = utils$g;
var rotr32 = utils$e.rotr32;

function ft_1$1(s, x, y, z) {
  if (s === 0)
    return ch32$1(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32$1(x, y, z);
}
common$4.ft_1 = ft_1$1;

function ch32$1(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
common$4.ch32 = ch32$1;

function maj32$1(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
common$4.maj32 = maj32$1;

function p32(x, y, z) {
  return x ^ y ^ z;
}
common$4.p32 = p32;

function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;

function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;

function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
common$4.g0_256 = g0_256$1;

function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
common$4.g1_256 = g1_256$1;

var utils$d = utils$g;
var common$3 = common$5;
var shaCommon$1 = common$4;

var rotl32$1 = utils$d.rotl32;
var sum32$2 = utils$d.sum32;
var sum32_5$1 = utils$d.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash$3.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils$d.inherits(SHA1, BlockHash$3);
var _1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32$1(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32$2(this.h[0], a);
  this.h[1] = sum32$2(this.h[1], b);
  this.h[2] = sum32$2(this.h[2], c);
  this.h[3] = sum32$2(this.h[3], d);
  this.h[4] = sum32$2(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$d.toHex32(this.h, 'big');
  else
    return utils$d.split32(this.h, 'big');
};

var utils$c = utils$g;
var common$2 = common$5;
var shaCommon = common$4;
var assert$9 = minimalisticAssert;

var sum32$1 = utils$c.sum32;
var sum32_4$1 = utils$c.sum32_4;
var sum32_5 = utils$c.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash$2 = common$2.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();

  BlockHash$2.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$c.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;

SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;

SHA256$1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert$9(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32$1(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32$1(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32$1(T1, T2);
  }

  this.h[0] = sum32$1(this.h[0], a);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c);
  this.h[3] = sum32$1(this.h[3], d);
  this.h[4] = sum32$1(this.h[4], e);
  this.h[5] = sum32$1(this.h[5], f);
  this.h[6] = sum32$1(this.h[6], g);
  this.h[7] = sum32$1(this.h[7], h);
};

SHA256$1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$c.toHex32(this.h, 'big');
  else
    return utils$c.split32(this.h, 'big');
};

var utils$b = utils$g;
var SHA256 = _256;

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils$b.inherits(SHA224, SHA256);
var _224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils$b.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils$b.split32(this.h.slice(0, 7), 'big');
};

var utils$a = utils$g;
var common$1 = common$5;
var assert$8 = minimalisticAssert;

var rotr64_hi = utils$a.rotr64_hi;
var rotr64_lo = utils$a.rotr64_lo;
var shr64_hi = utils$a.shr64_hi;
var shr64_lo = utils$a.shr64_lo;
var sum64 = utils$a.sum64;
var sum64_hi = utils$a.sum64_hi;
var sum64_lo = utils$a.sum64_lo;
var sum64_4_hi = utils$a.sum64_4_hi;
var sum64_4_lo = utils$a.sum64_4_lo;
var sum64_5_hi = utils$a.sum64_5_hi;
var sum64_5_lo = utils$a.sum64_5_lo;

var BlockHash$1 = common$1.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();

  BlockHash$1.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$a.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;

SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;

SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512$1.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert$8(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512$1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$a.toHex32(this.h, 'big');
  else
    return utils$a.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

var utils$9 = utils$g;

var SHA512 = _512;

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils$9.inherits(SHA384, SHA512);
var _384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$9.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils$9.split32(this.h.slice(0, 12), 'big');
};

sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;

var ripemd = {};

var utils$8 = utils$g;
var common = common$5;

var rotl32 = utils$8.rotl32;
var sum32 = utils$8.sum32;
var sum32_3 = utils$8.sum32_3;
var sum32_4 = utils$8.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils$8.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f$1(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f$1(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$8.toHex32(this.h, 'little');
  else
    return utils$8.split32(this.h, 'little');
};

function f$1(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

var utils$7 = utils$g;
var assert$7 = minimalisticAssert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils$7.toArray(key, enc));
}
var hmac = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert$7(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

(function (exports) {
var hash = exports;

hash.utils = utils$g;
hash.common = common$5;
hash.sha = sha;
hash.ripemd = ripemd;
hash.hmac = hmac;

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;
}(hash$2));

(function (exports) {

var curves = exports;

var hash = hash$2;
var curve$1 = curve;
var utils = utils$m;

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve$1.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve$1.edwards(options);
  else
    this.curve = new curve$1.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});
}(curves$2));

var hash$1 = hash$2;
var utils$6 = utils$l;
var assert$6 = minimalisticAssert;

function HmacDRBG$1(options) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils$6.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils$6.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils$6.toArray(options.pers, options.persEnc || 'hex');
  assert$6(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG$1;

HmacDRBG$1.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG$1.prototype._hmac = function hmac() {
  return new hash$1.hmac(this.hash, this.K);
};

HmacDRBG$1.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils$6.toArray(entropy, entropyEnc);
  add = utils$6.toArray(add, addEnc);

  assert$6(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG$1.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils$6.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils$6.encode(res, enc);
};

var BN$4 = bn.exports;
var utils$5 = utils$m;
var assert$5 = utils$5.assert;

function KeyPair$3(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$1 = KeyPair$3;

KeyPair$3.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair$3)
    return pub;

  return new KeyPair$3(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair$3.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair$3)
    return priv;

  return new KeyPair$3(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair$3.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair$3.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN$4(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair$3.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert$5(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert$5(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair$3.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert$5(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair$3.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair$3.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair$3.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

var BN$3 = bn.exports;

var utils$4 = utils$m;
var assert$4 = utils$4.assert;

function Signature$3(options, enc) {
  if (options instanceof Signature$3)
    return options;

  if (this._importDER(options, enc))
    return;

  assert$4(options.r && options.s, 'Signature without r or s');
  this.r = new BN$3(options.r, 16);
  this.s = new BN$3(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$1 = Signature$3;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature$3.prototype._importDER = function _importDER(data, enc) {
  data = utils$4.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN$3(r);
  this.s = new BN$3(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature$3.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils$4.encode(res, enc);
};

var BN$2 = bn.exports;
var HmacDRBG = hmacDrbg;
var utils$3 = utils$m;
var curves$1 = curves$2;
var rand = brorand.exports;
var assert$3 = utils$3.assert;

var KeyPair$2 = key$1;
var Signature$2 = signature$1;

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert$3(Object.prototype.hasOwnProperty.call(curves$1, options),
      'Unknown curve ' + options);

    options = curves$1[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves$1.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair$2(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair$2.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair$2.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN$2(2));
  for (;;) {
    var priv = new BN$2(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN$2(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN$2(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN$2(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature$2({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN$2(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature$2(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert$3((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature$2(signature, enc);

  var n = this.n;
  var e = new BN$2(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature$2(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

var utils$2 = utils$m;
var assert$2 = utils$2.assert;
var parseBytes$2 = utils$2.parseBytes;
var cachedProperty$1 = utils$2.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair$1(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes$2(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes$2(params.pub);
}

KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair$1)
    return pub;
  return new KeyPair$1(eddsa, { pub: pub });
};

KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair$1)
    return secret;
  return new KeyPair$1(eddsa, { secret: secret });
};

KeyPair$1.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty$1(KeyPair$1, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty$1(KeyPair$1, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty$1(KeyPair$1, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty$1(KeyPair$1, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty$1(KeyPair$1, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty$1(KeyPair$1, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair$1.prototype.sign = function sign(message) {
  assert$2(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair$1.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair$1.prototype.getSecret = function getSecret(enc) {
  assert$2(this._secret, 'KeyPair is public only');
  return utils$2.encode(this.secret(), enc);
};

KeyPair$1.prototype.getPublic = function getPublic(enc) {
  return utils$2.encode(this.pubBytes(), enc);
};

var key = KeyPair$1;

var BN$1 = bn.exports;
var utils$1 = utils$m;
var assert$1 = utils$1.assert;
var cachedProperty = utils$1.cachedProperty;
var parseBytes$1 = utils$1.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature$1(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes$1(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert$1(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN$1)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature$1, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature$1, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature$1, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature$1, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature$1.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature$1.prototype.toHex = function toHex() {
  return utils$1.encode(this.toBytes(), 'hex').toUpperCase();
};

var signature = Signature$1;

var hash = hash$2;
var curves = curves$2;
var utils = utils$m;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = key;
var Signature = signature;

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

var eddsa = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

(function (exports) {

var elliptic = exports;

elliptic.version = require$$0.version;
elliptic.utils = utils$m;
elliptic.rand = brorand.exports;
elliptic.curve = curve;
elliptic.curves = curves$2;

// Protocols
elliptic.ec = ec;
elliptic.eddsa = eddsa;
}(elliptic));

const secp256k1 = new elliptic.ec("secp256k1");

/**
 * @typedef {import("../EcdsaPrivateKey.js").KeyPair} KeyPair
 */

/**
 * @returns {KeyPair}
 */
function generate() {
    const keypair = secp256k1.genKeyPair();

    return {
        privateKey: decode$5(keypair.getPrivate("hex")),
        publicKey: decode$5(keypair.getPublic(true, "hex")),
    };
}

/**
 * @returns {Promise<KeyPair>}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
async function generateAsync() {
    return Promise.resolve(generate());
}

/**
 * @param {Uint8Array} data
 * @returns {KeyPair}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function fromBytes(data) {
    const keypair = secp256k1.keyFromPrivate(data);

    return {
        privateKey: decode$5(keypair.getPrivate("hex")),
        publicKey: decode$5(keypair.getPublic(true, "hex")),
    };
}

/**
 * @param {Uint8Array} keydata
 * @param {Uint8Array} message
 * @returns {Uint8Array}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function sign(keydata, message) {
    const msg = encode$3(message);
    const data = decode$5(keccak256$2(`0x${msg}`));
    const keypair = secp256k1.keyFromPrivate(keydata);
    const signature = keypair.sign(data);

    const r = signature.r.toArray("be", 32);
    const s = signature.s.toArray("be", 32);

    const result = new Uint8Array(64);
    result.set(r, 0);
    result.set(s, 32);
    return result;
}

/**
 * @param {Uint8Array} keydata
 * @param {Uint8Array} message
 * @param {Uint8Array} signature
 * @returns {boolean}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function verify(keydata, message, signature) {
    const msg = encode$3(message);
    const data = decode$5(keccak256$2(`0x${msg}`));
    const keypair = secp256k1.keyFromPublic(keydata);

    return keypair.verify(data, {
        r: signature.subarray(0, 32),
        s: signature.subarray(32, 64),
    });
}

const derPrefix$1 = "302d300706052b8104000a032200";
const derPrefixBytes$1 = decode$5(derPrefix$1);

/**
 * An public key on the Hedera network.
 */
class EcdsaPublicKey extends Key$1 {
    /**
     * @internal
     * @hideconstructor
     * @param {Uint8Array} keyData
     */
    constructor(keyData) {
        super();

        /**
         * @type {Uint8Array}
         * @private
         * @readonly
         */
        this._keyData = keyData;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return "secp256k1";
    }

    /**
     * @param {Uint8Array} data
     * @returns {EcdsaPublicKey}
     */
    static fromBytes(data) {
        switch (data.length) {
            case 33:
                return EcdsaPublicKey.fromBytesRaw(data);
            case 49:
                return EcdsaPublicKey.fromBytesDer(data);
            default:
                throw new BadKeyError(
                    `invalid public key length: ${data.length} bytes`
                );
        }
    }

    /**
     * @param {Uint8Array} data
     * @returns {EcdsaPublicKey}
     */
    static fromBytesDer(data) {
        if (data.length != 44 || !arrayStartsWith(data, derPrefixBytes$1)) {
            throw new BadKeyError(
                `invalid public key length: ${data.length} bytes`
            );
        }

        return new EcdsaPublicKey(data.subarray(12));
    }

    /**
     * @param {Uint8Array} data
     * @returns {EcdsaPublicKey}
     */
    static fromBytesRaw(data) {
        if (data.length != 33) {
            throw new BadKeyError(
                `invalid public key length: ${data.length} bytes`
            );
        }

        return new EcdsaPublicKey(data);
    }

    /**
     * Parse a public key from a string of hexadecimal digits.
     *
     * The public key may optionally be prefixed with
     * the DER header.
     *
     * @param {string} text
     * @returns {EcdsaPublicKey}
     */
    static fromString(text) {
        return EcdsaPublicKey.fromBytes(decode$5(text));
    }

    /**
     * Verify a signature on a message with this public key.
     *
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {boolean}
     */
    verify(message, signature) {
        return verify(this._keyData, message, signature);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        const bytes = new Uint8Array(
            derPrefixBytes$1.length + this._keyData.length
        );

        bytes.set(derPrefixBytes$1, 0);
        bytes.set(this._keyData, derPrefixBytes$1.length);

        return bytes;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return new Uint8Array(this._keyData.subarray());
    }

    /**
     * @param {EcdsaPublicKey} other
     * @returns {boolean}
     */
    equals(other) {
        return arrayEqual$1(this._keyData, other._keyData);
    }
}

const derPrefix = "3030020100300706052b8104000a04220420";
const derPrefixBytes = decode$5(derPrefix);

/**
 * @typedef {object} KeyPair
 * @property {Uint8Array} publicKey
 * @property {Uint8Array} privateKey
 */

class EcdsaPrivateKey {
    /**
     * @hideconstructor
     * @internal
     * @param {KeyPair} keyPair
     * @param {(Uint8Array)=} chainCode
     */
    constructor(keyPair, chainCode) {
        /**
         * @type {KeyPair}
         * @readonly
         * @private
         */
        this._keyPair = keyPair;

        /**
         * @type {?Uint8Array}
         * @readonly
         */
        this._chainCode = chainCode != null ? chainCode : null;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return "secp256k1";
    }

    /**
     * Generate a random ECDSA private key.
     *
     * @returns {EcdsaPrivateKey}
     */
    static generate() {
        return new EcdsaPrivateKey(generate());
    }

    /**
     * Generate a random Ed25519 private key.
     *
     * @returns {Promise<EcdsaPrivateKey>}
     */
    static async generateAsync() {
        return new EcdsaPrivateKey(await generateAsync());
    }

    /**
     * Construct a private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {EcdsaPrivateKey}
     */
    static fromBytes(data) {
        switch (data.length) {
            case 32:
                return EcdsaPrivateKey.fromBytesRaw(data);
            case 50:
                return EcdsaPrivateKey.fromBytesDer(data);
            default:
                throw new BadKeyError(
                    `invalid private key length: ${data.length} bytes`
                );
        }
    }

    /**
     * Construct a private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {EcdsaPrivateKey}
     */
    static fromBytesDer(data) {
        if (data.length != 32 && !arrayStartsWith(data, derPrefixBytes)) {
            throw new BadKeyError("invalid der header");
        }

        return new EcdsaPrivateKey(
            fromBytes(data.subarray(derPrefixBytes.length))
        );
    }

    /**
     * Construct a private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {EcdsaPrivateKey}
     */
    static fromBytesRaw(data) {
        return new EcdsaPrivateKey(fromBytes(data));
    }

    /**
     * Construct a private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {EcdsaPrivateKey}
     */
    static fromString(text) {
        return EcdsaPrivateKey.fromBytes(decode$5(text));
    }

    /**
     * Construct a private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {EcdsaPrivateKey}
     */
    static fromStringDer(text) {
        return EcdsaPrivateKey.fromBytesDer(decode$5(text));
    }

    /**
     * Construct a private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {EcdsaPrivateKey}
     */
    static fromStringRaw(text) {
        return EcdsaPrivateKey.fromBytesRaw(decode$5(text));
    }

    /**
     * Get the public key associated with this private key.
     *
     * The public key can be freely given and used by other parties to verify
     * the signatures generated by this private key.
     *
     * @returns {EcdsaPublicKey}
     */
    get publicKey() {
        return new EcdsaPublicKey(this._keyPair.publicKey);
    }

    /**
     * Sign a message with this private key.
     *
     * @param {Uint8Array} bytes
     * @returns {Uint8Array} - The signature bytes without the message
     */
    sign(bytes) {
        return sign(this._keyPair.privateKey, bytes);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        const bytes = new Uint8Array(derPrefixBytes.length + 32);

        bytes.set(derPrefixBytes, 0);
        bytes.set(
            this._keyPair.privateKey.subarray(0, 32),
            derPrefixBytes.length
        );

        return bytes;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._keyPair.privateKey.slice(0, 32);
    }
}

/**
 * @typedef {import("./PrivateKey.js").Transaction} Transaction
 */

/**
 * An public key on the Hedera network.
 */
class PublicKey$1 extends Key$1 {
    /**
     * @internal
     * @hideconstructor
     * @param {Ed25519PublicKey | EcdsaPublicKey} key
     */
    constructor(key) {
        super();

        /**
         * @type {Ed25519PublicKey | EcdsaPublicKey}
         * @private
         * @readonly
         */
        this._key = key;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return this._key._type;
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytes(data) {
        try {
            return new PublicKey$1(Ed25519PublicKey.fromBytes(data));
        } catch {
            // Do nothing
        }

        try {
            return new PublicKey$1(EcdsaPublicKey.fromBytes(data));
        } catch {
            // Do nothing
        }

        throw new BadKeyError(
            `invalid public key length: ${data.length} bytes`
        );
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytesED25519(data) {
        return new PublicKey$1(Ed25519PublicKey.fromBytes(data));
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytesECDSA(data) {
        return new PublicKey$1(EcdsaPublicKey.fromBytes(data));
    }

    /**
     * Parse a public key from a string of hexadecimal digits.
     *
     * The public key may optionally be prefixed with
     * the DER header.
     *
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromString(text) {
        return PublicKey$1.fromBytes(decode$5(text));
    }

    /**
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromStringED25519(text) {
        return PublicKey$1.fromBytesED25519(decode$5(text));
    }

    /**
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromStringECDSA(text) {
        return PublicKey$1.fromBytesECDSA(decode$5(text));
    }

    /**
     * Verify a signature on a message with this public key.
     *
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {boolean}
     */
    verify(message, signature) {
        return this._key.verify(message, signature);
    }

    /**
     * @deprecated - use `@hashgraph/sdk`.PublicKey instead
     * @param {Transaction} transaction
     * @returns {boolean}
     */
    verifyTransaction(transaction) {
        console.log("Deprecated: use `@hashgraph/sdk`.PublicKey instead");

        transaction._requireFrozen();

        if (!transaction.isFrozen()) {
            transaction.freeze();
        }

        for (const signedTransaction of transaction._signedTransactions) {
            if (
                signedTransaction.sigMap != null &&
                signedTransaction.sigMap.sigPair != null
            ) {
                let found = false;
                for (const sigPair of signedTransaction.sigMap.sigPair) {
                    const pubKeyPrefix = /** @type {Uint8Array} */ (
                        sigPair.pubKeyPrefix
                    );
                    if (arrayEqual$1(pubKeyPrefix, this.toBytesRaw())) {
                        found = true;
                        const bodyBytes = /** @type {Uint8Array} */ (
                            signedTransaction.bodyBytes
                        );
                        const signature =
                            sigPair.ed25519 != null
                                ? sigPair.ed25519
                                : /** @type {Uint8Array} */ (
                                      sigPair.ECDSASecp256k1
                                  );
                        if (!this.verify(bodyBytes, signature)) {
                            return false;
                        }
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        if (this._key instanceof Ed25519PublicKey) {
            return this.toBytesRaw();
        } else {
            return this.toBytesDer();
        }
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        return this._key.toBytesDer();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._key.toBytesRaw();
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringDer() {
        return encode$3(this.toBytesDer());
    }

    /**
     * @returns {string}
     */
    toStringRaw() {
        return encode$3(this.toBytesRaw());
    }

    /**
     * @param {PublicKey} other
     * @returns {boolean}
     */
    equals(other) {
        if (
            this._key instanceof Ed25519PublicKey &&
            other instanceof Ed25519PublicKey
        ) {
            return this._key.equals(other);
        } else if (
            this._key instanceof EcdsaPublicKey &&
            other instanceof EcdsaPublicKey
        ) {
            return this._key.equals(other);
        } else {
            return false;
        }
    }
}

const CipherAlgorithm = {
    Aes128Ctr: "AES-128-CTR",
    Aes128Cbc: "AES-128-CBC",
};

/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
async function createCipheriv(algorithm, key, iv, data) {
    let algorithm_;

    switch (algorithm.toUpperCase()) {
        case CipherAlgorithm.Aes128Ctr:
            algorithm_ = {
                name: "AES-CTR",
                counter: iv,
                length: 128,
            };
            break;
        case CipherAlgorithm.Aes128Cbc:
            algorithm_ = {
                name: "AES-CBC",
                iv: iv,
            };
            break;
        default:
            throw new Error(
                "(BUG) non-exhaustive switch statement for CipherAlgorithm"
            );
    }

    const key_ = await window.crypto.subtle.importKey(
        "raw",
        key,
        algorithm_.name,
        false,
        ["encrypt"]
    );

    return new Uint8Array(
        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
        /** @type {ArrayBuffer} */ (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            await window.crypto.subtle.encrypt(algorithm_, key_, data)
        )
    );
}

/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
async function createDecipheriv(algorithm, key, iv, data) {
    let algorithm_;

    switch (algorithm.toUpperCase()) {
        case CipherAlgorithm.Aes128Ctr:
            algorithm_ = {
                name: "AES-CTR",
                counter: iv,
                length: 128,
            };
            break;
        case CipherAlgorithm.Aes128Cbc:
            algorithm_ = {
                name: "AES-CBC",
                iv,
            };
            break;
        default:
            throw new Error(
                "(BUG) non-exhaustive switch statement for CipherAlgorithm"
            );
    }

    const key_ = await window.crypto.subtle.importKey(
        "raw",
        key,
        algorithm_.name,
        false,
        ["decrypt"]
    );

    return new Uint8Array(
        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
        /** @type {ArrayBuffer} */ (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            await window.crypto.subtle.decrypt(algorithm_, key_, data)
        )
    );
}

const HMAC_SHA256 = "hmac-sha256";

/**
 * @typedef {Object} KeystoreKdfParams
 * @property {number} dkLen
 * @property {string} salt
 * @property {number} c
 * @property {string} prf
 */

/**
 * @typedef {Object} KeystoreCipherParams
 * @property {string} iv
 */

/**
 * @typedef {Object} KeystoreCrypto
 * @property {string} ciphertext
 * @property {KeystoreCipherParams} cipherparams
 * @property {string} cipher
 * @property {string} kdf
 * @property {KeystoreKdfParams} kdfparams
 * @property {string} mac
 */

/**
 * @typedef {Object} Keystore
 * @property {number} version
 * @property {KeystoreCrypto} crypto
 */

/**
 * @param {Uint8Array} privateKey
 * @param {string} passphrase
 * @returns {Promise<Uint8Array>}
 */
async function createKeystore(privateKey, passphrase) {
    // all values taken from https://github.com/ethereumjs/ethereumjs-wallet/blob/de3a92e752673ada1d78f95cf80bc56ae1f59775/src/index.ts#L25
    const dkLen = 32;
    const c = 262144;
    const saltLen = 32;
    const salt = await bytesAsync(saltLen);

    const key = await deriveKey(
        HashAlgorithm.Sha256,
        passphrase,
        salt,
        c,
        dkLen
    );

    const iv = await bytesAsync(16);

    // AES-128-CTR with the first half of the derived key and a random IV
    const cipherText = await createCipheriv(
        CipherAlgorithm.Aes128Ctr,
        key.slice(0, 16),
        iv,
        privateKey
    );

    const mac = await hash$3(
        HashAlgorithm.Sha384,
        key.slice(16),
        cipherText
    );

    /**
     * @type {Keystore}
     */
    const keystore = {
        version: 1,
        crypto: {
            ciphertext: encode$3(cipherText),
            cipherparams: { iv: encode$3(iv) },
            cipher: CipherAlgorithm.Aes128Ctr,
            kdf: "pbkdf2",
            kdfparams: {
                dkLen,
                salt: encode$3(salt),
                c,
                prf: HMAC_SHA256,
            },
            mac: encode$3(mac),
        },
    };

    return encode$2(JSON.stringify(keystore));
}

/**
 * @param {Uint8Array} keystoreBytes
 * @param {string} passphrase
 * @returns {Promise<Uint8Array>}
 */
async function loadKeystore(keystoreBytes, passphrase) {
    /**
     * @type {Keystore}
     */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const keystore = JSON.parse(decode$4(keystoreBytes));

    if (keystore.version !== 1) {
        throw new BadKeyError(
            `unsupported keystore version: ${keystore.version}`
        );
    }

    const {
        ciphertext,
        cipherparams: { iv },
        cipher,
        kdf,
        kdfparams: { dkLen, salt, c, prf },
        mac,
    } = keystore.crypto;

    if (kdf !== "pbkdf2") {
        throw new BadKeyError(`unsupported key derivation function:" + ${kdf}`);
    }

    if (prf !== HMAC_SHA256) {
        throw new BadKeyError(
            `unsupported key derivation hash function: ${prf}`
        );
    }

    const saltBytes = decode$5(salt);
    const ivBytes = decode$5(iv);
    const cipherBytes = decode$5(ciphertext);

    const key = await deriveKey(
        HashAlgorithm.Sha256,
        passphrase,
        saltBytes,
        c,
        dkLen
    );

    const macHex = decode$5(mac);
    const verifyHmac = await hash$3(
        HashAlgorithm.Sha384,
        key.slice(16),
        cipherBytes
    );

    // compare that these two Uint8Arrays are equivalent
    if (!macHex.every((b, i) => b === verifyHmac[i])) {
        throw new BadKeyError("HMAC mismatch; passphrase is incorrect");
    }

    return createDecipheriv(
        cipher,
        key.slice(0, 16),
        ivBytes,
        cipherBytes
    );
}

/**
 * @typedef {Object} AsnSeq
 * @property {AsnType[]} seq
 */

/**
 * @typedef {Object} AsnInt
 * @property {number} int
 */

/**
 * @typedef {Object} AsnBytes
 * @property {Uint8Array} bytes
 */

/**
 * @typedef {Object} AsnIdent
 * @property {string} ident
 */

/**
 * @typedef {{}} AsnNull
 */

/**
 * @typedef {AsnSeq | AsnInt | AsnBytes | AsnIdent | AsnNull} AsnType
 */

/**
 * Note: may throw weird errors on malformed input. Catch and rethrow with, e.g. `BadKeyError`.
 *
 *@param {Uint8Array} data
 *@returns {AsnType}
 */
function decode$3(data) {
    return decodeIncremental(data)[0];
}

/**
 * @param {Uint8Array} bytes
 * @returns {[AsnType, Uint8Array]}
 */
function decodeIncremental(bytes) {
    // slice off the initial tag byte, `decodeLength` returns a slice of the remaining data
    const [len, rem] = decodeLength(bytes.subarray(1));
    const data = rem.subarray(0, len);
    const tail = rem.subarray(len);

    switch (bytes[0]) {
        case 2:
            return [{ int: decodeInt(data) }, tail];
        case 4: // must always be primitive form in DER; for OCTET STRING this is literal bytes
            return [{ bytes: data }, tail];
        case 5: // empty
            return [{}, tail];
        case 6:
            return [{ ident: decodeObjectIdent(data) }, tail];
        case 48:
            return [{ seq: decodeSeq(data) }, tail];
        default:
            throw new Error(`unsupported DER type tag: ${bytes[0]}`);
    }
}

/**
 * @param {Uint8Array} seqBytes
 * @returns {AsnType[]}
 */
function decodeSeq(seqBytes) {
    let data = seqBytes;

    const seq = [];

    while (data.length !== 0) {
        const [decoded, remaining] = decodeIncremental(data);
        seq.push(decoded);
        data = remaining;
    }

    return seq;
}

/**
 * @param {Uint8Array} idBytes
 * @returns {string}
 */
function decodeObjectIdent(idBytes) {
    const id = [
        // first octet is 40 * value1 + value2
        Math.floor(idBytes[0] / 40),
        idBytes[0] % 40,
    ];

    // each following ID component is big-endian base128 where the MSB is set if another byte
    // follows for the same value
    let val = 0;

    for (const byte of idBytes.subarray(1)) {
        // shift the entire value left by 7 bits
        val *= 128;

        if (byte < 128) {
            // no more octets follow for this value, finish it off
            val += byte;
            id.push(val);
            val = 0;
        } else {
            // zero the MSB
            val += byte & 127;
        }
    }

    return id.join(".");
}

/**
 * @param {Uint8Array} lenBytes
 * @returns {[number, Uint8Array]}
 */
function decodeLength(lenBytes) {
    if (lenBytes[0] < 128) {
        // definite, short form
        return [lenBytes[0], lenBytes.subarray(1)];
    }

    const numBytes = lenBytes[0] - 128;

    const intBytes = lenBytes.subarray(1, numBytes + 1);
    const rem = lenBytes.subarray(numBytes + 1);

    return [decodeInt(intBytes), rem];
}

/**
 * @param {Uint8Array} intBytes
 * @returns {number}
 */
function decodeInt(intBytes) {
    const len = intBytes.length;
    if (len === 1) {
        return intBytes[0];
    }

    let view = new DataView(
        intBytes.buffer,
        intBytes.byteOffset,
        intBytes.byteLength
    );

    if (len === 2) return view.getUint16(0, false);

    if (len === 3) {
        // prefix a zero byte and we'll treat it as a 32-bit int
        const data = Uint8Array.of(0, ...intBytes);
        view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }

    if (len > 4) {
        // this probably means a bug in the decoding as this would mean a >4GB structure
        throw new Error(`unsupported DER integer length of ${len} bytes`);
    }

    return view.getUint32(0, false);
}

class AlgorithmIdentifier {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if ("seq" in asn && asn.seq.length >= 1 && "ident" in asn.seq[0]) {
            /**
             * @type {string}
             */
            this.algIdent = asn.seq[0].ident;

            /**
             * @type {import("../encoding/der.js").AsnType | undefined}
             */
            this.parameters = asn.seq[1];
        } else {
            throw new Error(
                `error parsing AlgorithmIdentifier from ${JSON.stringify(asn)}`
            );
        }
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this);
    }
}

class PBES2Params {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if ("seq" in asn && asn.seq.length === 2) {
            /**
             * @type {AlgorithmIdentifier}
             */
            this.kdf = new AlgorithmIdentifier(asn.seq[0]);

            /**
             * @type {AlgorithmIdentifier}
             */
            this.encScheme = new AlgorithmIdentifier(asn.seq[1]);
        } else {
            throw new Error(
                `error parsing PBES2Params from ${JSON.stringify(asn)}`
            );
        }
    }
}

class PBKDF2Params {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if (
            "seq" in asn &&
            asn.seq.length >= 2 &&
            "bytes" in asn.seq[0] &&
            "int" in asn.seq[1]
        ) {
            /**
             * @type {Uint8Array}
             */
            this.salt = asn.seq[0].bytes;

            /**
             * @type {number}
             */
            this.iterCount = asn.seq[1]["int"];

            if (asn.seq.length > 2) {
                if ("seq" in asn.seq[2]) {
                    this.prf = new AlgorithmIdentifier(asn.seq[2]);
                    return;
                } else if ("int" in asn.seq[2]) {
                    /**
                     * @type {number | undefined}
                     */
                    this.keyLength = asn.seq[2]["int"];
                }

                if (asn.seq.length === 4) {
                    /**
                     * @type {AlgorithmIdentifier | undefined}
                     */
                    this.prf = new AlgorithmIdentifier(asn.seq[3]);
                }

                return;
            }
        }

        throw new Error(
            `error parsing PBKDF2Params from ${JSON.stringify(asn)}`
        );
    }
}

class PrivateKeyInfo {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if ("seq" in asn && asn.seq.length === 3) {
            if ("int" in asn.seq[0] && asn.seq[0]["int"] === 0) {
                /**
                 * @type {number}
                 */
                this.version = 0;
            } else {
                throw new Error(
                    `expected version = 0, got ${JSON.stringify(asn.seq[0])}`
                );
            }

            /**
             * @type {AlgorithmIdentifier}
             */
            this.algId = new AlgorithmIdentifier(asn.seq[1]);

            if ("bytes" in asn.seq[2]) {
                /**
                 * @type {Uint8Array}
                 */
                this.privateKey = asn.seq[2].bytes;
            } else {
                throw new Error(
                    `expected octet string as 3rd element, got ${JSON.stringify(
                        asn.seq[2]
                    )}`
                );
            }

            return;
        }

        throw new Error(
            `error parsing PrivateKeyInfo from ${JSON.stringify(asn)}`
        );
    }

    /**
     * @param {Uint8Array} encoded
     * @returns {PrivateKeyInfo}
     */
    static parse(encoded) {
        return new PrivateKeyInfo(decode$3(encoded));
    }
}

class EncryptedPrivateKeyInfo {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if ("seq" in asn && asn.seq.length === 2 && "bytes" in asn.seq[1]) {
            /**
             * @type {AlgorithmIdentifier}
             */
            this.algId = new AlgorithmIdentifier(asn.seq[0]);

            /**
             * @type {Uint8Array}
             */
            this.data = asn.seq[1].bytes;
            return;
        }

        throw new Error(
            `error parsing EncryptedPrivateKeyInfo from ${JSON.stringify(asn)}`
        );
    }

    /**
     * @param {Uint8Array} encoded
     * @returns {EncryptedPrivateKeyInfo}
     */
    static parse(encoded) {
        return new EncryptedPrivateKeyInfo(decode$3(encoded));
    }

    /**
     * @param {string} passphrase
     * @returns {Promise<PrivateKeyInfo>}
     */
    async decrypt(passphrase) {
        if (
            this.algId.algIdent !== "1.2.840.113549.1.5.13" ||
            !this.algId.parameters
        ) {
            // PBES2
            throw new Error(
                `unsupported key encryption algorithm: ${this.algId.toString()}`
            );
        }

        const pbes2Params = new PBES2Params(this.algId.parameters);

        if (
            pbes2Params.kdf.algIdent !== "1.2.840.113549.1.5.12" ||
            !pbes2Params.kdf.parameters
        ) {
            // PBKDF2
            throw new Error(
                `unsupported key derivation function: ${pbes2Params.kdf.toString()}`
            );
        }

        const pbkdf2Params = new PBKDF2Params(pbes2Params.kdf.parameters);

        if (!pbkdf2Params.prf) {
            throw new Error("unsupported PRF HMAC-SHA-1");
        } else if (pbkdf2Params.prf.algIdent !== "1.2.840.113549.2.9") {
            // HMAC-SHA-256
            throw new Error(`unsupported PRF ${pbkdf2Params.prf.toString()}`);
        }

        if (pbes2Params.encScheme.algIdent !== "2.16.840.1.101.3.4.1.2") {
            // AES-128-CBC
            throw new Error(
                `unsupported encryption scheme: ${pbes2Params.encScheme.toString()}`
            );
        }

        if (
            !pbes2Params.encScheme.parameters ||
            !("bytes" in pbes2Params.encScheme.parameters)
        ) {
            throw new Error(
                "expected IV as bytes for AES-128-CBC, " +
                    `got: ${JSON.stringify(pbes2Params.encScheme.parameters)}`
            );
        }

        const keyLen = pbkdf2Params.keyLength || 16;
        const iv = pbes2Params.encScheme.parameters.bytes;

        const key = await deriveKey(
            HashAlgorithm.Sha256,
            passphrase,
            pbkdf2Params.salt,
            pbkdf2Params.iterCount,
            keyLen
        );

        const decrypted = await createDecipheriv(
            CipherAlgorithm.Aes128Cbc,
            key,
            iv,
            this.data
        );

        return PrivateKeyInfo.parse(decrypted);
    }
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
function decode$2(text) {
    // note: assumes <atob> is available in the global scope if <Buffer> is not
    // eslint-disable-next-line deprecation/deprecation
    return Uint8Array.from(atob(text), (c) => c.charCodeAt(0));
}

const BEGIN_PRIVATEKEY = "-----BEGIN PRIVATE KEY-----\n";
const END_PRIVATEKEY = "-----END PRIVATE KEY-----\n";

const BEGIN_ENCRYPTED_PRIVATEKEY = "-----BEGIN ENCRYPTED PRIVATE KEY-----\n";
const END_ENCRYPTED_PRIVATEKEY = "-----END ENCRYPTED PRIVATE KEY-----\n";

/**
 * @param {string} pem
 * @param {string} [passphrase]
 * @returns {Promise<Ed25519PrivateKey | EcdsaPrivateKey | Uint8Array>}
 */
async function read(pem, passphrase) {
    const beginTag = passphrase ? BEGIN_ENCRYPTED_PRIVATEKEY : BEGIN_PRIVATEKEY;

    const endTag = passphrase ? END_ENCRYPTED_PRIVATEKEY : END_PRIVATEKEY;

    const beginIndex = pem.indexOf(beginTag);
    const endIndex = pem.indexOf(endTag);

    if (beginIndex === -1 || endIndex === -1) {
        throw new BadKeyError("failed to find a private key in the PEM file");
    }

    const keyEncoded = pem.slice(beginIndex + beginTag.length, endIndex);

    const key = decode$2(keyEncoded);

    if (passphrase) {
        let encrypted;

        try {
            encrypted = EncryptedPrivateKeyInfo.parse(key);
        } catch (error) {
            const message =
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                error != null && /** @type {Error} */ (error).message != null
                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                      /** @type {Error} */ (error).message
                    : "";

            throw new BadKeyError(
                `failed to parse encrypted private key: ${message}`
            );
        }

        const decrypted = await encrypted.decrypt(passphrase);

        let privateKey = null;

        if (decrypted.algId.algIdent === "1.3.101.112") {
            privateKey = Ed25519PrivateKey;
        } else if (decrypted.algId.algIdent === "1.3.132.0.10") {
            privateKey = EcdsaPrivateKey;
        } else {
            throw new BadKeyError(
                `unknown private key algorithm ${decrypted.algId.toString()}`
            );
        }

        const keyData = decode$3(decrypted.privateKey);

        if (!("bytes" in keyData)) {
            throw new BadKeyError(
                `expected ASN bytes, got ${JSON.stringify(keyData)}`
            );
        }

        return privateKey.fromBytes(keyData.bytes);
    }

    return key.subarray(16);
}

/**
 * @param {Uint8Array} seed
 * @param {number} index
 * @returns {Promise<Uint8Array>}
 */
function legacy(seed, index) {
    const password = new Uint8Array(seed.length + 8);
    password.set(seed, 0);

    const view = new DataView(
        password.buffer,
        password.byteOffset,
        password.byteLength
    );

    if (index === 0xffffffffff) {
        view.setInt32(seed.length + 0, 0xff);
        view.setInt32(seed.length + 4, -1); // 0xffffffff
    } else {
        view.setInt32(seed.length + 0, index < 0 ? -1 : 0);
        view.setInt32(seed.length + 4, index);
    }

    const salt = Uint8Array.from([0xff]);
    return deriveKey(
        HashAlgorithm.Sha512,
        password,
        salt,
        2048,
        32
    );
}

/**
 * @typedef {object} ProtoSignaturePair
 * @property {(Uint8Array | null)=} pubKeyPrefix
 * @property {(Uint8Array | null)=} ed25519
 * @property {(Uint8Array | null)=} ECDSASecp256k1
 */

/**
 * @typedef {object} ProtoSigMap
 * @property {(ProtoSignaturePair[] | null)=} sigPair
 */

/**
 * @typedef {object} ProtoSignedTransaction
 * @property {(Uint8Array | null)=} bodyBytes
 * @property {(ProtoSigMap | null)=} sigMap
 */

/**
 * @typedef {object} Transaction
 * @property {() => boolean} isFrozen
 * @property {ProtoSignedTransaction[]} _signedTransactions
 * @property {Set<string>} _signerPublicKeys
 * @property {(publicKey: PublicKey, signature: Uint8Array) => Transaction} addSignature
 * @property {() => void} _requireFrozen
 * @property {() => Transaction} freeze
 */

/**
 * A private key on the Hedera network.
 */
class PrivateKey$1 extends Key$1 {
    /**
     * @hideconstructor
     * @internal
     * @param {Ed25519PrivateKey | EcdsaPrivateKey} key
     */
    constructor(key) {
        super();

        /**
         * @type {Ed25519PrivateKey | EcdsaPrivateKey}
         * @readonly
         * @private
         */
        this._key = key;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return this._key._type;
    }

    /**
     * Generate a random Ed25519 private key.
     *
     * @returns {PrivateKey}
     */
    static generateED25519() {
        return new PrivateKey$1(Ed25519PrivateKey.generate());
    }

    /**
     * Generate a random EDSA private key.
     *
     * @returns {PrivateKey}
     */
    static generateECDSA() {
        return new PrivateKey$1(EcdsaPrivateKey.generate());
    }

    /**
     * Depredated - Use `generateEd25519()` instead
     * Generate a random Ed25519 private key.
     *
     * @returns {PrivateKey}
     */
    static generate() {
        return PrivateKey$1.generateED25519();
    }

    /**
     * Depredated - Use `generateEd25519Async()` instead
     * Generate a random Ed25519 private key.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generateAsync() {
        return PrivateKey$1.generateED25519Async();
    }

    /**
     * Generate a random Ed25519 private key.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generateED25519Async() {
        return new PrivateKey$1(await Ed25519PrivateKey.generateAsync());
    }

    /**
     * Generate a random ECDSA private key.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generateECDSAAsync() {
        return new PrivateKey$1(await EcdsaPrivateKey.generateAsync());
    }

    /**
     * Construct a private key from bytes. Requires DER header.
     *
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytes(data) {
        try {
            return new PrivateKey$1(Ed25519PrivateKey.fromBytes(data));
        } catch {
            // Do nothing
        }

        try {
            return new PrivateKey$1(EcdsaPrivateKey.fromBytes(data));
        } catch {
            // Do nothing
        }

        throw new BadKeyError(
            `invalid private key length: ${data.length} bytes`
        );
    }

    /**
     * Construct a ECDSA private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytesECDSA(data) {
        return new PrivateKey$1(EcdsaPrivateKey.fromBytes(data));
    }

    /**
     * Construct a ED25519 private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytesED25519(data) {
        return new PrivateKey$1(Ed25519PrivateKey.fromBytes(data));
    }

    /**
     * Construct a private key from a hex-encoded string. Requires DER header.
     *
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromString(text) {
        return PrivateKey$1.fromBytes(decode$5(text));
    }

    /**
     * Construct a ECDSA private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromStringECDSA(text) {
        return PrivateKey$1.fromBytesECDSA(decode$5(text));
    }

    /**
     * Construct a Ed25519 private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromStringED25519(text) {
        return PrivateKey$1.fromBytesED25519(decode$5(text));
    }

    /**
     * Recover a private key from a mnemonic phrase (and optionally a password).
     *
     * @param {Mnemonic | string} mnemonic
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    static async fromMnemonic(mnemonic, passphrase = "") {
        return (
            typeof mnemonic === "string"
                ? await Mnemonic$1.fromString(mnemonic)
                : mnemonic
        ).toPrivateKey(passphrase);
    }

    /**
     * Recover a private key from a keystore, previously created by `.toKeystore()`.
     *
     * This key will _not_ support child key derivation.
     *
     * @param {Uint8Array} data
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.
     */
    static async fromKeystore(data, passphrase = "") {
        return PrivateKey$1.fromBytes(await loadKeystore(data, passphrase));
    }

    /**
     * Recover a private key from a pem string; the private key may be encrypted.
     *
     * This method assumes the .pem file has been converted to a string already.
     *
     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
     * section and decodes that as a DER-encoded  private key.
     *
     * @param {string} data
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    static async fromPem(data, passphrase = "") {
        const pem = await read(data, passphrase);

        if (
            pem instanceof Ed25519PrivateKey ||
            pem instanceof EcdsaPrivateKey
        ) {
            return new PrivateKey$1(pem);
        }

        return PrivateKey$1.fromBytes(pem);
    }

    /**
     * Derive a new private key at the given wallet index.
     *
     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
     * an error.
     *
     * You can check if a key supports derivation with `.supportsDerivation()`
     *
     * @param {number} index
     * @returns {Promise<PrivateKey>}
     * @throws If this key does not support derivation.
     */
    async derive(index) {
        // return new PrivateKey(await this._key.derive(index));
        if (this._key._chainCode == null) {
            throw new Error("this private key does not support key derivation");
        }

        const { keyData, chainCode } = await derive(
            this.toBytesRaw(),
            this._key._chainCode,
            index
        );

        /** @type {new (bytes: Uint8Array, chainCode?: Uint8Array) => Ed25519PrivateKey | EcdsaPrivateKey} */
        const constructor = /** @type {any} */ (this._key.constructor);

        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        return new PrivateKey$1(new constructor(keyData, chainCode));
    }

    /**
     * @param {number} index
     * @returns {Promise<PrivateKey>}
     * @throws If this key does not support derivation.
     */
    async legacyDerive(index) {
        const keyBytes = await legacy(
            this.toBytesRaw().subarray(0, 32),
            index
        );

        /** @type {new (bytes: Uint8Array) => Ed25519PrivateKey | EcdsaPrivateKey} */
        const constructor = /** @type {any} */ (this._key.constructor);

        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        return new PrivateKey$1(new constructor(keyBytes));
    }

    /**
     * Get the public key associated with this private key.
     *
     * The public key can be freely given and used by other parties to verify
     * the signatures generated by this private key.
     *
     * @returns {PublicKey}
     */
    get publicKey() {
        return new PublicKey$1(this._key.publicKey);
    }

    /**
     * Sign a message with this private key.
     *
     * @param {Uint8Array} bytes
     * @returns {Uint8Array} - The signature bytes without the message
     */
    sign(bytes) {
        return this._key.sign(bytes);
    }

    /**
     * @param {Transaction} transaction
     * @returns {Uint8Array}
     */
    signTransaction(transaction) {
        transaction._requireFrozen();

        if (!transaction.isFrozen()) {
            transaction.freeze();
        }

        if (transaction._signedTransactions.length != 1) {
            throw new Error(
                "`PrivateKey.signTransaction()` requires `Transaction` to have a single node `AccountId` set"
            );
        }

        const tx = /** @type {ProtoSignedTransaction} */ (
            transaction._signedTransactions[0]
        );

        const publicKeyHex = encode$3(this.publicKey.toBytesRaw());

        if (tx.sigMap == null) {
            tx.sigMap = {};
        }

        if (tx.sigMap.sigPair == null) {
            tx.sigMap.sigPair = [];
        }

        for (const sigPair of tx.sigMap.sigPair) {
            if (
                sigPair.pubKeyPrefix != null &&
                encode$3(sigPair.pubKeyPrefix) === publicKeyHex
            ) {
                switch (this._type) {
                    case "ED25519":
                        return /** @type {Uint8Array} */ (sigPair.ed25519);
                    case "secp256k1":
                        return /** @type {Uint8Array} */ (
                            sigPair.ECDSASecp256k1
                        );
                }
            }
        }

        const siganture = this.sign(
            tx.bodyBytes != null ? tx.bodyBytes : new Uint8Array()
        );

        /** @type {ProtoSignaturePair} */
        const protoSignature = {
            pubKeyPrefix: this.publicKey.toBytesRaw(),
        };

        switch (this._type) {
            case "ED25519":
                protoSignature.ed25519 = siganture;
                break;
            case "secp256k1":
                protoSignature.ECDSASecp256k1 = siganture;
                break;
        }

        tx.sigMap.sigPair.push(protoSignature);
        transaction._signerPublicKeys.add(publicKeyHex);

        return siganture;
    }

    /**
     * Check if `derive` can be called on this private key.
     *
     * This is only the case if the key was created from a mnemonic.
     *
     * @returns {boolean}
     */
    isDerivable() {
        return this._key._chainCode != null;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        if (this._key instanceof Ed25519PrivateKey) {
            return this.toBytesRaw();
        } else {
            return this.toBytesDer();
        }
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        return this._key.toBytesDer();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._key.toBytesRaw();
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringDer() {
        return encode$3(this.toBytesDer());
    }

    /**
     * @returns {string}
     */
    toStringRaw() {
        return encode$3(this.toBytesRaw());
    }

    /**
     * Create a keystore with a given passphrase.
     *
     * The key can be recovered later with `fromKeystore()`.
     *
     * Note that this will not retain the ancillary data used for
     * deriving child keys, thus `.derive()` on the restored key will
     * throw even if this instance supports derivation.
     *
     * @param {string} [passphrase]
     * @returns {Promise<Uint8Array>}
     */
    toKeystore(passphrase = "") {
        return createKeystore(this.toBytesRaw(), passphrase);
    }
}

CACHE$1.privateKeyConstructor = (key) => new PrivateKey$1(key);
CACHE$1.privateKeyFromBytes = (bytes) => PrivateKey$1.fromBytes(bytes);

/**
 * @typedef {import("./contract/ContractId.js").default} ContractId
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./KeyList.js").default} KeyList
 * @typedef {import("./PublicKey.js").default} PublicKey
 * @typedef {import("./PrivateKey.js").default} PrivateKey
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").IKeyList} proto.IKeyList
 * @typedef {import("@hashgraph/proto").IThresholdKey} proto.IThresholdKey
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 */

/**
 * @namespace cryptography
 * @typedef {import("@hashgraph/cryptography").PrivateKey} cryptography.PrivateKey
 */

/**
 * @template {object} ProtobufT
 * @template {object} SdkT
 * @typedef {{ (proto: ProtobufT): SdkT }} FromProtobufKeyFuncT
 */

const CACHE = {
    /** @type {FromProtobufKeyFuncT<proto.IContractID, ContractId> | null} */
    contractId: null,

    /** @type {FromProtobufKeyFuncT<proto.IKeyList, KeyList> | null} */
    keyList: null,

    /** @type {FromProtobufKeyFuncT<proto.IThresholdKey, KeyList> | null} */
    thresholdKey: null,

    /** @type {FromProtobufKeyFuncT<Uint8Array, PublicKey> | null} */
    publicKeyED25519: null,

    /** @type {FromProtobufKeyFuncT<Uint8Array, PublicKey> | null} */
    publicKeyECDSA: null,

    /** @type {((key: cryptography.PrivateKey) => PrivateKey) | null} */
    privateKeyConstructor: null,

    /** @type {((shard: Long | number, realm: Long | number, key: PublicKey) => AccountId) | null} */
    accountIdConstructor: null,

    /** @type {FromProtobufKeyFuncT<proto.IContractID, ContractId> | null} */
    delegateContractId: null,
};

/**
 * @typedef {import("./PrivateKey.js").default} PrivateKey
 */

/**
 * Multi-word mnemonic phrase (BIP-39).
 *
 * Compatible with the official Hedera mobile
 * wallets (24-words or 22-words) and BRD (12-words).
 */
class Mnemonic {
    /**
     * @param {cryptography.Mnemonic} mnemonic
     * @hideconstructor
     * @private
     */
    constructor(mnemonic) {
        this._mnemonic = mnemonic;
    }

    /**
     * Returns a new random 24-word mnemonic from the BIP-39
     * standard English word list.
     *
     * @returns {Promise<Mnemonic>}
     */
    static async generate() {
        return new Mnemonic(await Mnemonic$1._generate(24));
    }

    /**
     * Returns a new random 12-word mnemonic from the BIP-39
     * standard English word list.
     *
     * @returns {Promise<Mnemonic>}
     */
    static async generate12() {
        return new Mnemonic(await Mnemonic$1._generate(12));
    }

    /**
     * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
     *
     * An exception of BadMnemonicError will be thrown if the mnemonic
     * contains unknown words or fails the checksum. An invalid mnemonic
     * can still be used to create private keys, the exception will
     * contain the failing mnemonic in case you wish to ignore the
     * validation error and continue.
     *
     * @param {string[]} words
     * @throws {BadMnemonicError}
     * @returns {Promise<Mnemonic>}
     */
    static async fromWords(words) {
        return new Mnemonic(await Mnemonic$1.fromWords(words));
    }

    /**
     * Recover a private key from this mnemonic phrase, with an
     * optional passphrase.
     *
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    async toPrivateKey(passphrase = "") {
        if (CACHE.privateKeyConstructor == null) {
            throw new Error("`PrivateKey` has not been loaded");
        }

        return CACHE.privateKeyConstructor(
            await this._mnemonic.toPrivateKey(passphrase)
        );
    }

    /**
     * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
     *
     * @param {string} mnemonic
     * @returns {Promise<Mnemonic>}
     */
    static async fromString(mnemonic) {
        return new Mnemonic(await Mnemonic$1.fromString(mnemonic));
    }

    /**
     * @returns {Promise<PrivateKey>}
     */
    async toLegacyPrivateKey() {
        if (CACHE.privateKeyConstructor == null) {
            throw new Error("`PrivateKey` has not been loaded");
        }

        return CACHE.privateKeyConstructor(
            await this._mnemonic.toLegacyPrivateKey()
        );
    }

    /**
     * @returns {string}
     */
    toString() {
        return this._mnemonic.toString();
    }
}

/**
 * @param {Uint8Array} array1
 * @param {Uint8Array} array2
 * @returns {boolean}
 */
function arrayEqual(array1, array2) {
    if (array1 === array2) {
        return true;
    }

    if (array1.byteLength !== array2.byteLength) {
        return false;
    }

    const view1 = new DataView(
        array1.buffer,
        array1.byteOffset,
        array1.byteLength
    );
    const view2 = new DataView(
        array2.buffer,
        array2.byteOffset,
        array2.byteLength
    );

    let i = array1.byteLength;

    while (i--) {
        if (view1.getUint8(i) !== view2.getUint8(i)) {
            return false;
        }
    }

    return true;
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 */

class Key {
    /**
     * @internal
     * @abstract
     * @returns {proto.IKey}
     */
    // eslint-disable-next-line jsdoc/require-returns-check
    _toProtobufKey() {
        throw new Error("not implemented");
    }

    /**
     * @internal
     * @param {proto.IKey} key
     * @returns {Key}
     */
    static _fromProtobufKey(key) {
        if (key.contractID != null) {
            if (CACHE.contractId == null) {
                throw new Error(
                    "`ContractId` was not loaded before decoding `Key`"
                );
            }

            return CACHE.contractId(key.contractID);
        }

        if (key.delegatableContractId != null) {
            if (CACHE.delegateContractId == null) {
                throw new Error(
                    "`ContractId` was not loaded before decoding `Key`"
                );
            }

            return CACHE.delegateContractId(key.delegatableContractId);
        }

        if (key.ed25519 != null && key.ed25519.byteLength > 0) {
            if (CACHE.publicKeyED25519 == null) {
                throw new Error(
                    "`PublicKey` was not loaded before decoding `Key`"
                );
            }

            return CACHE.publicKeyED25519(key.ed25519);
        }

        if (key.ECDSASecp256k1 != null && key.ECDSASecp256k1.byteLength > 0) {
            if (CACHE.publicKeyECDSA == null) {
                throw new Error(
                    "`PublicKey` was not loaded before decoding `Key`"
                );
            }

            return CACHE.publicKeyECDSA(key.ECDSASecp256k1);
        }

        if (key.thresholdKey != null && key.thresholdKey.threshold != null) {
            if (CACHE.thresholdKey == null) {
                throw new Error(
                    "`PublicKey` was not loaded before decoding `Key`"
                );
            }

            return CACHE.thresholdKey(key.thresholdKey);
        }

        if (key.keyList != null) {
            if (CACHE.keyList == null) {
                throw new Error(
                    "`PublicKey` was not loaded before decoding `Key`"
                );
            }

            return CACHE.keyList(key.keyList);
        }

        throw new Error(
            `(BUG) keyFromProtobuf: not implemented key case: ${JSON.stringify(
                key
            )}`
        );
    }
}

/**
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 * @typedef {import("./account/AccountId.js").default} AccountId
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignaturePair} proto.ISignaturePair
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 */

class PublicKey extends Key {
    /**
     * @internal
     * @hideconstructor
     * @param {cryptography.PublicKey} key
     */
    constructor(key) {
        super();

        this._key = key;
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytes(data) {
        return new PublicKey(PublicKey$1.fromBytes(data));
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytesED25519(data) {
        return new PublicKey(PublicKey$1.fromBytesED25519(data));
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytesECDSA(data) {
        return new PublicKey(PublicKey$1.fromBytesECDSA(data));
    }

    /**
     * Parse a public key from a string of hexadecimal digits.
     *
     * The public key may optionally be prefixed with
     * the DER header.
     *
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromString(text) {
        return new PublicKey(PublicKey$1.fromString(text));
    }

    /**
     * Verify a signature on a message with this public key.
     *
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {boolean}
     */
    verify(message, signature) {
        return this._key.verify(message, signature);
    }

    /**
     * @param {Transaction} transaction
     * @returns {boolean}
     */
    verifyTransaction(transaction) {
        transaction._requireFrozen();

        if (!transaction.isFrozen()) {
            transaction.freeze();
        }

        for (const signedTransaction of transaction._signedTransactions.list) {
            if (
                signedTransaction.sigMap != null &&
                signedTransaction.sigMap.sigPair != null
            ) {
                let found = false;
                for (const sigPair of signedTransaction.sigMap.sigPair) {
                    const pubKeyPrefix = /** @type {Uint8Array} */ (
                        sigPair.pubKeyPrefix
                    );
                    if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {
                        found = true;

                        const bodyBytes = /** @type {Uint8Array} */ (
                            signedTransaction.bodyBytes
                        );

                        let signature = null;
                        if (sigPair.ed25519 != null) {
                            signature = sigPair.ed25519;
                        } else if (sigPair.ECDSASecp256k1 != null) {
                            signature = sigPair.ECDSASecp256k1;
                        }

                        if (signature == null) {
                            continue;
                        }

                        if (!this.verify(bodyBytes, signature)) {
                            return false;
                        }
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return this._key.toBytes();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        return this._key.toBytesDer();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._key.toBytesRaw();
    }

    /**
     * @returns {string}
     */
    toString() {
        return this._key.toString();
    }

    /**
     * @returns {string}
     */
    toStringDer() {
        return this._key.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringRaw() {
        return this._key.toStringRaw();
    }

    /**
     * @param {PublicKey} other
     * @returns {boolean}
     */
    equals(other) {
        return this._key.equals(other._key);
    }

    /**
     * @returns {proto.IKey}
     */
    _toProtobufKey() {
        switch (this._key._type) {
            case "ED25519":
                return {
                    ed25519: this._key.toBytesRaw(),
                };
            case "secp256k1":
                return {
                    ECDSASecp256k1: this._key.toBytesRaw(),
                };
            default:
                throw new Error(`unrecognized key type ${this._key._type}`);
        }
    }

    /**
     * @param {Uint8Array} signature
     * @returns {proto.ISignaturePair}
     */
    _toProtobufSignature(signature) {
        switch (this._key._type) {
            case "ED25519":
                return {
                    pubKeyPrefix: this._key.toBytesRaw(),
                    ed25519: signature,
                };
            case "secp256k1":
                return {
                    pubKeyPrefix: this._key.toBytesRaw(),
                    ECDSASecp256k1: signature,
                };
            default:
                throw new Error(`unrecognized key type ${this._key._type}`);
        }
    }

    /**
     * @param {Long | number} shard
     * @param {Long | number} realm
     * @returns {AccountId}
     */
    toAccountId(shard, realm) {
        if (CACHE.accountIdConstructor == null) {
            throw new Error("`AccountId` not loaded");
        }

        return CACHE.accountIdConstructor(shard, realm, this);
    }
}

CACHE.publicKeyED25519 = (key) => PublicKey.fromBytesED25519(key);
CACHE.publicKeyECDSA = (key) => PublicKey.fromBytesECDSA(key);

/**
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 * @typedef {import("./account/AccountId.js").default} AccountId
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignaturePair} proto.ISignaturePair
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 */

class PrivateKey extends Key {
    /**
     * @internal
     * @hideconstructor
     * @param {cryptography.PrivateKey} key
     */
    constructor(key) {
        super();

        this._key = key;
    }

    /**
     * Generate a random Ed25519 private key.
     *
     * @returns {PrivateKey}
     */
    static generateED25519() {
        return new PrivateKey(PrivateKey$1.generateED25519());
    }

    /**
     * Generate a random EDSA private key.
     *
     * @returns {PrivateKey}
     */
    static generateECDSA() {
        return new PrivateKey(PrivateKey$1.generateECDSA());
    }

    /**
     * Depredated - Use `generateEd25519()` instead
     * Generate a random Ed25519 private key.
     *
     * @returns {PrivateKey}
     */
    static generate() {
        return PrivateKey.generateED25519();
    }

    /**
     * Depredated - Use `generateEd25519Async()` instead
     * Generate a random Ed25519 private key.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generateAsync() {
        return new PrivateKey(await PrivateKey$1.generateAsync());
    }

    /**
     * Generate a random Ed25519 private key.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generateED25519Async() {
        return new PrivateKey(
            await PrivateKey$1.generateED25519Async()
        );
    }

    /**
     * Generate a random ECDSA private key.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generateECDSAAsync() {
        return new PrivateKey(
            await PrivateKey$1.generateECDSAAsync()
        );
    }

    /**
     * Construct a private key from bytes. Requires DER header.
     *
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytes(data) {
        return new PrivateKey(PrivateKey$1.fromBytes(data));
    }

    /**
     * Construct a ECDSA private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytesECDSA(data) {
        return new PrivateKey(PrivateKey$1.fromBytesECDSA(data));
    }

    /**
     * Construct a ED25519 private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytesED25519(data) {
        return new PrivateKey(PrivateKey$1.fromBytesED25519(data));
    }

    /**
     * Construct a private key from a hex-encoded string. Requires DER header.
     *
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromString(text) {
        return new PrivateKey(PrivateKey$1.fromString(text));
    }

    /**
     * Construct a ECDSA private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromStringECDSA(text) {
        return new PrivateKey(PrivateKey$1.fromStringECDSA(text));
    }

    /**
     * Construct a Ed25519 private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromStringED25519(text) {
        return new PrivateKey(PrivateKey$1.fromStringED25519(text));
    }

    /**
     * Recover a private key from a mnemonic phrase (and optionally a password).
     *
     * @param {Mnemonic | cryptography.Mnemonic | string} mnemonic
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    static async fromMnemonic(mnemonic, passphrase = "") {
        if (mnemonic instanceof Mnemonic) {
            return new PrivateKey(
                await PrivateKey$1.fromMnemonic(
                    mnemonic._mnemonic,
                    passphrase
                )
            );
        }

        return new PrivateKey(
            await PrivateKey$1.fromMnemonic(mnemonic, passphrase)
        );
    }

    /**
     * Recover a private key from a keystore, previously created by `.toKeystore()`.
     *
     * This key will _not_ support child key derivation.
     *
     * @param {Uint8Array} data
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.
     */
    static async fromKeystore(data, passphrase = "") {
        return new PrivateKey(
            await PrivateKey$1.fromKeystore(data, passphrase)
        );
    }

    /**
     * Recover a private key from a pem string; the private key may be encrypted.
     *
     * This method assumes the .pem file has been converted to a string already.
     *
     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
     * section and decodes that as a DER-encoded  private key.
     *
     * @param {string} data
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    static async fromPem(data, passphrase = "") {
        return new PrivateKey(
            await PrivateKey$1.fromPem(data, passphrase)
        );
    }

    /**
     * Derive a new private key at the given wallet index.
     *
     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
     * an error.
     *
     * You can check if a key supports derivation with `.supportsDerivation()`
     *
     * @param {number} index
     * @returns {Promise<PrivateKey>}
     * @throws If this key does not support derivation.
     */
    async derive(index) {
        return new PrivateKey(await this._key.derive(index));
    }

    /**
     * @param {number} index
     * @returns {Promise<PrivateKey>}
     * @throws If this key does not support derivation.
     */
    async legacyDerive(index) {
        return new PrivateKey(await this._key.legacyDerive(index));
    }

    /**
     * Get the public key associated with this private key.
     *
     * The public key can be freely given and used by other parties to verify
     * the signatures generated by this private key.
     *
     * @returns {PublicKey}
     */
    get publicKey() {
        return new PublicKey(this._key.publicKey);
    }

    /**
     * Sign a message with this private key.
     *
     * @param {Uint8Array} bytes
     * @returns {Uint8Array} - The signature bytes without the message
     */
    sign(bytes) {
        return this._key.sign(bytes);
    }

    /**
     * @param {Transaction} transaction
     * @returns {Uint8Array}
     */
    signTransaction(transaction) {
        const tx = transaction._signedTransactions.get(0);
        const signature =
            tx.bodyBytes != null ? this.sign(tx.bodyBytes) : new Uint8Array();

        transaction.addSignature(this.publicKey, signature);

        return signature;
    }

    /**
     * Check if `derive` can be called on this private key.
     *
     * This is only the case if the key was created from a mnemonic.
     *
     * @returns {boolean}
     */
    isDerivable() {
        return this._key.isDerivable();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return this._key.toBytes();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        return this._key.toBytesDer();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._key.toBytesRaw();
    }

    /**
     * @returns {string}
     */
    toString() {
        return this._key.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringDer() {
        return this._key.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringRaw() {
        return this._key.toStringRaw();
    }

    /**
     * Create a keystore with a given passphrase.
     *
     * The key can be recovered later with `fromKeystore()`.
     *
     * Note that this will not retain the ancillary data used for
     * deriving child keys, thus `.derive()` on the restored key will
     * throw even if this instance supports derivation.
     *
     * @param {string} [passphrase]
     * @returns {Promise<Uint8Array>}
     */
    toKeystore(passphrase = "") {
        return this._key.toKeystore(passphrase);
    }

    /**
     * @returns {proto.IKey}
     */
    _toProtobufKey() {
        return this.publicKey._toProtobufKey();
    }

    /**
     * @param {Long | number} shard
     * @param {Long | number} realm
     * @returns {AccountId}
     */
    toAccountId(shard, realm) {
        return this.publicKey.toAccountId(shard, realm);
    }
}

CACHE.privateKeyConstructor = (key) => new PrivateKey(key);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").IKeyList} proto.IKeyList
 * @typedef {import("@hashgraph/proto").IThresholdKey} proto.IThresholdKey
 */

/**
 * A list of Keys (`Key`) with an optional threshold.
 */
class KeyList extends Key {
    /**
     * @param {?Key[]} [keys]
     * @param {?number} [threshold]
     */
    constructor(keys, threshold) {
        super();

        /**
         * @private
         * @type {Key[]}
         */
        this._keys = keys == null ? [] : keys;

        /**
         * @type {?number}
         */
        this._threshold = threshold == null ? null : threshold;
    }

    /**
     * @param {Key[]} keys
     * @returns {KeyList}
     */
    static of(...keys) {
        return new KeyList(keys, null);
    }

    /**
     * @template T
     * @param {ArrayLike<Key>} arrayLike
     * @param {((key: Key) => Key)} [mapFn]
     * @param {T} [thisArg]
     * @returns {KeyList}
     */
    static from(arrayLike, mapFn, thisArg) {
        if (mapFn == null) {
            return new KeyList(Array.from(arrayLike));
        }

        return new KeyList(Array.from(arrayLike, mapFn, thisArg));
    }

    /**
     * @returns {?number}
     */
    get threshold() {
        return this._threshold;
    }

    /**
     * @param {number} threshold
     * @returns {this}
     */
    setThreshold(threshold) {
        this._threshold = threshold;
        return this;
    }

    /**
     * @param {Key[]} keys
     * @returns {number}
     */
    push(...keys) {
        return this._keys.push(...keys);
    }

    /**
     * @param {number} start
     * @param {number} deleteCount
     * @param {Key[]} items
     * @returns {KeyList}
     */
    splice(start, deleteCount, ...items) {
        return new KeyList(
            this._keys.splice(start, deleteCount, ...items),
            this.threshold
        );
    }

    /**
     * @param {number=} start
     * @param {number=} end
     * @returns {KeyList}
     */
    slice(start, end) {
        return new KeyList(this._keys.slice(start, end), this.threshold);
    }

    /**
     * @returns {Iterator<Key>}
     */
    [Symbol.iterator]() {
        return this._keys[Symbol.iterator]();
    }

    /**
     * @returns {Key[]}
     */
    toArray() {
        return this._keys.slice();
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify({
            threshold: this._threshold,
            keys: this._keys.toString(),
        });
    }

    /**
     * @returns {proto.IKey}
     */
    _toProtobufKey() {
        const keys = this._keys.map((key) => key._toProtobufKey());

        if (this.threshold == null) {
            return { keyList: { keys } };
        } else {
            return {
                thresholdKey: {
                    threshold: this.threshold,
                    keys: { keys },
                },
            };
        }
    }

    /**
     * @param {proto.IKeyList} key
     * @returns {KeyList}
     */
    static __fromProtobufKeyList(key) {
        const keys = (key.keys != null ? key.keys : []).map((key) =>
            Key._fromProtobufKey(key)
        );
        return new KeyList(keys);
    }

    /**
     * @param {proto.IThresholdKey} key
     * @returns {KeyList}
     */
    static __fromProtobufThresoldKey(key) {
        const list = KeyList.__fromProtobufKeyList(
            key.keys != null ? key.keys : {}
        );
        list.setThreshold(key.threshold != null ? key.threshold : 0);
        return list;
    }
}

CACHE.keyList = (key) => KeyList.__fromProtobufKeyList(key);
CACHE.thresholdKey = (key) => KeyList.__fromProtobufThresoldKey(key);

/**
 * @typedef {{low: number, high: number, unsigned: boolean}} LongObject
 * @typedef {import("long")} Long
 */

/**
 * @param {Long | number | string | LongObject | BigNumber} value
 * @returns {BigNumber}
 */
function valueToLong(value) {
    if (BigNumber$1.isBigNumber(value)) {
        return value;
    } else {
        return new BigNumber$1(value.toString());
    }
}

class HbarUnit {
    /**
     * @internal
     * @param {string} name
     * @param {string} symbol
     * @param {BigNumber} tinybar
     */
    constructor(name, symbol, tinybar) {
        /**
         * @internal
         * @readonly
         */
        this._name = name;

        /**
         * @internal
         * @readonly
         */
        this._symbol = symbol;

        /**
         * @internal
         * @readonly
         */
        this._tinybar = tinybar;

        Object.freeze(this);
    }

    /**
     * @param {string} unit
     * @returns {HbarUnit}
     */
    static fromString(unit) {
        switch (unit) {
            case HbarUnit.Hbar._symbol:
                return HbarUnit.Hbar;
            case HbarUnit.Tinybar._symbol:
                return HbarUnit.Tinybar;
            case HbarUnit.Microbar._symbol:
                return HbarUnit.Microbar;
            case HbarUnit.Millibar._symbol:
                return HbarUnit.Millibar;
            case HbarUnit.Kilobar._symbol:
                return HbarUnit.Kilobar;
            case HbarUnit.Megabar._symbol:
                return HbarUnit.Megabar;
            case HbarUnit.Gigabar._symbol:
                return HbarUnit.Gigabar;
            default:
                throw new Error("Unknown unit.");
        }
    }
}

HbarUnit.Tinybar = new HbarUnit("tinybar", "t", new BigNumber$1(1));

HbarUnit.Microbar = new HbarUnit("microbar", "", new BigNumber$1(100));

HbarUnit.Millibar = new HbarUnit("millibar", "m", new BigNumber$1(100000));

HbarUnit.Hbar = new HbarUnit("hbar", "", new BigNumber$1("100000000"));

HbarUnit.Kilobar = new HbarUnit(
    "kilobar",
    "k",
    new BigNumber$1(1000).multipliedBy(new BigNumber$1("100000000"))
);

HbarUnit.Megabar = new HbarUnit(
    "megabar",
    "M",
    new BigNumber$1(1000000).multipliedBy(new BigNumber$1("100000000"))
);

HbarUnit.Gigabar = new HbarUnit(
    "gigabar",
    "G",
    new BigNumber$1("1000000000").multipliedBy(new BigNumber$1("100000000"))
);

var long = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong$1(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong$1;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString$1(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString$1(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString$1;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString$1(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong$1(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong$1(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong$1(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong$1(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong$1(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong$1(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong$1(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong$1(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong$1(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong$1(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong$1(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong$1(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong$1(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};

/**
 * @typedef {import("./long.js").LongObject} LongObject
 */

class Hbar {
    /**
     * @param {number | string | Long | LongObject | BigNumber} amount
     * @param {HbarUnit=} unit
     */
    constructor(amount, unit = HbarUnit.Hbar) {
        if (unit === HbarUnit.Tinybar) {
            this._valueInTinybar = valueToLong(amount);
        } else {
            /** @type {BigNumber} */
            let bigAmount;

            if (long.isLong(amount)) {
                bigAmount = new BigNumber$1(amount.toString(10));
            } else if (
                BigNumber$1.isBigNumber(amount) ||
                typeof amount === "string" ||
                typeof amount === "number"
            ) {
                bigAmount = new BigNumber$1(amount);
            } else {
                bigAmount = new BigNumber$1(0);
            }

            /**
             * @type {BigNumber}
             */
            this._valueInTinybar = bigAmount.multipliedBy(unit._tinybar);
        }
        if (!this._valueInTinybar.isInteger()) {
            throw new Error("Hbar in tinybars contains decimals");
        }
    }

    /**
     * @param {number | Long | BigNumber} amount
     * @param {HbarUnit} unit
     * @returns {Hbar}
     */
    static from(amount, unit) {
        return new Hbar(amount, unit);
    }

    /**
     * @param {number | Long | string | BigNumber} amount
     * @returns {Hbar}
     */
    static fromTinybars(amount) {
        if (typeof amount === "string") {
            return this.fromString(amount, HbarUnit.Tinybar);
        }
        return new Hbar(amount, HbarUnit.Tinybar);
    }

    /**
     * @param {string} str
     * @param {HbarUnit=} unit
     * @returns {Hbar}
     */
    static fromString(str, unit = HbarUnit.Hbar) {
        const pattern = /^((?:\+|-)?\d+(?:\.\d+)?)(?: (t||m||k|M|G))?$/;
        if (pattern.test(str)) {
            let [amount, symbol] = str.split(" ");
            if (symbol != null) {
                unit = HbarUnit.fromString(symbol);
            }
            return new Hbar(new BigNumber$1(amount), unit);
        } else {
            throw new Error("invalid argument provided");
        }
    }

    /**
     * @param {HbarUnit} unit
     * @returns {BigNumber}
     */
    to(unit) {
        return this._valueInTinybar.dividedBy(unit._tinybar);
    }

    /**
     * @returns {BigNumber}
     */
    toBigNumber() {
        return this.to(HbarUnit.Hbar);
    }

    /**
     * @returns {Long}
     */
    toTinybars() {
        return long.fromValue(this._valueInTinybar.toFixed());
    }

    /**
     * @returns {Hbar}
     */
    negated() {
        return Hbar.fromTinybars(this._valueInTinybar.negated());
    }

    /**
     * @returns {boolean}
     */
    isNegative() {
        return this._valueInTinybar.isNegative();
    }

    /**
     * @param {HbarUnit=} unit
     * @returns {string}
     */
    toString(unit) {
        if (unit != null) {
            return `${this._valueInTinybar
                .dividedBy(unit._tinybar)
                .toString()} ${unit._symbol}`;
        }

        if (
            this._valueInTinybar.isLessThan(10000) &&
            this._valueInTinybar.isGreaterThan(-10000)
        ) {
            return `${this._valueInTinybar.toFixed()} ${
                HbarUnit.Tinybar._symbol
            }`;
        }

        return `${this.to(HbarUnit.Hbar).toString()} ${HbarUnit.Hbar._symbol}`;
    }
}

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 */

class StatusError extends Error {
    /**
     * @param {object} props
     * @param {Status} props.status
     * @param {TransactionId} props.transactionId
     * @param {string} message
     */
    constructor(props, message) {
        super(message);

        this.name = "StatusError";

        this.status = props.status;

        this.transactionId = props.transactionId;

        this.message = message;

        if (typeof Error.captureStackTrace !== "undefined") {
            Error.captureStackTrace(this, StatusError);
        }
    }
}

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
 */

class ReceiptStatusError extends StatusError {
    /**
     * @param {object} props
     * @param {TransactionReceipt} props.transactionReceipt
     * @param {Status} props.status
     * @param {TransactionId} props.transactionId
     */
    constructor(props) {
        super(
            props,
            `receipt for transaction ${props.transactionId.toString()} contained error status ${props.status.toString()}`
        );

        /**
         * @type {TransactionReceipt}
         * @readonly
         */
        this.transactionReceipt = props.transactionReceipt;
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 */

class Status {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case Status.Ok:
                return "OK";
            case Status.InvalidTransaction:
                return "INVALID_TRANSACTION";
            case Status.PayerAccountNotFound:
                return "PAYER_ACCOUNT_NOT_FOUND";
            case Status.InvalidNodeAccount:
                return "INVALID_NODE_ACCOUNT";
            case Status.TransactionExpired:
                return "TRANSACTION_EXPIRED";
            case Status.InvalidTransactionStart:
                return "INVALID_TRANSACTION_START";
            case Status.InvalidTransactionDuration:
                return "INVALID_TRANSACTION_DURATION";
            case Status.InvalidSignature:
                return "INVALID_SIGNATURE";
            case Status.MemoTooLong:
                return "MEMO_TOO_LONG";
            case Status.InsufficientTxFee:
                return "INSUFFICIENT_TX_FEE";
            case Status.InsufficientPayerBalance:
                return "INSUFFICIENT_PAYER_BALANCE";
            case Status.DuplicateTransaction:
                return "DUPLICATE_TRANSACTION";
            case Status.Busy:
                return "BUSY";
            case Status.NotSupported:
                return "NOT_SUPPORTED";
            case Status.InvalidFileId:
                return "INVALID_FILE_ID";
            case Status.InvalidAccountId:
                return "INVALID_ACCOUNT_ID";
            case Status.InvalidContractId:
                return "INVALID_CONTRACT_ID";
            case Status.InvalidTransactionId:
                return "INVALID_TRANSACTION_ID";
            case Status.ReceiptNotFound:
                return "RECEIPT_NOT_FOUND";
            case Status.RecordNotFound:
                return "RECORD_NOT_FOUND";
            case Status.InvalidSolidityId:
                return "INVALID_SOLIDITY_ID";
            case Status.Unknown:
                return "UNKNOWN";
            case Status.Success:
                return "SUCCESS";
            case Status.FailInvalid:
                return "FAIL_INVALID";
            case Status.FailFee:
                return "FAIL_FEE";
            case Status.FailBalance:
                return "FAIL_BALANCE";
            case Status.KeyRequired:
                return "KEY_REQUIRED";
            case Status.BadEncoding:
                return "BAD_ENCODING";
            case Status.InsufficientAccountBalance:
                return "INSUFFICIENT_ACCOUNT_BALANCE";
            case Status.InvalidSolidityAddress:
                return "INVALID_SOLIDITY_ADDRESS";
            case Status.InsufficientGas:
                return "INSUFFICIENT_GAS";
            case Status.ContractSizeLimitExceeded:
                return "CONTRACT_SIZE_LIMIT_EXCEEDED";
            case Status.LocalCallModificationException:
                return "LOCAL_CALL_MODIFICATION_EXCEPTION";
            case Status.ContractRevertExecuted:
                return "CONTRACT_REVERT_EXECUTED";
            case Status.ContractExecutionException:
                return "CONTRACT_EXECUTION_EXCEPTION";
            case Status.InvalidReceivingNodeAccount:
                return "INVALID_RECEIVING_NODE_ACCOUNT";
            case Status.MissingQueryHeader:
                return "MISSING_QUERY_HEADER";
            case Status.AccountUpdateFailed:
                return "ACCOUNT_UPDATE_FAILED";
            case Status.InvalidKeyEncoding:
                return "INVALID_KEY_ENCODING";
            case Status.NullSolidityAddress:
                return "NULL_SOLIDITY_ADDRESS";
            case Status.ContractUpdateFailed:
                return "CONTRACT_UPDATE_FAILED";
            case Status.InvalidQueryHeader:
                return "INVALID_QUERY_HEADER";
            case Status.InvalidFeeSubmitted:
                return "INVALID_FEE_SUBMITTED";
            case Status.InvalidPayerSignature:
                return "INVALID_PAYER_SIGNATURE";
            case Status.KeyNotProvided:
                return "KEY_NOT_PROVIDED";
            case Status.InvalidExpirationTime:
                return "INVALID_EXPIRATION_TIME";
            case Status.NoWaclKey:
                return "NO_WACL_KEY";
            case Status.FileContentEmpty:
                return "FILE_CONTENT_EMPTY";
            case Status.InvalidAccountAmounts:
                return "INVALID_ACCOUNT_AMOUNTS";
            case Status.EmptyTransactionBody:
                return "EMPTY_TRANSACTION_BODY";
            case Status.InvalidTransactionBody:
                return "INVALID_TRANSACTION_BODY";
            case Status.InvalidSignatureTypeMismatchingKey:
                return "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY";
            case Status.InvalidSignatureCountMismatchingKey:
                return "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY";
            case Status.EmptyLiveHashBody:
                return "EMPTY_LIVE_HASH_BODY";
            case Status.EmptyLiveHash:
                return "EMPTY_LIVE_HASH";
            case Status.EmptyLiveHashKeys:
                return "EMPTY_LIVE_HASH_KEYS";
            case Status.InvalidLiveHashSize:
                return "INVALID_LIVE_HASH_SIZE";
            case Status.EmptyQueryBody:
                return "EMPTY_QUERY_BODY";
            case Status.EmptyLiveHashQuery:
                return "EMPTY_LIVE_HASH_QUERY";
            case Status.LiveHashNotFound:
                return "LIVE_HASH_NOT_FOUND";
            case Status.AccountIdDoesNotExist:
                return "ACCOUNT_ID_DOES_NOT_EXIST";
            case Status.LiveHashAlreadyExists:
                return "LIVE_HASH_ALREADY_EXISTS";
            case Status.InvalidFileWacl:
                return "INVALID_FILE_WACL";
            case Status.SerializationFailed:
                return "SERIALIZATION_FAILED";
            case Status.TransactionOversize:
                return "TRANSACTION_OVERSIZE";
            case Status.TransactionTooManyLayers:
                return "TRANSACTION_TOO_MANY_LAYERS";
            case Status.ContractDeleted:
                return "CONTRACT_DELETED";
            case Status.PlatformNotActive:
                return "PLATFORM_NOT_ACTIVE";
            case Status.KeyPrefixMismatch:
                return "KEY_PREFIX_MISMATCH";
            case Status.PlatformTransactionNotCreated:
                return "PLATFORM_TRANSACTION_NOT_CREATED";
            case Status.InvalidRenewalPeriod:
                return "INVALID_RENEWAL_PERIOD";
            case Status.InvalidPayerAccountId:
                return "INVALID_PAYER_ACCOUNT_ID";
            case Status.AccountDeleted:
                return "ACCOUNT_DELETED";
            case Status.FileDeleted:
                return "FILE_DELETED";
            case Status.AccountRepeatedInAccountAmounts:
                return "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS";
            case Status.SettingNegativeAccountBalance:
                return "SETTING_NEGATIVE_ACCOUNT_BALANCE";
            case Status.ObtainerRequired:
                return "OBTAINER_REQUIRED";
            case Status.ObtainerSameContractId:
                return "OBTAINER_SAME_CONTRACT_ID";
            case Status.ObtainerDoesNotExist:
                return "OBTAINER_DOES_NOT_EXIST";
            case Status.ModifyingImmutableContract:
                return "MODIFYING_IMMUTABLE_CONTRACT";
            case Status.FileSystemException:
                return "FILE_SYSTEM_EXCEPTION";
            case Status.AutorenewDurationNotInRange:
                return "AUTORENEW_DURATION_NOT_IN_RANGE";
            case Status.ErrorDecodingBytestring:
                return "ERROR_DECODING_BYTESTRING";
            case Status.ContractFileEmpty:
                return "CONTRACT_FILE_EMPTY";
            case Status.ContractBytecodeEmpty:
                return "CONTRACT_BYTECODE_EMPTY";
            case Status.InvalidInitialBalance:
                return "INVALID_INITIAL_BALANCE";
            case Status.InvalidReceiveRecordThreshold:
                return "INVALID_RECEIVE_RECORD_THRESHOLD";
            case Status.InvalidSendRecordThreshold:
                return "INVALID_SEND_RECORD_THRESHOLD";
            case Status.AccountIsNotGenesisAccount:
                return "ACCOUNT_IS_NOT_GENESIS_ACCOUNT";
            case Status.PayerAccountUnauthorized:
                return "PAYER_ACCOUNT_UNAUTHORIZED";
            case Status.InvalidFreezeTransactionBody:
                return "INVALID_FREEZE_TRANSACTION_BODY";
            case Status.FreezeTransactionBodyNotFound:
                return "FREEZE_TRANSACTION_BODY_NOT_FOUND";
            case Status.TransferListSizeLimitExceeded:
                return "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
            case Status.ResultSizeLimitExceeded:
                return "RESULT_SIZE_LIMIT_EXCEEDED";
            case Status.NotSpecialAccount:
                return "NOT_SPECIAL_ACCOUNT";
            case Status.ContractNegativeGas:
                return "CONTRACT_NEGATIVE_GAS";
            case Status.ContractNegativeValue:
                return "CONTRACT_NEGATIVE_VALUE";
            case Status.InvalidFeeFile:
                return "INVALID_FEE_FILE";
            case Status.InvalidExchangeRateFile:
                return "INVALID_EXCHANGE_RATE_FILE";
            case Status.InsufficientLocalCallGas:
                return "INSUFFICIENT_LOCAL_CALL_GAS";
            case Status.EntityNotAllowedToDelete:
                return "ENTITY_NOT_ALLOWED_TO_DELETE";
            case Status.AuthorizationFailed:
                return "AUTHORIZATION_FAILED";
            case Status.FileUploadedProtoInvalid:
                return "FILE_UPLOADED_PROTO_INVALID";
            case Status.FileUploadedProtoNotSavedToDisk:
                return "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK";
            case Status.FeeScheduleFilePartUploaded:
                return "FEE_SCHEDULE_FILE_PART_UPLOADED";
            case Status.ExchangeRateChangeLimitExceeded:
                return "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED";
            case Status.MaxContractStorageExceeded:
                return "MAX_CONTRACT_STORAGE_EXCEEDED";
            case Status.TransferAccountSameAsDeleteAccount:
                return "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT";
            case Status.TotalLedgerBalanceInvalid:
                return "TOTAL_LEDGER_BALANCE_INVALID";
            case Status.ExpirationReductionNotAllowed:
                return "EXPIRATION_REDUCTION_NOT_ALLOWED";
            case Status.MaxGasLimitExceeded:
                return "MAX_GAS_LIMIT_EXCEEDED";
            case Status.MaxFileSizeExceeded:
                return "MAX_FILE_SIZE_EXCEEDED";
            case Status.ReceiverSigRequired:
                return "RECEIVER_SIG_REQUIRED";
            case Status.InvalidTopicId:
                return "INVALID_TOPIC_ID";
            case Status.InvalidAdminKey:
                return "INVALID_ADMIN_KEY";
            case Status.InvalidSubmitKey:
                return "INVALID_SUBMIT_KEY";
            case Status.Unauthorized:
                return "UNAUTHORIZED";
            case Status.InvalidTopicMessage:
                return "INVALID_TOPIC_MESSAGE";
            case Status.InvalidAutorenewAccount:
                return "INVALID_AUTORENEW_ACCOUNT";
            case Status.AutorenewAccountNotAllowed:
                return "AUTORENEW_ACCOUNT_NOT_ALLOWED";
            case Status.TopicExpired:
                return "TOPIC_EXPIRED";
            case Status.InvalidChunkNumber:
                return "INVALID_CHUNK_NUMBER";
            case Status.InvalidChunkTransactionId:
                return "INVALID_CHUNK_TRANSACTION_ID";
            case Status.AccountFrozenForToken:
                return "ACCOUNT_FROZEN_FOR_TOKEN";
            case Status.TokensPerAccountLimitExceeded:
                return "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED";
            case Status.InvalidTokenId:
                return "INVALID_TOKEN_ID";
            case Status.InvalidTokenDecimals:
                return "INVALID_TOKEN_DECIMALS";
            case Status.InvalidTokenInitialSupply:
                return "INVALID_TOKEN_INITIAL_SUPPLY";
            case Status.InvalidTreasuryAccountForToken:
                return "INVALID_TREASURY_ACCOUNT_FOR_TOKEN";
            case Status.InvalidTokenSymbol:
                return "INVALID_TOKEN_SYMBOL";
            case Status.TokenHasNoFreezeKey:
                return "TOKEN_HAS_NO_FREEZE_KEY";
            case Status.TransfersNotZeroSumForToken:
                return "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN";
            case Status.MissingTokenSymbol:
                return "MISSING_TOKEN_SYMBOL";
            case Status.TokenSymbolTooLong:
                return "TOKEN_SYMBOL_TOO_LONG";
            case Status.AccountKycNotGrantedForToken:
                return "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN";
            case Status.TokenHasNoKycKey:
                return "TOKEN_HAS_NO_KYC_KEY";
            case Status.InsufficientTokenBalance:
                return "INSUFFICIENT_TOKEN_BALANCE";
            case Status.TokenWasDeleted:
                return "TOKEN_WAS_DELETED";
            case Status.TokenHasNoSupplyKey:
                return "TOKEN_HAS_NO_SUPPLY_KEY";
            case Status.TokenHasNoWipeKey:
                return "TOKEN_HAS_NO_WIPE_KEY";
            case Status.InvalidTokenMintAmount:
                return "INVALID_TOKEN_MINT_AMOUNT";
            case Status.InvalidTokenBurnAmount:
                return "INVALID_TOKEN_BURN_AMOUNT";
            case Status.TokenNotAssociatedToAccount:
                return "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT";
            case Status.CannotWipeTokenTreasuryAccount:
                return "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT";
            case Status.InvalidKycKey:
                return "INVALID_KYC_KEY";
            case Status.InvalidWipeKey:
                return "INVALID_WIPE_KEY";
            case Status.InvalidFreezeKey:
                return "INVALID_FREEZE_KEY";
            case Status.InvalidSupplyKey:
                return "INVALID_SUPPLY_KEY";
            case Status.MissingTokenName:
                return "MISSING_TOKEN_NAME";
            case Status.TokenNameTooLong:
                return "TOKEN_NAME_TOO_LONG";
            case Status.InvalidWipingAmount:
                return "INVALID_WIPING_AMOUNT";
            case Status.TokenIsImmutable:
                return "TOKEN_IS_IMMUTABLE";
            case Status.TokenAlreadyAssociatedToAccount:
                return "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT";
            case Status.TransactionRequiresZeroTokenBalances:
                return "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES";
            case Status.AccountIsTreasury:
                return "ACCOUNT_IS_TREASURY";
            case Status.TokenIdRepeatedInTokenList:
                return "TOKEN_ID_REPEATED_IN_TOKEN_LIST";
            case Status.TokenTransferListSizeLimitExceeded:
                return "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
            case Status.EmptyTokenTransferBody:
                return "EMPTY_TOKEN_TRANSFER_BODY";
            case Status.EmptyTokenTransferAccountAmounts:
                return "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS";
            case Status.InvalidScheduleId:
                return "INVALID_SCHEDULE_ID";
            case Status.ScheduleIsImmutable:
                return "SCHEDULE_IS_IMMUTABLE";
            case Status.InvalidSchedulePayerId:
                return "INVALID_SCHEDULE_PAYER_ID";
            case Status.InvalidScheduleAccountId:
                return "INVALID_SCHEDULE_ACCOUNT_ID";
            case Status.NoNewValidSignatures:
                return "NO_NEW_VALID_SIGNATURES";
            case Status.UnresolvableRequiredSigners:
                return "UNRESOLVABLE_REQUIRED_SIGNERS";
            case Status.ScheduledTransactionNotInWhitelist:
                return "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST";
            case Status.SomeSignaturesWereInvalid:
                return "SOME_SIGNATURES_WERE_INVALID";
            case Status.TransactionIdFieldNotAllowed:
                return "TRANSACTION_ID_FIELD_NOT_ALLOWED";
            case Status.IdenticalScheduleAlreadyCreated:
                return "IDENTICAL_SCHEDULE_ALREADY_CREATED";
            case Status.InvalidZeroByteInString:
                return "INVALID_ZERO_BYTE_IN_STRING";
            case Status.ScheduleAlreadyDeleted:
                return "SCHEDULE_ALREADY_DELETED";
            case Status.ScheduleAlreadyExecuted:
                return "SCHEDULE_ALREADY_EXECUTED";
            case Status.MessageSizeTooLarge:
                return "MESSAGE_SIZE_TOO_LARGE";
            case Status.OperationRepeatedInBucketGroups:
                return "OPERATION_REPEATED_IN_BUCKET_GROUPS";
            case Status.BucketCapacityOverflow:
                return "BUCKET_CAPACITY_OVERFLOW";
            case Status.NodeCapacityNotSufficientForOperation:
                return "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION";
            case Status.BucketHasNoThrottleGroups:
                return "BUCKET_HAS_NO_THROTTLE_GROUPS";
            case Status.ThrottleGroupHasZeroOpsPerSec:
                return "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC";
            case Status.SuccessButMissingExpectedOperation:
                return "SUCCESS_BUT_MISSING_EXPECTED_OPERATION";
            case Status.UnparseableThrottleDefinitions:
                return "UNPARSEABLE_THROTTLE_DEFINITIONS";
            case Status.InvalidThrottleDefinitions:
                return "INVALID_THROTTLE_DEFINITIONS";
            case Status.AccountExpiredAndPendingRemoval:
                return "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL";
            case Status.InvalidTokenMaxSupply:
                return "INVALID_TOKEN_MAX_SUPPLY";
            case Status.InvalidTokenNftSerialNumber:
                return "INVALID_TOKEN_NFT_SERIAL_NUMBER";
            case Status.InvalidNftId:
                return "INVALID_NFT_ID";
            case Status.MetadataTooLong:
                return "METADATA_TOO_LONG";
            case Status.BatchSizeLimitExceeded:
                return "BATCH_SIZE_LIMIT_EXCEEDED";
            case Status.InvalidQueryRange:
                return "INVALID_QUERY_RANGE";
            case Status.FractionDividesByZero:
                return "FRACTION_DIVIDES_BY_ZERO";
            case Status.InsufficientPayerBalanceForCustomFee:
                return "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE";
            case Status.CustomFeesListTooLong:
                return "CUSTOM_FEES_LIST_TOO_LONG";
            case Status.InvalidCustomFeeCollector:
                return "INVALID_CUSTOM_FEE_COLLECTOR";
            case Status.InvalidTokenIdInCustomFees:
                return "INVALID_TOKEN_ID_IN_CUSTOM_FEES";
            case Status.TokenNotAssociatedToFeeCollector:
                return "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR";
            case Status.TokenMaxSupplyReached:
                return "TOKEN_MAX_SUPPLY_REACHED";
            case Status.SenderDoesNotOwnNftSerialNo:
                return "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO";
            case Status.CustomFeeNotFullySpecified:
                return "CUSTOM_FEE_NOT_FULLY_SPECIFIED";
            case Status.CustomFeeMustBePositive:
                return "CUSTOM_FEE_MUST_BE_POSITIVE";
            case Status.TokenHasNoFeeScheduleKey:
                return "TOKEN_HAS_NO_FEE_SCHEDULE_KEY";
            case Status.CustomFeeOutsideNumericRange:
                return "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE";
            case Status.RoyaltyFractionCannotExceedOne:
                return "ROYALTY_FRACTION_CANNOT_EXCEED_ONE";
            case Status.FractionalFeeMaxAmountLessThanMinAmount:
                return "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT";
            case Status.CustomScheduleAlreadyHasNoFees:
                return "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES";
            case Status.CustomFeeDenominationMustBeFungibleCommon:
                return "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON";
            case Status.CustomFractionalFeeOnlyAllowedForFungibleCommon:
                return "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
            case Status.InvalidCustomFeeScheduleKey:
                return "INVALID_CUSTOM_FEE_SCHEDULE_KEY";
            case Status.InvalidTokenMintMetadata:
                return "INVALID_TOKEN_MINT_METADATA";
            case Status.InvalidTokenBurnMetadata:
                return "INVALID_TOKEN_BURN_METADATA";
            case Status.CurrentTreasuryStillOwnsNfts:
                return "CURRENT_TREASURY_STILL_OWNS_NFTS";
            case Status.AccountStillOwnsNfts:
                return "ACCOUNT_STILL_OWNS_NFTS";
            case Status.TreasuryMustOwnBurnedNft:
                return "TREASURY_MUST_OWN_BURNED_NFT";
            case Status.AccountDoesNotOwnWipedNft:
                return "ACCOUNT_DOES_NOT_OWN_WIPED_NFT";
            case Status.AccountAmountTransfersOnlyAllowedForFungibleCommon:
                return "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
            case Status.MaxNftsInPriceRegimeHaveBeenMinted:
                return "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED";
            case Status.PayerAccountDeleted:
                return "PAYER_ACCOUNT_DELETED";
            case Status.CustomFeeChargingExceededMaxRecursionDepth:
                return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH";
            case Status.CustomFeeChargingExceededMaxAccountAmounts:
                return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS";
            case Status.InsufficientSenderAccountBalanceForCustomFee:
                return "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE";
            case Status.SerialNumberLimitReached:
                return "SERIAL_NUMBER_LIMIT_REACHED";
            case Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique:
                return "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE";
            case Status.NoRemainingAutomaticAssociations:
                return "NO_REMAINING_AUTOMATIC_ASSOCIATIONS";
            case Status.ExistingAutomaticAssociationsExceedGivenLimit:
                return "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT";
            case Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit:
                return "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT";
            case Status.TokenIsPaused:
                return "TOKEN_IS_PAUSED";
            case Status.TokenHasNoPauseKey:
                return "TOKEN_HAS_NO_PAUSE_KEY";
            case Status.InvalidPauseKey:
                return "INVALID_PAUSE_KEY";
            case Status.FreezeUpdateFileDoesNotExist:
                return "FREEZE_UPDATE_FILE_DOES_NOT_EXIST";
            case Status.FreezeUpdateFileHashDoesNotMatch:
                return "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH";
            case Status.NoUpgradeHasBeenPrepared:
                return "NO_UPGRADE_HAS_BEEN_PREPARED";
            case Status.NoFreezeIsScheduled:
                return "NO_FREEZE_IS_SCHEDULED";
            case Status.UpdateFileHashChangedSincePrepareUpgrade:
                return "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE";
            case Status.FreezeStartTimeMustBeFuture:
                return "FREEZE_START_TIME_MUST_BE_FUTURE";
            case Status.PreparedUpdateFileIsImmutable:
                return "PREPARED_UPDATE_FILE_IS_IMMUTABLE";
            case Status.FreezeAlreadyScheduled:
                return "FREEZE_ALREADY_SCHEDULED";
            case Status.FreezeUpgradeInProgress:
                return "FREEZE_UPGRADE_IN_PROGRESS";
            case Status.UpdateFileIdDoesNotMatchPrepared:
                return "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED";
            case Status.UpdateFileHashDoesNotMatchPrepared:
                return "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED";
            case Status.ConsensusGasExhausted:
                return "CONSENSUS_GAS_EXHAUSTED";
            case Status.RevertedSuccess:
                return "REVERTED_SUCCESS";
            case Status.MaxStorageInPriceRegimeHasBeenUsed:
                return "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED";
            case Status.InvalidAliasKey:
                return "INVALID_ALIAS_KEY";
            case Status.UnexpectedTokenDecimals:
                return "UNEXPECTED_TOKEN_DECIMALS";
            case Status.InvalidProxyAccountId:
                return "INVALID_PROXY_ACCOUNT_ID";
            case Status.InvalidTransferAccountId:
                return "INVALID_TRANSFER_ACCOUNT_ID";
            case Status.InvalidFeeCollectorAccountId:
                return "INVALID_FEE_COLLECTOR_ACCOUNT_ID";
            case Status.AliasIsImmutable:
                return "ALIAS_IS_IMMUTABLE";
            case Status.SpenderAccountSameAsOwner:
                return "SPENDER_ACCOUNT_SAME_AS_OWNER";
            case Status.AmountExceedsTokenMaxSupply:
                return "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY";
            case Status.NegativeAllowanceAmount:
                return "NEGATIVE_ALLOWANCE_AMOUNT";
            case Status.CannotApproveForAllFungibleCommon:
                return "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON";
            case Status.SpenderDoesNotHaveAllowance:
                return "SPENDER_DOES_NOT_HAVE_ALLOWANCE";
            case Status.AmountExceedsAllowance:
                return "AMOUNT_EXCEEDS_ALLOWANCE";
            case Status.MaxAllowancesExceeded:
                return "MAX_ALLOWANCES_EXCEEDED";
            case Status.EmptyAllowances:
                return "EMPTY_ALLOWANCES";
            case Status.SpenderAccountRepeatedInAllowances:
                return "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES";
            case Status.RepeatedSerialNumsInNFTAllowances:
                return "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES";
            case Status.FungibleTokenInNFTAllowances:
                return "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES";
            case Status.NFTInFungibleTokenAllowances:
                return "NFT_IN_FUNGIBLE_PAYER_ALLOWANCES";
            case Status.PayerAndOwnerNotEqual:
                return "PAYER_AND_OWNER_NOT_EQUAL";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {Status}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return Status.Ok;
            case 1:
                return Status.InvalidTransaction;
            case 2:
                return Status.PayerAccountNotFound;
            case 3:
                return Status.InvalidNodeAccount;
            case 4:
                return Status.TransactionExpired;
            case 5:
                return Status.InvalidTransactionStart;
            case 6:
                return Status.InvalidTransactionDuration;
            case 7:
                return Status.InvalidSignature;
            case 8:
                return Status.MemoTooLong;
            case 9:
                return Status.InsufficientTxFee;
            case 10:
                return Status.InsufficientPayerBalance;
            case 11:
                return Status.DuplicateTransaction;
            case 12:
                return Status.Busy;
            case 13:
                return Status.NotSupported;
            case 14:
                return Status.InvalidFileId;
            case 15:
                return Status.InvalidAccountId;
            case 16:
                return Status.InvalidContractId;
            case 17:
                return Status.InvalidTransactionId;
            case 18:
                return Status.ReceiptNotFound;
            case 19:
                return Status.RecordNotFound;
            case 20:
                return Status.InvalidSolidityId;
            case 21:
                return Status.Unknown;
            case 22:
                return Status.Success;
            case 23:
                return Status.FailInvalid;
            case 24:
                return Status.FailFee;
            case 25:
                return Status.FailBalance;
            case 26:
                return Status.KeyRequired;
            case 27:
                return Status.BadEncoding;
            case 28:
                return Status.InsufficientAccountBalance;
            case 29:
                return Status.InvalidSolidityAddress;
            case 30:
                return Status.InsufficientGas;
            case 31:
                return Status.ContractSizeLimitExceeded;
            case 32:
                return Status.LocalCallModificationException;
            case 33:
                return Status.ContractRevertExecuted;
            case 34:
                return Status.ContractExecutionException;
            case 35:
                return Status.InvalidReceivingNodeAccount;
            case 36:
                return Status.MissingQueryHeader;
            case 37:
                return Status.AccountUpdateFailed;
            case 38:
                return Status.InvalidKeyEncoding;
            case 39:
                return Status.NullSolidityAddress;
            case 40:
                return Status.ContractUpdateFailed;
            case 41:
                return Status.InvalidQueryHeader;
            case 42:
                return Status.InvalidFeeSubmitted;
            case 43:
                return Status.InvalidPayerSignature;
            case 44:
                return Status.KeyNotProvided;
            case 45:
                return Status.InvalidExpirationTime;
            case 46:
                return Status.NoWaclKey;
            case 47:
                return Status.FileContentEmpty;
            case 48:
                return Status.InvalidAccountAmounts;
            case 49:
                return Status.EmptyTransactionBody;
            case 50:
                return Status.InvalidTransactionBody;
            case 51:
                return Status.InvalidSignatureTypeMismatchingKey;
            case 52:
                return Status.InvalidSignatureCountMismatchingKey;
            case 53:
                return Status.EmptyLiveHashBody;
            case 54:
                return Status.EmptyLiveHash;
            case 55:
                return Status.EmptyLiveHashKeys;
            case 56:
                return Status.InvalidLiveHashSize;
            case 57:
                return Status.EmptyQueryBody;
            case 58:
                return Status.EmptyLiveHashQuery;
            case 59:
                return Status.LiveHashNotFound;
            case 60:
                return Status.AccountIdDoesNotExist;
            case 61:
                return Status.LiveHashAlreadyExists;
            case 62:
                return Status.InvalidFileWacl;
            case 63:
                return Status.SerializationFailed;
            case 64:
                return Status.TransactionOversize;
            case 65:
                return Status.TransactionTooManyLayers;
            case 66:
                return Status.ContractDeleted;
            case 67:
                return Status.PlatformNotActive;
            case 68:
                return Status.KeyPrefixMismatch;
            case 69:
                return Status.PlatformTransactionNotCreated;
            case 70:
                return Status.InvalidRenewalPeriod;
            case 71:
                return Status.InvalidPayerAccountId;
            case 72:
                return Status.AccountDeleted;
            case 73:
                return Status.FileDeleted;
            case 74:
                return Status.AccountRepeatedInAccountAmounts;
            case 75:
                return Status.SettingNegativeAccountBalance;
            case 76:
                return Status.ObtainerRequired;
            case 77:
                return Status.ObtainerSameContractId;
            case 78:
                return Status.ObtainerDoesNotExist;
            case 79:
                return Status.ModifyingImmutableContract;
            case 80:
                return Status.FileSystemException;
            case 81:
                return Status.AutorenewDurationNotInRange;
            case 82:
                return Status.ErrorDecodingBytestring;
            case 83:
                return Status.ContractFileEmpty;
            case 84:
                return Status.ContractBytecodeEmpty;
            case 85:
                return Status.InvalidInitialBalance;
            case 86:
                return Status.InvalidReceiveRecordThreshold;
            case 87:
                return Status.InvalidSendRecordThreshold;
            case 88:
                return Status.AccountIsNotGenesisAccount;
            case 89:
                return Status.PayerAccountUnauthorized;
            case 90:
                return Status.InvalidFreezeTransactionBody;
            case 91:
                return Status.FreezeTransactionBodyNotFound;
            case 92:
                return Status.TransferListSizeLimitExceeded;
            case 93:
                return Status.ResultSizeLimitExceeded;
            case 94:
                return Status.NotSpecialAccount;
            case 95:
                return Status.ContractNegativeGas;
            case 96:
                return Status.ContractNegativeValue;
            case 97:
                return Status.InvalidFeeFile;
            case 98:
                return Status.InvalidExchangeRateFile;
            case 99:
                return Status.InsufficientLocalCallGas;
            case 100:
                return Status.EntityNotAllowedToDelete;
            case 101:
                return Status.AuthorizationFailed;
            case 102:
                return Status.FileUploadedProtoInvalid;
            case 103:
                return Status.FileUploadedProtoNotSavedToDisk;
            case 104:
                return Status.FeeScheduleFilePartUploaded;
            case 105:
                return Status.ExchangeRateChangeLimitExceeded;
            case 106:
                return Status.MaxContractStorageExceeded;
            case 107:
                return Status.TransferAccountSameAsDeleteAccount;
            case 108:
                return Status.TotalLedgerBalanceInvalid;
            case 110:
                return Status.ExpirationReductionNotAllowed;
            case 111:
                return Status.MaxGasLimitExceeded;
            case 112:
                return Status.MaxFileSizeExceeded;
            case 113:
                return Status.ReceiverSigRequired;
            case 150:
                return Status.InvalidTopicId;
            case 155:
                return Status.InvalidAdminKey;
            case 156:
                return Status.InvalidSubmitKey;
            case 157:
                return Status.Unauthorized;
            case 158:
                return Status.InvalidTopicMessage;
            case 159:
                return Status.InvalidAutorenewAccount;
            case 160:
                return Status.AutorenewAccountNotAllowed;
            case 162:
                return Status.TopicExpired;
            case 163:
                return Status.InvalidChunkNumber;
            case 164:
                return Status.InvalidChunkTransactionId;
            case 165:
                return Status.AccountFrozenForToken;
            case 166:
                return Status.TokensPerAccountLimitExceeded;
            case 167:
                return Status.InvalidTokenId;
            case 168:
                return Status.InvalidTokenDecimals;
            case 169:
                return Status.InvalidTokenInitialSupply;
            case 170:
                return Status.InvalidTreasuryAccountForToken;
            case 171:
                return Status.InvalidTokenSymbol;
            case 172:
                return Status.TokenHasNoFreezeKey;
            case 173:
                return Status.TransfersNotZeroSumForToken;
            case 174:
                return Status.MissingTokenSymbol;
            case 175:
                return Status.TokenSymbolTooLong;
            case 176:
                return Status.AccountKycNotGrantedForToken;
            case 177:
                return Status.TokenHasNoKycKey;
            case 178:
                return Status.InsufficientTokenBalance;
            case 179:
                return Status.TokenWasDeleted;
            case 180:
                return Status.TokenHasNoSupplyKey;
            case 181:
                return Status.TokenHasNoWipeKey;
            case 182:
                return Status.InvalidTokenMintAmount;
            case 183:
                return Status.InvalidTokenBurnAmount;
            case 184:
                return Status.TokenNotAssociatedToAccount;
            case 185:
                return Status.CannotWipeTokenTreasuryAccount;
            case 186:
                return Status.InvalidKycKey;
            case 187:
                return Status.InvalidWipeKey;
            case 188:
                return Status.InvalidFreezeKey;
            case 189:
                return Status.InvalidSupplyKey;
            case 190:
                return Status.MissingTokenName;
            case 191:
                return Status.TokenNameTooLong;
            case 192:
                return Status.InvalidWipingAmount;
            case 193:
                return Status.TokenIsImmutable;
            case 194:
                return Status.TokenAlreadyAssociatedToAccount;
            case 195:
                return Status.TransactionRequiresZeroTokenBalances;
            case 196:
                return Status.AccountIsTreasury;
            case 197:
                return Status.TokenIdRepeatedInTokenList;
            case 198:
                return Status.TokenTransferListSizeLimitExceeded;
            case 199:
                return Status.EmptyTokenTransferBody;
            case 200:
                return Status.EmptyTokenTransferAccountAmounts;
            case 201:
                return Status.InvalidScheduleId;
            case 202:
                return Status.ScheduleIsImmutable;
            case 203:
                return Status.InvalidSchedulePayerId;
            case 204:
                return Status.InvalidScheduleAccountId;
            case 205:
                return Status.NoNewValidSignatures;
            case 206:
                return Status.UnresolvableRequiredSigners;
            case 207:
                return Status.ScheduledTransactionNotInWhitelist;
            case 208:
                return Status.SomeSignaturesWereInvalid;
            case 209:
                return Status.TransactionIdFieldNotAllowed;
            case 210:
                return Status.IdenticalScheduleAlreadyCreated;
            case 211:
                return Status.InvalidZeroByteInString;
            case 212:
                return Status.ScheduleAlreadyDeleted;
            case 213:
                return Status.ScheduleAlreadyExecuted;
            case 214:
                return Status.MessageSizeTooLarge;
            case 215:
                return Status.OperationRepeatedInBucketGroups;
            case 216:
                return Status.BucketCapacityOverflow;
            case 217:
                return Status.NodeCapacityNotSufficientForOperation;
            case 218:
                return Status.BucketHasNoThrottleGroups;
            case 219:
                return Status.ThrottleGroupHasZeroOpsPerSec;
            case 220:
                return Status.SuccessButMissingExpectedOperation;
            case 221:
                return Status.UnparseableThrottleDefinitions;
            case 222:
                return Status.InvalidThrottleDefinitions;
            case 223:
                return Status.AccountExpiredAndPendingRemoval;
            case 224:
                return Status.InvalidTokenMaxSupply;
            case 225:
                return Status.InvalidTokenNftSerialNumber;
            case 226:
                return Status.InvalidNftId;
            case 227:
                return Status.MetadataTooLong;
            case 228:
                return Status.BatchSizeLimitExceeded;
            case 229:
                return Status.InvalidQueryRange;
            case 230:
                return Status.FractionDividesByZero;
            case 231:
                return Status.InsufficientPayerBalanceForCustomFee;
            case 232:
                return Status.CustomFeesListTooLong;
            case 233:
                return Status.InvalidCustomFeeCollector;
            case 234:
                return Status.InvalidTokenIdInCustomFees;
            case 235:
                return Status.TokenNotAssociatedToFeeCollector;
            case 236:
                return Status.TokenMaxSupplyReached;
            case 237:
                return Status.SenderDoesNotOwnNftSerialNo;
            case 238:
                return Status.CustomFeeNotFullySpecified;
            case 239:
                return Status.CustomFeeMustBePositive;
            case 240:
                return Status.TokenHasNoFeeScheduleKey;
            case 241:
                return Status.CustomFeeOutsideNumericRange;
            case 242:
                return Status.RoyaltyFractionCannotExceedOne;
            case 243:
                return Status.FractionalFeeMaxAmountLessThanMinAmount;
            case 244:
                return Status.CustomScheduleAlreadyHasNoFees;
            case 245:
                return Status.CustomFeeDenominationMustBeFungibleCommon;
            case 246:
                return Status.CustomFractionalFeeOnlyAllowedForFungibleCommon;
            case 247:
                return Status.InvalidCustomFeeScheduleKey;
            case 248:
                return Status.InvalidTokenMintMetadata;
            case 249:
                return Status.InvalidTokenBurnMetadata;
            case 250:
                return Status.CurrentTreasuryStillOwnsNfts;
            case 251:
                return Status.AccountStillOwnsNfts;
            case 252:
                return Status.TreasuryMustOwnBurnedNft;
            case 253:
                return Status.AccountDoesNotOwnWipedNft;
            case 254:
                return Status.AccountAmountTransfersOnlyAllowedForFungibleCommon;
            case 255:
                return Status.MaxNftsInPriceRegimeHaveBeenMinted;
            case 256:
                return Status.PayerAccountDeleted;
            case 257:
                return Status.CustomFeeChargingExceededMaxRecursionDepth;
            case 258:
                return Status.CustomFeeChargingExceededMaxAccountAmounts;
            case 259:
                return Status.InsufficientSenderAccountBalanceForCustomFee;
            case 260:
                return Status.SerialNumberLimitReached;
            case 261:
                return Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique;
            case 262:
                return Status.NoRemainingAutomaticAssociations;
            case 263:
                return Status.ExistingAutomaticAssociationsExceedGivenLimit;
            case 264:
                return Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit;
            case 265:
                return Status.TokenIsPaused;
            case 266:
                return Status.TokenHasNoPauseKey;
            case 267:
                return Status.InvalidPauseKey;
            case 268:
                return Status.FreezeUpdateFileDoesNotExist;
            case 269:
                return Status.FreezeUpdateFileHashDoesNotMatch;
            case 270:
                return Status.NoUpgradeHasBeenPrepared;
            case 271:
                return Status.NoFreezeIsScheduled;
            case 272:
                return Status.UpdateFileHashChangedSincePrepareUpgrade;
            case 273:
                return Status.FreezeStartTimeMustBeFuture;
            case 274:
                return Status.PreparedUpdateFileIsImmutable;
            case 275:
                return Status.FreezeAlreadyScheduled;
            case 276:
                return Status.FreezeUpgradeInProgress;
            case 277:
                return Status.UpdateFileIdDoesNotMatchPrepared;
            case 278:
                return Status.UpdateFileHashDoesNotMatchPrepared;
            case 279:
                return Status.ConsensusGasExhausted;
            case 280:
                return Status.RevertedSuccess;
            case 281:
                return Status.MaxStorageInPriceRegimeHasBeenUsed;
            case 282:
                return Status.InvalidAliasKey;
            case 283:
                return Status.UnexpectedTokenDecimals;
            case 284:
                return Status.InvalidProxyAccountId;
            case 285:
                return Status.InvalidTransferAccountId;
            case 286:
                return Status.InvalidFeeCollectorAccountId;
            case 287:
                return Status.AliasIsImmutable;
            case 288:
                return Status.SpenderAccountSameAsOwner;
            case 289:
                return Status.AmountExceedsTokenMaxSupply;
            case 290:
                return Status.NegativeAllowanceAmount;
            case 291:
                return Status.CannotApproveForAllFungibleCommon;
            case 292:
                return Status.SpenderDoesNotHaveAllowance;
            case 293:
                return Status.AmountExceedsAllowance;
            case 294:
                return Status.MaxAllowancesExceeded;
            case 295:
                return Status.EmptyAllowances;
            case 296:
                return Status.SpenderAccountRepeatedInAllowances;
            case 297:
                return Status.RepeatedSerialNumsInNFTAllowances;
            case 298:
                return Status.FungibleTokenInNFTAllowances;
            case 299:
                return Status.NFTInFungibleTokenAllowances;
            case 300:
                return Status.PayerAndOwnerNotEqual;
            default:
                throw new Error(
                    `(BUG) Status.fromCode() does not handle code: ${code}`
                );
        }
    }

    /**
     * @returns {proto.ResponseCodeEnum}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * The transaction passed the precheck validations.
 */
Status.Ok = new Status(0);

/**
 * For any error not handled by specific error codes listed below.
 */
Status.InvalidTransaction = new Status(1);

/**
 * Payer account does not exist.
 */
Status.PayerAccountNotFound = new Status(2);

/**
 * Node Account provided does not match the node account of the node the transaction was submitted
 * to.
 */
Status.InvalidNodeAccount = new Status(3);

/**
 * Pre-Check error when TransactionValidStart + transactionValidDuration is less than current
 * consensus time.
 */
Status.TransactionExpired = new Status(4);

/**
 * Transaction start time is greater than current consensus time
 */
Status.InvalidTransactionStart = new Status(5);

/**
 * valid transaction duration is a positive non zero number that does not exceed 120 seconds
 */
Status.InvalidTransactionDuration = new Status(6);

/**
 * The transaction signature is not valid
 */
Status.InvalidSignature = new Status(7);

/**
 * Transaction memo size exceeded 100 bytes
 */
Status.MemoTooLong = new Status(8);

/**
 * The fee provided in the transaction is insufficient for this type of transaction
 */
Status.InsufficientTxFee = new Status(9);

/**
 * The payer account has insufficient cryptocurrency to pay the transaction fee
 */
Status.InsufficientPayerBalance = new Status(10);

/**
 * This transaction ID is a duplicate of one that was submitted to this node or reached consensus
 * in the last 180 seconds (receipt period)
 */
Status.DuplicateTransaction = new Status(11);

/**
 * If API is throttled out
 */
Status.Busy = new Status(12);

/**
 * The API is not currently supported
 */
Status.NotSupported = new Status(13);

/**
 * The file id is invalid or does not exist
 */
Status.InvalidFileId = new Status(14);

/**
 * The account id is invalid or does not exist
 */
Status.InvalidAccountId = new Status(15);

/**
 * The contract id is invalid or does not exist
 */
Status.InvalidContractId = new Status(16);

/**
 * Transaction id is not valid
 */
Status.InvalidTransactionId = new Status(17);

/**
 * Receipt for given transaction id does not exist
 */
Status.ReceiptNotFound = new Status(18);

/**
 * Record for given transaction id does not exist
 */
Status.RecordNotFound = new Status(19);

/**
 * The solidity id is invalid or entity with this solidity id does not exist
 */
Status.InvalidSolidityId = new Status(20);

/**
 * The responding node has submitted the transaction to the network. Its final status is still
 * unknown.
 */
Status.Unknown = new Status(21);

/**
 * The transaction succeeded
 */
Status.Success = new Status(22);

/**
 * There was a system error and the transaction failed because of invalid request parameters.
 */
Status.FailInvalid = new Status(23);

/**
 * There was a system error while performing fee calculation, reserved for future.
 */
Status.FailFee = new Status(24);

/**
 * There was a system error while performing balance checks, reserved for future.
 */
Status.FailBalance = new Status(25);

/**
 * Key not provided in the transaction body
 */
Status.KeyRequired = new Status(26);

/**
 * Unsupported algorithm/encoding used for keys in the transaction
 */
Status.BadEncoding = new Status(27);

/**
 * When the account balance is not sufficient for the transfer
 */
Status.InsufficientAccountBalance = new Status(28);

/**
 * During an update transaction when the system is not able to find the Users Solidity address
 */
Status.InvalidSolidityAddress = new Status(29);

/**
 * Not enough gas was supplied to execute transaction
 */
Status.InsufficientGas = new Status(30);

/**
 * contract byte code size is over the limit
 */
Status.ContractSizeLimitExceeded = new Status(31);

/**
 * local execution (query) is requested for a function which changes state
 */
Status.LocalCallModificationException = new Status(32);

/**
 * Contract REVERT OPCODE executed
 */
Status.ContractRevertExecuted = new Status(33);

/**
 * For any contract execution related error not handled by specific error codes listed above.
 */
Status.ContractExecutionException = new Status(34);

/**
 * In Query validation, account with +ve(amount) value should be Receiving node account, the
 * receiver account should be only one account in the list
 */
Status.InvalidReceivingNodeAccount = new Status(35);

/**
 * Header is missing in Query request
 */
Status.MissingQueryHeader = new Status(36);

/**
 * The update of the account failed
 */
Status.AccountUpdateFailed = new Status(37);

/**
 * Provided key encoding was not supported by the system
 */
Status.InvalidKeyEncoding = new Status(38);

/**
 * null solidity address
 */
Status.NullSolidityAddress = new Status(39);

/**
 * update of the contract failed
 */
Status.ContractUpdateFailed = new Status(40);

/**
 * the query header is invalid
 */
Status.InvalidQueryHeader = new Status(41);

/**
 * Invalid fee submitted
 */
Status.InvalidFeeSubmitted = new Status(42);

/**
 * Payer signature is invalid
 */
Status.InvalidPayerSignature = new Status(43);

/**
 * The keys were not provided in the request.
 */
Status.KeyNotProvided = new Status(44);

/**
 * Expiration time provided in the transaction was invalid.
 */
Status.InvalidExpirationTime = new Status(45);

/**
 * WriteAccess Control Keys are not provided for the file
 */
Status.NoWaclKey = new Status(46);

/**
 * The contents of file are provided as empty.
 */
Status.FileContentEmpty = new Status(47);

/**
 * The crypto transfer credit and debit do not sum equal to 0
 */
Status.InvalidAccountAmounts = new Status(48);

/**
 * Transaction body provided is empty
 */
Status.EmptyTransactionBody = new Status(49);

/**
 * Invalid transaction body provided
 */
Status.InvalidTransactionBody = new Status(50);

/**
 * the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of
 * signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)
 */
Status.InvalidSignatureTypeMismatchingKey = new Status(51);

/**
 * the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList,
 * or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding
 * signatureList should also have 3 base signatures.
 */
Status.InvalidSignatureCountMismatchingKey = new Status(52);

/**
 * the livehash body is empty
 */
Status.EmptyLiveHashBody = new Status(53);

/**
 * the livehash data is missing
 */
Status.EmptyLiveHash = new Status(54);

/**
 * the keys for a livehash are missing
 */
Status.EmptyLiveHashKeys = new Status(55);

/**
 * the livehash data is not the output of a SHA-384 digest
 */
Status.InvalidLiveHashSize = new Status(56);

/**
 * the query body is empty
 */
Status.EmptyQueryBody = new Status(57);

/**
 * the crypto livehash query is empty
 */
Status.EmptyLiveHashQuery = new Status(58);

/**
 * the livehash is not present
 */
Status.LiveHashNotFound = new Status(59);

/**
 * the account id passed has not yet been created.
 */
Status.AccountIdDoesNotExist = new Status(60);

/**
 * the livehash already exists for a given account
 */
Status.LiveHashAlreadyExists = new Status(61);

/**
 * File WACL keys are invalid
 */
Status.InvalidFileWacl = new Status(62);

/**
 * Serialization failure
 */
Status.SerializationFailed = new Status(63);

/**
 * The size of the Transaction is greater than transactionMaxBytes
 */
Status.TransactionOversize = new Status(64);

/**
 * The Transaction has more than 50 levels
 */
Status.TransactionTooManyLayers = new Status(65);

/**
 * Contract is marked as deleted
 */
Status.ContractDeleted = new Status(66);

/**
 * the platform node is either disconnected or lagging behind.
 */
Status.PlatformNotActive = new Status(67);

/**
 * one public key matches more than one prefixes on the signature map
 */
Status.KeyPrefixMismatch = new Status(68);

/**
 * transaction not created by platform due to large backlog
 */
Status.PlatformTransactionNotCreated = new Status(69);

/**
 * auto renewal period is not a positive number of seconds
 */
Status.InvalidRenewalPeriod = new Status(70);

/**
 * the response code when a smart contract id is passed for a crypto API request
 */
Status.InvalidPayerAccountId = new Status(71);

/**
 * the account has been marked as deleted
 */
Status.AccountDeleted = new Status(72);

/**
 * the file has been marked as deleted
 */
Status.FileDeleted = new Status(73);

/**
 * same accounts repeated in the transfer account list
 */
Status.AccountRepeatedInAccountAmounts = new Status(74);

/**
 * attempting to set negative balance value for crypto account
 */
Status.SettingNegativeAccountBalance = new Status(75);

/**
 * when deleting smart contract that has crypto balance either transfer account or transfer smart
 * contract is required
 */
Status.ObtainerRequired = new Status(76);

/**
 * when deleting smart contract that has crypto balance you can not use the same contract id as
 * transferContractId as the one being deleted
 */
Status.ObtainerSameContractId = new Status(77);

/**
 * transferAccountId or transferContractId specified for contract delete does not exist
 */
Status.ObtainerDoesNotExist = new Status(78);

/**
 * attempting to modify (update or delete a immutable smart contract, i.e. one created without a
 * admin key)
 */
Status.ModifyingImmutableContract = new Status(79);

/**
 * Unexpected exception thrown by file system functions
 */
Status.FileSystemException = new Status(80);

/**
 * the duration is not a subset of [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]
 */
Status.AutorenewDurationNotInRange = new Status(81);

/**
 * Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex
 * string.
 */
Status.ErrorDecodingBytestring = new Status(82);

/**
 * File to create a smart contract was of length zero
 */
Status.ContractFileEmpty = new Status(83);

/**
 * Bytecode for smart contract is of length zero
 */
Status.ContractBytecodeEmpty = new Status(84);

/**
 * Attempt to set negative initial balance
 */
Status.InvalidInitialBalance = new Status(85);

/**
 * [Deprecated]. attempt to set negative receive record threshold
 */
Status.InvalidReceiveRecordThreshold = new Status(86);

/**
 * [Deprecated]. attempt to set negative send record threshold
 */
Status.InvalidSendRecordThreshold = new Status(87);

/**
 * Special Account Operations should be performed by only Genesis account, return this code if it
 * is not Genesis Account
 */
Status.AccountIsNotGenesisAccount = new Status(88);

/**
 * The fee payer account doesn't have permission to submit such Transaction
 */
Status.PayerAccountUnauthorized = new Status(89);

/**
 * FreezeTransactionBody is invalid
 */
Status.InvalidFreezeTransactionBody = new Status(90);

/**
 * FreezeTransactionBody does not exist
 */
Status.FreezeTransactionBodyNotFound = new Status(91);

/**
 * Exceeded the number of accounts (both from and to) allowed for crypto transfer list
 */
Status.TransferListSizeLimitExceeded = new Status(92);

/**
 * Smart contract result size greater than specified maxResultSize
 */
Status.ResultSizeLimitExceeded = new Status(93);

/**
 * The payer account is not a special account(account 0.0.55)
 */
Status.NotSpecialAccount = new Status(94);

/**
 * Negative gas was offered in smart contract call
 */
Status.ContractNegativeGas = new Status(95);

/**
 * Negative value / initial balance was specified in a smart contract call / create
 */
Status.ContractNegativeValue = new Status(96);

/**
 * Failed to update fee file
 */
Status.InvalidFeeFile = new Status(97);

/**
 * Failed to update exchange rate file
 */
Status.InvalidExchangeRateFile = new Status(98);

/**
 * Payment tendered for contract local call cannot cover both the fee and the gas
 */
Status.InsufficientLocalCallGas = new Status(99);

/**
 * Entities with Entity ID below 1000 are not allowed to be deleted
 */
Status.EntityNotAllowedToDelete = new Status(100);

/**
 * Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2)
 * account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account
 * A/c 0.0.50 - Update all Network Function accounts & perform all the Network Functions listed
 * below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102),
 * ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate
 * (0.0.112).
 */
Status.AuthorizationFailed = new Status(101);

/**
 * Fee Schedule Proto uploaded but not valid (append or update is required)
 */
Status.FileUploadedProtoInvalid = new Status(102);

/**
 * Fee Schedule Proto uploaded but not valid (append or update is required)
 */
Status.FileUploadedProtoNotSavedToDisk = new Status(103);

/**
 * Fee Schedule Proto File Part uploaded
 */
Status.FeeScheduleFilePartUploaded = new Status(104);

/**
 * The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage
 */
Status.ExchangeRateChangeLimitExceeded = new Status(105);

/**
 * Contract permanent storage exceeded the currently allowable limit
 */
Status.MaxContractStorageExceeded = new Status(106);

/**
 * Transfer Account should not be same as Account to be deleted
 */
Status.TransferAccountSameAsDeleteAccount = new Status(107);

Status.TotalLedgerBalanceInvalid = new Status(108);
/**
 * The expiration date/time on a smart contract may not be reduced
 */
Status.ExpirationReductionNotAllowed = new Status(110);

/**
 * Gas exceeded currently allowable gas limit per transaction
 */
Status.MaxGasLimitExceeded = new Status(111);

/**
 * File size exceeded the currently allowable limit
 */
Status.MaxFileSizeExceeded = new Status(112);

/**
 * When a valid signature is not provided for operations on account with receiverSigRequired=true
 */
Status.ReceiverSigRequired = new Status(113);

/**
 * The Topic ID specified is not in the system.
 */
Status.InvalidTopicId = new Status(150);

/**
 * A provided admin key was invalid.
 */
Status.InvalidAdminKey = new Status(155);

/**
 * A provided submit key was invalid.
 */
Status.InvalidSubmitKey = new Status(156);

/**
 * An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).
 */
Status.Unauthorized = new Status(157);

/**
 * A ConsensusService message is empty.
 */
Status.InvalidTopicMessage = new Status(158);

/**
 * The autoRenewAccount specified is not a valid, active account.
 */
Status.InvalidAutorenewAccount = new Status(159);

/**
 * An adminKey was not specified on the topic, so there must not be an autoRenewAccount.
 */
Status.AutorenewAccountNotAllowed = new Status(160);

/**
 * The topic has expired, was not automatically renewed, and is in a 7 day grace period before the
 * topic will be deleted unrecoverably. This error response code will not be returned until
 * autoRenew functionality is supported by HAPI.
 */
Status.TopicExpired = new Status(162);

/**
 * chunk number must be from 1 to total (chunks) inclusive.
 */
Status.InvalidChunkNumber = new Status(163);

/**
 * For every chunk, the payer account that is part of initialTransactionID must match the Payer
 * Account of this transaction. The entire initialTransactionID should match the transactionID of
 * the first chunk, but this is not checked or enforced by Hedera except when the chunk number is 1.
 */
Status.InvalidChunkTransactionId = new Status(164);

/**
 * Account is frozen and cannot transact with the token
 */
Status.AccountFrozenForToken = new Status(165);

/**
 * An involved account already has more than <tt>tokens.maxPerAccount</tt> associations with
 * non-deleted tokens.
 */
Status.TokensPerAccountLimitExceeded = new Status(166);

/**
 * The token is invalid or does not exist
 */
Status.InvalidTokenId = new Status(167);

/**
 * Invalid token decimals
 */
Status.InvalidTokenDecimals = new Status(168);

/**
 * Invalid token initial supply
 */
Status.InvalidTokenInitialSupply = new Status(169);

/**
 * Treasury Account does not exist or is deleted
 */
Status.InvalidTreasuryAccountForToken = new Status(170);

/**
 * Token Symbol is not UTF-8 capitalized alphabetical string
 */
Status.InvalidTokenSymbol = new Status(171);

/**
 * Freeze key is not set on token
 */
Status.TokenHasNoFreezeKey = new Status(172);

/**
 * Amounts in transfer list are not net zero
 */
Status.TransfersNotZeroSumForToken = new Status(173);

/**
 * A token symbol was not provided
 */
Status.MissingTokenSymbol = new Status(174);

/**
 * The provided token symbol was too long
 */
Status.TokenSymbolTooLong = new Status(175);

/**
 * KYC must be granted and account does not have KYC granted
 */
Status.AccountKycNotGrantedForToken = new Status(176);

/**
 * KYC key is not set on token
 */
Status.TokenHasNoKycKey = new Status(177);

/**
 * Token balance is not sufficient for the transaction
 */
Status.InsufficientTokenBalance = new Status(178);

/**
 * Token transactions cannot be executed on deleted token
 */
Status.TokenWasDeleted = new Status(179);

/**
 * Supply key is not set on token
 */
Status.TokenHasNoSupplyKey = new Status(180);

/**
 * Wipe key is not set on token
 */
Status.TokenHasNoWipeKey = new Status(181);

/**
 * The requested token mint amount would cause an invalid total supply
 */
Status.InvalidTokenMintAmount = new Status(182);

/**
 * The requested token burn amount would cause an invalid total supply
 */
Status.InvalidTokenBurnAmount = new Status(183);

/**
 * A required token-account relationship is missing
 */
Status.TokenNotAssociatedToAccount = new Status(184);

/**
 * The target of a wipe operation was the token treasury account
 */
Status.CannotWipeTokenTreasuryAccount = new Status(185);

/**
 * The provided KYC key was invalid.
 */
Status.InvalidKycKey = new Status(186);

/**
 * The provided wipe key was invalid.
 */
Status.InvalidWipeKey = new Status(187);

/**
 * The provided freeze key was invalid.
 */
Status.InvalidFreezeKey = new Status(188);

/**
 * The provided supply key was invalid.
 */
Status.InvalidSupplyKey = new Status(189);

/**
 * Token Name is not provided
 */
Status.MissingTokenName = new Status(190);

/**
 * Token Name is too long
 */
Status.TokenNameTooLong = new Status(191);

/**
 * The provided wipe amount must not be negative, zero or bigger than the token holder balance
 */
Status.InvalidWipingAmount = new Status(192);

/**
 * Token does not have Admin key set, thus update/delete transactions cannot be performed
 */
Status.TokenIsImmutable = new Status(193);

/**
 * An <tt>associateToken</tt> operation specified a token already associated to the account
 */
Status.TokenAlreadyAssociatedToAccount = new Status(194);

/**
 * An attempted operation is invalid until all token balances for the target account are zero
 */
Status.TransactionRequiresZeroTokenBalances = new Status(195);

/**
 * An attempted operation is invalid because the account is a treasury
 */
Status.AccountIsTreasury = new Status(196);

/**
 * Same TokenIDs present in the token list
 */
Status.TokenIdRepeatedInTokenList = new Status(197);

/**
 * Exceeded the number of token transfers (both from and to) allowed for token transfer list
 */
Status.TokenTransferListSizeLimitExceeded = new Status(198);

/**
 * TokenTransfersTransactionBody has no TokenTransferList
 */
Status.EmptyTokenTransferBody = new Status(199);

/**
 * TokenTransfersTransactionBody has a TokenTransferList with no AccountAmounts
 */
Status.EmptyTokenTransferAccountAmounts = new Status(200);

/**
 * The Scheduled entity does not exist; or has now expired, been deleted, or been executed
 */
Status.InvalidScheduleId = new Status(201);

/**
 * The Scheduled entity cannot be modified. Admin key not set
 */
Status.ScheduleIsImmutable = new Status(202);

/**
 * The provided Scheduled Payer does not exist
 */
Status.InvalidSchedulePayerId = new Status(203);

/**
 * The Schedule Create Transaction TransactionID account does not exist
 */
Status.InvalidScheduleAccountId = new Status(204);

/**
 * The provided sig map did not contain any new valid signatures from required signers of the
 * scheduled transaction
 */
Status.NoNewValidSignatures = new Status(205);

/**
 * The required signers for a scheduled transaction cannot be resolved, for example because they do
 * not exist or have been deleted
 */
Status.UnresolvableRequiredSigners = new Status(206);

/**
 * Only whitelisted transaction types may be scheduled
 */
Status.ScheduledTransactionNotInWhitelist = new Status(207);

/**
 * At least one of the signatures in the provided sig map did not represent a valid signature for
 * any required signer
 */
Status.SomeSignaturesWereInvalid = new Status(208);

/**
 * The scheduled field in the TransactionID may not be set to true
 */
Status.TransactionIdFieldNotAllowed = new Status(209);

/**
 * A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that
 * is, all fields other than scheduledPayerAccountID)
 */
Status.IdenticalScheduleAlreadyCreated = new Status(210);

/**
 * A string field in the transaction has a UTF-8 encoding with the prohibited zero byte
 */
Status.InvalidZeroByteInString = new Status(211);

/**
 * A schedule being signed or deleted has already been deleted
 */
Status.ScheduleAlreadyDeleted = new Status(212);

/**
 * A schedule being signed or deleted has already been executed
 */
Status.ScheduleAlreadyExecuted = new Status(213);

/**
 * ConsensusSubmitMessage request's message size is larger than allowed.
 */
Status.MessageSizeTooLarge = new Status(214);

/**
 * An operation was assigned to more than one throttle group in a given bucket
 */
Status.OperationRepeatedInBucketGroups = new Status(215);

/**
 * The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte
 * integral type
 */
Status.BucketCapacityOverflow = new Status(216);

/**
 * Given the network size in the address book, the node-level capacity for an operation would never
 * be enough to accept a single request; usually means a bucket burstPeriod should be increased
 */
Status.NodeCapacityNotSufficientForOperation = new Status(217);

/**
 * A bucket was defined without any throttle groups
 */
Status.BucketHasNoThrottleGroups = new Status(218);

/**
 * A throttle group was granted zero opsPerSec
 */
Status.ThrottleGroupHasZeroOpsPerSec = new Status(219);

/**
 * The throttle definitions file was updated, but some supported operations were not assigned a
 * bucket
 */
Status.SuccessButMissingExpectedOperation = new Status(220);

/**
 * The new contents for the throttle definitions system file were not valid protobuf
 */
Status.UnparseableThrottleDefinitions = new Status(221);

/**
 * The new throttle definitions system file were invalid, and no more specific error could be
 * divined
 */
Status.InvalidThrottleDefinitions = new Status(222);

/**
 * The transaction references an account which has passed its expiration without renewal funds
 * available, and currently remains in the ledger only because of the grace period given to expired
 * entities
 */
Status.AccountExpiredAndPendingRemoval = new Status(223);

/**
 * Invalid token max supply
 */
Status.InvalidTokenMaxSupply = new Status(224);

/**
 * Invalid token nft serial number
 */
Status.InvalidTokenNftSerialNumber = new Status(225);

/**
 * Invalid nft id
 */
Status.InvalidNftId = new Status(226);

/**
 * Nft metadata is too long
 */
Status.MetadataTooLong = new Status(227);

/**
 * Repeated operations count exceeds the limit
 */
Status.BatchSizeLimitExceeded = new Status(228);

/**
 * The range of data to be gathered is out of the set boundaries
 */
Status.InvalidQueryRange = new Status(229);

/**
 * A custom fractional fee set a denominator of zero
 */
Status.FractionDividesByZero = new Status(230);

/**
 * The transaction payer could not afford a custom fee
 */
Status.InsufficientPayerBalanceForCustomFee = new Status(231);

/**
 * More than 10 custom fees were specified
 */
Status.CustomFeesListTooLong = new Status(232);

/**
 * Any of the feeCollector accounts for customFees is invalid
 */
Status.InvalidCustomFeeCollector = new Status(233);

/**
 * Any of the token Ids in customFees is invalid
 */
Status.InvalidTokenIdInCustomFees = new Status(234);

/**
 * Any of the token Ids in customFees are not associated to feeCollector
 */
Status.TokenNotAssociatedToFeeCollector = new Status(235);

/**
 * A token cannot have more units minted due to its configured supply ceiling
 */
Status.TokenMaxSupplyReached = new Status(236);

/**
 * The transaction attempted to move an NFT serial number from an account other than its owner
 */
Status.SenderDoesNotOwnNftSerialNo = new Status(237);

/**
 * A custom fee schedule entry did not specify either a fixed or fractional fee
 */
Status.CustomFeeNotFullySpecified = new Status(238);

/**
 * Only positive fees may be assessed at this time
 */
Status.CustomFeeMustBePositive = new Status(239);

/**
 * Fee schedule key is not set on token
 */
Status.TokenHasNoFeeScheduleKey = new Status(240);

/**
 * A fractional custom fee exceeded the range of a 64-bit signed integer
 */
Status.CustomFeeOutsideNumericRange = new Status(241);

/**
 * A royalty cannot exceed the total fungible value exchanged for an NFT
 */
Status.RoyaltyFractionCannotExceedOne = new Status(242);

/**
 * Each fractional custom fee must have its maximum_amount, if specified, at least its
 * minimum_amount
 */
Status.FractionalFeeMaxAmountLessThanMinAmount = new Status(243);

/**
 * A fee schedule update tried to clear the custom fees from a token whose fee schedule was already
 * empty
 */
Status.CustomScheduleAlreadyHasNoFees = new Status(244);

/**
 * Only tokens of type FUNGIBLE_COMMON can be used to as fee schedule denominations
 */
Status.CustomFeeDenominationMustBeFungibleCommon = new Status(245);

/**
 * Only tokens of type FUNGIBLE_COMMON can have fractional fees
 */
Status.CustomFractionalFeeOnlyAllowedForFungibleCommon = new Status(246);

/**
 * The provided custom fee schedule key was invalid
 */
Status.InvalidCustomFeeScheduleKey = new Status(247);

/**
 * The requested token mint metadata was invalid
 */
Status.InvalidTokenMintMetadata = new Status(248);

/**
 * The requested token burn metadata was invalid
 */
Status.InvalidTokenBurnMetadata = new Status(249);

/**
 * The treasury for a unique token cannot be changed until it owns no NFTs
 */
Status.CurrentTreasuryStillOwnsNfts = new Status(250);

/**
 * An account cannot be dissociated from a unique token if it owns NFTs for the token
 */
Status.AccountStillOwnsNfts = new Status(251);

/**
 * A NFT can only be burned when owned by the unique token's treasury
 */
Status.TreasuryMustOwnBurnedNft = new Status(252);

/**
 * An account did not own the NFT to be wiped
 */
Status.AccountDoesNotOwnWipedNft = new Status(253);

/**
 * An AccountAmount token transfers list referenced a token type other than FUNGIBLE_COMMON
 */
Status.AccountAmountTransfersOnlyAllowedForFungibleCommon = new Status(254);

/**
 * All the NFTs allowed in the current price regime have already been minted
 */
Status.MaxNftsInPriceRegimeHaveBeenMinted = new Status(255);

/**
 * The payer account has been marked as deleted
 */
Status.PayerAccountDeleted = new Status(256);

/**
 * The reference chain of custom fees for a transferred token exceeded the maximum length of 2
 */
Status.CustomFeeChargingExceededMaxRecursionDepth = new Status(257);

/**
 * More than 20 balance adjustments were to satisfy a CryptoTransfer and its implied custom fee
 * payments
 */
Status.CustomFeeChargingExceededMaxAccountAmounts = new Status(258);

/**
 * The sender account in the token transfer transaction could not afford a custom fee
 */
Status.InsufficientSenderAccountBalanceForCustomFee = new Status(259);

/**
 * Currently no more than 4,294,967,295 NFTs may be minted for a given unique token type
 */
Status.SerialNumberLimitReached = new Status(260);

/**
 * Only tokens of type NON_FUNGIBLE_UNIQUE can have royalty fees
 */
Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique = new Status(261);

/**
 * The account has reached the limit on the automatic associations count.
 */
Status.NoRemainingAutomaticAssociations = new Status(262);

/**
 * Already existing automatic associations are more than the new maximum automatic associations.
 */
Status.ExistingAutomaticAssociationsExceedGivenLimit = new Status(263);

/**
 * Cannot set the number of automatic associations for an account more than the
 * maximum allowed token associations <tt>tokens.maxPerAccount</tt>
 */
Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit = new Status(
    264
);

/**
 * Token is paused. This Token cannot be a part of any kind of Transaction until unpaused.
 */
Status.TokenIsPaused = new Status(265);

/**
 * Pause key is not set on token
 */
Status.TokenHasNoPauseKey = new Status(266);

/**
 * The provided pause key was invalid
 */
Status.InvalidPauseKey = new Status(267);

/**
 * The update file in a freeze transaction body must exist.
 */
Status.FreezeUpdateFileDoesNotExist = new Status(268);

/**
 * The hash of the update file in a freeze transaction body must match the in-memory hash.
 */
Status.FreezeUpdateFileHashDoesNotMatch = new Status(269);

/**
 * A FREEZE_UPGRADE transaction was handled with no previous update prepared.
 */
Status.NoUpgradeHasBeenPrepared = new Status(270);

/**
 * A FREEZE_ABORT transaction was handled with no scheduled freeze.
 */
Status.NoFreezeIsScheduled = new Status(271);

/**
 * The update file hash when handling a FREEZE_UPGRADE transaction differs from the file
 * hash at the time of handling the PREPARE_UPGRADE transaction.
 */
Status.UpdateFileHashChangedSincePrepareUpgrade = new Status(272);

/**
 * The given freeze start time was in the (consensus) past.
 */
Status.FreezeStartTimeMustBeFuture = new Status(273);

/**
 * The prepared update file cannot be updated or appended until either the upgrade has
 * been completed, or a FREEZE_ABORT has been handled.
 */
Status.PreparedUpdateFileIsImmutable = new Status(274);

/**
 * Once a freeze is scheduled, it must be aborted before any other type of freeze can
 * can be performed.
 */
Status.FreezeAlreadyScheduled = new Status(275);

/**
 * If an NMT upgrade has been prepared, the following operation must be a FREEZE_UPGRADE.
 * (To issue a FREEZE_ONLY, submit a FREEZE_ABORT first.)
 */
Status.FreezeUpgradeInProgress = new Status(276);

/**
 * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
 * confirm the id of the file to be used in the upgrade.
 */
Status.UpdateFileIdDoesNotMatchPrepared = new Status(277);

/**
 * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
 * confirm the hash of the file to be used in the upgrade.
 */
Status.UpdateFileHashDoesNotMatchPrepared = new Status(278);

/**
 * Consensus throttle did not allow execution of this transaction. System is throttled at
 * consensus level.
 */
Status.ConsensusGasExhausted = new Status(279);

/**
 * A precompiled contract succeeded, but was later reverted.
 */
Status.RevertedSuccess = new Status(280);

/**
 * All contract storage allocated to the current price regime has been consumed.
 */
Status.MaxStorageInPriceRegimeHasBeenUsed = new Status(281);

/**
 * An alias used in a CryptoTransfer transaction is not the serialization of a primitive Key
 * message--that is, a Key with a single Ed25519 or ECDSA(secp256k1) public key and no
 * unknown protobuf fields.
 */
Status.InvalidAliasKey = new Status(282);

/**
 * A fungible token transfer expected a different number of decimals than the involved
 * type actually has.
 */
Status.UnexpectedTokenDecimals = new Status(283);

/**
 * The proxy account id is invalid or does not exist.
 */
Status.InvalidProxyAccountId = new Status(284);

/**
 * The transfer account id in CryptoDelete transaction is invalid or does not exist.
 */
Status.InvalidTransferAccountId = new Status(285);

/**
 * The fee collector account id in TokenFeeScheduleUpdate is invalid or does not exist.
 */
Status.InvalidFeeCollectorAccountId = new Status(286);

/**
 * The alias already set on an account cannot be updated using CryptoUpdate transaction.
 */
Status.AliasIsImmutable = new Status(287);

/**
 * An approved allowance specifies a spender account that is the same as the hbar/token
 * owner account.
 */
Status.SpenderAccountSameAsOwner = new Status(288);

/**
 * The establishment or adjustment of an approved allowance cause the token allowance
 * to exceed the token maximum supply.
 */
Status.AmountExceedsTokenMaxSupply = new Status(289);

/**
 * The specified amount for an approved allowance cannot be negative.
 */
Status.NegativeAllowanceAmount = new Status(290);

/**
 * The approveForAll flag cannot be set for a fungible token.
 */
Status.CannotApproveForAllFungibleCommon = new Status(291);

/**
 * The spender does not have an existing approved allowance with the hbar/token owner.
 */
Status.SpenderDoesNotHaveAllowance = new Status(292);

/**
 * The transfer amount exceeds the current approved allowance for the spender account.
 */
Status.AmountExceedsAllowance = new Status(293);

/**
 * The payer account of an approveAllowances or adjustAllowance transaction is attempting
 * to go beyond the maximum allowed number of allowances.
 */
Status.MaxAllowancesExceeded = new Status(294);

/**
 * No allowances have been specified in the approval/adjust transaction.
 */
Status.EmptyAllowances = new Status(295);

/**
 * Spender is repeated more than once in Crypto or Token or NFT allowance lists in a single
 * CryptoApproveAllowance or CryptoAdjustAllowance transaction.
 */
Status.SpenderAccountRepeatedInAllowances = new Status(296);

/**
 * Serial numbers are repeated in nft allowance for a single spender account
 */
Status.RepeatedSerialNumsInNFTAllowances = new Status(297);

/**
 * Fungible common token used in NFT allowances
 */
Status.FungibleTokenInNFTAllowances = new Status(298);

/**
 * Non fungible token used in fungible token allowances
 */
Status.NFTInFungibleTokenAllowances = new Status(299);

/**
 * An approval/adjustment transaction was submitted where the payer and owner account are
 * not the same. Currently only the owner is permitted to perform these operations.
 */
Status.PayerAndOwnerNotEqual = new Status(300);

/**
 * @type {string[]}
 */
const byteToHex = [];

for (let n = 0; n <= 0xff; n += 1) {
    byteToHex.push(n.toString(16).padStart(2, "0"));
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
function encode$1(data) {
    let string = "";

    for (const byte of data) {
        string += byteToHex[byte];
    }

    return string;
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
function decode$1(text) {
    const str = text.startsWith("0x") ? text.substring(2) : text;
    const result = str.match(/.{1,2}/gu);

    return new Uint8Array(
        (result == null ? [] : result).map((byte) => parseInt(byte, 16))
    );
}

class BadEntityIdException extends Error {
    /**
     * @param {Long} shard
     * @param {Long} realm
     * @param {Long} num
     * @param {string} presentChecksum
     * @param {string} expectedChecksum
     */
    constructor(shard, realm, num, presentChecksum, expectedChecksum) {
        super(
            `Entity ID ${shard.toString()}.${realm.toString()}.${num.toString()}-${presentChecksum} was incorrect.`
        );

        this.name = "BadEntityIdException";

        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.presentChecksum = presentChecksum;
        this.expectedChecksum = expectedChecksum;
    }
}

/**
 * @typedef {import("./Hbar.js").default} Hbar
 */

/**
 * Utility Error Messages
 */
const REQUIRE_NON_NULL_ERROR = "This value cannot be null | undefined.";
const REQUIRE_STRING_OR_UINT8ARRAY_ERROR =
    "This value must be a string or Uint8Array.";
const REQUIRE_ARRAY_ERROR = "The provided variable must be an Array.";

const FUNCTION_CONVERT_TO_BIGNUMBER_ERROR =
    "This value must be a String, Number, or BigNumber to be converted.";
const FUNCTION_CONVERT_TO_NUMBER_ERROR =
    "This value must be a String, Number, or BigNumber to be converted.";
const FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR =
    "Unable to parse given variable. Returns NaN.";

//Soft Checks

/**
 * Takes any param and returns false if null or undefined.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
function isNonNull(variable) {
    if (variable == null || variable == undefined) {
        return false;
    } else {
        return true;
    }
}

/**
 * Takes any param and returns true if param is not null and of type Uint8Array.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
function isUint8Array(variable) {
    return isNonNull(variable) && variable instanceof Uint8Array;
}

/**
 * Takes any param and returns true if param is not null and of type Number.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
function isNumber$1(variable) {
    return (
        isNonNull(variable) &&
        (typeof variable == "number" || variable instanceof Number)
    );
}

/**
 * Takes any param and returns true if param is not null and of type BigNumber.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
function isBigNumber(variable) {
    return isNonNull(variable) && variable instanceof BigNumber$1;
}

/**
 * Takes any param and returns true if param is not null and of type BigNumber.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
function isLong(variable) {
    return isNonNull(variable) && variable instanceof long;
}

/**
 * Takes any param and returns true if param is not null and of type string.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
function isString$1(variable) {
    return isNonNull(variable) && typeof variable == "string";
}

/**
 * Takes any param and returns true if param is not null and type string or Uint8Array.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
function isStringOrUint8Array(variable) {
    return (
        isNonNull(variable) && (isString$1(variable) || isUint8Array(variable))
    );
}

/**
 * Takes any param and returns false if null or undefined.
 *
 * @template {Long | Hbar} T
 * @param {T} variable
 * @returns {T}
 */
function requireNotNegative(variable) {
    if (variable.isNegative()) {
        throw new Error("negative value not allowed");
    }

    return variable;
}

/**
 * Takes any param and throws custom error if null or undefined.
 *
 * @param {any} variable
 * @returns {object}
 */
function requireNonNull(variable) {
    if (!isNonNull(variable)) {
        throw new Error(REQUIRE_NON_NULL_ERROR);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return variable;
    }
}

/**
 * Takes any param and throws custom error if null or undefined and not a string or Uint8Array.
 *
 * @param {any | null | undefined} variable
 * @returns {string | Uint8Array}
 */
function requireStringOrUint8Array(variable) {
    if (isStringOrUint8Array(requireNonNull(variable))) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return /** @type {string | Uint8Array} */ (variable);
    } else {
        throw new Error(REQUIRE_STRING_OR_UINT8ARRAY_ERROR);
    }
}

//Conversions

/**
 * Converts number or string to BigNumber.
 *
 * @param {any | null | undefined} variable
 * @returns {BigNumber}
 */
function convertToBigNumber(variable) {
    requireNonNull(variable);
    if (
        isBigNumber(variable) ||
        isString$1(variable) ||
        isNumber$1(variable) ||
        isLong(variable)
    ) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return new BigNumber$1(variable);
    }
    throw new Error(FUNCTION_CONVERT_TO_BIGNUMBER_ERROR);
}

/**
 * Converts Array of Numbers or Strings to Array of BigNumbers.
 *
 * @param {any | null | undefined} variable
 * @returns {Array<BigNumber>}
 */
function convertToBigNumberArray(variable) {
    if (variable instanceof Array) {
        return /** @type {Array<BigNumber>} */ (
            variable.map(convertToBigNumber)
        );
    } else {
        throw new Error(REQUIRE_ARRAY_ERROR);
    }
}

/**
 * @param {*} variable
 * @returns {number}
 */
function convertToNumber(variable) {
    requireNonNull(variable);
    if (
        isBigNumber(variable) ||
        isString$1(variable) ||
        isNumber$1(variable) ||
        isLong(variable)
    ) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        const num = parseInt(variable);
        if (isNaN(num)) {
            throw new Error(FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR);
        } else {
            return num;
        }
    } else {
        throw new Error(FUNCTION_CONVERT_TO_NUMBER_ERROR);
    }
}

/**
 * Creates a DataView on top of an Uint8Array that could be or not be pooled, ensuring that we don't get out of bounds.
 *
 * @param {Uint8Array} arr
 * @param {number | undefined} offset
 * @param {number | undefined} length
 * @returns {DataView}
 */
function safeView(arr, offset = 0, length = arr.byteLength) {
    if (!(Number.isInteger(offset) && offset >= 0))
        throw new Error("Invalid offset!");
    if (!(Number.isInteger(length) && length >= 0))
        throw new Error("Invalid length!");
    return new DataView(
        arr.buffer,
        arr.byteOffset + offset,
        Math.min(length, arr.byteLength - offset)
    );
}

/**
 * This regex supports entity IDs
 *  - as stand alone nubmers
 *  - as shard.realm.num
 *  - as shard.realm.hex
 *  - can optionally provide checksum for any of the above
 */
const ENTITY_ID_REGEX = /^(\d+)(?:\.(\d+)\.([a-fA-F0-9]+))?(?:-([a-z]{5}))?$/;

/**
 * @param {number | Long | IEntityId} props
 * @param {(number | null | Long)=} realmOrNull
 * @param {(number | null | Long)=} numOrNull
 * @returns {IEntityIdResult}
 */
function constructor(props, realmOrNull, numOrNull) {
    if (
        (realmOrNull == null && numOrNull != null) ||
        (realmOrNull != null && numOrNull == null)
    ) {
        throw new Error("invalid entity ID");
    }

    const [shard, realm, num] =
        typeof props === "number" || long.isLong(props)
            ? [
                  numOrNull != null
                      ? long.fromValue(/** @type {Long | number} */ (props))
                      : long.ZERO,
                  realmOrNull != null ? long.fromValue(realmOrNull) : long.ZERO,
                  numOrNull != null
                      ? long.fromValue(numOrNull)
                      : long.fromValue(/** @type {Long | number} */ (props)),
              ]
            : [
                  props.shard != null ? long.fromValue(props.shard) : long.ZERO,
                  props.realm != null ? long.fromValue(props.realm) : long.ZERO,
                  long.fromValue(props.num),
              ];

    if (shard.isNegative() || realm.isNegative() || num.isNegative()) {
        throw new Error("negative numbers are not allowed in IDs");
    }

    return {
        shard,
        realm,
        num,
    };
}

/**
 * @param {[Long, Long, Long]} a
 * @param {[Long, Long, Long]} b
 * @returns {number}
 */
function compare(a, b) {
    let comparison = a[0].compare(b[0]);
    if (comparison != 0) {
        return comparison;
    }

    comparison = a[1].compare(b[1]);
    if (comparison != 0) {
        return comparison;
    }

    return a[2].compare(b[2]);
}

/**
 * @typedef {object} ParseAddressResult
 * @property {number} status
 * @property {Long} [num1]
 * @property {Long} [num2]
 * @property {Long} [num3]
 * @property {string} [correctChecksum]
 * @property {string} [givenChecksum]
 * @property {string} [noChecksumFormat]
 * @property {string} [withChecksumFormat]
 */

/**
 * @param {string} text
 * @returns {IEntityIdParts}
 */
function fromStringSplitter(text) {
    const match = ENTITY_ID_REGEX.exec(text);

    if (match == null) {
        throw new Error(`failed to parse entity id: ${text}`);
    }

    if (match[2] == null && match[3] == null) {
        return {
            shard: "0",
            realm: "0",
            numOrHex: match[1],
            checksum: match[4],
        };
    } else {
        return {
            shard: match[1],
            realm: match[2],
            numOrHex: match[3],
            checksum: match[4],
        };
    }
}

/**
 * @param {string} text
 * @returns {IEntityIdResultWithChecksum}
 */
function fromString(text) {
    const result = fromStringSplitter(text);

    if (
        Number.isNaN(result.shard) ||
        Number.isNaN(result.realm) ||
        Number.isNaN(result.numOrHex)
    ) {
        throw new Error("invalid format for entity ID");
    }

    return {
        shard: result.shard != null ? long.fromString(result.shard) : long.ZERO,
        realm: result.realm != null ? long.fromString(result.realm) : long.ZERO,
        num: long.fromString(result.numOrHex),
        checksum: result.checksum,
    };
}

/**
 * @param {string} address
 * @returns {[Long, Long, Long]}
 */
function fromSolidityAddress(address) {
    const addr = address.startsWith("0x")
        ? decode$1(address.slice(2))
        : decode$1(address);

    if (addr.length !== 20) {
        throw new Error(`Invalid hex encoded solidity address length:
                expected length 40, got length ${address.length}`);
    }

    const shard = long.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);
    const realm = long.fromBytesBE(Array.from(addr.slice(4, 12)));
    const num = long.fromBytesBE(Array.from(addr.slice(12, 20)));

    return [shard, realm, num];
}

/**
 * @param {[Long,Long,Long] | [number,number,number]} address
 * @returns {string}
 */
function toSolidityAddress(address) {
    const buffer = new Uint8Array(20);
    const view = safeView(buffer);
    const [shard, realm, num] = address;

    view.setUint32(0, convertToNumber(shard));
    view.setUint32(8, convertToNumber(realm));
    view.setUint32(16, convertToNumber(num));

    return encode$1(buffer);
}

/**
 * Given an address like "0.0.123", return a checksum like "laujm"
 *
 * @param {string} ledgerId
 * @param {string} addr
 * @returns {string}
 */
function _checksum(ledgerId, addr) {
    let answer = "";
    let d = []; // Digits with 10 for ".", so if addr == "0.0.123" then d == [0, 10, 0, 10, 1, 2, 3]
    let s0 = 0; // Sum of even positions (mod 11)
    let s1 = 0; // Sum of odd positions (mod 11)
    let s = 0; // Weighted sum of all positions (mod p3)
    let sh = 0; // Hash of the ledger ID
    let c = 0; // The checksum, as a single number
    const p3 = 26 * 26 * 26; // 3 digits in base 26
    const p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26
    const ascii_a = "a".charCodeAt(0); // 97
    const m = 1000003; // Min prime greater than a million. Used for the final permutation.
    const w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.

    let id = ledgerId + "000000000000";
    let h = [];
    for (var i = 0; i < id.length; i += 2) {
        h.push(parseInt(id.substring(i, i + 2), 16));
    }
    for (let i = 0; i < addr.length; i++) {
        d.push(addr[i] === "." ? 10 : parseInt(addr[i], 10));
    }
    for (let i = 0; i < d.length; i++) {
        s = (w * s + d[i]) % p3;
        if (i % 2 === 0) {
            s0 = (s0 + d[i]) % 11;
        } else {
            s1 = (s1 + d[i]) % 11;
        }
    }
    for (let i = 0; i < h.length; i++) {
        sh = (w * sh + h[i]) % p5;
    }
    c = ((((addr.length % 5) * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;
    c = (c * m) % p5;

    for (let i = 0; i < 5; i++) {
        answer = String.fromCharCode(ascii_a + (c % 26)) + answer;
        c /= 26;
    }

    return answer;
}

/**
 * @param {Long} shard
 * @param {Long} realm
 * @param {Long} num
 * @param {string | null} checksum
 * @param {Client} client
 */
function validateChecksum(shard, realm, num, checksum, client) {
    if (client._network._ledgerId == null || checksum == null) {
        return;
    }

    const expectedChecksum = _checksum(
        client._network._ledgerId._toStringForChecksum(),
        `${shard.toString()}.${realm.toString()}.${num.toString()}`
    );

    if (checksum != expectedChecksum) {
        throw new BadEntityIdException(
            shard,
            realm,
            num,
            checksum,
            expectedChecksum
        );
    }
}

/**
 * @param {string} string
 * @param {Client} client
 * @returns {string}
 */
function toStringWithChecksum(string, client) {
    if (client._network._ledgerId == null) {
        throw new Error(
            "cannot calculate checksum with a client that does not contain a recognzied ledger ID"
        );
    }

    const checksum = _checksum(
        client._network._ledgerId._toStringForChecksum(),
        string
    );

    return `${string}-${checksum}`;
}

var lib = {};

var indexMinimal = {};

var minimal$1 = {};

var aspromise = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

var base64$1 = {};

(function (exports) {

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};
}(base64$1));

var eventemitter = EventEmitter$1;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter$1() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter$1.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter$1.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter$1.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

var float = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

var inquire_1 = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

var utf8$2 = {};

(function (exports) {

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};
}(utf8$2));

var pool_1 = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

var longbits = LongBits$2;

var util$5 = minimal$1;

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits$2(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits$2.zero = new LongBits$2(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits$2.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits$2.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits$2(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits$2.from = function from(value) {
    if (typeof value === "number")
        return LongBits$2.fromNumber(value);
    if (util$5.isString(value)) {
        /* istanbul ignore else */
        if (util$5.Long)
            value = util$5.Long.fromString(value);
        else
            return LongBits$2.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits$2(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits$2.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits$2.prototype.toLong = function toLong(unsigned) {
    return util$5.Long
        ? new util$5.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits$2.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits$2(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits$2.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits$2.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits$2.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits$2.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

(function (exports) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = aspromise;

// converts to / from base64 encoded strings
util.base64 = base64$1;

// base class of rpc.Service
util.EventEmitter = eventemitter;

// float handling accross browsers
util.float = float;

// requires modules optionally and hides the call from bundlers
util.inquire = inquire_1;

// converts to / from utf8 encoded strings
util.utf8 = utf8$2;

// provides a node-like buffer pool in the browser
util.pool = pool_1;

// utility to work with the low and high bits of a 64 bit value
util.LongBits = longbits;

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof commonjsGlobal !== "undefined"
                   && commonjsGlobal
                   && commonjsGlobal.process
                   && commonjsGlobal.process.versions
                   && commonjsGlobal.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && commonjsGlobal
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || commonjsGlobal; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};
}(minimal$1));

var writer = Writer$2;

var util$4      = minimal$1;

var BufferWriter$1; // cyclic

var LongBits$1  = util$4.LongBits,
    base64    = util$4.base64,
    utf8$1      = util$4.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop$1() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer$2() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop$1, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create$1 = function create() {
    return util$4.Buffer
        ? function create_buffer_setup() {
            return (Writer$2.create = function create_buffer() {
                return new BufferWriter$1();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer$2();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer$2.create = create$1();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer$2.alloc = function alloc(size) {
    return new util$4.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util$4.Array !== Array)
    Writer$2.alloc = util$4.pool(Writer$2.alloc, util$4.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer$2.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer$2.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits$1.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer$2.prototype.int64 = Writer$2.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer$2.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits$1.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.sfixed32 = Writer$2.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer$2.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits$1.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer$2.prototype.sfixed64 = Writer$2.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.float = function write_float(value) {
    return this._push(util$4.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.double = function write_double(value) {
    return this._push(util$4.float.writeDoubleLE, 8, value);
};

var writeBytes = util$4.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util$4.isString(value)) {
        var buf = Writer$2.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer$2.prototype.string = function write_string(value) {
    var len = utf8$1.length(value);
    return len
        ? this.uint32(len)._push(utf8$1.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer$2.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop$1, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer$2.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop$1, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer$2.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer$2.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer$2._configure = function(BufferWriter_) {
    BufferWriter$1 = BufferWriter_;
    Writer$2.create = create$1();
    BufferWriter$1._configure();
};

var writer_buffer = BufferWriter;

// extends Writer
var Writer$1 = writer;
(BufferWriter.prototype = Object.create(Writer$1.prototype)).constructor = BufferWriter;

var util$3 = minimal$1;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer$1.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util$3._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util$3.isString(value))
        value = util$3._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util$3.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util$3.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

var reader = Reader$2;

var util$2      = minimal$1;

var BufferReader$1; // cyclic

var LongBits  = util$2.LongBits,
    utf8      = util$2.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader$2(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader$2(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader$2(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util$2.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader$2.create = function create_buffer(buffer) {
                return util$2.Buffer.isBuffer(buffer)
                    ? new BufferReader$1(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader$2.create = create();

Reader$2.prototype._slice = util$2.Array.prototype.subarray || /* istanbul ignore next */ util$2.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader$2.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader$2.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader$2.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader$2.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader$2.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader$2.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader$2.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util$2.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader$2.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util$2.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader$2.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader$2.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader$2.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader$2.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader$2._configure = function(BufferReader_) {
    BufferReader$1 = BufferReader_;
    Reader$2.create = create();
    BufferReader$1._configure();

    var fn = util$2.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util$2.merge(Reader$2.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

var reader_buffer = BufferReader;

// extends Reader
var Reader$1 = reader;
(BufferReader.prototype = Object.create(Reader$1.prototype)).constructor = BufferReader;

var util$1 = minimal$1;

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader$1.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util$1.Buffer)
        BufferReader.prototype._slice = util$1.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

var rpc = {};

var service = Service;

var util = minimal$1;

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

(function (exports) {

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = service;
}(rpc));

var roots = {};

(function (exports) {
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = writer;
protobuf.BufferWriter = writer_buffer;
protobuf.Reader       = reader;
protobuf.BufferReader = reader_buffer;

// Utility
protobuf.util         = minimal$1;
protobuf.rpc          = rpc;
protobuf.roots        = roots;
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();
}(indexMinimal));

var minimal = indexMinimal;

var proto = {};

(function (exports) {
var $protobuf=_interopRequireWildcard(minimal);Object.defineProperty(exports,"__esModule",{value:!0}),exports.proto=exports.google=exports.default=void 0;function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var o=new WeakMap,t=new WeakMap;return (_getRequireWildcardCache=function(e){return e?t:o})(e)}function _interopRequireWildcard(e,o){if(!o&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=_getRequireWildcardCache(o);if(t&&t.has(e))return t.get(e);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var d in e)if("default"!=d&&Object.prototype.hasOwnProperty.call(e,d)){var i=r?Object.getOwnPropertyDescriptor(e,d):null;i&&(i.get||i.set)?Object.defineProperty(n,d,i):n[d]=e[d];}return n.default=e,t&&t.set(e,n),n}const $Reader=$protobuf.Reader,$Writer=$protobuf.Writer,$util=$protobuf.util,$root=$protobuf.roots.hashgraph||($protobuf.roots.hashgraph={});exports.default=$root;const proto=$root.proto=(()=>{const e={TokenUnitBalance:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(16).uint64(e.balance),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenUnitBalance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.balance=e.uint64();break;default:e.skipType(7&i);}return d},e}(),SingleAccountBalances:function(){function e(e){if(this.tokenUnitBalances=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.accountID=null,e.prototype.hbarBalance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.tokenUnitBalances=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.hbarBalance&&Object.hasOwnProperty.call(e,"hbarBalance")&&o.uint32(16).uint64(e.hbarBalance),null!=e.tokenUnitBalances&&e.tokenUnitBalances.length)for(var t=0;t<e.tokenUnitBalances.length;++t)$root.proto.TokenUnitBalance.encode(e.tokenUnitBalances[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SingleAccountBalances,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.hbarBalance=e.uint64();break;case 3:d.tokenUnitBalances&&d.tokenUnitBalances.length||(d.tokenUnitBalances=[]),d.tokenUnitBalances.push($root.proto.TokenUnitBalance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),AllAccountBalances:function(){function e(e){if(this.allAccounts=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.consensusTimestamp=null,e.prototype.allAccounts=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.consensusTimestamp&&Object.hasOwnProperty.call(e,"consensusTimestamp")&&$root.proto.Timestamp.encode(e.consensusTimestamp,o.uint32(10).fork()).ldelim(),null!=e.allAccounts&&e.allAccounts.length)for(var t=0;t<e.allAccounts.length;++t)$root.proto.SingleAccountBalances.encode(e.allAccounts[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AllAccountBalances,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.consensusTimestamp=$root.proto.Timestamp.decode(e,e.uint32());break;case 2:d.allAccounts&&d.allAccounts.length||(d.allAccounts=[]),d.allAccounts.push($root.proto.SingleAccountBalances.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),ShardID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ShardID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),RealmID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.RealmID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),AccountID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.accountNum=null,e.prototype.alias=null;let o;return Object.defineProperty(e.prototype,"account",{get:$util.oneOfGetter(o=["accountNum","alias"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.accountNum&&Object.hasOwnProperty.call(e,"accountNum")&&o.uint32(24).int64(e.accountNum),null!=e.alias&&Object.hasOwnProperty.call(e,"alias")&&o.uint32(34).bytes(e.alias),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AccountID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.accountNum=e.int64();break;case 4:d.alias=e.bytes();break;default:e.skipType(7&i);}return d},e}(),FileID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.fileNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.fileNum&&Object.hasOwnProperty.call(e,"fileNum")&&o.uint32(24).int64(e.fileNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.fileNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),ContractID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.contractNum=null,e.prototype.evmAddress=null;let o;return Object.defineProperty(e.prototype,"contract",{get:$util.oneOfGetter(o=["contractNum","evmAddress"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.contractNum&&Object.hasOwnProperty.call(e,"contractNum")&&o.uint32(24).int64(e.contractNum),null!=e.evmAddress&&Object.hasOwnProperty.call(e,"evmAddress")&&o.uint32(34).bytes(e.evmAddress),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.contractNum=e.int64();break;case 4:d.evmAddress=e.bytes();break;default:e.skipType(7&i);}return d},e}(),TransactionID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.transactionValidStart=null,e.prototype.accountID=null,e.prototype.scheduled=!1,e.prototype.nonce=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transactionValidStart&&Object.hasOwnProperty.call(e,"transactionValidStart")&&$root.proto.Timestamp.encode(e.transactionValidStart,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.scheduled&&Object.hasOwnProperty.call(e,"scheduled")&&o.uint32(24).bool(e.scheduled),null!=e.nonce&&Object.hasOwnProperty.call(e,"nonce")&&o.uint32(32).int32(e.nonce),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionValidStart=$root.proto.Timestamp.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.scheduled=e.bool();break;case 4:d.nonce=e.int32();break;default:e.skipType(7&i);}return d},e}(),AccountAmount:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.accountID=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.isApproval=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(16).sint64(e.amount),null!=e.isApproval&&Object.hasOwnProperty.call(e,"isApproval")&&o.uint32(24).bool(e.isApproval),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AccountAmount,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.amount=e.sint64();break;case 3:d.isApproval=e.bool();break;default:e.skipType(7&i);}return d},e}(),TransferList:function(){function e(e){if(this.accountAmounts=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.accountAmounts=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.accountAmounts&&e.accountAmounts.length)for(var t=0;t<e.accountAmounts.length;++t)$root.proto.AccountAmount.encode(e.accountAmounts[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransferList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountAmounts&&d.accountAmounts.length||(d.accountAmounts=[]),d.accountAmounts.push($root.proto.AccountAmount.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),NftTransfer:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.senderAccountID=null,e.prototype.receiverAccountID=null,e.prototype.serialNumber=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.isApproval=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.senderAccountID&&Object.hasOwnProperty.call(e,"senderAccountID")&&$root.proto.AccountID.encode(e.senderAccountID,o.uint32(10).fork()).ldelim(),null!=e.receiverAccountID&&Object.hasOwnProperty.call(e,"receiverAccountID")&&$root.proto.AccountID.encode(e.receiverAccountID,o.uint32(18).fork()).ldelim(),null!=e.serialNumber&&Object.hasOwnProperty.call(e,"serialNumber")&&o.uint32(24).int64(e.serialNumber),null!=e.isApproval&&Object.hasOwnProperty.call(e,"isApproval")&&o.uint32(32).bool(e.isApproval),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NftTransfer,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.senderAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.receiverAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.serialNumber=e.int64();break;case 4:d.isApproval=e.bool();break;default:e.skipType(7&i);}return d},e}(),TokenTransferList:function(){function e(e){if(this.transfers=[],this.nftTransfers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.prototype.transfers=$util.emptyArray,e.prototype.nftTransfers=$util.emptyArray,e.prototype.expectedDecimals=null,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.transfers&&e.transfers.length)for(var t=0;t<e.transfers.length;++t)$root.proto.AccountAmount.encode(e.transfers[t],o.uint32(18).fork()).ldelim();if(null!=e.nftTransfers&&e.nftTransfers.length)for(var t=0;t<e.nftTransfers.length;++t)$root.proto.NftTransfer.encode(e.nftTransfers[t],o.uint32(26).fork()).ldelim();return null!=e.expectedDecimals&&Object.hasOwnProperty.call(e,"expectedDecimals")&&$root.google.protobuf.UInt32Value.encode(e.expectedDecimals,o.uint32(34).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenTransferList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.transfers&&d.transfers.length||(d.transfers=[]),d.transfers.push($root.proto.AccountAmount.decode(e,e.uint32()));break;case 3:d.nftTransfers&&d.nftTransfers.length||(d.nftTransfers=[]),d.nftTransfers.push($root.proto.NftTransfer.decode(e,e.uint32()));break;case 4:d.expectedDecimals=$root.google.protobuf.UInt32Value.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),Fraction:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.numerator=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.denominator=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.numerator&&Object.hasOwnProperty.call(e,"numerator")&&o.uint32(8).int64(e.numerator),null!=e.denominator&&Object.hasOwnProperty.call(e,"denominator")&&o.uint32(16).int64(e.denominator),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Fraction,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.numerator=e.int64();break;case 2:d.denominator=e.int64();break;default:e.skipType(7&i);}return d},e}(),TopicID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.topicNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.topicNum&&Object.hasOwnProperty.call(e,"topicNum")&&o.uint32(24).int64(e.topicNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TopicID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.topicNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),TokenID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.tokenNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.tokenNum&&Object.hasOwnProperty.call(e,"tokenNum")&&o.uint32(24).int64(e.tokenNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.tokenNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),ScheduleID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.shardNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.realmNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.scheduleNum=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.shardNum&&Object.hasOwnProperty.call(e,"shardNum")&&o.uint32(8).int64(e.shardNum),null!=e.realmNum&&Object.hasOwnProperty.call(e,"realmNum")&&o.uint32(16).int64(e.realmNum),null!=e.scheduleNum&&Object.hasOwnProperty.call(e,"scheduleNum")&&o.uint32(24).int64(e.scheduleNum),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.shardNum=e.int64();break;case 2:d.realmNum=e.int64();break;case 3:d.scheduleNum=e.int64();break;default:e.skipType(7&i);}return d},e}(),TokenType:function(){const e={},o=Object.create(e);return o[e[0]="FUNGIBLE_COMMON"]=0,o[e[1]="NON_FUNGIBLE_UNIQUE"]=1,o}(),SubType:function(){const e={},o=Object.create(e);return o[e[0]="DEFAULT"]=0,o[e[1]="TOKEN_FUNGIBLE_COMMON"]=1,o[e[2]="TOKEN_NON_FUNGIBLE_UNIQUE"]=2,o[e[3]="TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES"]=3,o[e[4]="TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES"]=4,o}(),TokenSupplyType:function(){const e={},o=Object.create(e);return o[e[0]="INFINITE"]=0,o[e[1]="FINITE"]=1,o}(),TokenFreezeStatus:function(){const e={},o=Object.create(e);return o[e[0]="FreezeNotApplicable"]=0,o[e[1]="Frozen"]=1,o[e[2]="Unfrozen"]=2,o}(),TokenKycStatus:function(){const e={},o=Object.create(e);return o[e[0]="KycNotApplicable"]=0,o[e[1]="Granted"]=1,o[e[2]="Revoked"]=2,o}(),TokenPauseStatus:function(){const e={},o=Object.create(e);return o[e[0]="PauseNotApplicable"]=0,o[e[1]="Paused"]=1,o[e[2]="Unpaused"]=2,o}(),Key:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.contractID=null,e.prototype.ed25519=null,e.prototype.RSA_3072=null,e.prototype.ECDSA_384=null,e.prototype.thresholdKey=null,e.prototype.keyList=null,e.prototype.ECDSASecp256k1=null,e.prototype.delegatableContractId=null;let o;return Object.defineProperty(e.prototype,"key",{get:$util.oneOfGetter(o=["contractID","ed25519","RSA_3072","ECDSA_384","thresholdKey","keyList","ECDSASecp256k1","delegatableContractId"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.ed25519&&Object.hasOwnProperty.call(e,"ed25519")&&o.uint32(18).bytes(e.ed25519),null!=e.RSA_3072&&Object.hasOwnProperty.call(e,"RSA_3072")&&o.uint32(26).bytes(e.RSA_3072),null!=e.ECDSA_384&&Object.hasOwnProperty.call(e,"ECDSA_384")&&o.uint32(34).bytes(e.ECDSA_384),null!=e.thresholdKey&&Object.hasOwnProperty.call(e,"thresholdKey")&&$root.proto.ThresholdKey.encode(e.thresholdKey,o.uint32(42).fork()).ldelim(),null!=e.keyList&&Object.hasOwnProperty.call(e,"keyList")&&$root.proto.KeyList.encode(e.keyList,o.uint32(50).fork()).ldelim(),null!=e.ECDSASecp256k1&&Object.hasOwnProperty.call(e,"ECDSASecp256k1")&&o.uint32(58).bytes(e.ECDSASecp256k1),null!=e.delegatableContractId&&Object.hasOwnProperty.call(e,"delegatableContractId")&&$root.proto.ContractID.encode(e.delegatableContractId,o.uint32(66).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Key,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.ed25519=e.bytes();break;case 3:d.RSA_3072=e.bytes();break;case 4:d.ECDSA_384=e.bytes();break;case 5:d.thresholdKey=$root.proto.ThresholdKey.decode(e,e.uint32());break;case 6:d.keyList=$root.proto.KeyList.decode(e,e.uint32());break;case 7:d.ECDSASecp256k1=e.bytes();break;case 8:d.delegatableContractId=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ThresholdKey:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.threshold=0,e.prototype.keys=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.threshold&&Object.hasOwnProperty.call(e,"threshold")&&o.uint32(8).uint32(e.threshold),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThresholdKey,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.threshold=e.uint32();break;case 2:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),KeyList:function(){function e(e){if(this.keys=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.keys=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.keys&&e.keys.length)for(var t=0;t<e.keys.length;++t)$root.proto.Key.encode(e.keys[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.KeyList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.keys&&d.keys.length||(d.keys=[]),d.keys.push($root.proto.Key.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),Signature:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.contract=null,e.prototype.ed25519=null,e.prototype.RSA_3072=null,e.prototype.ECDSA_384=null,e.prototype.thresholdSignature=null,e.prototype.signatureList=null;let o;return Object.defineProperty(e.prototype,"signature",{get:$util.oneOfGetter(o=["contract","ed25519","RSA_3072","ECDSA_384","thresholdSignature","signatureList"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contract&&Object.hasOwnProperty.call(e,"contract")&&o.uint32(10).bytes(e.contract),null!=e.ed25519&&Object.hasOwnProperty.call(e,"ed25519")&&o.uint32(18).bytes(e.ed25519),null!=e.RSA_3072&&Object.hasOwnProperty.call(e,"RSA_3072")&&o.uint32(26).bytes(e.RSA_3072),null!=e.ECDSA_384&&Object.hasOwnProperty.call(e,"ECDSA_384")&&o.uint32(34).bytes(e.ECDSA_384),null!=e.thresholdSignature&&Object.hasOwnProperty.call(e,"thresholdSignature")&&$root.proto.ThresholdSignature.encode(e.thresholdSignature,o.uint32(42).fork()).ldelim(),null!=e.signatureList&&Object.hasOwnProperty.call(e,"signatureList")&&$root.proto.SignatureList.encode(e.signatureList,o.uint32(50).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Signature,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contract=e.bytes();break;case 2:d.ed25519=e.bytes();break;case 3:d.RSA_3072=e.bytes();break;case 4:d.ECDSA_384=e.bytes();break;case 5:d.thresholdSignature=$root.proto.ThresholdSignature.decode(e,e.uint32());break;case 6:d.signatureList=$root.proto.SignatureList.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ThresholdSignature:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.sigs=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.sigs&&Object.hasOwnProperty.call(e,"sigs")&&$root.proto.SignatureList.encode(e.sigs,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThresholdSignature,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.sigs=$root.proto.SignatureList.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),SignatureList:function(){function e(e){if(this.sigs=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.sigs=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.sigs&&e.sigs.length)for(var t=0;t<e.sigs.length;++t)$root.proto.Signature.encode(e.sigs[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SignatureList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.sigs&&d.sigs.length||(d.sigs=[]),d.sigs.push($root.proto.Signature.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),SignaturePair:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.pubKeyPrefix=$util.newBuffer([]),e.prototype.contract=null,e.prototype.ed25519=null,e.prototype.RSA_3072=null,e.prototype.ECDSA_384=null,e.prototype.ECDSASecp256k1=null;let o;return Object.defineProperty(e.prototype,"signature",{get:$util.oneOfGetter(o=["contract","ed25519","RSA_3072","ECDSA_384","ECDSASecp256k1"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.pubKeyPrefix&&Object.hasOwnProperty.call(e,"pubKeyPrefix")&&o.uint32(10).bytes(e.pubKeyPrefix),null!=e.contract&&Object.hasOwnProperty.call(e,"contract")&&o.uint32(18).bytes(e.contract),null!=e.ed25519&&Object.hasOwnProperty.call(e,"ed25519")&&o.uint32(26).bytes(e.ed25519),null!=e.RSA_3072&&Object.hasOwnProperty.call(e,"RSA_3072")&&o.uint32(34).bytes(e.RSA_3072),null!=e.ECDSA_384&&Object.hasOwnProperty.call(e,"ECDSA_384")&&o.uint32(42).bytes(e.ECDSA_384),null!=e.ECDSASecp256k1&&Object.hasOwnProperty.call(e,"ECDSASecp256k1")&&o.uint32(50).bytes(e.ECDSASecp256k1),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SignaturePair,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.pubKeyPrefix=e.bytes();break;case 2:d.contract=e.bytes();break;case 3:d.ed25519=e.bytes();break;case 4:d.RSA_3072=e.bytes();break;case 5:d.ECDSA_384=e.bytes();break;case 6:d.ECDSASecp256k1=e.bytes();break;default:e.skipType(7&i);}return d},e}(),SignatureMap:function(){function e(e){if(this.sigPair=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.sigPair=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.sigPair&&e.sigPair.length)for(var t=0;t<e.sigPair.length;++t)$root.proto.SignaturePair.encode(e.sigPair[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SignatureMap,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.sigPair&&d.sigPair.length||(d.sigPair=[]),d.sigPair.push($root.proto.SignaturePair.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),HederaFunctionality:function(){const e={},o=Object.create(e);return o[e[0]="NONE"]=0,o[e[1]="CryptoTransfer"]=1,o[e[2]="CryptoUpdate"]=2,o[e[3]="CryptoDelete"]=3,o[e[4]="CryptoAddLiveHash"]=4,o[e[5]="CryptoDeleteLiveHash"]=5,o[e[6]="ContractCall"]=6,o[e[7]="ContractCreate"]=7,o[e[8]="ContractUpdate"]=8,o[e[9]="FileCreate"]=9,o[e[10]="FileAppend"]=10,o[e[11]="FileUpdate"]=11,o[e[12]="FileDelete"]=12,o[e[13]="CryptoGetAccountBalance"]=13,o[e[14]="CryptoGetAccountRecords"]=14,o[e[15]="CryptoGetInfo"]=15,o[e[16]="ContractCallLocal"]=16,o[e[17]="ContractGetInfo"]=17,o[e[18]="ContractGetBytecode"]=18,o[e[19]="GetBySolidityID"]=19,o[e[20]="GetByKey"]=20,o[e[21]="CryptoGetLiveHash"]=21,o[e[22]="CryptoGetStakers"]=22,o[e[23]="FileGetContents"]=23,o[e[24]="FileGetInfo"]=24,o[e[25]="TransactionGetRecord"]=25,o[e[26]="ContractGetRecords"]=26,o[e[27]="CryptoCreate"]=27,o[e[28]="SystemDelete"]=28,o[e[29]="SystemUndelete"]=29,o[e[30]="ContractDelete"]=30,o[e[31]="Freeze"]=31,o[e[32]="CreateTransactionRecord"]=32,o[e[33]="CryptoAccountAutoRenew"]=33,o[e[34]="ContractAutoRenew"]=34,o[e[35]="GetVersionInfo"]=35,o[e[36]="TransactionGetReceipt"]=36,o[e[50]="ConsensusCreateTopic"]=50,o[e[51]="ConsensusUpdateTopic"]=51,o[e[52]="ConsensusDeleteTopic"]=52,o[e[53]="ConsensusGetTopicInfo"]=53,o[e[54]="ConsensusSubmitMessage"]=54,o[e[55]="UncheckedSubmit"]=55,o[e[56]="TokenCreate"]=56,o[e[58]="TokenGetInfo"]=58,o[e[59]="TokenFreezeAccount"]=59,o[e[60]="TokenUnfreezeAccount"]=60,o[e[61]="TokenGrantKycToAccount"]=61,o[e[62]="TokenRevokeKycFromAccount"]=62,o[e[63]="TokenDelete"]=63,o[e[64]="TokenUpdate"]=64,o[e[65]="TokenMint"]=65,o[e[66]="TokenBurn"]=66,o[e[67]="TokenAccountWipe"]=67,o[e[68]="TokenAssociateToAccount"]=68,o[e[69]="TokenDissociateFromAccount"]=69,o[e[70]="ScheduleCreate"]=70,o[e[71]="ScheduleDelete"]=71,o[e[72]="ScheduleSign"]=72,o[e[73]="ScheduleGetInfo"]=73,o[e[74]="TokenGetAccountNftInfos"]=74,o[e[75]="TokenGetNftInfo"]=75,o[e[76]="TokenGetNftInfos"]=76,o[e[77]="TokenFeeScheduleUpdate"]=77,o[e[78]="NetworkGetExecutionTime"]=78,o[e[79]="TokenPause"]=79,o[e[80]="TokenUnpause"]=80,o[e[81]="CryptoApproveAllowance"]=81,o[e[82]="CryptoAdjustAllowance"]=82,o}(),FeeComponents:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.min=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.max=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.constant=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.bpt=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.vpt=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.rbh=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.sbh=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.gas=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.tv=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.bpr=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.sbpr=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.min&&Object.hasOwnProperty.call(e,"min")&&o.uint32(8).int64(e.min),null!=e.max&&Object.hasOwnProperty.call(e,"max")&&o.uint32(16).int64(e.max),null!=e.constant&&Object.hasOwnProperty.call(e,"constant")&&o.uint32(24).int64(e.constant),null!=e.bpt&&Object.hasOwnProperty.call(e,"bpt")&&o.uint32(32).int64(e.bpt),null!=e.vpt&&Object.hasOwnProperty.call(e,"vpt")&&o.uint32(40).int64(e.vpt),null!=e.rbh&&Object.hasOwnProperty.call(e,"rbh")&&o.uint32(48).int64(e.rbh),null!=e.sbh&&Object.hasOwnProperty.call(e,"sbh")&&o.uint32(56).int64(e.sbh),null!=e.gas&&Object.hasOwnProperty.call(e,"gas")&&o.uint32(64).int64(e.gas),null!=e.tv&&Object.hasOwnProperty.call(e,"tv")&&o.uint32(72).int64(e.tv),null!=e.bpr&&Object.hasOwnProperty.call(e,"bpr")&&o.uint32(80).int64(e.bpr),null!=e.sbpr&&Object.hasOwnProperty.call(e,"sbpr")&&o.uint32(88).int64(e.sbpr),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FeeComponents,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.min=e.int64();break;case 2:d.max=e.int64();break;case 3:d.constant=e.int64();break;case 4:d.bpt=e.int64();break;case 5:d.vpt=e.int64();break;case 6:d.rbh=e.int64();break;case 7:d.sbh=e.int64();break;case 8:d.gas=e.int64();break;case 9:d.tv=e.int64();break;case 10:d.bpr=e.int64();break;case 11:d.sbpr=e.int64();break;default:e.skipType(7&i);}return d},e}(),TransactionFeeSchedule:function(){function e(e){if(this.fees=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.hederaFunctionality=0,e.prototype.feeData=null,e.prototype.fees=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.hederaFunctionality&&Object.hasOwnProperty.call(e,"hederaFunctionality")&&o.uint32(8).int32(e.hederaFunctionality),null!=e.feeData&&Object.hasOwnProperty.call(e,"feeData")&&$root.proto.FeeData.encode(e.feeData,o.uint32(18).fork()).ldelim(),null!=e.fees&&e.fees.length)for(var t=0;t<e.fees.length;++t)$root.proto.FeeData.encode(e.fees[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionFeeSchedule,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.hederaFunctionality=e.int32();break;case 2:d.feeData=$root.proto.FeeData.decode(e,e.uint32());break;case 3:d.fees&&d.fees.length||(d.fees=[]),d.fees.push($root.proto.FeeData.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),FeeData:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.nodedata=null,e.prototype.networkdata=null,e.prototype.servicedata=null,e.prototype.subType=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.nodedata&&Object.hasOwnProperty.call(e,"nodedata")&&$root.proto.FeeComponents.encode(e.nodedata,o.uint32(10).fork()).ldelim(),null!=e.networkdata&&Object.hasOwnProperty.call(e,"networkdata")&&$root.proto.FeeComponents.encode(e.networkdata,o.uint32(18).fork()).ldelim(),null!=e.servicedata&&Object.hasOwnProperty.call(e,"servicedata")&&$root.proto.FeeComponents.encode(e.servicedata,o.uint32(26).fork()).ldelim(),null!=e.subType&&Object.hasOwnProperty.call(e,"subType")&&o.uint32(32).int32(e.subType),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FeeData,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nodedata=$root.proto.FeeComponents.decode(e,e.uint32());break;case 2:d.networkdata=$root.proto.FeeComponents.decode(e,e.uint32());break;case 3:d.servicedata=$root.proto.FeeComponents.decode(e,e.uint32());break;case 4:d.subType=e.int32();break;default:e.skipType(7&i);}return d},e}(),FeeSchedule:function(){function e(e){if(this.transactionFeeSchedule=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.transactionFeeSchedule=$util.emptyArray,e.prototype.expiryTime=null,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.transactionFeeSchedule&&e.transactionFeeSchedule.length)for(var t=0;t<e.transactionFeeSchedule.length;++t)$root.proto.TransactionFeeSchedule.encode(e.transactionFeeSchedule[t],o.uint32(10).fork()).ldelim();return null!=e.expiryTime&&Object.hasOwnProperty.call(e,"expiryTime")&&$root.proto.TimestampSeconds.encode(e.expiryTime,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FeeSchedule,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionFeeSchedule&&d.transactionFeeSchedule.length||(d.transactionFeeSchedule=[]),d.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(e,e.uint32()));break;case 2:d.expiryTime=$root.proto.TimestampSeconds.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CurrentAndNextFeeSchedule:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.currentFeeSchedule=null,e.prototype.nextFeeSchedule=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.currentFeeSchedule&&Object.hasOwnProperty.call(e,"currentFeeSchedule")&&$root.proto.FeeSchedule.encode(e.currentFeeSchedule,o.uint32(10).fork()).ldelim(),null!=e.nextFeeSchedule&&Object.hasOwnProperty.call(e,"nextFeeSchedule")&&$root.proto.FeeSchedule.encode(e.nextFeeSchedule,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CurrentAndNextFeeSchedule,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.currentFeeSchedule=$root.proto.FeeSchedule.decode(e,e.uint32());break;case 2:d.nextFeeSchedule=$root.proto.FeeSchedule.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ServiceEndpoint:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.ipAddressV4=$util.newBuffer([]),e.prototype.port=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.ipAddressV4&&Object.hasOwnProperty.call(e,"ipAddressV4")&&o.uint32(10).bytes(e.ipAddressV4),null!=e.port&&Object.hasOwnProperty.call(e,"port")&&o.uint32(16).int32(e.port),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ServiceEndpoint,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.ipAddressV4=e.bytes();break;case 2:d.port=e.int32();break;default:e.skipType(7&i);}return d},e}(),NodeAddress:function(){function e(e){if(this.serviceEndpoint=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.ipAddress=$util.newBuffer([]),e.prototype.portno=0,e.prototype.memo=$util.newBuffer([]),e.prototype.RSA_PubKey="",e.prototype.nodeId=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.nodeAccountId=null,e.prototype.nodeCertHash=$util.newBuffer([]),e.prototype.serviceEndpoint=$util.emptyArray,e.prototype.description="",e.prototype.stake=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.ipAddress&&Object.hasOwnProperty.call(e,"ipAddress")&&o.uint32(10).bytes(e.ipAddress),null!=e.portno&&Object.hasOwnProperty.call(e,"portno")&&o.uint32(16).int32(e.portno),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(26).bytes(e.memo),null!=e.RSA_PubKey&&Object.hasOwnProperty.call(e,"RSA_PubKey")&&o.uint32(34).string(e.RSA_PubKey),null!=e.nodeId&&Object.hasOwnProperty.call(e,"nodeId")&&o.uint32(40).int64(e.nodeId),null!=e.nodeAccountId&&Object.hasOwnProperty.call(e,"nodeAccountId")&&$root.proto.AccountID.encode(e.nodeAccountId,o.uint32(50).fork()).ldelim(),null!=e.nodeCertHash&&Object.hasOwnProperty.call(e,"nodeCertHash")&&o.uint32(58).bytes(e.nodeCertHash),null!=e.serviceEndpoint&&e.serviceEndpoint.length)for(var t=0;t<e.serviceEndpoint.length;++t)$root.proto.ServiceEndpoint.encode(e.serviceEndpoint[t],o.uint32(66).fork()).ldelim();return null!=e.description&&Object.hasOwnProperty.call(e,"description")&&o.uint32(74).string(e.description),null!=e.stake&&Object.hasOwnProperty.call(e,"stake")&&o.uint32(80).int64(e.stake),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NodeAddress,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.ipAddress=e.bytes();break;case 2:d.portno=e.int32();break;case 3:d.memo=e.bytes();break;case 4:d.RSA_PubKey=e.string();break;case 5:d.nodeId=e.int64();break;case 6:d.nodeAccountId=$root.proto.AccountID.decode(e,e.uint32());break;case 7:d.nodeCertHash=e.bytes();break;case 8:d.serviceEndpoint&&d.serviceEndpoint.length||(d.serviceEndpoint=[]),d.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(e,e.uint32()));break;case 9:d.description=e.string();break;case 10:d.stake=e.int64();break;default:e.skipType(7&i);}return d},e}(),NodeAddressBook:function(){function e(e){if(this.nodeAddress=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.nodeAddress=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.nodeAddress&&e.nodeAddress.length)for(var t=0;t<e.nodeAddress.length;++t)$root.proto.NodeAddress.encode(e.nodeAddress[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NodeAddressBook,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nodeAddress&&d.nodeAddress.length||(d.nodeAddress=[]),d.nodeAddress.push($root.proto.NodeAddress.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),SemanticVersion:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.major=0,e.prototype.minor=0,e.prototype.patch=0,e.prototype.pre="",e.prototype.build="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.major&&Object.hasOwnProperty.call(e,"major")&&o.uint32(8).int32(e.major),null!=e.minor&&Object.hasOwnProperty.call(e,"minor")&&o.uint32(16).int32(e.minor),null!=e.patch&&Object.hasOwnProperty.call(e,"patch")&&o.uint32(24).int32(e.patch),null!=e.pre&&Object.hasOwnProperty.call(e,"pre")&&o.uint32(34).string(e.pre),null!=e.build&&Object.hasOwnProperty.call(e,"build")&&o.uint32(42).string(e.build),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SemanticVersion,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.major=e.int32();break;case 2:d.minor=e.int32();break;case 3:d.patch=e.int32();break;case 4:d.pre=e.string();break;case 5:d.build=e.string();break;default:e.skipType(7&i);}return d},e}(),Setting:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.name="",e.prototype.value="",e.prototype.data=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(10).string(e.name),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(18).string(e.value),null!=e.data&&Object.hasOwnProperty.call(e,"data")&&o.uint32(26).bytes(e.data),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Setting,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.name=e.string();break;case 2:d.value=e.string();break;case 3:d.data=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ServicesConfigurationList:function(){function e(e){if(this.nameValue=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.nameValue=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.nameValue&&e.nameValue.length)for(var t=0;t<e.nameValue.length;++t)$root.proto.Setting.encode(e.nameValue[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ServicesConfigurationList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nameValue&&d.nameValue.length||(d.nameValue=[]),d.nameValue.push($root.proto.Setting.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenRelationship:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.symbol="",e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.kycStatus=0,e.prototype.freezeStatus=0,e.prototype.decimals=0,e.prototype.automaticAssociation=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.symbol&&Object.hasOwnProperty.call(e,"symbol")&&o.uint32(18).string(e.symbol),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(24).uint64(e.balance),null!=e.kycStatus&&Object.hasOwnProperty.call(e,"kycStatus")&&o.uint32(32).int32(e.kycStatus),null!=e.freezeStatus&&Object.hasOwnProperty.call(e,"freezeStatus")&&o.uint32(40).int32(e.freezeStatus),null!=e.decimals&&Object.hasOwnProperty.call(e,"decimals")&&o.uint32(48).uint32(e.decimals),null!=e.automaticAssociation&&Object.hasOwnProperty.call(e,"automaticAssociation")&&o.uint32(56).bool(e.automaticAssociation),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenRelationship,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.symbol=e.string();break;case 3:d.balance=e.uint64();break;case 4:d.kycStatus=e.int32();break;case 5:d.freezeStatus=e.int32();break;case 6:d.decimals=e.uint32();break;case 7:d.automaticAssociation=e.bool();break;default:e.skipType(7&i);}return d},e}(),TokenBalance:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.decimals=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(16).uint64(e.balance),null!=e.decimals&&Object.hasOwnProperty.call(e,"decimals")&&o.uint32(24).uint32(e.decimals),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenBalance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.balance=e.uint64();break;case 3:d.decimals=e.uint32();break;default:e.skipType(7&i);}return d},e}(),TokenBalances:function(){function e(e){if(this.tokenBalances=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenBalances=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.tokenBalances&&e.tokenBalances.length)for(var t=0;t<e.tokenBalances.length;++t)$root.proto.TokenBalance.encode(e.tokenBalances[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenBalances,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenBalances&&d.tokenBalances.length||(d.tokenBalances=[]),d.tokenBalances.push($root.proto.TokenBalance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenAssociation:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.accountId=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.accountId&&Object.hasOwnProperty.call(e,"accountId")&&$root.proto.AccountID.encode(e.accountId,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenAssociation,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.accountId=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoAllowance:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.owner=null,e.prototype.spender=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.owner&&Object.hasOwnProperty.call(e,"owner")&&$root.proto.AccountID.encode(e.owner,o.uint32(10).fork()).ldelim(),null!=e.spender&&Object.hasOwnProperty.call(e,"spender")&&$root.proto.AccountID.encode(e.spender,o.uint32(18).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(24).int64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoAllowance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.owner=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.spender=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.amount=e.int64();break;default:e.skipType(7&i);}return d},e}(),NftAllowance:function(){function e(e){if(this.serialNumbers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.owner=null,e.prototype.spender=null,e.prototype.serialNumbers=$util.emptyArray,e.prototype.approvedForAll=null,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.owner&&Object.hasOwnProperty.call(e,"owner")&&$root.proto.AccountID.encode(e.owner,o.uint32(18).fork()).ldelim(),null!=e.spender&&Object.hasOwnProperty.call(e,"spender")&&$root.proto.AccountID.encode(e.spender,o.uint32(26).fork()).ldelim(),null!=e.serialNumbers&&e.serialNumbers.length){o.uint32(34).fork();for(var t=0;t<e.serialNumbers.length;++t)o.int64(e.serialNumbers[t]);o.ldelim();}return null!=e.approvedForAll&&Object.hasOwnProperty.call(e,"approvedForAll")&&$root.google.protobuf.BoolValue.encode(e.approvedForAll,o.uint32(42).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NftAllowance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.owner=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.spender=$root.proto.AccountID.decode(e,e.uint32());break;case 4:if(d.serialNumbers&&d.serialNumbers.length||(d.serialNumbers=[]),2==(7&i))for(var a=e.uint32()+e.pos;e.pos<a;)d.serialNumbers.push(e.int64());else d.serialNumbers.push(e.int64());break;case 5:d.approvedForAll=$root.google.protobuf.BoolValue.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenAllowance:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.owner=null,e.prototype.spender=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.owner&&Object.hasOwnProperty.call(e,"owner")&&$root.proto.AccountID.encode(e.owner,o.uint32(18).fork()).ldelim(),null!=e.spender&&Object.hasOwnProperty.call(e,"spender")&&$root.proto.AccountID.encode(e.spender,o.uint32(26).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(32).int64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenAllowance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.owner=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.spender=$root.proto.AccountID.decode(e,e.uint32());break;case 4:d.amount=e.int64();break;default:e.skipType(7&i);}return d},e}(),GrantedCryptoAllowance:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.spender=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.spender&&Object.hasOwnProperty.call(e,"spender")&&$root.proto.AccountID.encode(e.spender,o.uint32(10).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(16).int64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GrantedCryptoAllowance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.spender=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.amount=e.int64();break;default:e.skipType(7&i);}return d},e}(),GrantedNftAllowance:function(){function e(e){if(this.serialNumbers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.spender=null,e.prototype.serialNumbers=$util.emptyArray,e.prototype.approvedForAll=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.spender&&Object.hasOwnProperty.call(e,"spender")&&$root.proto.AccountID.encode(e.spender,o.uint32(18).fork()).ldelim(),null!=e.serialNumbers&&e.serialNumbers.length){o.uint32(26).fork();for(var t=0;t<e.serialNumbers.length;++t)o.int64(e.serialNumbers[t]);o.ldelim();}return null!=e.approvedForAll&&Object.hasOwnProperty.call(e,"approvedForAll")&&o.uint32(32).bool(e.approvedForAll),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GrantedNftAllowance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.spender=$root.proto.AccountID.decode(e,e.uint32());break;case 3:if(d.serialNumbers&&d.serialNumbers.length||(d.serialNumbers=[]),2==(7&i))for(var a=e.uint32()+e.pos;e.pos<a;)d.serialNumbers.push(e.int64());else d.serialNumbers.push(e.int64());break;case 4:d.approvedForAll=e.bool();break;default:e.skipType(7&i);}return d},e}(),GrantedTokenAllowance:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.spender=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.spender&&Object.hasOwnProperty.call(e,"spender")&&$root.proto.AccountID.encode(e.spender,o.uint32(18).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(24).int64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GrantedTokenAllowance,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.spender=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.amount=e.int64();break;default:e.skipType(7&i);}return d},e}(),Timestamp:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.nanos=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.seconds&&Object.hasOwnProperty.call(e,"seconds")&&o.uint32(8).int64(e.seconds),null!=e.nanos&&Object.hasOwnProperty.call(e,"nanos")&&o.uint32(16).int32(e.nanos),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Timestamp,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.seconds=e.int64();break;case 2:d.nanos=e.int32();break;default:e.skipType(7&i);}return d},e}(),TimestampSeconds:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.seconds&&Object.hasOwnProperty.call(e,"seconds")&&o.uint32(8).int64(e.seconds),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TimestampSeconds,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.seconds=e.int64();break;default:e.skipType(7&i);}return d},e}(),ConsensusCreateTopicTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.memo="",e.prototype.adminKey=null,e.prototype.submitKey=null,e.prototype.autoRenewPeriod=null,e.prototype.autoRenewAccount=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(10).string(e.memo),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(18).fork()).ldelim(),null!=e.submitKey&&Object.hasOwnProperty.call(e,"submitKey")&&$root.proto.Key.encode(e.submitKey,o.uint32(26).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(50).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(58).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusCreateTopicTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.memo=e.string();break;case 2:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 3:d.submitKey=$root.proto.Key.decode(e,e.uint32());break;case 6:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 7:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),Duration:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.seconds&&Object.hasOwnProperty.call(e,"seconds")&&o.uint32(8).int64(e.seconds),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Duration,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.seconds=e.int64();break;default:e.skipType(7&i);}return d},e}(),ConsensusDeleteTopicTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.topicID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusDeleteTopicTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ConsensusGetTopicInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.topicID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusGetTopicInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ConsensusGetTopicInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.topicID=null,e.prototype.topicInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(18).fork()).ldelim(),null!=e.topicInfo&&Object.hasOwnProperty.call(e,"topicInfo")&&$root.proto.ConsensusTopicInfo.encode(e.topicInfo,o.uint32(42).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusGetTopicInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 5:d.topicInfo=$root.proto.ConsensusTopicInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ResponseType:function(){const e={},o=Object.create(e);return o[e[0]="ANSWER_ONLY"]=0,o[e[1]="ANSWER_STATE_PROOF"]=1,o[e[2]="COST_ANSWER"]=2,o[e[3]="COST_ANSWER_STATE_PROOF"]=3,o}(),QueryHeader:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.payment=null,e.prototype.responseType=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.payment&&Object.hasOwnProperty.call(e,"payment")&&$root.proto.Transaction.encode(e.payment,o.uint32(10).fork()).ldelim(),null!=e.responseType&&Object.hasOwnProperty.call(e,"responseType")&&o.uint32(16).int32(e.responseType),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.QueryHeader,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.payment=$root.proto.Transaction.decode(e,e.uint32());break;case 2:d.responseType=e.int32();break;default:e.skipType(7&i);}return d},e}(),Transaction:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.body=null,e.prototype.sigs=null,e.prototype.sigMap=null,e.prototype.bodyBytes=$util.newBuffer([]),e.prototype.signedTransactionBytes=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.body&&Object.hasOwnProperty.call(e,"body")&&$root.proto.TransactionBody.encode(e.body,o.uint32(10).fork()).ldelim(),null!=e.sigs&&Object.hasOwnProperty.call(e,"sigs")&&$root.proto.SignatureList.encode(e.sigs,o.uint32(18).fork()).ldelim(),null!=e.sigMap&&Object.hasOwnProperty.call(e,"sigMap")&&$root.proto.SignatureMap.encode(e.sigMap,o.uint32(26).fork()).ldelim(),null!=e.bodyBytes&&Object.hasOwnProperty.call(e,"bodyBytes")&&o.uint32(34).bytes(e.bodyBytes),null!=e.signedTransactionBytes&&Object.hasOwnProperty.call(e,"signedTransactionBytes")&&o.uint32(42).bytes(e.signedTransactionBytes),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Transaction,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.body=$root.proto.TransactionBody.decode(e,e.uint32());break;case 2:d.sigs=$root.proto.SignatureList.decode(e,e.uint32());break;case 3:d.sigMap=$root.proto.SignatureMap.decode(e,e.uint32());break;case 4:d.bodyBytes=e.bytes();break;case 5:d.signedTransactionBytes=e.bytes();break;default:e.skipType(7&i);}return d},e}(),TransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.transactionID=null,e.prototype.nodeAccountID=null,e.prototype.transactionFee=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.transactionValidDuration=null,e.prototype.generateRecord=!1,e.prototype.memo="",e.prototype.contractCall=null,e.prototype.contractCreateInstance=null,e.prototype.contractUpdateInstance=null,e.prototype.contractDeleteInstance=null,e.prototype.cryptoAddLiveHash=null,e.prototype.cryptoAdjustAllowance=null,e.prototype.cryptoApproveAllowance=null,e.prototype.cryptoCreateAccount=null,e.prototype.cryptoDelete=null,e.prototype.cryptoDeleteLiveHash=null,e.prototype.cryptoTransfer=null,e.prototype.cryptoUpdateAccount=null,e.prototype.fileAppend=null,e.prototype.fileCreate=null,e.prototype.fileDelete=null,e.prototype.fileUpdate=null,e.prototype.systemDelete=null,e.prototype.systemUndelete=null,e.prototype.freeze=null,e.prototype.consensusCreateTopic=null,e.prototype.consensusUpdateTopic=null,e.prototype.consensusDeleteTopic=null,e.prototype.consensusSubmitMessage=null,e.prototype.uncheckedSubmit=null,e.prototype.tokenCreation=null,e.prototype.tokenFreeze=null,e.prototype.tokenUnfreeze=null,e.prototype.tokenGrantKyc=null,e.prototype.tokenRevokeKyc=null,e.prototype.tokenDeletion=null,e.prototype.tokenUpdate=null,e.prototype.tokenMint=null,e.prototype.tokenBurn=null,e.prototype.tokenWipe=null,e.prototype.tokenAssociate=null,e.prototype.tokenDissociate=null,e.prototype.tokenFeeScheduleUpdate=null,e.prototype.tokenPause=null,e.prototype.tokenUnpause=null,e.prototype.scheduleCreate=null,e.prototype.scheduleDelete=null,e.prototype.scheduleSign=null;let o;return Object.defineProperty(e.prototype,"data",{get:$util.oneOfGetter(o=["contractCall","contractCreateInstance","contractUpdateInstance","contractDeleteInstance","cryptoAddLiveHash","cryptoAdjustAllowance","cryptoApproveAllowance","cryptoCreateAccount","cryptoDelete","cryptoDeleteLiveHash","cryptoTransfer","cryptoUpdateAccount","fileAppend","fileCreate","fileDelete","fileUpdate","systemDelete","systemUndelete","freeze","consensusCreateTopic","consensusUpdateTopic","consensusDeleteTopic","consensusSubmitMessage","uncheckedSubmit","tokenCreation","tokenFreeze","tokenUnfreeze","tokenGrantKyc","tokenRevokeKyc","tokenDeletion","tokenUpdate","tokenMint","tokenBurn","tokenWipe","tokenAssociate","tokenDissociate","tokenFeeScheduleUpdate","tokenPause","tokenUnpause","scheduleCreate","scheduleDelete","scheduleSign"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(10).fork()).ldelim(),null!=e.nodeAccountID&&Object.hasOwnProperty.call(e,"nodeAccountID")&&$root.proto.AccountID.encode(e.nodeAccountID,o.uint32(18).fork()).ldelim(),null!=e.transactionFee&&Object.hasOwnProperty.call(e,"transactionFee")&&o.uint32(24).uint64(e.transactionFee),null!=e.transactionValidDuration&&Object.hasOwnProperty.call(e,"transactionValidDuration")&&$root.proto.Duration.encode(e.transactionValidDuration,o.uint32(34).fork()).ldelim(),null!=e.generateRecord&&Object.hasOwnProperty.call(e,"generateRecord")&&o.uint32(40).bool(e.generateRecord),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(50).string(e.memo),null!=e.contractCall&&Object.hasOwnProperty.call(e,"contractCall")&&$root.proto.ContractCallTransactionBody.encode(e.contractCall,o.uint32(58).fork()).ldelim(),null!=e.contractCreateInstance&&Object.hasOwnProperty.call(e,"contractCreateInstance")&&$root.proto.ContractCreateTransactionBody.encode(e.contractCreateInstance,o.uint32(66).fork()).ldelim(),null!=e.contractUpdateInstance&&Object.hasOwnProperty.call(e,"contractUpdateInstance")&&$root.proto.ContractUpdateTransactionBody.encode(e.contractUpdateInstance,o.uint32(74).fork()).ldelim(),null!=e.cryptoAddLiveHash&&Object.hasOwnProperty.call(e,"cryptoAddLiveHash")&&$root.proto.CryptoAddLiveHashTransactionBody.encode(e.cryptoAddLiveHash,o.uint32(82).fork()).ldelim(),null!=e.cryptoCreateAccount&&Object.hasOwnProperty.call(e,"cryptoCreateAccount")&&$root.proto.CryptoCreateTransactionBody.encode(e.cryptoCreateAccount,o.uint32(90).fork()).ldelim(),null!=e.cryptoDelete&&Object.hasOwnProperty.call(e,"cryptoDelete")&&$root.proto.CryptoDeleteTransactionBody.encode(e.cryptoDelete,o.uint32(98).fork()).ldelim(),null!=e.cryptoDeleteLiveHash&&Object.hasOwnProperty.call(e,"cryptoDeleteLiveHash")&&$root.proto.CryptoDeleteLiveHashTransactionBody.encode(e.cryptoDeleteLiveHash,o.uint32(106).fork()).ldelim(),null!=e.cryptoTransfer&&Object.hasOwnProperty.call(e,"cryptoTransfer")&&$root.proto.CryptoTransferTransactionBody.encode(e.cryptoTransfer,o.uint32(114).fork()).ldelim(),null!=e.cryptoUpdateAccount&&Object.hasOwnProperty.call(e,"cryptoUpdateAccount")&&$root.proto.CryptoUpdateTransactionBody.encode(e.cryptoUpdateAccount,o.uint32(122).fork()).ldelim(),null!=e.fileAppend&&Object.hasOwnProperty.call(e,"fileAppend")&&$root.proto.FileAppendTransactionBody.encode(e.fileAppend,o.uint32(130).fork()).ldelim(),null!=e.fileCreate&&Object.hasOwnProperty.call(e,"fileCreate")&&$root.proto.FileCreateTransactionBody.encode(e.fileCreate,o.uint32(138).fork()).ldelim(),null!=e.fileDelete&&Object.hasOwnProperty.call(e,"fileDelete")&&$root.proto.FileDeleteTransactionBody.encode(e.fileDelete,o.uint32(146).fork()).ldelim(),null!=e.fileUpdate&&Object.hasOwnProperty.call(e,"fileUpdate")&&$root.proto.FileUpdateTransactionBody.encode(e.fileUpdate,o.uint32(154).fork()).ldelim(),null!=e.systemDelete&&Object.hasOwnProperty.call(e,"systemDelete")&&$root.proto.SystemDeleteTransactionBody.encode(e.systemDelete,o.uint32(162).fork()).ldelim(),null!=e.systemUndelete&&Object.hasOwnProperty.call(e,"systemUndelete")&&$root.proto.SystemUndeleteTransactionBody.encode(e.systemUndelete,o.uint32(170).fork()).ldelim(),null!=e.contractDeleteInstance&&Object.hasOwnProperty.call(e,"contractDeleteInstance")&&$root.proto.ContractDeleteTransactionBody.encode(e.contractDeleteInstance,o.uint32(178).fork()).ldelim(),null!=e.freeze&&Object.hasOwnProperty.call(e,"freeze")&&$root.proto.FreezeTransactionBody.encode(e.freeze,o.uint32(186).fork()).ldelim(),null!=e.consensusCreateTopic&&Object.hasOwnProperty.call(e,"consensusCreateTopic")&&$root.proto.ConsensusCreateTopicTransactionBody.encode(e.consensusCreateTopic,o.uint32(194).fork()).ldelim(),null!=e.consensusUpdateTopic&&Object.hasOwnProperty.call(e,"consensusUpdateTopic")&&$root.proto.ConsensusUpdateTopicTransactionBody.encode(e.consensusUpdateTopic,o.uint32(202).fork()).ldelim(),null!=e.consensusDeleteTopic&&Object.hasOwnProperty.call(e,"consensusDeleteTopic")&&$root.proto.ConsensusDeleteTopicTransactionBody.encode(e.consensusDeleteTopic,o.uint32(210).fork()).ldelim(),null!=e.consensusSubmitMessage&&Object.hasOwnProperty.call(e,"consensusSubmitMessage")&&$root.proto.ConsensusSubmitMessageTransactionBody.encode(e.consensusSubmitMessage,o.uint32(218).fork()).ldelim(),null!=e.uncheckedSubmit&&Object.hasOwnProperty.call(e,"uncheckedSubmit")&&$root.proto.UncheckedSubmitBody.encode(e.uncheckedSubmit,o.uint32(226).fork()).ldelim(),null!=e.tokenCreation&&Object.hasOwnProperty.call(e,"tokenCreation")&&$root.proto.TokenCreateTransactionBody.encode(e.tokenCreation,o.uint32(234).fork()).ldelim(),null!=e.tokenFreeze&&Object.hasOwnProperty.call(e,"tokenFreeze")&&$root.proto.TokenFreezeAccountTransactionBody.encode(e.tokenFreeze,o.uint32(250).fork()).ldelim(),null!=e.tokenUnfreeze&&Object.hasOwnProperty.call(e,"tokenUnfreeze")&&$root.proto.TokenUnfreezeAccountTransactionBody.encode(e.tokenUnfreeze,o.uint32(258).fork()).ldelim(),null!=e.tokenGrantKyc&&Object.hasOwnProperty.call(e,"tokenGrantKyc")&&$root.proto.TokenGrantKycTransactionBody.encode(e.tokenGrantKyc,o.uint32(266).fork()).ldelim(),null!=e.tokenRevokeKyc&&Object.hasOwnProperty.call(e,"tokenRevokeKyc")&&$root.proto.TokenRevokeKycTransactionBody.encode(e.tokenRevokeKyc,o.uint32(274).fork()).ldelim(),null!=e.tokenDeletion&&Object.hasOwnProperty.call(e,"tokenDeletion")&&$root.proto.TokenDeleteTransactionBody.encode(e.tokenDeletion,o.uint32(282).fork()).ldelim(),null!=e.tokenUpdate&&Object.hasOwnProperty.call(e,"tokenUpdate")&&$root.proto.TokenUpdateTransactionBody.encode(e.tokenUpdate,o.uint32(290).fork()).ldelim(),null!=e.tokenMint&&Object.hasOwnProperty.call(e,"tokenMint")&&$root.proto.TokenMintTransactionBody.encode(e.tokenMint,o.uint32(298).fork()).ldelim(),null!=e.tokenBurn&&Object.hasOwnProperty.call(e,"tokenBurn")&&$root.proto.TokenBurnTransactionBody.encode(e.tokenBurn,o.uint32(306).fork()).ldelim(),null!=e.tokenWipe&&Object.hasOwnProperty.call(e,"tokenWipe")&&$root.proto.TokenWipeAccountTransactionBody.encode(e.tokenWipe,o.uint32(314).fork()).ldelim(),null!=e.tokenAssociate&&Object.hasOwnProperty.call(e,"tokenAssociate")&&$root.proto.TokenAssociateTransactionBody.encode(e.tokenAssociate,o.uint32(322).fork()).ldelim(),null!=e.tokenDissociate&&Object.hasOwnProperty.call(e,"tokenDissociate")&&$root.proto.TokenDissociateTransactionBody.encode(e.tokenDissociate,o.uint32(330).fork()).ldelim(),null!=e.scheduleCreate&&Object.hasOwnProperty.call(e,"scheduleCreate")&&$root.proto.ScheduleCreateTransactionBody.encode(e.scheduleCreate,o.uint32(338).fork()).ldelim(),null!=e.scheduleDelete&&Object.hasOwnProperty.call(e,"scheduleDelete")&&$root.proto.ScheduleDeleteTransactionBody.encode(e.scheduleDelete,o.uint32(346).fork()).ldelim(),null!=e.scheduleSign&&Object.hasOwnProperty.call(e,"scheduleSign")&&$root.proto.ScheduleSignTransactionBody.encode(e.scheduleSign,o.uint32(354).fork()).ldelim(),null!=e.tokenFeeScheduleUpdate&&Object.hasOwnProperty.call(e,"tokenFeeScheduleUpdate")&&$root.proto.TokenFeeScheduleUpdateTransactionBody.encode(e.tokenFeeScheduleUpdate,o.uint32(362).fork()).ldelim(),null!=e.tokenPause&&Object.hasOwnProperty.call(e,"tokenPause")&&$root.proto.TokenPauseTransactionBody.encode(e.tokenPause,o.uint32(370).fork()).ldelim(),null!=e.tokenUnpause&&Object.hasOwnProperty.call(e,"tokenUnpause")&&$root.proto.TokenUnpauseTransactionBody.encode(e.tokenUnpause,o.uint32(378).fork()).ldelim(),null!=e.cryptoAdjustAllowance&&Object.hasOwnProperty.call(e,"cryptoAdjustAllowance")&&$root.proto.CryptoAdjustAllowanceTransactionBody.encode(e.cryptoAdjustAllowance,o.uint32(386).fork()).ldelim(),null!=e.cryptoApproveAllowance&&Object.hasOwnProperty.call(e,"cryptoApproveAllowance")&&$root.proto.CryptoApproveAllowanceTransactionBody.encode(e.cryptoApproveAllowance,o.uint32(394).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 2:d.nodeAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.transactionFee=e.uint64();break;case 4:d.transactionValidDuration=$root.proto.Duration.decode(e,e.uint32());break;case 5:d.generateRecord=e.bool();break;case 6:d.memo=e.string();break;case 7:d.contractCall=$root.proto.ContractCallTransactionBody.decode(e,e.uint32());break;case 8:d.contractCreateInstance=$root.proto.ContractCreateTransactionBody.decode(e,e.uint32());break;case 9:d.contractUpdateInstance=$root.proto.ContractUpdateTransactionBody.decode(e,e.uint32());break;case 22:d.contractDeleteInstance=$root.proto.ContractDeleteTransactionBody.decode(e,e.uint32());break;case 10:d.cryptoAddLiveHash=$root.proto.CryptoAddLiveHashTransactionBody.decode(e,e.uint32());break;case 48:d.cryptoAdjustAllowance=$root.proto.CryptoAdjustAllowanceTransactionBody.decode(e,e.uint32());break;case 49:d.cryptoApproveAllowance=$root.proto.CryptoApproveAllowanceTransactionBody.decode(e,e.uint32());break;case 11:d.cryptoCreateAccount=$root.proto.CryptoCreateTransactionBody.decode(e,e.uint32());break;case 12:d.cryptoDelete=$root.proto.CryptoDeleteTransactionBody.decode(e,e.uint32());break;case 13:d.cryptoDeleteLiveHash=$root.proto.CryptoDeleteLiveHashTransactionBody.decode(e,e.uint32());break;case 14:d.cryptoTransfer=$root.proto.CryptoTransferTransactionBody.decode(e,e.uint32());break;case 15:d.cryptoUpdateAccount=$root.proto.CryptoUpdateTransactionBody.decode(e,e.uint32());break;case 16:d.fileAppend=$root.proto.FileAppendTransactionBody.decode(e,e.uint32());break;case 17:d.fileCreate=$root.proto.FileCreateTransactionBody.decode(e,e.uint32());break;case 18:d.fileDelete=$root.proto.FileDeleteTransactionBody.decode(e,e.uint32());break;case 19:d.fileUpdate=$root.proto.FileUpdateTransactionBody.decode(e,e.uint32());break;case 20:d.systemDelete=$root.proto.SystemDeleteTransactionBody.decode(e,e.uint32());break;case 21:d.systemUndelete=$root.proto.SystemUndeleteTransactionBody.decode(e,e.uint32());break;case 23:d.freeze=$root.proto.FreezeTransactionBody.decode(e,e.uint32());break;case 24:d.consensusCreateTopic=$root.proto.ConsensusCreateTopicTransactionBody.decode(e,e.uint32());break;case 25:d.consensusUpdateTopic=$root.proto.ConsensusUpdateTopicTransactionBody.decode(e,e.uint32());break;case 26:d.consensusDeleteTopic=$root.proto.ConsensusDeleteTopicTransactionBody.decode(e,e.uint32());break;case 27:d.consensusSubmitMessage=$root.proto.ConsensusSubmitMessageTransactionBody.decode(e,e.uint32());break;case 28:d.uncheckedSubmit=$root.proto.UncheckedSubmitBody.decode(e,e.uint32());break;case 29:d.tokenCreation=$root.proto.TokenCreateTransactionBody.decode(e,e.uint32());break;case 31:d.tokenFreeze=$root.proto.TokenFreezeAccountTransactionBody.decode(e,e.uint32());break;case 32:d.tokenUnfreeze=$root.proto.TokenUnfreezeAccountTransactionBody.decode(e,e.uint32());break;case 33:d.tokenGrantKyc=$root.proto.TokenGrantKycTransactionBody.decode(e,e.uint32());break;case 34:d.tokenRevokeKyc=$root.proto.TokenRevokeKycTransactionBody.decode(e,e.uint32());break;case 35:d.tokenDeletion=$root.proto.TokenDeleteTransactionBody.decode(e,e.uint32());break;case 36:d.tokenUpdate=$root.proto.TokenUpdateTransactionBody.decode(e,e.uint32());break;case 37:d.tokenMint=$root.proto.TokenMintTransactionBody.decode(e,e.uint32());break;case 38:d.tokenBurn=$root.proto.TokenBurnTransactionBody.decode(e,e.uint32());break;case 39:d.tokenWipe=$root.proto.TokenWipeAccountTransactionBody.decode(e,e.uint32());break;case 40:d.tokenAssociate=$root.proto.TokenAssociateTransactionBody.decode(e,e.uint32());break;case 41:d.tokenDissociate=$root.proto.TokenDissociateTransactionBody.decode(e,e.uint32());break;case 45:d.tokenFeeScheduleUpdate=$root.proto.TokenFeeScheduleUpdateTransactionBody.decode(e,e.uint32());break;case 46:d.tokenPause=$root.proto.TokenPauseTransactionBody.decode(e,e.uint32());break;case 47:d.tokenUnpause=$root.proto.TokenUnpauseTransactionBody.decode(e,e.uint32());break;case 42:d.scheduleCreate=$root.proto.ScheduleCreateTransactionBody.decode(e,e.uint32());break;case 43:d.scheduleDelete=$root.proto.ScheduleDeleteTransactionBody.decode(e,e.uint32());break;case 44:d.scheduleSign=$root.proto.ScheduleSignTransactionBody.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),SystemDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.fileID=null,e.prototype.contractID=null,e.prototype.expirationTime=null;let o;return Object.defineProperty(e.prototype,"id",{get:$util.oneOfGetter(o=["fileID","contractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.TimestampSeconds.encode(e.expirationTime,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SystemDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 3:d.expirationTime=$root.proto.TimestampSeconds.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),SystemUndeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.fileID=null,e.prototype.contractID=null;let o;return Object.defineProperty(e.prototype,"id",{get:$util.oneOfGetter(o=["fileID","contractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SystemUndeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FreezeTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.startHour=0,e.prototype.startMin=0,e.prototype.endHour=0,e.prototype.endMin=0,e.prototype.updateFile=null,e.prototype.fileHash=$util.newBuffer([]),e.prototype.startTime=null,e.prototype.freezeType=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.startHour&&Object.hasOwnProperty.call(e,"startHour")&&o.uint32(8).int32(e.startHour),null!=e.startMin&&Object.hasOwnProperty.call(e,"startMin")&&o.uint32(16).int32(e.startMin),null!=e.endHour&&Object.hasOwnProperty.call(e,"endHour")&&o.uint32(24).int32(e.endHour),null!=e.endMin&&Object.hasOwnProperty.call(e,"endMin")&&o.uint32(32).int32(e.endMin),null!=e.updateFile&&Object.hasOwnProperty.call(e,"updateFile")&&$root.proto.FileID.encode(e.updateFile,o.uint32(42).fork()).ldelim(),null!=e.fileHash&&Object.hasOwnProperty.call(e,"fileHash")&&o.uint32(50).bytes(e.fileHash),null!=e.startTime&&Object.hasOwnProperty.call(e,"startTime")&&$root.proto.Timestamp.encode(e.startTime,o.uint32(58).fork()).ldelim(),null!=e.freezeType&&Object.hasOwnProperty.call(e,"freezeType")&&o.uint32(64).int32(e.freezeType),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FreezeTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.startHour=e.int32();break;case 2:d.startMin=e.int32();break;case 3:d.endHour=e.int32();break;case 4:d.endMin=e.int32();break;case 5:d.updateFile=$root.proto.FileID.decode(e,e.uint32());break;case 6:d.fileHash=e.bytes();break;case 7:d.startTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 8:d.freezeType=e.int32();break;default:e.skipType(7&i);}return d},e}(),FreezeType:function(){const e={},o=Object.create(e);return o[e[0]="UNKNOWN_FREEZE_TYPE"]=0,o[e[1]="FREEZE_ONLY"]=1,o[e[2]="PREPARE_UPGRADE"]=2,o[e[3]="FREEZE_UPGRADE"]=3,o[e[4]="FREEZE_ABORT"]=4,o[e[5]="TELEMETRY_UPGRADE"]=5,o}(),ContractCallTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.contractID=null,e.prototype.gas=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.functionParameters=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.gas&&Object.hasOwnProperty.call(e,"gas")&&o.uint32(16).int64(e.gas),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(24).int64(e.amount),null!=e.functionParameters&&Object.hasOwnProperty.call(e,"functionParameters")&&o.uint32(34).bytes(e.functionParameters),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractCallTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.gas=e.int64();break;case 3:d.amount=e.int64();break;case 4:d.functionParameters=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ContractCreateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.fileID=null,e.prototype.adminKey=null,e.prototype.gas=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.initialBalance=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.proxyAccountID=null,e.prototype.autoRenewPeriod=null,e.prototype.constructorParameters=$util.newBuffer([]),e.prototype.shardID=null,e.prototype.realmID=null,e.prototype.newRealmAdminKey=null,e.prototype.memo="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(26).fork()).ldelim(),null!=e.gas&&Object.hasOwnProperty.call(e,"gas")&&o.uint32(32).int64(e.gas),null!=e.initialBalance&&Object.hasOwnProperty.call(e,"initialBalance")&&o.uint32(40).int64(e.initialBalance),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(50).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(66).fork()).ldelim(),null!=e.constructorParameters&&Object.hasOwnProperty.call(e,"constructorParameters")&&o.uint32(74).bytes(e.constructorParameters),null!=e.shardID&&Object.hasOwnProperty.call(e,"shardID")&&$root.proto.ShardID.encode(e.shardID,o.uint32(82).fork()).ldelim(),null!=e.realmID&&Object.hasOwnProperty.call(e,"realmID")&&$root.proto.RealmID.encode(e.realmID,o.uint32(90).fork()).ldelim(),null!=e.newRealmAdminKey&&Object.hasOwnProperty.call(e,"newRealmAdminKey")&&$root.proto.Key.encode(e.newRealmAdminKey,o.uint32(98).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(106).string(e.memo),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 3:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 4:d.gas=e.int64();break;case 5:d.initialBalance=e.int64();break;case 6:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 8:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 9:d.constructorParameters=e.bytes();break;case 10:d.shardID=$root.proto.ShardID.decode(e,e.uint32());break;case 11:d.realmID=$root.proto.RealmID.decode(e,e.uint32());break;case 12:d.newRealmAdminKey=$root.proto.Key.decode(e,e.uint32());break;case 13:d.memo=e.string();break;default:e.skipType(7&i);}return d},e}(),ContractUpdateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.contractID=null,e.prototype.expirationTime=null,e.prototype.adminKey=null,e.prototype.proxyAccountID=null,e.prototype.autoRenewPeriod=null,e.prototype.fileID=null,e.prototype.memo=null,e.prototype.memoWrapper=null;let o;return Object.defineProperty(e.prototype,"memoField",{get:$util.oneOfGetter(o=["memo","memoWrapper"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(18).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(26).fork()).ldelim(),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(50).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(58).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(66).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(74).string(e.memo),null!=e.memoWrapper&&Object.hasOwnProperty.call(e,"memoWrapper")&&$root.google.protobuf.StringValue.encode(e.memoWrapper,o.uint32(82).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractUpdateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 6:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 7:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 8:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 9:d.memo=e.string();break;case 10:d.memoWrapper=$root.google.protobuf.StringValue.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),LiveHash:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.accountId=null,e.prototype.hash=$util.newBuffer([]),e.prototype.keys=null,e.prototype.duration=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountId&&Object.hasOwnProperty.call(e,"accountId")&&$root.proto.AccountID.encode(e.accountId,o.uint32(10).fork()).ldelim(),null!=e.hash&&Object.hasOwnProperty.call(e,"hash")&&o.uint32(18).bytes(e.hash),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(26).fork()).ldelim(),null!=e.duration&&Object.hasOwnProperty.call(e,"duration")&&$root.proto.Duration.encode(e.duration,o.uint32(42).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.LiveHash,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountId=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.hash=e.bytes();break;case 3:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;case 5:d.duration=$root.proto.Duration.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoAddLiveHashTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.liveHash=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.liveHash&&Object.hasOwnProperty.call(e,"liveHash")&&$root.proto.LiveHash.encode(e.liveHash,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoAddLiveHashTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 3:d.liveHash=$root.proto.LiveHash.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoCreateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.key=null,e.prototype.initialBalance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.proxyAccountID=null,e.prototype.sendRecordThreshold=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.receiveRecordThreshold=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.receiverSigRequired=!1,e.prototype.autoRenewPeriod=null,e.prototype.shardID=null,e.prototype.realmID=null,e.prototype.newRealmAdminKey=null,e.prototype.memo="",e.prototype.maxAutomaticTokenAssociations=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&$root.proto.Key.encode(e.key,o.uint32(10).fork()).ldelim(),null!=e.initialBalance&&Object.hasOwnProperty.call(e,"initialBalance")&&o.uint32(16).uint64(e.initialBalance),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(26).fork()).ldelim(),null!=e.sendRecordThreshold&&Object.hasOwnProperty.call(e,"sendRecordThreshold")&&o.uint32(48).uint64(e.sendRecordThreshold),null!=e.receiveRecordThreshold&&Object.hasOwnProperty.call(e,"receiveRecordThreshold")&&o.uint32(56).uint64(e.receiveRecordThreshold),null!=e.receiverSigRequired&&Object.hasOwnProperty.call(e,"receiverSigRequired")&&o.uint32(64).bool(e.receiverSigRequired),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(74).fork()).ldelim(),null!=e.shardID&&Object.hasOwnProperty.call(e,"shardID")&&$root.proto.ShardID.encode(e.shardID,o.uint32(82).fork()).ldelim(),null!=e.realmID&&Object.hasOwnProperty.call(e,"realmID")&&$root.proto.RealmID.encode(e.realmID,o.uint32(90).fork()).ldelim(),null!=e.newRealmAdminKey&&Object.hasOwnProperty.call(e,"newRealmAdminKey")&&$root.proto.Key.encode(e.newRealmAdminKey,o.uint32(98).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(106).string(e.memo),null!=e.maxAutomaticTokenAssociations&&Object.hasOwnProperty.call(e,"maxAutomaticTokenAssociations")&&o.uint32(112).int32(e.maxAutomaticTokenAssociations),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.key=$root.proto.Key.decode(e,e.uint32());break;case 2:d.initialBalance=e.uint64();break;case 3:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 6:d.sendRecordThreshold=e.uint64();break;case 7:d.receiveRecordThreshold=e.uint64();break;case 8:d.receiverSigRequired=e.bool();break;case 9:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 10:d.shardID=$root.proto.ShardID.decode(e,e.uint32());break;case 11:d.realmID=$root.proto.RealmID.decode(e,e.uint32());break;case 12:d.newRealmAdminKey=$root.proto.Key.decode(e,e.uint32());break;case 13:d.memo=e.string();break;case 14:d.maxAutomaticTokenAssociations=e.int32();break;default:e.skipType(7&i);}return d},e}(),CryptoDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.transferAccountID=null,e.prototype.deleteAccountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transferAccountID&&Object.hasOwnProperty.call(e,"transferAccountID")&&$root.proto.AccountID.encode(e.transferAccountID,o.uint32(10).fork()).ldelim(),null!=e.deleteAccountID&&Object.hasOwnProperty.call(e,"deleteAccountID")&&$root.proto.AccountID.encode(e.deleteAccountID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transferAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.deleteAccountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoDeleteLiveHashTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.accountOfLiveHash=null,e.prototype.liveHashToDelete=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountOfLiveHash&&Object.hasOwnProperty.call(e,"accountOfLiveHash")&&$root.proto.AccountID.encode(e.accountOfLiveHash,o.uint32(10).fork()).ldelim(),null!=e.liveHashToDelete&&Object.hasOwnProperty.call(e,"liveHashToDelete")&&o.uint32(18).bytes(e.liveHashToDelete),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoDeleteLiveHashTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountOfLiveHash=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.liveHashToDelete=e.bytes();break;default:e.skipType(7&i);}return d},e}(),CryptoTransferTransactionBody:function(){function e(e){if(this.tokenTransfers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.transfers=null,e.prototype.tokenTransfers=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.transfers&&Object.hasOwnProperty.call(e,"transfers")&&$root.proto.TransferList.encode(e.transfers,o.uint32(10).fork()).ldelim(),null!=e.tokenTransfers&&e.tokenTransfers.length)for(var t=0;t<e.tokenTransfers.length;++t)$root.proto.TokenTransferList.encode(e.tokenTransfers[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoTransferTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transfers=$root.proto.TransferList.decode(e,e.uint32());break;case 2:d.tokenTransfers&&d.tokenTransfers.length||(d.tokenTransfers=[]),d.tokenTransfers.push($root.proto.TokenTransferList.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),CryptoUpdateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.accountIDToUpdate=null,e.prototype.key=null,e.prototype.proxyAccountID=null,e.prototype.proxyFraction=0,e.prototype.sendRecordThreshold=null,e.prototype.sendRecordThresholdWrapper=null,e.prototype.receiveRecordThreshold=null,e.prototype.receiveRecordThresholdWrapper=null,e.prototype.autoRenewPeriod=null,e.prototype.expirationTime=null,e.prototype.receiverSigRequired=null,e.prototype.receiverSigRequiredWrapper=null,e.prototype.memo=null,e.prototype.maxAutomaticTokenAssociations=null;let o;return Object.defineProperty(e.prototype,"sendRecordThresholdField",{get:$util.oneOfGetter(o=["sendRecordThreshold","sendRecordThresholdWrapper"]),set:$util.oneOfSetter(o)}),Object.defineProperty(e.prototype,"receiveRecordThresholdField",{get:$util.oneOfGetter(o=["receiveRecordThreshold","receiveRecordThresholdWrapper"]),set:$util.oneOfSetter(o)}),Object.defineProperty(e.prototype,"receiverSigRequiredField",{get:$util.oneOfGetter(o=["receiverSigRequired","receiverSigRequiredWrapper"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountIDToUpdate&&Object.hasOwnProperty.call(e,"accountIDToUpdate")&&$root.proto.AccountID.encode(e.accountIDToUpdate,o.uint32(18).fork()).ldelim(),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&$root.proto.Key.encode(e.key,o.uint32(26).fork()).ldelim(),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(34).fork()).ldelim(),null!=e.proxyFraction&&Object.hasOwnProperty.call(e,"proxyFraction")&&o.uint32(40).int32(e.proxyFraction),null!=e.sendRecordThreshold&&Object.hasOwnProperty.call(e,"sendRecordThreshold")&&o.uint32(48).uint64(e.sendRecordThreshold),null!=e.receiveRecordThreshold&&Object.hasOwnProperty.call(e,"receiveRecordThreshold")&&o.uint32(56).uint64(e.receiveRecordThreshold),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(66).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(74).fork()).ldelim(),null!=e.receiverSigRequired&&Object.hasOwnProperty.call(e,"receiverSigRequired")&&o.uint32(80).bool(e.receiverSigRequired),null!=e.sendRecordThresholdWrapper&&Object.hasOwnProperty.call(e,"sendRecordThresholdWrapper")&&$root.google.protobuf.UInt64Value.encode(e.sendRecordThresholdWrapper,o.uint32(90).fork()).ldelim(),null!=e.receiveRecordThresholdWrapper&&Object.hasOwnProperty.call(e,"receiveRecordThresholdWrapper")&&$root.google.protobuf.UInt64Value.encode(e.receiveRecordThresholdWrapper,o.uint32(98).fork()).ldelim(),null!=e.receiverSigRequiredWrapper&&Object.hasOwnProperty.call(e,"receiverSigRequiredWrapper")&&$root.google.protobuf.BoolValue.encode(e.receiverSigRequiredWrapper,o.uint32(106).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&$root.google.protobuf.StringValue.encode(e.memo,o.uint32(114).fork()).ldelim(),null!=e.maxAutomaticTokenAssociations&&Object.hasOwnProperty.call(e,"maxAutomaticTokenAssociations")&&$root.google.protobuf.Int32Value.encode(e.maxAutomaticTokenAssociations,o.uint32(122).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoUpdateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.accountIDToUpdate=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.key=$root.proto.Key.decode(e,e.uint32());break;case 4:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 5:d.proxyFraction=e.int32();break;case 6:d.sendRecordThreshold=e.uint64();break;case 11:d.sendRecordThresholdWrapper=$root.google.protobuf.UInt64Value.decode(e,e.uint32());break;case 7:d.receiveRecordThreshold=e.uint64();break;case 12:d.receiveRecordThresholdWrapper=$root.google.protobuf.UInt64Value.decode(e,e.uint32());break;case 8:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 9:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 10:d.receiverSigRequired=e.bool();break;case 13:d.receiverSigRequiredWrapper=$root.google.protobuf.BoolValue.decode(e,e.uint32());break;case 14:d.memo=$root.google.protobuf.StringValue.decode(e,e.uint32());break;case 15:d.maxAutomaticTokenAssociations=$root.google.protobuf.Int32Value.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoApproveAllowanceTransactionBody:function(){function e(e){if(this.cryptoAllowances=[],this.nftAllowances=[],this.tokenAllowances=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.cryptoAllowances=$util.emptyArray,e.prototype.nftAllowances=$util.emptyArray,e.prototype.tokenAllowances=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.cryptoAllowances&&e.cryptoAllowances.length)for(var t=0;t<e.cryptoAllowances.length;++t)$root.proto.CryptoAllowance.encode(e.cryptoAllowances[t],o.uint32(10).fork()).ldelim();if(null!=e.nftAllowances&&e.nftAllowances.length)for(var t=0;t<e.nftAllowances.length;++t)$root.proto.NftAllowance.encode(e.nftAllowances[t],o.uint32(18).fork()).ldelim();if(null!=e.tokenAllowances&&e.tokenAllowances.length)for(var t=0;t<e.tokenAllowances.length;++t)$root.proto.TokenAllowance.encode(e.tokenAllowances[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoApproveAllowanceTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.cryptoAllowances&&d.cryptoAllowances.length||(d.cryptoAllowances=[]),d.cryptoAllowances.push($root.proto.CryptoAllowance.decode(e,e.uint32()));break;case 2:d.nftAllowances&&d.nftAllowances.length||(d.nftAllowances=[]),d.nftAllowances.push($root.proto.NftAllowance.decode(e,e.uint32()));break;case 3:d.tokenAllowances&&d.tokenAllowances.length||(d.tokenAllowances=[]),d.tokenAllowances.push($root.proto.TokenAllowance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),CryptoAdjustAllowanceTransactionBody:function(){function e(e){if(this.cryptoAllowances=[],this.nftAllowances=[],this.tokenAllowances=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.cryptoAllowances=$util.emptyArray,e.prototype.nftAllowances=$util.emptyArray,e.prototype.tokenAllowances=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.cryptoAllowances&&e.cryptoAllowances.length)for(var t=0;t<e.cryptoAllowances.length;++t)$root.proto.CryptoAllowance.encode(e.cryptoAllowances[t],o.uint32(10).fork()).ldelim();if(null!=e.nftAllowances&&e.nftAllowances.length)for(var t=0;t<e.nftAllowances.length;++t)$root.proto.NftAllowance.encode(e.nftAllowances[t],o.uint32(18).fork()).ldelim();if(null!=e.tokenAllowances&&e.tokenAllowances.length)for(var t=0;t<e.tokenAllowances.length;++t)$root.proto.TokenAllowance.encode(e.tokenAllowances[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoAdjustAllowanceTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.cryptoAllowances&&d.cryptoAllowances.length||(d.cryptoAllowances=[]),d.cryptoAllowances.push($root.proto.CryptoAllowance.decode(e,e.uint32()));break;case 2:d.nftAllowances&&d.nftAllowances.length||(d.nftAllowances=[]),d.nftAllowances.push($root.proto.NftAllowance.decode(e,e.uint32()));break;case 3:d.tokenAllowances&&d.tokenAllowances.length||(d.tokenAllowances=[]),d.tokenAllowances.push($root.proto.TokenAllowance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),FileAppendTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.fileID=null,e.prototype.contents=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(18).fork()).ldelim(),null!=e.contents&&Object.hasOwnProperty.call(e,"contents")&&o.uint32(34).bytes(e.contents),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileAppendTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 4:d.contents=e.bytes();break;default:e.skipType(7&i);}return d},e}(),FileCreateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.expirationTime=null,e.prototype.keys=null,e.prototype.contents=$util.newBuffer([]),e.prototype.shardID=null,e.prototype.realmID=null,e.prototype.newRealmAdminKey=null,e.prototype.memo="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(18).fork()).ldelim(),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(26).fork()).ldelim(),null!=e.contents&&Object.hasOwnProperty.call(e,"contents")&&o.uint32(34).bytes(e.contents),null!=e.shardID&&Object.hasOwnProperty.call(e,"shardID")&&$root.proto.ShardID.encode(e.shardID,o.uint32(42).fork()).ldelim(),null!=e.realmID&&Object.hasOwnProperty.call(e,"realmID")&&$root.proto.RealmID.encode(e.realmID,o.uint32(50).fork()).ldelim(),null!=e.newRealmAdminKey&&Object.hasOwnProperty.call(e,"newRealmAdminKey")&&$root.proto.Key.encode(e.newRealmAdminKey,o.uint32(58).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(66).string(e.memo),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;case 4:d.contents=e.bytes();break;case 5:d.shardID=$root.proto.ShardID.decode(e,e.uint32());break;case 6:d.realmID=$root.proto.RealmID.decode(e,e.uint32());break;case 7:d.newRealmAdminKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.memo=e.string();break;default:e.skipType(7&i);}return d},e}(),FileDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.fileID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 2:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FileUpdateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.fileID=null,e.prototype.expirationTime=null,e.prototype.keys=null,e.prototype.contents=$util.newBuffer([]),e.prototype.memo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(18).fork()).ldelim(),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(26).fork()).ldelim(),null!=e.contents&&Object.hasOwnProperty.call(e,"contents")&&o.uint32(34).bytes(e.contents),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&$root.google.protobuf.StringValue.encode(e.memo,o.uint32(42).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileUpdateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;case 4:d.contents=e.bytes();break;case 5:d.memo=$root.google.protobuf.StringValue.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.contractID=null,e.prototype.transferAccountID=null,e.prototype.transferContractID=null;let o;return Object.defineProperty(e.prototype,"obtainers",{get:$util.oneOfGetter(o=["transferAccountID","transferContractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.transferAccountID&&Object.hasOwnProperty.call(e,"transferAccountID")&&$root.proto.AccountID.encode(e.transferAccountID,o.uint32(18).fork()).ldelim(),null!=e.transferContractID&&Object.hasOwnProperty.call(e,"transferContractID")&&$root.proto.ContractID.encode(e.transferContractID,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.transferAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.transferContractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ConsensusUpdateTopicTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.topicID=null,e.prototype.memo=null,e.prototype.expirationTime=null,e.prototype.adminKey=null,e.prototype.submitKey=null,e.prototype.autoRenewPeriod=null,e.prototype.autoRenewAccount=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(10).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&$root.google.protobuf.StringValue.encode(e.memo,o.uint32(18).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(34).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(50).fork()).ldelim(),null!=e.submitKey&&Object.hasOwnProperty.call(e,"submitKey")&&$root.proto.Key.encode(e.submitKey,o.uint32(58).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(66).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(74).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusUpdateTopicTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 2:d.memo=$root.google.protobuf.StringValue.decode(e,e.uint32());break;case 4:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 6:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 7:d.submitKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 9:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ConsensusMessageChunkInfo:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.initialTransactionID=null,e.prototype.total=0,e.prototype.number=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.initialTransactionID&&Object.hasOwnProperty.call(e,"initialTransactionID")&&$root.proto.TransactionID.encode(e.initialTransactionID,o.uint32(10).fork()).ldelim(),null!=e.total&&Object.hasOwnProperty.call(e,"total")&&o.uint32(16).int32(e.total),null!=e.number&&Object.hasOwnProperty.call(e,"number")&&o.uint32(24).int32(e.number),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusMessageChunkInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.initialTransactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 2:d.total=e.int32();break;case 3:d.number=e.int32();break;default:e.skipType(7&i);}return d},e}(),ConsensusSubmitMessageTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.topicID=null,e.prototype.message=$util.newBuffer([]),e.prototype.chunkInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(10).fork()).ldelim(),null!=e.message&&Object.hasOwnProperty.call(e,"message")&&o.uint32(18).bytes(e.message),null!=e.chunkInfo&&Object.hasOwnProperty.call(e,"chunkInfo")&&$root.proto.ConsensusMessageChunkInfo.encode(e.chunkInfo,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusSubmitMessageTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 2:d.message=e.bytes();break;case 3:d.chunkInfo=$root.proto.ConsensusMessageChunkInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),UncheckedSubmitBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.transactionBytes=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transactionBytes&&Object.hasOwnProperty.call(e,"transactionBytes")&&o.uint32(10).bytes(e.transactionBytes),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.UncheckedSubmitBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionBytes=e.bytes();break;default:e.skipType(7&i);}return d},e}(),TokenCreateTransactionBody:function(){function e(e){if(this.customFees=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.name="",e.prototype.symbol="",e.prototype.decimals=0,e.prototype.initialSupply=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.treasury=null,e.prototype.adminKey=null,e.prototype.kycKey=null,e.prototype.freezeKey=null,e.prototype.wipeKey=null,e.prototype.supplyKey=null,e.prototype.freezeDefault=!1,e.prototype.expiry=null,e.prototype.autoRenewAccount=null,e.prototype.autoRenewPeriod=null,e.prototype.memo="",e.prototype.tokenType=0,e.prototype.supplyType=0,e.prototype.maxSupply=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.feeScheduleKey=null,e.prototype.customFees=$util.emptyArray,e.prototype.pauseKey=null,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(10).string(e.name),null!=e.symbol&&Object.hasOwnProperty.call(e,"symbol")&&o.uint32(18).string(e.symbol),null!=e.decimals&&Object.hasOwnProperty.call(e,"decimals")&&o.uint32(24).uint32(e.decimals),null!=e.initialSupply&&Object.hasOwnProperty.call(e,"initialSupply")&&o.uint32(32).uint64(e.initialSupply),null!=e.treasury&&Object.hasOwnProperty.call(e,"treasury")&&$root.proto.AccountID.encode(e.treasury,o.uint32(42).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(50).fork()).ldelim(),null!=e.kycKey&&Object.hasOwnProperty.call(e,"kycKey")&&$root.proto.Key.encode(e.kycKey,o.uint32(58).fork()).ldelim(),null!=e.freezeKey&&Object.hasOwnProperty.call(e,"freezeKey")&&$root.proto.Key.encode(e.freezeKey,o.uint32(66).fork()).ldelim(),null!=e.wipeKey&&Object.hasOwnProperty.call(e,"wipeKey")&&$root.proto.Key.encode(e.wipeKey,o.uint32(74).fork()).ldelim(),null!=e.supplyKey&&Object.hasOwnProperty.call(e,"supplyKey")&&$root.proto.Key.encode(e.supplyKey,o.uint32(82).fork()).ldelim(),null!=e.freezeDefault&&Object.hasOwnProperty.call(e,"freezeDefault")&&o.uint32(88).bool(e.freezeDefault),null!=e.expiry&&Object.hasOwnProperty.call(e,"expiry")&&$root.proto.Timestamp.encode(e.expiry,o.uint32(106).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(114).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(122).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(130).string(e.memo),null!=e.tokenType&&Object.hasOwnProperty.call(e,"tokenType")&&o.uint32(136).int32(e.tokenType),null!=e.supplyType&&Object.hasOwnProperty.call(e,"supplyType")&&o.uint32(144).int32(e.supplyType),null!=e.maxSupply&&Object.hasOwnProperty.call(e,"maxSupply")&&o.uint32(152).int64(e.maxSupply),null!=e.feeScheduleKey&&Object.hasOwnProperty.call(e,"feeScheduleKey")&&$root.proto.Key.encode(e.feeScheduleKey,o.uint32(162).fork()).ldelim(),null!=e.customFees&&e.customFees.length)for(var t=0;t<e.customFees.length;++t)$root.proto.CustomFee.encode(e.customFees[t],o.uint32(170).fork()).ldelim();return null!=e.pauseKey&&Object.hasOwnProperty.call(e,"pauseKey")&&$root.proto.Key.encode(e.pauseKey,o.uint32(178).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.name=e.string();break;case 2:d.symbol=e.string();break;case 3:d.decimals=e.uint32();break;case 4:d.initialSupply=e.uint64();break;case 5:d.treasury=$root.proto.AccountID.decode(e,e.uint32());break;case 6:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 7:d.kycKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.freezeKey=$root.proto.Key.decode(e,e.uint32());break;case 9:d.wipeKey=$root.proto.Key.decode(e,e.uint32());break;case 10:d.supplyKey=$root.proto.Key.decode(e,e.uint32());break;case 11:d.freezeDefault=e.bool();break;case 13:d.expiry=$root.proto.Timestamp.decode(e,e.uint32());break;case 14:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;case 15:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 16:d.memo=e.string();break;case 17:d.tokenType=e.int32();break;case 18:d.supplyType=e.int32();break;case 19:d.maxSupply=e.int64();break;case 20:d.feeScheduleKey=$root.proto.Key.decode(e,e.uint32());break;case 21:d.customFees&&d.customFees.length||(d.customFees=[]),d.customFees.push($root.proto.CustomFee.decode(e,e.uint32()));break;case 22:d.pauseKey=$root.proto.Key.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FractionalFee:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.fractionalAmount=null,e.prototype.minimumAmount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.maximumAmount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.netOfTransfers=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fractionalAmount&&Object.hasOwnProperty.call(e,"fractionalAmount")&&$root.proto.Fraction.encode(e.fractionalAmount,o.uint32(10).fork()).ldelim(),null!=e.minimumAmount&&Object.hasOwnProperty.call(e,"minimumAmount")&&o.uint32(16).int64(e.minimumAmount),null!=e.maximumAmount&&Object.hasOwnProperty.call(e,"maximumAmount")&&o.uint32(24).int64(e.maximumAmount),null!=e.netOfTransfers&&Object.hasOwnProperty.call(e,"netOfTransfers")&&o.uint32(32).bool(e.netOfTransfers),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FractionalFee,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fractionalAmount=$root.proto.Fraction.decode(e,e.uint32());break;case 2:d.minimumAmount=e.int64();break;case 3:d.maximumAmount=e.int64();break;case 4:d.netOfTransfers=e.bool();break;default:e.skipType(7&i);}return d},e}(),FixedFee:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.denominatingTokenId=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(8).int64(e.amount),null!=e.denominatingTokenId&&Object.hasOwnProperty.call(e,"denominatingTokenId")&&$root.proto.TokenID.encode(e.denominatingTokenId,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FixedFee,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.amount=e.int64();break;case 2:d.denominatingTokenId=$root.proto.TokenID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),RoyaltyFee:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.exchangeValueFraction=null,e.prototype.fallbackFee=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.exchangeValueFraction&&Object.hasOwnProperty.call(e,"exchangeValueFraction")&&$root.proto.Fraction.encode(e.exchangeValueFraction,o.uint32(10).fork()).ldelim(),null!=e.fallbackFee&&Object.hasOwnProperty.call(e,"fallbackFee")&&$root.proto.FixedFee.encode(e.fallbackFee,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.RoyaltyFee,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.exchangeValueFraction=$root.proto.Fraction.decode(e,e.uint32());break;case 2:d.fallbackFee=$root.proto.FixedFee.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CustomFee:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.fixedFee=null,e.prototype.fractionalFee=null,e.prototype.royaltyFee=null,e.prototype.feeCollectorAccountId=null;let o;return Object.defineProperty(e.prototype,"fee",{get:$util.oneOfGetter(o=["fixedFee","fractionalFee","royaltyFee"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fixedFee&&Object.hasOwnProperty.call(e,"fixedFee")&&$root.proto.FixedFee.encode(e.fixedFee,o.uint32(10).fork()).ldelim(),null!=e.fractionalFee&&Object.hasOwnProperty.call(e,"fractionalFee")&&$root.proto.FractionalFee.encode(e.fractionalFee,o.uint32(18).fork()).ldelim(),null!=e.feeCollectorAccountId&&Object.hasOwnProperty.call(e,"feeCollectorAccountId")&&$root.proto.AccountID.encode(e.feeCollectorAccountId,o.uint32(26).fork()).ldelim(),null!=e.royaltyFee&&Object.hasOwnProperty.call(e,"royaltyFee")&&$root.proto.RoyaltyFee.encode(e.royaltyFee,o.uint32(34).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CustomFee,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fixedFee=$root.proto.FixedFee.decode(e,e.uint32());break;case 2:d.fractionalFee=$root.proto.FractionalFee.decode(e,e.uint32());break;case 4:d.royaltyFee=$root.proto.RoyaltyFee.decode(e,e.uint32());break;case 3:d.feeCollectorAccountId=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),AssessedCustomFee:function(){function e(e){if(this.effectivePayerAccountId=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.tokenId=null,e.prototype.feeCollectorAccountId=null,e.prototype.effectivePayerAccountId=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(8).int64(e.amount),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(18).fork()).ldelim(),null!=e.feeCollectorAccountId&&Object.hasOwnProperty.call(e,"feeCollectorAccountId")&&$root.proto.AccountID.encode(e.feeCollectorAccountId,o.uint32(26).fork()).ldelim(),null!=e.effectivePayerAccountId&&e.effectivePayerAccountId.length)for(var t=0;t<e.effectivePayerAccountId.length;++t)$root.proto.AccountID.encode(e.effectivePayerAccountId[t],o.uint32(34).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AssessedCustomFee,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.amount=e.int64();break;case 2:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 3:d.feeCollectorAccountId=$root.proto.AccountID.decode(e,e.uint32());break;case 4:d.effectivePayerAccountId&&d.effectivePayerAccountId.length||(d.effectivePayerAccountId=[]),d.effectivePayerAccountId.push($root.proto.AccountID.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenFreezeAccountTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.prototype.account=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenFreezeAccountTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenUnfreezeAccountTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.prototype.account=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenUnfreezeAccountTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenGrantKycTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.prototype.account=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGrantKycTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenRevokeKycTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.prototype.account=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenRevokeKycTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenUpdateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.prototype.symbol="",e.prototype.name="",e.prototype.treasury=null,e.prototype.adminKey=null,e.prototype.kycKey=null,e.prototype.freezeKey=null,e.prototype.wipeKey=null,e.prototype.supplyKey=null,e.prototype.autoRenewAccount=null,e.prototype.autoRenewPeriod=null,e.prototype.expiry=null,e.prototype.memo=null,e.prototype.feeScheduleKey=null,e.prototype.pauseKey=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.symbol&&Object.hasOwnProperty.call(e,"symbol")&&o.uint32(18).string(e.symbol),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(26).string(e.name),null!=e.treasury&&Object.hasOwnProperty.call(e,"treasury")&&$root.proto.AccountID.encode(e.treasury,o.uint32(34).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(42).fork()).ldelim(),null!=e.kycKey&&Object.hasOwnProperty.call(e,"kycKey")&&$root.proto.Key.encode(e.kycKey,o.uint32(50).fork()).ldelim(),null!=e.freezeKey&&Object.hasOwnProperty.call(e,"freezeKey")&&$root.proto.Key.encode(e.freezeKey,o.uint32(58).fork()).ldelim(),null!=e.wipeKey&&Object.hasOwnProperty.call(e,"wipeKey")&&$root.proto.Key.encode(e.wipeKey,o.uint32(66).fork()).ldelim(),null!=e.supplyKey&&Object.hasOwnProperty.call(e,"supplyKey")&&$root.proto.Key.encode(e.supplyKey,o.uint32(74).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(82).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(90).fork()).ldelim(),null!=e.expiry&&Object.hasOwnProperty.call(e,"expiry")&&$root.proto.Timestamp.encode(e.expiry,o.uint32(98).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&$root.google.protobuf.StringValue.encode(e.memo,o.uint32(106).fork()).ldelim(),null!=e.feeScheduleKey&&Object.hasOwnProperty.call(e,"feeScheduleKey")&&$root.proto.Key.encode(e.feeScheduleKey,o.uint32(114).fork()).ldelim(),null!=e.pauseKey&&Object.hasOwnProperty.call(e,"pauseKey")&&$root.proto.Key.encode(e.pauseKey,o.uint32(122).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenUpdateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.symbol=e.string();break;case 3:d.name=e.string();break;case 4:d.treasury=$root.proto.AccountID.decode(e,e.uint32());break;case 5:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 6:d.kycKey=$root.proto.Key.decode(e,e.uint32());break;case 7:d.freezeKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.wipeKey=$root.proto.Key.decode(e,e.uint32());break;case 9:d.supplyKey=$root.proto.Key.decode(e,e.uint32());break;case 10:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;case 11:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 12:d.expiry=$root.proto.Timestamp.decode(e,e.uint32());break;case 13:d.memo=$root.google.protobuf.StringValue.decode(e,e.uint32());break;case 14:d.feeScheduleKey=$root.proto.Key.decode(e,e.uint32());break;case 15:d.pauseKey=$root.proto.Key.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenMintTransactionBody:function(){function e(e){if(this.metadata=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.metadata=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(16).uint64(e.amount),null!=e.metadata&&e.metadata.length)for(var t=0;t<e.metadata.length;++t)o.uint32(26).bytes(e.metadata[t]);return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenMintTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.amount=e.uint64();break;case 3:d.metadata&&d.metadata.length||(d.metadata=[]),d.metadata.push(e.bytes());break;default:e.skipType(7&i);}return d},e}(),TokenBurnTransactionBody:function(){function e(e){if(this.serialNumbers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.serialNumbers=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(16).uint64(e.amount),null!=e.serialNumbers&&e.serialNumbers.length){o.uint32(26).fork();for(var t=0;t<e.serialNumbers.length;++t)o.int64(e.serialNumbers[t]);o.ldelim();}return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenBurnTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.amount=e.uint64();break;case 3:if(d.serialNumbers&&d.serialNumbers.length||(d.serialNumbers=[]),2==(7&i))for(var a=e.uint32()+e.pos;e.pos<a;)d.serialNumbers.push(e.int64());else d.serialNumbers.push(e.int64());break;default:e.skipType(7&i);}return d},e}(),TokenWipeAccountTransactionBody:function(){function e(e){if(this.serialNumbers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.prototype.account=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.serialNumbers=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(18).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(24).uint64(e.amount),null!=e.serialNumbers&&e.serialNumbers.length){o.uint32(34).fork();for(var t=0;t<e.serialNumbers.length;++t)o.int64(e.serialNumbers[t]);o.ldelim();}return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenWipeAccountTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.account=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.amount=e.uint64();break;case 4:if(d.serialNumbers&&d.serialNumbers.length||(d.serialNumbers=[]),2==(7&i))for(var a=e.uint32()+e.pos;e.pos<a;)d.serialNumbers.push(e.int64());else d.serialNumbers.push(e.int64());break;default:e.skipType(7&i);}return d},e}(),TokenAssociateTransactionBody:function(){function e(e){if(this.tokens=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.account=null,e.prototype.tokens=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(10).fork()).ldelim(),null!=e.tokens&&e.tokens.length)for(var t=0;t<e.tokens.length;++t)$root.proto.TokenID.encode(e.tokens[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenAssociateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.account=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.tokens&&d.tokens.length||(d.tokens=[]),d.tokens.push($root.proto.TokenID.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenDissociateTransactionBody:function(){function e(e){if(this.tokens=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.account=null,e.prototype.tokens=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.account&&Object.hasOwnProperty.call(e,"account")&&$root.proto.AccountID.encode(e.account,o.uint32(10).fork()).ldelim(),null!=e.tokens&&e.tokens.length)for(var t=0;t<e.tokens.length;++t)$root.proto.TokenID.encode(e.tokens[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenDissociateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.account=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.tokens&&d.tokens.length||(d.tokens=[]),d.tokens.push($root.proto.TokenID.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenFeeScheduleUpdateTransactionBody:function(){function e(e){if(this.customFees=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.customFees=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.customFees&&e.customFees.length)for(var t=0;t<e.customFees.length;++t)$root.proto.CustomFee.encode(e.customFees[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenFeeScheduleUpdateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.customFees&&d.customFees.length||(d.customFees=[]),d.customFees.push($root.proto.CustomFee.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenPauseTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenPauseTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenUnpauseTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.token=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenUnpauseTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.token=$root.proto.TokenID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ScheduleCreateTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.scheduledTransactionBody=null,e.prototype.memo="",e.prototype.adminKey=null,e.prototype.payerAccountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.scheduledTransactionBody&&Object.hasOwnProperty.call(e,"scheduledTransactionBody")&&$root.proto.SchedulableTransactionBody.encode(e.scheduledTransactionBody,o.uint32(10).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(18).string(e.memo),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(26).fork()).ldelim(),null!=e.payerAccountID&&Object.hasOwnProperty.call(e,"payerAccountID")&&$root.proto.AccountID.encode(e.payerAccountID,o.uint32(34).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleCreateTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.scheduledTransactionBody=$root.proto.SchedulableTransactionBody.decode(e,e.uint32());break;case 2:d.memo=e.string();break;case 3:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 4:d.payerAccountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),SchedulableTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.transactionFee=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.memo="",e.prototype.contractCall=null,e.prototype.contractCreateInstance=null,e.prototype.contractUpdateInstance=null,e.prototype.contractDeleteInstance=null,e.prototype.cryptoAdjustAllowance=null,e.prototype.cryptoApproveAllowance=null,e.prototype.cryptoCreateAccount=null,e.prototype.cryptoDelete=null,e.prototype.cryptoTransfer=null,e.prototype.cryptoUpdateAccount=null,e.prototype.fileAppend=null,e.prototype.fileCreate=null,e.prototype.fileDelete=null,e.prototype.fileUpdate=null,e.prototype.systemDelete=null,e.prototype.systemUndelete=null,e.prototype.freeze=null,e.prototype.consensusCreateTopic=null,e.prototype.consensusUpdateTopic=null,e.prototype.consensusDeleteTopic=null,e.prototype.consensusSubmitMessage=null,e.prototype.tokenCreation=null,e.prototype.tokenFreeze=null,e.prototype.tokenUnfreeze=null,e.prototype.tokenGrantKyc=null,e.prototype.tokenRevokeKyc=null,e.prototype.tokenDeletion=null,e.prototype.tokenUpdate=null,e.prototype.tokenMint=null,e.prototype.tokenBurn=null,e.prototype.tokenWipe=null,e.prototype.tokenAssociate=null,e.prototype.tokenDissociate=null,e.prototype.tokenFeeScheduleUpdate=null,e.prototype.tokenPause=null,e.prototype.tokenUnpause=null,e.prototype.scheduleDelete=null;let o;return Object.defineProperty(e.prototype,"data",{get:$util.oneOfGetter(o=["contractCall","contractCreateInstance","contractUpdateInstance","contractDeleteInstance","cryptoAdjustAllowance","cryptoApproveAllowance","cryptoCreateAccount","cryptoDelete","cryptoTransfer","cryptoUpdateAccount","fileAppend","fileCreate","fileDelete","fileUpdate","systemDelete","systemUndelete","freeze","consensusCreateTopic","consensusUpdateTopic","consensusDeleteTopic","consensusSubmitMessage","tokenCreation","tokenFreeze","tokenUnfreeze","tokenGrantKyc","tokenRevokeKyc","tokenDeletion","tokenUpdate","tokenMint","tokenBurn","tokenWipe","tokenAssociate","tokenDissociate","tokenFeeScheduleUpdate","tokenPause","tokenUnpause","scheduleDelete"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.transactionFee&&Object.hasOwnProperty.call(e,"transactionFee")&&o.uint32(8).uint64(e.transactionFee),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(18).string(e.memo),null!=e.contractCall&&Object.hasOwnProperty.call(e,"contractCall")&&$root.proto.ContractCallTransactionBody.encode(e.contractCall,o.uint32(26).fork()).ldelim(),null!=e.contractCreateInstance&&Object.hasOwnProperty.call(e,"contractCreateInstance")&&$root.proto.ContractCreateTransactionBody.encode(e.contractCreateInstance,o.uint32(34).fork()).ldelim(),null!=e.contractUpdateInstance&&Object.hasOwnProperty.call(e,"contractUpdateInstance")&&$root.proto.ContractUpdateTransactionBody.encode(e.contractUpdateInstance,o.uint32(42).fork()).ldelim(),null!=e.contractDeleteInstance&&Object.hasOwnProperty.call(e,"contractDeleteInstance")&&$root.proto.ContractDeleteTransactionBody.encode(e.contractDeleteInstance,o.uint32(50).fork()).ldelim(),null!=e.cryptoCreateAccount&&Object.hasOwnProperty.call(e,"cryptoCreateAccount")&&$root.proto.CryptoCreateTransactionBody.encode(e.cryptoCreateAccount,o.uint32(58).fork()).ldelim(),null!=e.cryptoDelete&&Object.hasOwnProperty.call(e,"cryptoDelete")&&$root.proto.CryptoDeleteTransactionBody.encode(e.cryptoDelete,o.uint32(66).fork()).ldelim(),null!=e.cryptoTransfer&&Object.hasOwnProperty.call(e,"cryptoTransfer")&&$root.proto.CryptoTransferTransactionBody.encode(e.cryptoTransfer,o.uint32(74).fork()).ldelim(),null!=e.cryptoUpdateAccount&&Object.hasOwnProperty.call(e,"cryptoUpdateAccount")&&$root.proto.CryptoUpdateTransactionBody.encode(e.cryptoUpdateAccount,o.uint32(82).fork()).ldelim(),null!=e.fileAppend&&Object.hasOwnProperty.call(e,"fileAppend")&&$root.proto.FileAppendTransactionBody.encode(e.fileAppend,o.uint32(90).fork()).ldelim(),null!=e.fileCreate&&Object.hasOwnProperty.call(e,"fileCreate")&&$root.proto.FileCreateTransactionBody.encode(e.fileCreate,o.uint32(98).fork()).ldelim(),null!=e.fileDelete&&Object.hasOwnProperty.call(e,"fileDelete")&&$root.proto.FileDeleteTransactionBody.encode(e.fileDelete,o.uint32(106).fork()).ldelim(),null!=e.fileUpdate&&Object.hasOwnProperty.call(e,"fileUpdate")&&$root.proto.FileUpdateTransactionBody.encode(e.fileUpdate,o.uint32(114).fork()).ldelim(),null!=e.systemDelete&&Object.hasOwnProperty.call(e,"systemDelete")&&$root.proto.SystemDeleteTransactionBody.encode(e.systemDelete,o.uint32(122).fork()).ldelim(),null!=e.systemUndelete&&Object.hasOwnProperty.call(e,"systemUndelete")&&$root.proto.SystemUndeleteTransactionBody.encode(e.systemUndelete,o.uint32(130).fork()).ldelim(),null!=e.freeze&&Object.hasOwnProperty.call(e,"freeze")&&$root.proto.FreezeTransactionBody.encode(e.freeze,o.uint32(138).fork()).ldelim(),null!=e.consensusCreateTopic&&Object.hasOwnProperty.call(e,"consensusCreateTopic")&&$root.proto.ConsensusCreateTopicTransactionBody.encode(e.consensusCreateTopic,o.uint32(146).fork()).ldelim(),null!=e.consensusUpdateTopic&&Object.hasOwnProperty.call(e,"consensusUpdateTopic")&&$root.proto.ConsensusUpdateTopicTransactionBody.encode(e.consensusUpdateTopic,o.uint32(154).fork()).ldelim(),null!=e.consensusDeleteTopic&&Object.hasOwnProperty.call(e,"consensusDeleteTopic")&&$root.proto.ConsensusDeleteTopicTransactionBody.encode(e.consensusDeleteTopic,o.uint32(162).fork()).ldelim(),null!=e.consensusSubmitMessage&&Object.hasOwnProperty.call(e,"consensusSubmitMessage")&&$root.proto.ConsensusSubmitMessageTransactionBody.encode(e.consensusSubmitMessage,o.uint32(170).fork()).ldelim(),null!=e.tokenCreation&&Object.hasOwnProperty.call(e,"tokenCreation")&&$root.proto.TokenCreateTransactionBody.encode(e.tokenCreation,o.uint32(178).fork()).ldelim(),null!=e.tokenFreeze&&Object.hasOwnProperty.call(e,"tokenFreeze")&&$root.proto.TokenFreezeAccountTransactionBody.encode(e.tokenFreeze,o.uint32(186).fork()).ldelim(),null!=e.tokenUnfreeze&&Object.hasOwnProperty.call(e,"tokenUnfreeze")&&$root.proto.TokenUnfreezeAccountTransactionBody.encode(e.tokenUnfreeze,o.uint32(194).fork()).ldelim(),null!=e.tokenGrantKyc&&Object.hasOwnProperty.call(e,"tokenGrantKyc")&&$root.proto.TokenGrantKycTransactionBody.encode(e.tokenGrantKyc,o.uint32(202).fork()).ldelim(),null!=e.tokenRevokeKyc&&Object.hasOwnProperty.call(e,"tokenRevokeKyc")&&$root.proto.TokenRevokeKycTransactionBody.encode(e.tokenRevokeKyc,o.uint32(210).fork()).ldelim(),null!=e.tokenDeletion&&Object.hasOwnProperty.call(e,"tokenDeletion")&&$root.proto.TokenDeleteTransactionBody.encode(e.tokenDeletion,o.uint32(218).fork()).ldelim(),null!=e.tokenUpdate&&Object.hasOwnProperty.call(e,"tokenUpdate")&&$root.proto.TokenUpdateTransactionBody.encode(e.tokenUpdate,o.uint32(226).fork()).ldelim(),null!=e.tokenMint&&Object.hasOwnProperty.call(e,"tokenMint")&&$root.proto.TokenMintTransactionBody.encode(e.tokenMint,o.uint32(234).fork()).ldelim(),null!=e.tokenBurn&&Object.hasOwnProperty.call(e,"tokenBurn")&&$root.proto.TokenBurnTransactionBody.encode(e.tokenBurn,o.uint32(242).fork()).ldelim(),null!=e.tokenWipe&&Object.hasOwnProperty.call(e,"tokenWipe")&&$root.proto.TokenWipeAccountTransactionBody.encode(e.tokenWipe,o.uint32(250).fork()).ldelim(),null!=e.tokenAssociate&&Object.hasOwnProperty.call(e,"tokenAssociate")&&$root.proto.TokenAssociateTransactionBody.encode(e.tokenAssociate,o.uint32(258).fork()).ldelim(),null!=e.tokenDissociate&&Object.hasOwnProperty.call(e,"tokenDissociate")&&$root.proto.TokenDissociateTransactionBody.encode(e.tokenDissociate,o.uint32(266).fork()).ldelim(),null!=e.scheduleDelete&&Object.hasOwnProperty.call(e,"scheduleDelete")&&$root.proto.ScheduleDeleteTransactionBody.encode(e.scheduleDelete,o.uint32(274).fork()).ldelim(),null!=e.tokenPause&&Object.hasOwnProperty.call(e,"tokenPause")&&$root.proto.TokenPauseTransactionBody.encode(e.tokenPause,o.uint32(282).fork()).ldelim(),null!=e.tokenUnpause&&Object.hasOwnProperty.call(e,"tokenUnpause")&&$root.proto.TokenUnpauseTransactionBody.encode(e.tokenUnpause,o.uint32(290).fork()).ldelim(),null!=e.cryptoAdjustAllowance&&Object.hasOwnProperty.call(e,"cryptoAdjustAllowance")&&$root.proto.CryptoAdjustAllowanceTransactionBody.encode(e.cryptoAdjustAllowance,o.uint32(298).fork()).ldelim(),null!=e.cryptoApproveAllowance&&Object.hasOwnProperty.call(e,"cryptoApproveAllowance")&&$root.proto.CryptoApproveAllowanceTransactionBody.encode(e.cryptoApproveAllowance,o.uint32(306).fork()).ldelim(),null!=e.tokenFeeScheduleUpdate&&Object.hasOwnProperty.call(e,"tokenFeeScheduleUpdate")&&$root.proto.TokenFeeScheduleUpdateTransactionBody.encode(e.tokenFeeScheduleUpdate,o.uint32(314).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SchedulableTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionFee=e.uint64();break;case 2:d.memo=e.string();break;case 3:d.contractCall=$root.proto.ContractCallTransactionBody.decode(e,e.uint32());break;case 4:d.contractCreateInstance=$root.proto.ContractCreateTransactionBody.decode(e,e.uint32());break;case 5:d.contractUpdateInstance=$root.proto.ContractUpdateTransactionBody.decode(e,e.uint32());break;case 6:d.contractDeleteInstance=$root.proto.ContractDeleteTransactionBody.decode(e,e.uint32());break;case 37:d.cryptoAdjustAllowance=$root.proto.CryptoAdjustAllowanceTransactionBody.decode(e,e.uint32());break;case 38:d.cryptoApproveAllowance=$root.proto.CryptoApproveAllowanceTransactionBody.decode(e,e.uint32());break;case 7:d.cryptoCreateAccount=$root.proto.CryptoCreateTransactionBody.decode(e,e.uint32());break;case 8:d.cryptoDelete=$root.proto.CryptoDeleteTransactionBody.decode(e,e.uint32());break;case 9:d.cryptoTransfer=$root.proto.CryptoTransferTransactionBody.decode(e,e.uint32());break;case 10:d.cryptoUpdateAccount=$root.proto.CryptoUpdateTransactionBody.decode(e,e.uint32());break;case 11:d.fileAppend=$root.proto.FileAppendTransactionBody.decode(e,e.uint32());break;case 12:d.fileCreate=$root.proto.FileCreateTransactionBody.decode(e,e.uint32());break;case 13:d.fileDelete=$root.proto.FileDeleteTransactionBody.decode(e,e.uint32());break;case 14:d.fileUpdate=$root.proto.FileUpdateTransactionBody.decode(e,e.uint32());break;case 15:d.systemDelete=$root.proto.SystemDeleteTransactionBody.decode(e,e.uint32());break;case 16:d.systemUndelete=$root.proto.SystemUndeleteTransactionBody.decode(e,e.uint32());break;case 17:d.freeze=$root.proto.FreezeTransactionBody.decode(e,e.uint32());break;case 18:d.consensusCreateTopic=$root.proto.ConsensusCreateTopicTransactionBody.decode(e,e.uint32());break;case 19:d.consensusUpdateTopic=$root.proto.ConsensusUpdateTopicTransactionBody.decode(e,e.uint32());break;case 20:d.consensusDeleteTopic=$root.proto.ConsensusDeleteTopicTransactionBody.decode(e,e.uint32());break;case 21:d.consensusSubmitMessage=$root.proto.ConsensusSubmitMessageTransactionBody.decode(e,e.uint32());break;case 22:d.tokenCreation=$root.proto.TokenCreateTransactionBody.decode(e,e.uint32());break;case 23:d.tokenFreeze=$root.proto.TokenFreezeAccountTransactionBody.decode(e,e.uint32());break;case 24:d.tokenUnfreeze=$root.proto.TokenUnfreezeAccountTransactionBody.decode(e,e.uint32());break;case 25:d.tokenGrantKyc=$root.proto.TokenGrantKycTransactionBody.decode(e,e.uint32());break;case 26:d.tokenRevokeKyc=$root.proto.TokenRevokeKycTransactionBody.decode(e,e.uint32());break;case 27:d.tokenDeletion=$root.proto.TokenDeleteTransactionBody.decode(e,e.uint32());break;case 28:d.tokenUpdate=$root.proto.TokenUpdateTransactionBody.decode(e,e.uint32());break;case 29:d.tokenMint=$root.proto.TokenMintTransactionBody.decode(e,e.uint32());break;case 30:d.tokenBurn=$root.proto.TokenBurnTransactionBody.decode(e,e.uint32());break;case 31:d.tokenWipe=$root.proto.TokenWipeAccountTransactionBody.decode(e,e.uint32());break;case 32:d.tokenAssociate=$root.proto.TokenAssociateTransactionBody.decode(e,e.uint32());break;case 33:d.tokenDissociate=$root.proto.TokenDissociateTransactionBody.decode(e,e.uint32());break;case 39:d.tokenFeeScheduleUpdate=$root.proto.TokenFeeScheduleUpdateTransactionBody.decode(e,e.uint32());break;case 35:d.tokenPause=$root.proto.TokenPauseTransactionBody.decode(e,e.uint32());break;case 36:d.tokenUnpause=$root.proto.TokenUnpauseTransactionBody.decode(e,e.uint32());break;case 34:d.scheduleDelete=$root.proto.ScheduleDeleteTransactionBody.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ScheduleDeleteTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.scheduleID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleDeleteTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ScheduleSignTransactionBody:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.scheduleID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleSignTransactionBody,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ResponseHeader:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.nodeTransactionPrecheckCode=0,e.prototype.responseType=0,e.prototype.cost=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.stateProof=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.nodeTransactionPrecheckCode&&Object.hasOwnProperty.call(e,"nodeTransactionPrecheckCode")&&o.uint32(8).int32(e.nodeTransactionPrecheckCode),null!=e.responseType&&Object.hasOwnProperty.call(e,"responseType")&&o.uint32(16).int32(e.responseType),null!=e.cost&&Object.hasOwnProperty.call(e,"cost")&&o.uint32(24).uint64(e.cost),null!=e.stateProof&&Object.hasOwnProperty.call(e,"stateProof")&&o.uint32(34).bytes(e.stateProof),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ResponseHeader,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nodeTransactionPrecheckCode=e.int32();break;case 2:d.responseType=e.int32();break;case 3:d.cost=e.uint64();break;case 4:d.stateProof=e.bytes();break;default:e.skipType(7&i);}return d},e}(),TransactionResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.nodeTransactionPrecheckCode=0,e.prototype.cost=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.nodeTransactionPrecheckCode&&Object.hasOwnProperty.call(e,"nodeTransactionPrecheckCode")&&o.uint32(8).int32(e.nodeTransactionPrecheckCode),null!=e.cost&&Object.hasOwnProperty.call(e,"cost")&&o.uint32(16).uint64(e.cost),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nodeTransactionPrecheckCode=e.int32();break;case 2:d.cost=e.uint64();break;default:e.skipType(7&i);}return d},e}(),ResponseCodeEnum:function(){const e={},o=Object.create(e);return o[e[0]="OK"]=0,o[e[1]="INVALID_TRANSACTION"]=1,o[e[2]="PAYER_ACCOUNT_NOT_FOUND"]=2,o[e[3]="INVALID_NODE_ACCOUNT"]=3,o[e[4]="TRANSACTION_EXPIRED"]=4,o[e[5]="INVALID_TRANSACTION_START"]=5,o[e[6]="INVALID_TRANSACTION_DURATION"]=6,o[e[7]="INVALID_SIGNATURE"]=7,o[e[8]="MEMO_TOO_LONG"]=8,o[e[9]="INSUFFICIENT_TX_FEE"]=9,o[e[10]="INSUFFICIENT_PAYER_BALANCE"]=10,o[e[11]="DUPLICATE_TRANSACTION"]=11,o[e[12]="BUSY"]=12,o[e[13]="NOT_SUPPORTED"]=13,o[e[14]="INVALID_FILE_ID"]=14,o[e[15]="INVALID_ACCOUNT_ID"]=15,o[e[16]="INVALID_CONTRACT_ID"]=16,o[e[17]="INVALID_TRANSACTION_ID"]=17,o[e[18]="RECEIPT_NOT_FOUND"]=18,o[e[19]="RECORD_NOT_FOUND"]=19,o[e[20]="INVALID_SOLIDITY_ID"]=20,o[e[21]="UNKNOWN"]=21,o[e[22]="SUCCESS"]=22,o[e[23]="FAIL_INVALID"]=23,o[e[24]="FAIL_FEE"]=24,o[e[25]="FAIL_BALANCE"]=25,o[e[26]="KEY_REQUIRED"]=26,o[e[27]="BAD_ENCODING"]=27,o[e[28]="INSUFFICIENT_ACCOUNT_BALANCE"]=28,o[e[29]="INVALID_SOLIDITY_ADDRESS"]=29,o[e[30]="INSUFFICIENT_GAS"]=30,o[e[31]="CONTRACT_SIZE_LIMIT_EXCEEDED"]=31,o[e[32]="LOCAL_CALL_MODIFICATION_EXCEPTION"]=32,o[e[33]="CONTRACT_REVERT_EXECUTED"]=33,o[e[34]="CONTRACT_EXECUTION_EXCEPTION"]=34,o[e[35]="INVALID_RECEIVING_NODE_ACCOUNT"]=35,o[e[36]="MISSING_QUERY_HEADER"]=36,o[e[37]="ACCOUNT_UPDATE_FAILED"]=37,o[e[38]="INVALID_KEY_ENCODING"]=38,o[e[39]="NULL_SOLIDITY_ADDRESS"]=39,o[e[40]="CONTRACT_UPDATE_FAILED"]=40,o[e[41]="INVALID_QUERY_HEADER"]=41,o[e[42]="INVALID_FEE_SUBMITTED"]=42,o[e[43]="INVALID_PAYER_SIGNATURE"]=43,o[e[44]="KEY_NOT_PROVIDED"]=44,o[e[45]="INVALID_EXPIRATION_TIME"]=45,o[e[46]="NO_WACL_KEY"]=46,o[e[47]="FILE_CONTENT_EMPTY"]=47,o[e[48]="INVALID_ACCOUNT_AMOUNTS"]=48,o[e[49]="EMPTY_TRANSACTION_BODY"]=49,o[e[50]="INVALID_TRANSACTION_BODY"]=50,o[e[51]="INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"]=51,o[e[52]="INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"]=52,o[e[53]="EMPTY_LIVE_HASH_BODY"]=53,o[e[54]="EMPTY_LIVE_HASH"]=54,o[e[55]="EMPTY_LIVE_HASH_KEYS"]=55,o[e[56]="INVALID_LIVE_HASH_SIZE"]=56,o[e[57]="EMPTY_QUERY_BODY"]=57,o[e[58]="EMPTY_LIVE_HASH_QUERY"]=58,o[e[59]="LIVE_HASH_NOT_FOUND"]=59,o[e[60]="ACCOUNT_ID_DOES_NOT_EXIST"]=60,o[e[61]="LIVE_HASH_ALREADY_EXISTS"]=61,o[e[62]="INVALID_FILE_WACL"]=62,o[e[63]="SERIALIZATION_FAILED"]=63,o[e[64]="TRANSACTION_OVERSIZE"]=64,o[e[65]="TRANSACTION_TOO_MANY_LAYERS"]=65,o[e[66]="CONTRACT_DELETED"]=66,o[e[67]="PLATFORM_NOT_ACTIVE"]=67,o[e[68]="KEY_PREFIX_MISMATCH"]=68,o[e[69]="PLATFORM_TRANSACTION_NOT_CREATED"]=69,o[e[70]="INVALID_RENEWAL_PERIOD"]=70,o[e[71]="INVALID_PAYER_ACCOUNT_ID"]=71,o[e[72]="ACCOUNT_DELETED"]=72,o[e[73]="FILE_DELETED"]=73,o[e[74]="ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"]=74,o[e[75]="SETTING_NEGATIVE_ACCOUNT_BALANCE"]=75,o[e[76]="OBTAINER_REQUIRED"]=76,o[e[77]="OBTAINER_SAME_CONTRACT_ID"]=77,o[e[78]="OBTAINER_DOES_NOT_EXIST"]=78,o[e[79]="MODIFYING_IMMUTABLE_CONTRACT"]=79,o[e[80]="FILE_SYSTEM_EXCEPTION"]=80,o[e[81]="AUTORENEW_DURATION_NOT_IN_RANGE"]=81,o[e[82]="ERROR_DECODING_BYTESTRING"]=82,o[e[83]="CONTRACT_FILE_EMPTY"]=83,o[e[84]="CONTRACT_BYTECODE_EMPTY"]=84,o[e[85]="INVALID_INITIAL_BALANCE"]=85,o[e[86]="INVALID_RECEIVE_RECORD_THRESHOLD"]=86,o[e[87]="INVALID_SEND_RECORD_THRESHOLD"]=87,o[e[88]="ACCOUNT_IS_NOT_GENESIS_ACCOUNT"]=88,o[e[89]="PAYER_ACCOUNT_UNAUTHORIZED"]=89,o[e[90]="INVALID_FREEZE_TRANSACTION_BODY"]=90,o[e[91]="FREEZE_TRANSACTION_BODY_NOT_FOUND"]=91,o[e[92]="TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"]=92,o[e[93]="RESULT_SIZE_LIMIT_EXCEEDED"]=93,o[e[94]="NOT_SPECIAL_ACCOUNT"]=94,o[e[95]="CONTRACT_NEGATIVE_GAS"]=95,o[e[96]="CONTRACT_NEGATIVE_VALUE"]=96,o[e[97]="INVALID_FEE_FILE"]=97,o[e[98]="INVALID_EXCHANGE_RATE_FILE"]=98,o[e[99]="INSUFFICIENT_LOCAL_CALL_GAS"]=99,o[e[100]="ENTITY_NOT_ALLOWED_TO_DELETE"]=100,o[e[101]="AUTHORIZATION_FAILED"]=101,o[e[102]="FILE_UPLOADED_PROTO_INVALID"]=102,o[e[103]="FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"]=103,o[e[104]="FEE_SCHEDULE_FILE_PART_UPLOADED"]=104,o[e[105]="EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"]=105,o[e[106]="MAX_CONTRACT_STORAGE_EXCEEDED"]=106,o[e[107]="TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"]=107,o[e[108]="TOTAL_LEDGER_BALANCE_INVALID"]=108,o[e[110]="EXPIRATION_REDUCTION_NOT_ALLOWED"]=110,o[e[111]="MAX_GAS_LIMIT_EXCEEDED"]=111,o[e[112]="MAX_FILE_SIZE_EXCEEDED"]=112,o[e[113]="RECEIVER_SIG_REQUIRED"]=113,o[e[150]="INVALID_TOPIC_ID"]=150,o[e[155]="INVALID_ADMIN_KEY"]=155,o[e[156]="INVALID_SUBMIT_KEY"]=156,o[e[157]="UNAUTHORIZED"]=157,o[e[158]="INVALID_TOPIC_MESSAGE"]=158,o[e[159]="INVALID_AUTORENEW_ACCOUNT"]=159,o[e[160]="AUTORENEW_ACCOUNT_NOT_ALLOWED"]=160,o[e[162]="TOPIC_EXPIRED"]=162,o[e[163]="INVALID_CHUNK_NUMBER"]=163,o[e[164]="INVALID_CHUNK_TRANSACTION_ID"]=164,o[e[165]="ACCOUNT_FROZEN_FOR_TOKEN"]=165,o[e[166]="TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED"]=166,o[e[167]="INVALID_TOKEN_ID"]=167,o[e[168]="INVALID_TOKEN_DECIMALS"]=168,o[e[169]="INVALID_TOKEN_INITIAL_SUPPLY"]=169,o[e[170]="INVALID_TREASURY_ACCOUNT_FOR_TOKEN"]=170,o[e[171]="INVALID_TOKEN_SYMBOL"]=171,o[e[172]="TOKEN_HAS_NO_FREEZE_KEY"]=172,o[e[173]="TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN"]=173,o[e[174]="MISSING_TOKEN_SYMBOL"]=174,o[e[175]="TOKEN_SYMBOL_TOO_LONG"]=175,o[e[176]="ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN"]=176,o[e[177]="TOKEN_HAS_NO_KYC_KEY"]=177,o[e[178]="INSUFFICIENT_TOKEN_BALANCE"]=178,o[e[179]="TOKEN_WAS_DELETED"]=179,o[e[180]="TOKEN_HAS_NO_SUPPLY_KEY"]=180,o[e[181]="TOKEN_HAS_NO_WIPE_KEY"]=181,o[e[182]="INVALID_TOKEN_MINT_AMOUNT"]=182,o[e[183]="INVALID_TOKEN_BURN_AMOUNT"]=183,o[e[184]="TOKEN_NOT_ASSOCIATED_TO_ACCOUNT"]=184,o[e[185]="CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT"]=185,o[e[186]="INVALID_KYC_KEY"]=186,o[e[187]="INVALID_WIPE_KEY"]=187,o[e[188]="INVALID_FREEZE_KEY"]=188,o[e[189]="INVALID_SUPPLY_KEY"]=189,o[e[190]="MISSING_TOKEN_NAME"]=190,o[e[191]="TOKEN_NAME_TOO_LONG"]=191,o[e[192]="INVALID_WIPING_AMOUNT"]=192,o[e[193]="TOKEN_IS_IMMUTABLE"]=193,o[e[194]="TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT"]=194,o[e[195]="TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES"]=195,o[e[196]="ACCOUNT_IS_TREASURY"]=196,o[e[197]="TOKEN_ID_REPEATED_IN_TOKEN_LIST"]=197,o[e[198]="TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"]=198,o[e[199]="EMPTY_TOKEN_TRANSFER_BODY"]=199,o[e[200]="EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS"]=200,o[e[201]="INVALID_SCHEDULE_ID"]=201,o[e[202]="SCHEDULE_IS_IMMUTABLE"]=202,o[e[203]="INVALID_SCHEDULE_PAYER_ID"]=203,o[e[204]="INVALID_SCHEDULE_ACCOUNT_ID"]=204,o[e[205]="NO_NEW_VALID_SIGNATURES"]=205,o[e[206]="UNRESOLVABLE_REQUIRED_SIGNERS"]=206,o[e[207]="SCHEDULED_TRANSACTION_NOT_IN_WHITELIST"]=207,o[e[208]="SOME_SIGNATURES_WERE_INVALID"]=208,o[e[209]="TRANSACTION_ID_FIELD_NOT_ALLOWED"]=209,o[e[210]="IDENTICAL_SCHEDULE_ALREADY_CREATED"]=210,o[e[211]="INVALID_ZERO_BYTE_IN_STRING"]=211,o[e[212]="SCHEDULE_ALREADY_DELETED"]=212,o[e[213]="SCHEDULE_ALREADY_EXECUTED"]=213,o[e[214]="MESSAGE_SIZE_TOO_LARGE"]=214,o[e[215]="OPERATION_REPEATED_IN_BUCKET_GROUPS"]=215,o[e[216]="BUCKET_CAPACITY_OVERFLOW"]=216,o[e[217]="NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION"]=217,o[e[218]="BUCKET_HAS_NO_THROTTLE_GROUPS"]=218,o[e[219]="THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC"]=219,o[e[220]="SUCCESS_BUT_MISSING_EXPECTED_OPERATION"]=220,o[e[221]="UNPARSEABLE_THROTTLE_DEFINITIONS"]=221,o[e[222]="INVALID_THROTTLE_DEFINITIONS"]=222,o[e[223]="ACCOUNT_EXPIRED_AND_PENDING_REMOVAL"]=223,o[e[224]="INVALID_TOKEN_MAX_SUPPLY"]=224,o[e[225]="INVALID_TOKEN_NFT_SERIAL_NUMBER"]=225,o[e[226]="INVALID_NFT_ID"]=226,o[e[227]="METADATA_TOO_LONG"]=227,o[e[228]="BATCH_SIZE_LIMIT_EXCEEDED"]=228,o[e[229]="INVALID_QUERY_RANGE"]=229,o[e[230]="FRACTION_DIVIDES_BY_ZERO"]=230,o[e[231]="INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE"]=231,o[e[232]="CUSTOM_FEES_LIST_TOO_LONG"]=232,o[e[233]="INVALID_CUSTOM_FEE_COLLECTOR"]=233,o[e[234]="INVALID_TOKEN_ID_IN_CUSTOM_FEES"]=234,o[e[235]="TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR"]=235,o[e[236]="TOKEN_MAX_SUPPLY_REACHED"]=236,o[e[237]="SENDER_DOES_NOT_OWN_NFT_SERIAL_NO"]=237,o[e[238]="CUSTOM_FEE_NOT_FULLY_SPECIFIED"]=238,o[e[239]="CUSTOM_FEE_MUST_BE_POSITIVE"]=239,o[e[240]="TOKEN_HAS_NO_FEE_SCHEDULE_KEY"]=240,o[e[241]="CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE"]=241,o[e[242]="ROYALTY_FRACTION_CANNOT_EXCEED_ONE"]=242,o[e[243]="FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT"]=243,o[e[244]="CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES"]=244,o[e[245]="CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON"]=245,o[e[246]="CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"]=246,o[e[247]="INVALID_CUSTOM_FEE_SCHEDULE_KEY"]=247,o[e[248]="INVALID_TOKEN_MINT_METADATA"]=248,o[e[249]="INVALID_TOKEN_BURN_METADATA"]=249,o[e[250]="CURRENT_TREASURY_STILL_OWNS_NFTS"]=250,o[e[251]="ACCOUNT_STILL_OWNS_NFTS"]=251,o[e[252]="TREASURY_MUST_OWN_BURNED_NFT"]=252,o[e[253]="ACCOUNT_DOES_NOT_OWN_WIPED_NFT"]=253,o[e[254]="ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"]=254,o[e[255]="MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED"]=255,o[e[256]="PAYER_ACCOUNT_DELETED"]=256,o[e[257]="CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH"]=257,o[e[258]="CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS"]=258,o[e[259]="INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE"]=259,o[e[260]="SERIAL_NUMBER_LIMIT_REACHED"]=260,o[e[261]="CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"]=261,o[e[262]="NO_REMAINING_AUTOMATIC_ASSOCIATIONS"]=262,o[e[263]="EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT"]=263,o[e[264]="REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT"]=264,o[e[265]="TOKEN_IS_PAUSED"]=265,o[e[266]="TOKEN_HAS_NO_PAUSE_KEY"]=266,o[e[267]="INVALID_PAUSE_KEY"]=267,o[e[268]="FREEZE_UPDATE_FILE_DOES_NOT_EXIST"]=268,o[e[269]="FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH"]=269,o[e[270]="NO_UPGRADE_HAS_BEEN_PREPARED"]=270,o[e[271]="NO_FREEZE_IS_SCHEDULED"]=271,o[e[272]="UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE"]=272,o[e[273]="FREEZE_START_TIME_MUST_BE_FUTURE"]=273,o[e[274]="PREPARED_UPDATE_FILE_IS_IMMUTABLE"]=274,o[e[275]="FREEZE_ALREADY_SCHEDULED"]=275,o[e[276]="FREEZE_UPGRADE_IN_PROGRESS"]=276,o[e[277]="UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED"]=277,o[e[278]="UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED"]=278,o[e[279]="CONSENSUS_GAS_EXHAUSTED"]=279,o[e[280]="REVERTED_SUCCESS"]=280,o[e[281]="MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED"]=281,o[e[282]="INVALID_ALIAS_KEY"]=282,o[e[283]="UNEXPECTED_TOKEN_DECIMALS"]=283,o[e[284]="INVALID_PROXY_ACCOUNT_ID"]=284,o[e[285]="INVALID_TRANSFER_ACCOUNT_ID"]=285,o[e[286]="INVALID_FEE_COLLECTOR_ACCOUNT_ID"]=286,o[e[287]="ALIAS_IS_IMMUTABLE"]=287,o[e[288]="SPENDER_ACCOUNT_SAME_AS_OWNER"]=288,o[e[289]="AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY"]=289,o[e[290]="NEGATIVE_ALLOWANCE_AMOUNT"]=290,o[e[291]="CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON"]=291,o[e[292]="SPENDER_DOES_NOT_HAVE_ALLOWANCE"]=292,o[e[293]="AMOUNT_EXCEEDS_ALLOWANCE"]=293,o[e[294]="MAX_ALLOWANCES_EXCEEDED"]=294,o[e[295]="EMPTY_ALLOWANCES"]=295,o[e[296]="SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES"]=296,o[e[297]="REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES"]=297,o[e[298]="FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES"]=298,o[e[299]="NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES"]=299,o[e[300]="INVALID_ALLOWANCE_OWNER_ID"]=300,o[e[301]="INVALID_ALLOWANCE_SPENDER_ID"]=301,o}(),ConsensusTopicInfo:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.memo="",e.prototype.runningHash=$util.newBuffer([]),e.prototype.sequenceNumber=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.expirationTime=null,e.prototype.adminKey=null,e.prototype.submitKey=null,e.prototype.autoRenewPeriod=null,e.prototype.autoRenewAccount=null,e.prototype.ledgerId=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(10).string(e.memo),null!=e.runningHash&&Object.hasOwnProperty.call(e,"runningHash")&&o.uint32(18).bytes(e.runningHash),null!=e.sequenceNumber&&Object.hasOwnProperty.call(e,"sequenceNumber")&&o.uint32(24).uint64(e.sequenceNumber),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(34).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(42).fork()).ldelim(),null!=e.submitKey&&Object.hasOwnProperty.call(e,"submitKey")&&$root.proto.Key.encode(e.submitKey,o.uint32(50).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(58).fork()).ldelim(),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(66).fork()).ldelim(),null!=e.ledgerId&&Object.hasOwnProperty.call(e,"ledgerId")&&o.uint32(74).bytes(e.ledgerId),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusTopicInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.memo=e.string();break;case 2:d.runningHash=e.bytes();break;case 3:d.sequenceNumber=e.uint64();break;case 4:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 5:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 6:d.submitKey=$root.proto.Key.decode(e,e.uint32());break;case 7:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 8:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;case 9:d.ledgerId=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ConsensusService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createTopic=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"createTopic"}),Object.defineProperty(e.prototype.updateTopic=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"updateTopic"}),Object.defineProperty(e.prototype.deleteTopic=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"deleteTopic"}),Object.defineProperty(e.prototype.getTopicInfo=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getTopicInfo"}),Object.defineProperty(e.prototype.submitMessage=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"submitMessage"}),e}(),Query:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.getByKey=null,e.prototype.getBySolidityID=null,e.prototype.contractCallLocal=null,e.prototype.contractGetInfo=null,e.prototype.contractGetBytecode=null,e.prototype.ContractGetRecords=null,e.prototype.cryptogetAccountBalance=null,e.prototype.cryptoGetAccountRecords=null,e.prototype.cryptoGetInfo=null,e.prototype.cryptoGetLiveHash=null,e.prototype.cryptoGetProxyStakers=null,e.prototype.fileGetContents=null,e.prototype.fileGetInfo=null,e.prototype.transactionGetReceipt=null,e.prototype.transactionGetRecord=null,e.prototype.transactionGetFastRecord=null,e.prototype.consensusGetTopicInfo=null,e.prototype.networkGetVersionInfo=null,e.prototype.tokenGetInfo=null,e.prototype.scheduleGetInfo=null,e.prototype.tokenGetAccountNftInfos=null,e.prototype.tokenGetNftInfo=null,e.prototype.tokenGetNftInfos=null,e.prototype.networkGetExecutionTime=null;let o;return Object.defineProperty(e.prototype,"query",{get:$util.oneOfGetter(o=["getByKey","getBySolidityID","contractCallLocal","contractGetInfo","contractGetBytecode","ContractGetRecords","cryptogetAccountBalance","cryptoGetAccountRecords","cryptoGetInfo","cryptoGetLiveHash","cryptoGetProxyStakers","fileGetContents","fileGetInfo","transactionGetReceipt","transactionGetRecord","transactionGetFastRecord","consensusGetTopicInfo","networkGetVersionInfo","tokenGetInfo","scheduleGetInfo","tokenGetAccountNftInfos","tokenGetNftInfo","tokenGetNftInfos","networkGetExecutionTime"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.getByKey&&Object.hasOwnProperty.call(e,"getByKey")&&$root.proto.GetByKeyQuery.encode(e.getByKey,o.uint32(10).fork()).ldelim(),null!=e.getBySolidityID&&Object.hasOwnProperty.call(e,"getBySolidityID")&&$root.proto.GetBySolidityIDQuery.encode(e.getBySolidityID,o.uint32(18).fork()).ldelim(),null!=e.contractCallLocal&&Object.hasOwnProperty.call(e,"contractCallLocal")&&$root.proto.ContractCallLocalQuery.encode(e.contractCallLocal,o.uint32(26).fork()).ldelim(),null!=e.contractGetInfo&&Object.hasOwnProperty.call(e,"contractGetInfo")&&$root.proto.ContractGetInfoQuery.encode(e.contractGetInfo,o.uint32(34).fork()).ldelim(),null!=e.contractGetBytecode&&Object.hasOwnProperty.call(e,"contractGetBytecode")&&$root.proto.ContractGetBytecodeQuery.encode(e.contractGetBytecode,o.uint32(42).fork()).ldelim(),null!=e.ContractGetRecords&&Object.hasOwnProperty.call(e,"ContractGetRecords")&&$root.proto.ContractGetRecordsQuery.encode(e.ContractGetRecords,o.uint32(50).fork()).ldelim(),null!=e.cryptogetAccountBalance&&Object.hasOwnProperty.call(e,"cryptogetAccountBalance")&&$root.proto.CryptoGetAccountBalanceQuery.encode(e.cryptogetAccountBalance,o.uint32(58).fork()).ldelim(),null!=e.cryptoGetAccountRecords&&Object.hasOwnProperty.call(e,"cryptoGetAccountRecords")&&$root.proto.CryptoGetAccountRecordsQuery.encode(e.cryptoGetAccountRecords,o.uint32(66).fork()).ldelim(),null!=e.cryptoGetInfo&&Object.hasOwnProperty.call(e,"cryptoGetInfo")&&$root.proto.CryptoGetInfoQuery.encode(e.cryptoGetInfo,o.uint32(74).fork()).ldelim(),null!=e.cryptoGetLiveHash&&Object.hasOwnProperty.call(e,"cryptoGetLiveHash")&&$root.proto.CryptoGetLiveHashQuery.encode(e.cryptoGetLiveHash,o.uint32(82).fork()).ldelim(),null!=e.cryptoGetProxyStakers&&Object.hasOwnProperty.call(e,"cryptoGetProxyStakers")&&$root.proto.CryptoGetStakersQuery.encode(e.cryptoGetProxyStakers,o.uint32(90).fork()).ldelim(),null!=e.fileGetContents&&Object.hasOwnProperty.call(e,"fileGetContents")&&$root.proto.FileGetContentsQuery.encode(e.fileGetContents,o.uint32(98).fork()).ldelim(),null!=e.fileGetInfo&&Object.hasOwnProperty.call(e,"fileGetInfo")&&$root.proto.FileGetInfoQuery.encode(e.fileGetInfo,o.uint32(106).fork()).ldelim(),null!=e.transactionGetReceipt&&Object.hasOwnProperty.call(e,"transactionGetReceipt")&&$root.proto.TransactionGetReceiptQuery.encode(e.transactionGetReceipt,o.uint32(114).fork()).ldelim(),null!=e.transactionGetRecord&&Object.hasOwnProperty.call(e,"transactionGetRecord")&&$root.proto.TransactionGetRecordQuery.encode(e.transactionGetRecord,o.uint32(122).fork()).ldelim(),null!=e.transactionGetFastRecord&&Object.hasOwnProperty.call(e,"transactionGetFastRecord")&&$root.proto.TransactionGetFastRecordQuery.encode(e.transactionGetFastRecord,o.uint32(130).fork()).ldelim(),null!=e.consensusGetTopicInfo&&Object.hasOwnProperty.call(e,"consensusGetTopicInfo")&&$root.proto.ConsensusGetTopicInfoQuery.encode(e.consensusGetTopicInfo,o.uint32(402).fork()).ldelim(),null!=e.networkGetVersionInfo&&Object.hasOwnProperty.call(e,"networkGetVersionInfo")&&$root.proto.NetworkGetVersionInfoQuery.encode(e.networkGetVersionInfo,o.uint32(410).fork()).ldelim(),null!=e.tokenGetInfo&&Object.hasOwnProperty.call(e,"tokenGetInfo")&&$root.proto.TokenGetInfoQuery.encode(e.tokenGetInfo,o.uint32(418).fork()).ldelim(),null!=e.scheduleGetInfo&&Object.hasOwnProperty.call(e,"scheduleGetInfo")&&$root.proto.ScheduleGetInfoQuery.encode(e.scheduleGetInfo,o.uint32(426).fork()).ldelim(),null!=e.tokenGetAccountNftInfos&&Object.hasOwnProperty.call(e,"tokenGetAccountNftInfos")&&$root.proto.TokenGetAccountNftInfosQuery.encode(e.tokenGetAccountNftInfos,o.uint32(434).fork()).ldelim(),null!=e.tokenGetNftInfo&&Object.hasOwnProperty.call(e,"tokenGetNftInfo")&&$root.proto.TokenGetNftInfoQuery.encode(e.tokenGetNftInfo,o.uint32(442).fork()).ldelim(),null!=e.tokenGetNftInfos&&Object.hasOwnProperty.call(e,"tokenGetNftInfos")&&$root.proto.TokenGetNftInfosQuery.encode(e.tokenGetNftInfos,o.uint32(450).fork()).ldelim(),null!=e.networkGetExecutionTime&&Object.hasOwnProperty.call(e,"networkGetExecutionTime")&&$root.proto.NetworkGetExecutionTimeQuery.encode(e.networkGetExecutionTime,o.uint32(458).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Query,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.getByKey=$root.proto.GetByKeyQuery.decode(e,e.uint32());break;case 2:d.getBySolidityID=$root.proto.GetBySolidityIDQuery.decode(e,e.uint32());break;case 3:d.contractCallLocal=$root.proto.ContractCallLocalQuery.decode(e,e.uint32());break;case 4:d.contractGetInfo=$root.proto.ContractGetInfoQuery.decode(e,e.uint32());break;case 5:d.contractGetBytecode=$root.proto.ContractGetBytecodeQuery.decode(e,e.uint32());break;case 6:d.ContractGetRecords=$root.proto.ContractGetRecordsQuery.decode(e,e.uint32());break;case 7:d.cryptogetAccountBalance=$root.proto.CryptoGetAccountBalanceQuery.decode(e,e.uint32());break;case 8:d.cryptoGetAccountRecords=$root.proto.CryptoGetAccountRecordsQuery.decode(e,e.uint32());break;case 9:d.cryptoGetInfo=$root.proto.CryptoGetInfoQuery.decode(e,e.uint32());break;case 10:d.cryptoGetLiveHash=$root.proto.CryptoGetLiveHashQuery.decode(e,e.uint32());break;case 11:d.cryptoGetProxyStakers=$root.proto.CryptoGetStakersQuery.decode(e,e.uint32());break;case 12:d.fileGetContents=$root.proto.FileGetContentsQuery.decode(e,e.uint32());break;case 13:d.fileGetInfo=$root.proto.FileGetInfoQuery.decode(e,e.uint32());break;case 14:d.transactionGetReceipt=$root.proto.TransactionGetReceiptQuery.decode(e,e.uint32());break;case 15:d.transactionGetRecord=$root.proto.TransactionGetRecordQuery.decode(e,e.uint32());break;case 16:d.transactionGetFastRecord=$root.proto.TransactionGetFastRecordQuery.decode(e,e.uint32());break;case 50:d.consensusGetTopicInfo=$root.proto.ConsensusGetTopicInfoQuery.decode(e,e.uint32());break;case 51:d.networkGetVersionInfo=$root.proto.NetworkGetVersionInfoQuery.decode(e,e.uint32());break;case 52:d.tokenGetInfo=$root.proto.TokenGetInfoQuery.decode(e,e.uint32());break;case 53:d.scheduleGetInfo=$root.proto.ScheduleGetInfoQuery.decode(e,e.uint32());break;case 54:d.tokenGetAccountNftInfos=$root.proto.TokenGetAccountNftInfosQuery.decode(e,e.uint32());break;case 55:d.tokenGetNftInfo=$root.proto.TokenGetNftInfoQuery.decode(e,e.uint32());break;case 56:d.tokenGetNftInfos=$root.proto.TokenGetNftInfosQuery.decode(e,e.uint32());break;case 57:d.networkGetExecutionTime=$root.proto.NetworkGetExecutionTimeQuery.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),GetByKeyQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.key=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&$root.proto.Key.encode(e.key,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GetByKeyQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.key=$root.proto.Key.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),EntityID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.accountID=null,e.prototype.liveHash=null,e.prototype.fileID=null,e.prototype.contractID=null;let o;return Object.defineProperty(e.prototype,"entity",{get:$util.oneOfGetter(o=["accountID","liveHash","fileID","contractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.liveHash&&Object.hasOwnProperty.call(e,"liveHash")&&$root.proto.LiveHash.encode(e.liveHash,o.uint32(18).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(26).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(34).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.EntityID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.liveHash=$root.proto.LiveHash.decode(e,e.uint32());break;case 3:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 4:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),GetByKeyResponse:function(){function e(e){if(this.entities=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.entities=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.entities&&e.entities.length)for(var t=0;t<e.entities.length;++t)$root.proto.EntityID.encode(e.entities[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GetByKeyResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.entities&&d.entities.length||(d.entities=[]),d.entities.push($root.proto.EntityID.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),GetBySolidityIDQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.solidityID="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.solidityID&&Object.hasOwnProperty.call(e,"solidityID")&&o.uint32(18).string(e.solidityID),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GetBySolidityIDQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.solidityID=e.string();break;default:e.skipType(7&i);}return d},e}(),GetBySolidityIDResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.fileID=null,e.prototype.contractID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(26).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(34).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.GetBySolidityIDResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 4:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractLoginfo:function(){function e(e){if(this.topic=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.contractID=null,e.prototype.bloom=$util.newBuffer([]),e.prototype.topic=$util.emptyArray,e.prototype.data=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.bloom&&Object.hasOwnProperty.call(e,"bloom")&&o.uint32(18).bytes(e.bloom),null!=e.topic&&e.topic.length)for(var t=0;t<e.topic.length;++t)o.uint32(26).bytes(e.topic[t]);return null!=e.data&&Object.hasOwnProperty.call(e,"data")&&o.uint32(34).bytes(e.data),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractLoginfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.bloom=e.bytes();break;case 3:d.topic&&d.topic.length||(d.topic=[]),d.topic.push(e.bytes());break;case 4:d.data=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ContractFunctionResult:function(){function e(e){if(this.logInfo=[],this.createdContractIDs=[],this.stateChanges=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.contractID=null,e.prototype.contractCallResult=$util.newBuffer([]),e.prototype.errorMessage="",e.prototype.bloom=$util.newBuffer([]),e.prototype.gasUsed=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.logInfo=$util.emptyArray,e.prototype.createdContractIDs=$util.emptyArray,e.prototype.stateChanges=$util.emptyArray,e.prototype.evmAddress=null,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.contractCallResult&&Object.hasOwnProperty.call(e,"contractCallResult")&&o.uint32(18).bytes(e.contractCallResult),null!=e.errorMessage&&Object.hasOwnProperty.call(e,"errorMessage")&&o.uint32(26).string(e.errorMessage),null!=e.bloom&&Object.hasOwnProperty.call(e,"bloom")&&o.uint32(34).bytes(e.bloom),null!=e.gasUsed&&Object.hasOwnProperty.call(e,"gasUsed")&&o.uint32(40).uint64(e.gasUsed),null!=e.logInfo&&e.logInfo.length)for(var t=0;t<e.logInfo.length;++t)$root.proto.ContractLoginfo.encode(e.logInfo[t],o.uint32(50).fork()).ldelim();if(null!=e.createdContractIDs&&e.createdContractIDs.length)for(var t=0;t<e.createdContractIDs.length;++t)$root.proto.ContractID.encode(e.createdContractIDs[t],o.uint32(58).fork()).ldelim();if(null!=e.stateChanges&&e.stateChanges.length)for(var t=0;t<e.stateChanges.length;++t)$root.proto.ContractStateChange.encode(e.stateChanges[t],o.uint32(66).fork()).ldelim();return null!=e.evmAddress&&Object.hasOwnProperty.call(e,"evmAddress")&&$root.google.protobuf.BytesValue.encode(e.evmAddress,o.uint32(74).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractFunctionResult,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.contractCallResult=e.bytes();break;case 3:d.errorMessage=e.string();break;case 4:d.bloom=e.bytes();break;case 5:d.gasUsed=e.uint64();break;case 6:d.logInfo&&d.logInfo.length||(d.logInfo=[]),d.logInfo.push($root.proto.ContractLoginfo.decode(e,e.uint32()));break;case 7:d.createdContractIDs&&d.createdContractIDs.length||(d.createdContractIDs=[]),d.createdContractIDs.push($root.proto.ContractID.decode(e,e.uint32()));break;case 8:d.stateChanges&&d.stateChanges.length||(d.stateChanges=[]),d.stateChanges.push($root.proto.ContractStateChange.decode(e,e.uint32()));break;case 9:d.evmAddress=$root.google.protobuf.BytesValue.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractCallLocalQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.contractID=null,e.prototype.gas=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.functionParameters=$util.newBuffer([]),e.prototype.maxResultSize=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),null!=e.gas&&Object.hasOwnProperty.call(e,"gas")&&o.uint32(24).int64(e.gas),null!=e.functionParameters&&Object.hasOwnProperty.call(e,"functionParameters")&&o.uint32(34).bytes(e.functionParameters),null!=e.maxResultSize&&Object.hasOwnProperty.call(e,"maxResultSize")&&o.uint32(40).int64(e.maxResultSize),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractCallLocalQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 3:d.gas=e.int64();break;case 4:d.functionParameters=e.bytes();break;case 5:d.maxResultSize=e.int64();break;default:e.skipType(7&i);}return d},e}(),ContractCallLocalResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.functionResult=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.functionResult&&Object.hasOwnProperty.call(e,"functionResult")&&$root.proto.ContractFunctionResult.encode(e.functionResult,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractCallLocalResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.functionResult=$root.proto.ContractFunctionResult.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractStateChange:function(){function e(e){if(this.storageChanges=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.contractID=null,e.prototype.storageChanges=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.storageChanges&&e.storageChanges.length)for(var t=0;t<e.storageChanges.length;++t)$root.proto.StorageChange.encode(e.storageChanges[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractStateChange,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.storageChanges&&d.storageChanges.length||(d.storageChanges=[]),d.storageChanges.push($root.proto.StorageChange.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),StorageChange:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.slot=$util.newBuffer([]),e.prototype.valueRead=$util.newBuffer([]),e.prototype.valueWritten=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.slot&&Object.hasOwnProperty.call(e,"slot")&&o.uint32(10).bytes(e.slot),null!=e.valueRead&&Object.hasOwnProperty.call(e,"valueRead")&&o.uint32(18).bytes(e.valueRead),null!=e.valueWritten&&Object.hasOwnProperty.call(e,"valueWritten")&&$root.google.protobuf.BytesValue.encode(e.valueWritten,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.StorageChange,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.slot=e.bytes();break;case 2:d.valueRead=e.bytes();break;case 3:d.valueWritten=$root.google.protobuf.BytesValue.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.contractID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.contractInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractInfo&&Object.hasOwnProperty.call(e,"contractInfo")&&$root.proto.ContractGetInfoResponse.ContractInfo.encode(e.contractInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.contractInfo=$root.proto.ContractGetInfoResponse.ContractInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e.ContractInfo=function(){function e(e){if(this.tokenRelationships=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.contractID=null,e.prototype.accountID=null,e.prototype.contractAccountID="",e.prototype.adminKey=null,e.prototype.expirationTime=null,e.prototype.autoRenewPeriod=null,e.prototype.storage=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.memo="",e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.deleted=!1,e.prototype.tokenRelationships=$util.emptyArray,e.prototype.ledgerId=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.contractAccountID&&Object.hasOwnProperty.call(e,"contractAccountID")&&o.uint32(26).string(e.contractAccountID),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(34).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(42).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(50).fork()).ldelim(),null!=e.storage&&Object.hasOwnProperty.call(e,"storage")&&o.uint32(56).int64(e.storage),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(66).string(e.memo),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(72).uint64(e.balance),null!=e.deleted&&Object.hasOwnProperty.call(e,"deleted")&&o.uint32(80).bool(e.deleted),null!=e.tokenRelationships&&e.tokenRelationships.length)for(var t=0;t<e.tokenRelationships.length;++t)$root.proto.TokenRelationship.encode(e.tokenRelationships[t],o.uint32(90).fork()).ldelim();return null!=e.ledgerId&&Object.hasOwnProperty.call(e,"ledgerId")&&o.uint32(98).bytes(e.ledgerId),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetInfoResponse.ContractInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.contractAccountID=e.string();break;case 4:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 5:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 6:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 7:d.storage=e.int64();break;case 8:d.memo=e.string();break;case 9:d.balance=e.uint64();break;case 10:d.deleted=e.bool();break;case 11:d.tokenRelationships&&d.tokenRelationships.length||(d.tokenRelationships=[]),d.tokenRelationships.push($root.proto.TokenRelationship.decode(e,e.uint32()));break;case 12:d.ledgerId=e.bytes();break;default:e.skipType(7&i);}return d},e}(),e}(),ContractGetBytecodeQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.contractID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetBytecodeQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractGetBytecodeResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.bytecode=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.bytecode&&Object.hasOwnProperty.call(e,"bytecode")&&o.uint32(50).bytes(e.bytecode),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetBytecodeResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 6:d.bytecode=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ContractGetRecordsQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.contractID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetRecordsQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ContractGetRecordsResponse:function(){function e(e){if(this.records=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.contractID=null,e.prototype.records=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(18).fork()).ldelim(),null!=e.records&&e.records.length)for(var t=0;t<e.records.length;++t)$root.proto.TransactionRecord.encode(e.records[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ContractGetRecordsResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 3:d.records&&d.records.length||(d.records=[]),d.records.push($root.proto.TransactionRecord.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TransactionRecord:function(){function e(e){if(this.tokenTransferLists=[],this.assessedCustomFees=[],this.automaticTokenAssociations=[],this.cryptoAdjustments=[],this.nftAdjustments=[],this.tokenAdjustments=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.receipt=null,e.prototype.transactionHash=$util.newBuffer([]),e.prototype.consensusTimestamp=null,e.prototype.transactionID=null,e.prototype.memo="",e.prototype.transactionFee=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.contractCallResult=null,e.prototype.contractCreateResult=null,e.prototype.transferList=null,e.prototype.tokenTransferLists=$util.emptyArray,e.prototype.scheduleRef=null,e.prototype.assessedCustomFees=$util.emptyArray,e.prototype.automaticTokenAssociations=$util.emptyArray,e.prototype.parentConsensusTimestamp=null,e.prototype.alias=$util.newBuffer([]),e.prototype.cryptoAdjustments=$util.emptyArray,e.prototype.nftAdjustments=$util.emptyArray,e.prototype.tokenAdjustments=$util.emptyArray;let o;return Object.defineProperty(e.prototype,"body",{get:$util.oneOfGetter(o=["contractCallResult","contractCreateResult"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.receipt&&Object.hasOwnProperty.call(e,"receipt")&&$root.proto.TransactionReceipt.encode(e.receipt,o.uint32(10).fork()).ldelim(),null!=e.transactionHash&&Object.hasOwnProperty.call(e,"transactionHash")&&o.uint32(18).bytes(e.transactionHash),null!=e.consensusTimestamp&&Object.hasOwnProperty.call(e,"consensusTimestamp")&&$root.proto.Timestamp.encode(e.consensusTimestamp,o.uint32(26).fork()).ldelim(),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(34).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(42).string(e.memo),null!=e.transactionFee&&Object.hasOwnProperty.call(e,"transactionFee")&&o.uint32(48).uint64(e.transactionFee),null!=e.contractCallResult&&Object.hasOwnProperty.call(e,"contractCallResult")&&$root.proto.ContractFunctionResult.encode(e.contractCallResult,o.uint32(58).fork()).ldelim(),null!=e.contractCreateResult&&Object.hasOwnProperty.call(e,"contractCreateResult")&&$root.proto.ContractFunctionResult.encode(e.contractCreateResult,o.uint32(66).fork()).ldelim(),null!=e.transferList&&Object.hasOwnProperty.call(e,"transferList")&&$root.proto.TransferList.encode(e.transferList,o.uint32(82).fork()).ldelim(),null!=e.tokenTransferLists&&e.tokenTransferLists.length)for(var t=0;t<e.tokenTransferLists.length;++t)$root.proto.TokenTransferList.encode(e.tokenTransferLists[t],o.uint32(90).fork()).ldelim();if(null!=e.scheduleRef&&Object.hasOwnProperty.call(e,"scheduleRef")&&$root.proto.ScheduleID.encode(e.scheduleRef,o.uint32(98).fork()).ldelim(),null!=e.assessedCustomFees&&e.assessedCustomFees.length)for(var t=0;t<e.assessedCustomFees.length;++t)$root.proto.AssessedCustomFee.encode(e.assessedCustomFees[t],o.uint32(106).fork()).ldelim();if(null!=e.automaticTokenAssociations&&e.automaticTokenAssociations.length)for(var t=0;t<e.automaticTokenAssociations.length;++t)$root.proto.TokenAssociation.encode(e.automaticTokenAssociations[t],o.uint32(114).fork()).ldelim();if(null!=e.parentConsensusTimestamp&&Object.hasOwnProperty.call(e,"parentConsensusTimestamp")&&$root.proto.Timestamp.encode(e.parentConsensusTimestamp,o.uint32(122).fork()).ldelim(),null!=e.alias&&Object.hasOwnProperty.call(e,"alias")&&o.uint32(130).bytes(e.alias),null!=e.cryptoAdjustments&&e.cryptoAdjustments.length)for(var t=0;t<e.cryptoAdjustments.length;++t)$root.proto.CryptoAllowance.encode(e.cryptoAdjustments[t],o.uint32(138).fork()).ldelim();if(null!=e.nftAdjustments&&e.nftAdjustments.length)for(var t=0;t<e.nftAdjustments.length;++t)$root.proto.NftAllowance.encode(e.nftAdjustments[t],o.uint32(146).fork()).ldelim();if(null!=e.tokenAdjustments&&e.tokenAdjustments.length)for(var t=0;t<e.tokenAdjustments.length;++t)$root.proto.TokenAllowance.encode(e.tokenAdjustments[t],o.uint32(154).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionRecord,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.receipt=$root.proto.TransactionReceipt.decode(e,e.uint32());break;case 2:d.transactionHash=e.bytes();break;case 3:d.consensusTimestamp=$root.proto.Timestamp.decode(e,e.uint32());break;case 4:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 5:d.memo=e.string();break;case 6:d.transactionFee=e.uint64();break;case 7:d.contractCallResult=$root.proto.ContractFunctionResult.decode(e,e.uint32());break;case 8:d.contractCreateResult=$root.proto.ContractFunctionResult.decode(e,e.uint32());break;case 10:d.transferList=$root.proto.TransferList.decode(e,e.uint32());break;case 11:d.tokenTransferLists&&d.tokenTransferLists.length||(d.tokenTransferLists=[]),d.tokenTransferLists.push($root.proto.TokenTransferList.decode(e,e.uint32()));break;case 12:d.scheduleRef=$root.proto.ScheduleID.decode(e,e.uint32());break;case 13:d.assessedCustomFees&&d.assessedCustomFees.length||(d.assessedCustomFees=[]),d.assessedCustomFees.push($root.proto.AssessedCustomFee.decode(e,e.uint32()));break;case 14:d.automaticTokenAssociations&&d.automaticTokenAssociations.length||(d.automaticTokenAssociations=[]),d.automaticTokenAssociations.push($root.proto.TokenAssociation.decode(e,e.uint32()));break;case 15:d.parentConsensusTimestamp=$root.proto.Timestamp.decode(e,e.uint32());break;case 16:d.alias=e.bytes();break;case 17:d.cryptoAdjustments&&d.cryptoAdjustments.length||(d.cryptoAdjustments=[]),d.cryptoAdjustments.push($root.proto.CryptoAllowance.decode(e,e.uint32()));break;case 18:d.nftAdjustments&&d.nftAdjustments.length||(d.nftAdjustments=[]),d.nftAdjustments.push($root.proto.NftAllowance.decode(e,e.uint32()));break;case 19:d.tokenAdjustments&&d.tokenAdjustments.length||(d.tokenAdjustments=[]),d.tokenAdjustments.push($root.proto.TokenAllowance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TransactionReceipt:function(){function e(e){if(this.serialNumbers=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.status=0,e.prototype.accountID=null,e.prototype.fileID=null,e.prototype.contractID=null,e.prototype.exchangeRate=null,e.prototype.topicID=null,e.prototype.topicSequenceNumber=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.topicRunningHash=$util.newBuffer([]),e.prototype.topicRunningHashVersion=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.tokenID=null,e.prototype.newTotalSupply=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.scheduleID=null,e.prototype.scheduledTransactionID=null,e.prototype.serialNumbers=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.status&&Object.hasOwnProperty.call(e,"status")&&o.uint32(8).int32(e.status),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(26).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(34).fork()).ldelim(),null!=e.exchangeRate&&Object.hasOwnProperty.call(e,"exchangeRate")&&$root.proto.ExchangeRateSet.encode(e.exchangeRate,o.uint32(42).fork()).ldelim(),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(50).fork()).ldelim(),null!=e.topicSequenceNumber&&Object.hasOwnProperty.call(e,"topicSequenceNumber")&&o.uint32(56).uint64(e.topicSequenceNumber),null!=e.topicRunningHash&&Object.hasOwnProperty.call(e,"topicRunningHash")&&o.uint32(66).bytes(e.topicRunningHash),null!=e.topicRunningHashVersion&&Object.hasOwnProperty.call(e,"topicRunningHashVersion")&&o.uint32(72).uint64(e.topicRunningHashVersion),null!=e.tokenID&&Object.hasOwnProperty.call(e,"tokenID")&&$root.proto.TokenID.encode(e.tokenID,o.uint32(82).fork()).ldelim(),null!=e.newTotalSupply&&Object.hasOwnProperty.call(e,"newTotalSupply")&&o.uint32(88).uint64(e.newTotalSupply),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(98).fork()).ldelim(),null!=e.scheduledTransactionID&&Object.hasOwnProperty.call(e,"scheduledTransactionID")&&$root.proto.TransactionID.encode(e.scheduledTransactionID,o.uint32(106).fork()).ldelim(),null!=e.serialNumbers&&e.serialNumbers.length){o.uint32(114).fork();for(var t=0;t<e.serialNumbers.length;++t)o.int64(e.serialNumbers[t]);o.ldelim();}return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionReceipt,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.status=e.int32();break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 4:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;case 5:d.exchangeRate=$root.proto.ExchangeRateSet.decode(e,e.uint32());break;case 6:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 7:d.topicSequenceNumber=e.uint64();break;case 8:d.topicRunningHash=e.bytes();break;case 9:d.topicRunningHashVersion=e.uint64();break;case 10:d.tokenID=$root.proto.TokenID.decode(e,e.uint32());break;case 11:d.newTotalSupply=e.uint64();break;case 12:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;case 13:d.scheduledTransactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 14:if(d.serialNumbers&&d.serialNumbers.length||(d.serialNumbers=[]),2==(7&i))for(var a=e.uint32()+e.pos;e.pos<a;)d.serialNumbers.push(e.int64());else d.serialNumbers.push(e.int64());break;default:e.skipType(7&i);}return d},e}(),ExchangeRate:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.hbarEquiv=0,e.prototype.centEquiv=0,e.prototype.expirationTime=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.hbarEquiv&&Object.hasOwnProperty.call(e,"hbarEquiv")&&o.uint32(8).int32(e.hbarEquiv),null!=e.centEquiv&&Object.hasOwnProperty.call(e,"centEquiv")&&o.uint32(16).int32(e.centEquiv),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.TimestampSeconds.encode(e.expirationTime,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ExchangeRate,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.hbarEquiv=e.int32();break;case 2:d.centEquiv=e.int32();break;case 3:d.expirationTime=$root.proto.TimestampSeconds.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ExchangeRateSet:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.currentRate=null,e.prototype.nextRate=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.currentRate&&Object.hasOwnProperty.call(e,"currentRate")&&$root.proto.ExchangeRate.encode(e.currentRate,o.uint32(10).fork()).ldelim(),null!=e.nextRate&&Object.hasOwnProperty.call(e,"nextRate")&&$root.proto.ExchangeRate.encode(e.nextRate,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ExchangeRateSet,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.currentRate=$root.proto.ExchangeRate.decode(e,e.uint32());break;case 2:d.nextRate=$root.proto.ExchangeRate.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoGetAccountBalanceQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.header=null,e.prototype.accountID=null,e.prototype.contractID=null;let o;return Object.defineProperty(e.prototype,"balanceSource",{get:$util.oneOfGetter(o=["accountID","contractID"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.contractID&&Object.hasOwnProperty.call(e,"contractID")&&$root.proto.ContractID.encode(e.contractID,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetAccountBalanceQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.contractID=$root.proto.ContractID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoGetAccountBalanceResponse:function(){function e(e){if(this.tokenBalances=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.tokenBalances=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(24).uint64(e.balance),null!=e.tokenBalances&&e.tokenBalances.length)for(var t=0;t<e.tokenBalances.length;++t)$root.proto.TokenBalance.encode(e.tokenBalances[t],o.uint32(34).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetAccountBalanceResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.balance=e.uint64();break;case 4:d.tokenBalances&&d.tokenBalances.length||(d.tokenBalances=[]),d.tokenBalances.push($root.proto.TokenBalance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),CryptoGetAccountRecordsQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.accountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetAccountRecordsQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoGetAccountRecordsResponse:function(){function e(e){if(this.records=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.records=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.records&&e.records.length)for(var t=0;t<e.records.length;++t)$root.proto.TransactionRecord.encode(e.records[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetAccountRecordsResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.records&&d.records.length||(d.records=[]),d.records.push($root.proto.TransactionRecord.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),CryptoGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.accountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.accountInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountInfo&&Object.hasOwnProperty.call(e,"accountInfo")&&$root.proto.CryptoGetInfoResponse.AccountInfo.encode(e.accountInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.accountInfo=$root.proto.CryptoGetInfoResponse.AccountInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e.AccountInfo=function(){function e(e){if(this.liveHashes=[],this.tokenRelationships=[],this.grantedCryptoAllowances=[],this.grantedNftAllowances=[],this.grantedTokenAllowances=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.accountID=null,e.prototype.contractAccountID="",e.prototype.deleted=!1,e.prototype.proxyAccountID=null,e.prototype.proxyReceived=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.key=null,e.prototype.balance=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.generateSendRecordThreshold=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.generateReceiveRecordThreshold=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.receiverSigRequired=!1,e.prototype.expirationTime=null,e.prototype.autoRenewPeriod=null,e.prototype.liveHashes=$util.emptyArray,e.prototype.tokenRelationships=$util.emptyArray,e.prototype.memo="",e.prototype.ownedNfts=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.maxAutomaticTokenAssociations=0,e.prototype.alias=$util.newBuffer([]),e.prototype.ledgerId=$util.newBuffer([]),e.prototype.grantedCryptoAllowances=$util.emptyArray,e.prototype.grantedNftAllowances=$util.emptyArray,e.prototype.grantedTokenAllowances=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.contractAccountID&&Object.hasOwnProperty.call(e,"contractAccountID")&&o.uint32(18).string(e.contractAccountID),null!=e.deleted&&Object.hasOwnProperty.call(e,"deleted")&&o.uint32(24).bool(e.deleted),null!=e.proxyAccountID&&Object.hasOwnProperty.call(e,"proxyAccountID")&&$root.proto.AccountID.encode(e.proxyAccountID,o.uint32(34).fork()).ldelim(),null!=e.proxyReceived&&Object.hasOwnProperty.call(e,"proxyReceived")&&o.uint32(48).int64(e.proxyReceived),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&$root.proto.Key.encode(e.key,o.uint32(58).fork()).ldelim(),null!=e.balance&&Object.hasOwnProperty.call(e,"balance")&&o.uint32(64).uint64(e.balance),null!=e.generateSendRecordThreshold&&Object.hasOwnProperty.call(e,"generateSendRecordThreshold")&&o.uint32(72).uint64(e.generateSendRecordThreshold),null!=e.generateReceiveRecordThreshold&&Object.hasOwnProperty.call(e,"generateReceiveRecordThreshold")&&o.uint32(80).uint64(e.generateReceiveRecordThreshold),null!=e.receiverSigRequired&&Object.hasOwnProperty.call(e,"receiverSigRequired")&&o.uint32(88).bool(e.receiverSigRequired),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(98).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(106).fork()).ldelim(),null!=e.liveHashes&&e.liveHashes.length)for(var t=0;t<e.liveHashes.length;++t)$root.proto.LiveHash.encode(e.liveHashes[t],o.uint32(114).fork()).ldelim();if(null!=e.tokenRelationships&&e.tokenRelationships.length)for(var t=0;t<e.tokenRelationships.length;++t)$root.proto.TokenRelationship.encode(e.tokenRelationships[t],o.uint32(122).fork()).ldelim();if(null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(130).string(e.memo),null!=e.ownedNfts&&Object.hasOwnProperty.call(e,"ownedNfts")&&o.uint32(136).int64(e.ownedNfts),null!=e.maxAutomaticTokenAssociations&&Object.hasOwnProperty.call(e,"maxAutomaticTokenAssociations")&&o.uint32(144).int32(e.maxAutomaticTokenAssociations),null!=e.alias&&Object.hasOwnProperty.call(e,"alias")&&o.uint32(154).bytes(e.alias),null!=e.ledgerId&&Object.hasOwnProperty.call(e,"ledgerId")&&o.uint32(162).bytes(e.ledgerId),null!=e.grantedCryptoAllowances&&e.grantedCryptoAllowances.length)for(var t=0;t<e.grantedCryptoAllowances.length;++t)$root.proto.GrantedCryptoAllowance.encode(e.grantedCryptoAllowances[t],o.uint32(170).fork()).ldelim();if(null!=e.grantedNftAllowances&&e.grantedNftAllowances.length)for(var t=0;t<e.grantedNftAllowances.length;++t)$root.proto.GrantedNftAllowance.encode(e.grantedNftAllowances[t],o.uint32(178).fork()).ldelim();if(null!=e.grantedTokenAllowances&&e.grantedTokenAllowances.length)for(var t=0;t<e.grantedTokenAllowances.length;++t)$root.proto.GrantedTokenAllowance.encode(e.grantedTokenAllowances[t],o.uint32(186).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetInfoResponse.AccountInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.contractAccountID=e.string();break;case 3:d.deleted=e.bool();break;case 4:d.proxyAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 6:d.proxyReceived=e.int64();break;case 7:d.key=$root.proto.Key.decode(e,e.uint32());break;case 8:d.balance=e.uint64();break;case 9:d.generateSendRecordThreshold=e.uint64();break;case 10:d.generateReceiveRecordThreshold=e.uint64();break;case 11:d.receiverSigRequired=e.bool();break;case 12:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 13:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 14:d.liveHashes&&d.liveHashes.length||(d.liveHashes=[]),d.liveHashes.push($root.proto.LiveHash.decode(e,e.uint32()));break;case 15:d.tokenRelationships&&d.tokenRelationships.length||(d.tokenRelationships=[]),d.tokenRelationships.push($root.proto.TokenRelationship.decode(e,e.uint32()));break;case 16:d.memo=e.string();break;case 17:d.ownedNfts=e.int64();break;case 18:d.maxAutomaticTokenAssociations=e.int32();break;case 19:d.alias=e.bytes();break;case 20:d.ledgerId=e.bytes();break;case 21:d.grantedCryptoAllowances&&d.grantedCryptoAllowances.length||(d.grantedCryptoAllowances=[]),d.grantedCryptoAllowances.push($root.proto.GrantedCryptoAllowance.decode(e,e.uint32()));break;case 22:d.grantedNftAllowances&&d.grantedNftAllowances.length||(d.grantedNftAllowances=[]),d.grantedNftAllowances.push($root.proto.GrantedNftAllowance.decode(e,e.uint32()));break;case 23:d.grantedTokenAllowances&&d.grantedTokenAllowances.length||(d.grantedTokenAllowances=[]),d.grantedTokenAllowances.push($root.proto.GrantedTokenAllowance.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),e}(),CryptoGetLiveHashQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.hash=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.hash&&Object.hasOwnProperty.call(e,"hash")&&o.uint32(26).bytes(e.hash),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetLiveHashQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.hash=e.bytes();break;default:e.skipType(7&i);}return d},e}(),CryptoGetLiveHashResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.liveHash=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.liveHash&&Object.hasOwnProperty.call(e,"liveHash")&&$root.proto.LiveHash.encode(e.liveHash,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetLiveHashResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.liveHash=$root.proto.LiveHash.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoGetStakersQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.accountID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetStakersQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ProxyStaker:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.accountID=null,e.prototype.amount=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.amount&&Object.hasOwnProperty.call(e,"amount")&&o.uint32(16).int64(e.amount),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ProxyStaker,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.amount=e.int64();break;default:e.skipType(7&i);}return d},e}(),AllProxyStakers:function(){function e(e){if(this.proxyStaker=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.accountID=null,e.prototype.proxyStaker=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(10).fork()).ldelim(),null!=e.proxyStaker&&e.proxyStaker.length)for(var t=0;t<e.proxyStaker.length;++t)$root.proto.ProxyStaker.encode(e.proxyStaker[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AllProxyStakers,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 2:d.proxyStaker&&d.proxyStaker.length||(d.proxyStaker=[]),d.proxyStaker.push($root.proto.ProxyStaker.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),CryptoGetStakersResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.stakers=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.stakers&&Object.hasOwnProperty.call(e,"stakers")&&$root.proto.AllProxyStakers.encode(e.stakers,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.CryptoGetStakersResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 3:d.stakers=$root.proto.AllProxyStakers.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FileGetContentsQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.fileID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetContentsQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FileGetContentsResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.fileContents=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.fileContents&&Object.hasOwnProperty.call(e,"fileContents")&&$root.proto.FileGetContentsResponse.FileContents.encode(e.fileContents,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetContentsResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.fileContents=$root.proto.FileGetContentsResponse.FileContents.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e.FileContents=function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.fileID=null,e.prototype.contents=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.contents&&Object.hasOwnProperty.call(e,"contents")&&o.uint32(18).bytes(e.contents),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetContentsResponse.FileContents,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.contents=e.bytes();break;default:e.skipType(7&i);}return d},e}(),e}(),FileGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.fileID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),FileGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.fileInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.fileInfo&&Object.hasOwnProperty.call(e,"fileInfo")&&$root.proto.FileGetInfoResponse.FileInfo.encode(e.fileInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.fileInfo=$root.proto.FileGetInfoResponse.FileInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e.FileInfo=function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.fileID=null,e.prototype.size=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.expirationTime=null,e.prototype.deleted=!1,e.prototype.keys=null,e.prototype.memo="",e.prototype.ledgerId=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileID&&Object.hasOwnProperty.call(e,"fileID")&&$root.proto.FileID.encode(e.fileID,o.uint32(10).fork()).ldelim(),null!=e.size&&Object.hasOwnProperty.call(e,"size")&&o.uint32(16).int64(e.size),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(26).fork()).ldelim(),null!=e.deleted&&Object.hasOwnProperty.call(e,"deleted")&&o.uint32(32).bool(e.deleted),null!=e.keys&&Object.hasOwnProperty.call(e,"keys")&&$root.proto.KeyList.encode(e.keys,o.uint32(42).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(50).string(e.memo),null!=e.ledgerId&&Object.hasOwnProperty.call(e,"ledgerId")&&o.uint32(58).bytes(e.ledgerId),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FileGetInfoResponse.FileInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileID=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.size=e.int64();break;case 3:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 4:d.deleted=e.bool();break;case 5:d.keys=$root.proto.KeyList.decode(e,e.uint32());break;case 6:d.memo=e.string();break;case 7:d.ledgerId=e.bytes();break;default:e.skipType(7&i);}return d},e}(),e}(),TransactionGetReceiptQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.transactionID=null,e.prototype.includeDuplicates=!1,e.prototype.includeChildReceipts=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(18).fork()).ldelim(),null!=e.includeDuplicates&&Object.hasOwnProperty.call(e,"includeDuplicates")&&o.uint32(24).bool(e.includeDuplicates),null!=e.includeChildReceipts&&Object.hasOwnProperty.call(e,"includeChildReceipts")&&o.uint32(32).bool(e.includeChildReceipts),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetReceiptQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 3:d.includeDuplicates=e.bool();break;case 4:d.includeChildReceipts=e.bool();break;default:e.skipType(7&i);}return d},e}(),TransactionGetReceiptResponse:function(){function e(e){if(this.duplicateTransactionReceipts=[],this.childTransactionReceipts=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.receipt=null,e.prototype.duplicateTransactionReceipts=$util.emptyArray,e.prototype.childTransactionReceipts=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.receipt&&Object.hasOwnProperty.call(e,"receipt")&&$root.proto.TransactionReceipt.encode(e.receipt,o.uint32(18).fork()).ldelim(),null!=e.duplicateTransactionReceipts&&e.duplicateTransactionReceipts.length)for(var t=0;t<e.duplicateTransactionReceipts.length;++t)$root.proto.TransactionReceipt.encode(e.duplicateTransactionReceipts[t],o.uint32(34).fork()).ldelim();if(null!=e.childTransactionReceipts&&e.childTransactionReceipts.length)for(var t=0;t<e.childTransactionReceipts.length;++t)$root.proto.TransactionReceipt.encode(e.childTransactionReceipts[t],o.uint32(42).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetReceiptResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.receipt=$root.proto.TransactionReceipt.decode(e,e.uint32());break;case 4:d.duplicateTransactionReceipts&&d.duplicateTransactionReceipts.length||(d.duplicateTransactionReceipts=[]),d.duplicateTransactionReceipts.push($root.proto.TransactionReceipt.decode(e,e.uint32()));break;case 5:d.childTransactionReceipts&&d.childTransactionReceipts.length||(d.childTransactionReceipts=[]),d.childTransactionReceipts.push($root.proto.TransactionReceipt.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TransactionGetRecordQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.transactionID=null,e.prototype.includeDuplicates=!1,e.prototype.includeChildRecords=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(18).fork()).ldelim(),null!=e.includeDuplicates&&Object.hasOwnProperty.call(e,"includeDuplicates")&&o.uint32(24).bool(e.includeDuplicates),null!=e.includeChildRecords&&Object.hasOwnProperty.call(e,"includeChildRecords")&&o.uint32(32).bool(e.includeChildRecords),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetRecordQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 3:d.includeDuplicates=e.bool();break;case 4:d.includeChildRecords=e.bool();break;default:e.skipType(7&i);}return d},e}(),TransactionGetRecordResponse:function(){function e(e){if(this.duplicateTransactionRecords=[],this.childTransactionRecords=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.transactionRecord=null,e.prototype.duplicateTransactionRecords=$util.emptyArray,e.prototype.childTransactionRecords=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionRecord&&Object.hasOwnProperty.call(e,"transactionRecord")&&$root.proto.TransactionRecord.encode(e.transactionRecord,o.uint32(26).fork()).ldelim(),null!=e.duplicateTransactionRecords&&e.duplicateTransactionRecords.length)for(var t=0;t<e.duplicateTransactionRecords.length;++t)$root.proto.TransactionRecord.encode(e.duplicateTransactionRecords[t],o.uint32(34).fork()).ldelim();if(null!=e.childTransactionRecords&&e.childTransactionRecords.length)for(var t=0;t<e.childTransactionRecords.length;++t)$root.proto.TransactionRecord.encode(e.childTransactionRecords[t],o.uint32(42).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetRecordResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 3:d.transactionRecord=$root.proto.TransactionRecord.decode(e,e.uint32());break;case 4:d.duplicateTransactionRecords&&d.duplicateTransactionRecords.length||(d.duplicateTransactionRecords=[]),d.duplicateTransactionRecords.push($root.proto.TransactionRecord.decode(e,e.uint32()));break;case 5:d.childTransactionRecords&&d.childTransactionRecords.length||(d.childTransactionRecords=[]),d.childTransactionRecords.push($root.proto.TransactionRecord.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TransactionGetFastRecordQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.transactionID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionID&&Object.hasOwnProperty.call(e,"transactionID")&&$root.proto.TransactionID.encode(e.transactionID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetFastRecordQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.transactionID=$root.proto.TransactionID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TransactionGetFastRecordResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.transactionRecord=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionRecord&&Object.hasOwnProperty.call(e,"transactionRecord")&&$root.proto.TransactionRecord.encode(e.transactionRecord,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionGetFastRecordResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.transactionRecord=$root.proto.TransactionRecord.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),NetworkGetVersionInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NetworkGetVersionInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),NetworkGetVersionInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.hapiProtoVersion=null,e.prototype.hederaServicesVersion=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.hapiProtoVersion&&Object.hasOwnProperty.call(e,"hapiProtoVersion")&&$root.proto.SemanticVersion.encode(e.hapiProtoVersion,o.uint32(18).fork()).ldelim(),null!=e.hederaServicesVersion&&Object.hasOwnProperty.call(e,"hederaServicesVersion")&&$root.proto.SemanticVersion.encode(e.hederaServicesVersion,o.uint32(26).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NetworkGetVersionInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.hapiProtoVersion=$root.proto.SemanticVersion.decode(e,e.uint32());break;case 3:d.hederaServicesVersion=$root.proto.SemanticVersion.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),NetworkGetExecutionTimeQuery:function(){function e(e){if(this.transactionIds=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.transactionIds=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.transactionIds&&e.transactionIds.length)for(var t=0;t<e.transactionIds.length;++t)$root.proto.TransactionID.encode(e.transactionIds[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NetworkGetExecutionTimeQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.transactionIds&&d.transactionIds.length||(d.transactionIds=[]),d.transactionIds.push($root.proto.TransactionID.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),NetworkGetExecutionTimeResponse:function(){function e(e){if(this.executionTimes=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.executionTimes=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.executionTimes&&e.executionTimes.length){o.uint32(18).fork();for(var t=0;t<e.executionTimes.length;++t)o.uint64(e.executionTimes[t]);o.ldelim();}return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NetworkGetExecutionTimeResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:if(d.executionTimes&&d.executionTimes.length||(d.executionTimes=[]),2==(7&i))for(var a=e.uint32()+e.pos;e.pos<a;)d.executionTimes.push(e.uint64());else d.executionTimes.push(e.uint64());break;default:e.skipType(7&i);}return d},e}(),TokenGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.token=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.token&&Object.hasOwnProperty.call(e,"token")&&$root.proto.TokenID.encode(e.token,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.token=$root.proto.TokenID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenInfo:function(){function e(e){if(this.customFees=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenId=null,e.prototype.name="",e.prototype.symbol="",e.prototype.decimals=0,e.prototype.totalSupply=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.treasury=null,e.prototype.adminKey=null,e.prototype.kycKey=null,e.prototype.freezeKey=null,e.prototype.wipeKey=null,e.prototype.supplyKey=null,e.prototype.defaultFreezeStatus=0,e.prototype.defaultKycStatus=0,e.prototype.deleted=!1,e.prototype.autoRenewAccount=null,e.prototype.autoRenewPeriod=null,e.prototype.expiry=null,e.prototype.memo="",e.prototype.tokenType=0,e.prototype.supplyType=0,e.prototype.maxSupply=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.feeScheduleKey=null,e.prototype.customFees=$util.emptyArray,e.prototype.pauseKey=null,e.prototype.pauseStatus=0,e.prototype.ledgerId=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.tokenId&&Object.hasOwnProperty.call(e,"tokenId")&&$root.proto.TokenID.encode(e.tokenId,o.uint32(10).fork()).ldelim(),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(18).string(e.name),null!=e.symbol&&Object.hasOwnProperty.call(e,"symbol")&&o.uint32(26).string(e.symbol),null!=e.decimals&&Object.hasOwnProperty.call(e,"decimals")&&o.uint32(32).uint32(e.decimals),null!=e.totalSupply&&Object.hasOwnProperty.call(e,"totalSupply")&&o.uint32(40).uint64(e.totalSupply),null!=e.treasury&&Object.hasOwnProperty.call(e,"treasury")&&$root.proto.AccountID.encode(e.treasury,o.uint32(50).fork()).ldelim(),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(58).fork()).ldelim(),null!=e.kycKey&&Object.hasOwnProperty.call(e,"kycKey")&&$root.proto.Key.encode(e.kycKey,o.uint32(66).fork()).ldelim(),null!=e.freezeKey&&Object.hasOwnProperty.call(e,"freezeKey")&&$root.proto.Key.encode(e.freezeKey,o.uint32(74).fork()).ldelim(),null!=e.wipeKey&&Object.hasOwnProperty.call(e,"wipeKey")&&$root.proto.Key.encode(e.wipeKey,o.uint32(82).fork()).ldelim(),null!=e.supplyKey&&Object.hasOwnProperty.call(e,"supplyKey")&&$root.proto.Key.encode(e.supplyKey,o.uint32(90).fork()).ldelim(),null!=e.defaultFreezeStatus&&Object.hasOwnProperty.call(e,"defaultFreezeStatus")&&o.uint32(96).int32(e.defaultFreezeStatus),null!=e.defaultKycStatus&&Object.hasOwnProperty.call(e,"defaultKycStatus")&&o.uint32(104).int32(e.defaultKycStatus),null!=e.deleted&&Object.hasOwnProperty.call(e,"deleted")&&o.uint32(112).bool(e.deleted),null!=e.autoRenewAccount&&Object.hasOwnProperty.call(e,"autoRenewAccount")&&$root.proto.AccountID.encode(e.autoRenewAccount,o.uint32(122).fork()).ldelim(),null!=e.autoRenewPeriod&&Object.hasOwnProperty.call(e,"autoRenewPeriod")&&$root.proto.Duration.encode(e.autoRenewPeriod,o.uint32(130).fork()).ldelim(),null!=e.expiry&&Object.hasOwnProperty.call(e,"expiry")&&$root.proto.Timestamp.encode(e.expiry,o.uint32(138).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(146).string(e.memo),null!=e.tokenType&&Object.hasOwnProperty.call(e,"tokenType")&&o.uint32(152).int32(e.tokenType),null!=e.supplyType&&Object.hasOwnProperty.call(e,"supplyType")&&o.uint32(160).int32(e.supplyType),null!=e.maxSupply&&Object.hasOwnProperty.call(e,"maxSupply")&&o.uint32(168).int64(e.maxSupply),null!=e.feeScheduleKey&&Object.hasOwnProperty.call(e,"feeScheduleKey")&&$root.proto.Key.encode(e.feeScheduleKey,o.uint32(178).fork()).ldelim(),null!=e.customFees&&e.customFees.length)for(var t=0;t<e.customFees.length;++t)$root.proto.CustomFee.encode(e.customFees[t],o.uint32(186).fork()).ldelim();return null!=e.pauseKey&&Object.hasOwnProperty.call(e,"pauseKey")&&$root.proto.Key.encode(e.pauseKey,o.uint32(194).fork()).ldelim(),null!=e.pauseStatus&&Object.hasOwnProperty.call(e,"pauseStatus")&&o.uint32(200).int32(e.pauseStatus),null!=e.ledgerId&&Object.hasOwnProperty.call(e,"ledgerId")&&o.uint32(210).bytes(e.ledgerId),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenId=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.name=e.string();break;case 3:d.symbol=e.string();break;case 4:d.decimals=e.uint32();break;case 5:d.totalSupply=e.uint64();break;case 6:d.treasury=$root.proto.AccountID.decode(e,e.uint32());break;case 7:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.kycKey=$root.proto.Key.decode(e,e.uint32());break;case 9:d.freezeKey=$root.proto.Key.decode(e,e.uint32());break;case 10:d.wipeKey=$root.proto.Key.decode(e,e.uint32());break;case 11:d.supplyKey=$root.proto.Key.decode(e,e.uint32());break;case 12:d.defaultFreezeStatus=e.int32();break;case 13:d.defaultKycStatus=e.int32();break;case 14:d.deleted=e.bool();break;case 15:d.autoRenewAccount=$root.proto.AccountID.decode(e,e.uint32());break;case 16:d.autoRenewPeriod=$root.proto.Duration.decode(e,e.uint32());break;case 17:d.expiry=$root.proto.Timestamp.decode(e,e.uint32());break;case 18:d.memo=e.string();break;case 19:d.tokenType=e.int32();break;case 20:d.supplyType=e.int32();break;case 21:d.maxSupply=e.int64();break;case 22:d.feeScheduleKey=$root.proto.Key.decode(e,e.uint32());break;case 23:d.customFees&&d.customFees.length||(d.customFees=[]),d.customFees.push($root.proto.CustomFee.decode(e,e.uint32()));break;case 24:d.pauseKey=$root.proto.Key.decode(e,e.uint32());break;case 25:d.pauseStatus=e.int32();break;case 26:d.ledgerId=e.bytes();break;default:e.skipType(7&i);}return d},e}(),TokenGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.tokenInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.tokenInfo&&Object.hasOwnProperty.call(e,"tokenInfo")&&$root.proto.TokenInfo.encode(e.tokenInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.tokenInfo=$root.proto.TokenInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ScheduleGetInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.scheduleID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleGetInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),ScheduleInfo:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.scheduleID=null,e.prototype.deletionTime=null,e.prototype.executionTime=null,e.prototype.expirationTime=null,e.prototype.scheduledTransactionBody=null,e.prototype.memo="",e.prototype.adminKey=null,e.prototype.signers=null,e.prototype.creatorAccountID=null,e.prototype.payerAccountID=null,e.prototype.scheduledTransactionID=null,e.prototype.ledgerId=$util.newBuffer([]);let o;return Object.defineProperty(e.prototype,"data",{get:$util.oneOfGetter(o=["deletionTime","executionTime"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.scheduleID&&Object.hasOwnProperty.call(e,"scheduleID")&&$root.proto.ScheduleID.encode(e.scheduleID,o.uint32(10).fork()).ldelim(),null!=e.deletionTime&&Object.hasOwnProperty.call(e,"deletionTime")&&$root.proto.Timestamp.encode(e.deletionTime,o.uint32(18).fork()).ldelim(),null!=e.executionTime&&Object.hasOwnProperty.call(e,"executionTime")&&$root.proto.Timestamp.encode(e.executionTime,o.uint32(26).fork()).ldelim(),null!=e.expirationTime&&Object.hasOwnProperty.call(e,"expirationTime")&&$root.proto.Timestamp.encode(e.expirationTime,o.uint32(34).fork()).ldelim(),null!=e.scheduledTransactionBody&&Object.hasOwnProperty.call(e,"scheduledTransactionBody")&&$root.proto.SchedulableTransactionBody.encode(e.scheduledTransactionBody,o.uint32(42).fork()).ldelim(),null!=e.memo&&Object.hasOwnProperty.call(e,"memo")&&o.uint32(50).string(e.memo),null!=e.adminKey&&Object.hasOwnProperty.call(e,"adminKey")&&$root.proto.Key.encode(e.adminKey,o.uint32(58).fork()).ldelim(),null!=e.signers&&Object.hasOwnProperty.call(e,"signers")&&$root.proto.KeyList.encode(e.signers,o.uint32(66).fork()).ldelim(),null!=e.creatorAccountID&&Object.hasOwnProperty.call(e,"creatorAccountID")&&$root.proto.AccountID.encode(e.creatorAccountID,o.uint32(74).fork()).ldelim(),null!=e.payerAccountID&&Object.hasOwnProperty.call(e,"payerAccountID")&&$root.proto.AccountID.encode(e.payerAccountID,o.uint32(82).fork()).ldelim(),null!=e.scheduledTransactionID&&Object.hasOwnProperty.call(e,"scheduledTransactionID")&&$root.proto.TransactionID.encode(e.scheduledTransactionID,o.uint32(90).fork()).ldelim(),null!=e.ledgerId&&Object.hasOwnProperty.call(e,"ledgerId")&&o.uint32(98).bytes(e.ledgerId),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.scheduleID=$root.proto.ScheduleID.decode(e,e.uint32());break;case 2:d.deletionTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.executionTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 4:d.expirationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 5:d.scheduledTransactionBody=$root.proto.SchedulableTransactionBody.decode(e,e.uint32());break;case 6:d.memo=e.string();break;case 7:d.adminKey=$root.proto.Key.decode(e,e.uint32());break;case 8:d.signers=$root.proto.KeyList.decode(e,e.uint32());break;case 9:d.creatorAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 10:d.payerAccountID=$root.proto.AccountID.decode(e,e.uint32());break;case 11:d.scheduledTransactionID=$root.proto.TransactionID.decode(e,e.uint32());break;case 12:d.ledgerId=e.bytes();break;default:e.skipType(7&i);}return d},e}(),ScheduleGetInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.scheduleInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.scheduleInfo&&Object.hasOwnProperty.call(e,"scheduleInfo")&&$root.proto.ScheduleInfo.encode(e.scheduleInfo,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ScheduleGetInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.scheduleInfo=$root.proto.ScheduleInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenGetAccountNftInfosQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.accountID=null,e.prototype.start=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.end=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.start&&Object.hasOwnProperty.call(e,"start")&&o.uint32(24).int64(e.start),null!=e.end&&Object.hasOwnProperty.call(e,"end")&&o.uint32(32).int64(e.end),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetAccountNftInfosQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.start=e.int64();break;case 4:d.end=e.int64();break;default:e.skipType(7&i);}return d},e}(),TokenGetAccountNftInfosResponse:function(){function e(e){if(this.nfts=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.nfts=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.nfts&&e.nfts.length)for(var t=0;t<e.nfts.length;++t)$root.proto.TokenNftInfo.encode(e.nfts[t],o.uint32(18).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetAccountNftInfosResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.nfts&&d.nfts.length||(d.nfts=[]),d.nfts.push($root.proto.TokenNftInfo.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),NftID:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.tokenID=null,e.prototype.serialNumber=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.tokenID&&Object.hasOwnProperty.call(e,"tokenID")&&$root.proto.TokenID.encode(e.tokenID,o.uint32(10).fork()).ldelim(),null!=e.serialNumber&&Object.hasOwnProperty.call(e,"serialNumber")&&o.uint32(16).int64(e.serialNumber),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.NftID,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.tokenID=$root.proto.TokenID.decode(e,e.uint32());break;case 2:d.serialNumber=e.int64();break;default:e.skipType(7&i);}return d},e}(),TokenGetNftInfoQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.nftID=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.nftID&&Object.hasOwnProperty.call(e,"nftID")&&$root.proto.NftID.encode(e.nftID,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetNftInfoQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.nftID=$root.proto.NftID.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenNftInfo:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.nftID=null,e.prototype.accountID=null,e.prototype.creationTime=null,e.prototype.metadata=$util.newBuffer([]),e.prototype.ledgerId=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.nftID&&Object.hasOwnProperty.call(e,"nftID")&&$root.proto.NftID.encode(e.nftID,o.uint32(10).fork()).ldelim(),null!=e.accountID&&Object.hasOwnProperty.call(e,"accountID")&&$root.proto.AccountID.encode(e.accountID,o.uint32(18).fork()).ldelim(),null!=e.creationTime&&Object.hasOwnProperty.call(e,"creationTime")&&$root.proto.Timestamp.encode(e.creationTime,o.uint32(26).fork()).ldelim(),null!=e.metadata&&Object.hasOwnProperty.call(e,"metadata")&&o.uint32(34).bytes(e.metadata),null!=e.ledgerId&&Object.hasOwnProperty.call(e,"ledgerId")&&o.uint32(42).bytes(e.ledgerId),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenNftInfo,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.nftID=$root.proto.NftID.decode(e,e.uint32());break;case 2:d.accountID=$root.proto.AccountID.decode(e,e.uint32());break;case 3:d.creationTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 4:d.metadata=e.bytes();break;case 5:d.ledgerId=e.bytes();break;default:e.skipType(7&i);}return d},e}(),TokenGetNftInfoResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.nft=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.nft&&Object.hasOwnProperty.call(e,"nft")&&$root.proto.TokenNftInfo.encode(e.nft,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetNftInfoResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.nft=$root.proto.TokenNftInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TokenGetNftInfosQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.tokenID=null,e.prototype.start=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.end=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.QueryHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.tokenID&&Object.hasOwnProperty.call(e,"tokenID")&&$root.proto.TokenID.encode(e.tokenID,o.uint32(18).fork()).ldelim(),null!=e.start&&Object.hasOwnProperty.call(e,"start")&&o.uint32(24).int64(e.start),null!=e.end&&Object.hasOwnProperty.call(e,"end")&&o.uint32(32).int64(e.end),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetNftInfosQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.QueryHeader.decode(e,e.uint32());break;case 2:d.tokenID=$root.proto.TokenID.decode(e,e.uint32());break;case 3:d.start=e.int64();break;case 4:d.end=e.int64();break;default:e.skipType(7&i);}return d},e}(),TokenGetNftInfosResponse:function(){function e(e){if(this.nfts=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.header=null,e.prototype.tokenID=null,e.prototype.nfts=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.header&&Object.hasOwnProperty.call(e,"header")&&$root.proto.ResponseHeader.encode(e.header,o.uint32(10).fork()).ldelim(),null!=e.tokenID&&Object.hasOwnProperty.call(e,"tokenID")&&$root.proto.TokenID.encode(e.tokenID,o.uint32(18).fork()).ldelim(),null!=e.nfts&&e.nfts.length)for(var t=0;t<e.nfts.length;++t)$root.proto.TokenNftInfo.encode(e.nfts[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TokenGetNftInfosResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.header=$root.proto.ResponseHeader.decode(e,e.uint32());break;case 2:d.tokenID=$root.proto.TokenID.decode(e,e.uint32());break;case 3:d.nfts&&d.nfts.length||(d.nfts=[]),d.nfts.push($root.proto.TokenNftInfo.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),Response:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}e.prototype.getByKey=null,e.prototype.getBySolidityID=null,e.prototype.contractCallLocal=null,e.prototype.contractGetBytecodeResponse=null,e.prototype.contractGetInfo=null,e.prototype.contractGetRecordsResponse=null,e.prototype.cryptogetAccountBalance=null,e.prototype.cryptoGetAccountRecords=null,e.prototype.cryptoGetInfo=null,e.prototype.cryptoGetLiveHash=null,e.prototype.cryptoGetProxyStakers=null,e.prototype.fileGetContents=null,e.prototype.fileGetInfo=null,e.prototype.transactionGetReceipt=null,e.prototype.transactionGetRecord=null,e.prototype.transactionGetFastRecord=null,e.prototype.consensusGetTopicInfo=null,e.prototype.networkGetVersionInfo=null,e.prototype.tokenGetInfo=null,e.prototype.scheduleGetInfo=null,e.prototype.tokenGetAccountNftInfos=null,e.prototype.tokenGetNftInfo=null,e.prototype.tokenGetNftInfos=null,e.prototype.networkGetExecutionTime=null;let o;return Object.defineProperty(e.prototype,"response",{get:$util.oneOfGetter(o=["getByKey","getBySolidityID","contractCallLocal","contractGetBytecodeResponse","contractGetInfo","contractGetRecordsResponse","cryptogetAccountBalance","cryptoGetAccountRecords","cryptoGetInfo","cryptoGetLiveHash","cryptoGetProxyStakers","fileGetContents","fileGetInfo","transactionGetReceipt","transactionGetRecord","transactionGetFastRecord","consensusGetTopicInfo","networkGetVersionInfo","tokenGetInfo","scheduleGetInfo","tokenGetAccountNftInfos","tokenGetNftInfo","tokenGetNftInfos","networkGetExecutionTime"]),set:$util.oneOfSetter(o)}),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.getByKey&&Object.hasOwnProperty.call(e,"getByKey")&&$root.proto.GetByKeyResponse.encode(e.getByKey,o.uint32(10).fork()).ldelim(),null!=e.getBySolidityID&&Object.hasOwnProperty.call(e,"getBySolidityID")&&$root.proto.GetBySolidityIDResponse.encode(e.getBySolidityID,o.uint32(18).fork()).ldelim(),null!=e.contractCallLocal&&Object.hasOwnProperty.call(e,"contractCallLocal")&&$root.proto.ContractCallLocalResponse.encode(e.contractCallLocal,o.uint32(26).fork()).ldelim(),null!=e.contractGetInfo&&Object.hasOwnProperty.call(e,"contractGetInfo")&&$root.proto.ContractGetInfoResponse.encode(e.contractGetInfo,o.uint32(34).fork()).ldelim(),null!=e.contractGetBytecodeResponse&&Object.hasOwnProperty.call(e,"contractGetBytecodeResponse")&&$root.proto.ContractGetBytecodeResponse.encode(e.contractGetBytecodeResponse,o.uint32(42).fork()).ldelim(),null!=e.contractGetRecordsResponse&&Object.hasOwnProperty.call(e,"contractGetRecordsResponse")&&$root.proto.ContractGetRecordsResponse.encode(e.contractGetRecordsResponse,o.uint32(50).fork()).ldelim(),null!=e.cryptogetAccountBalance&&Object.hasOwnProperty.call(e,"cryptogetAccountBalance")&&$root.proto.CryptoGetAccountBalanceResponse.encode(e.cryptogetAccountBalance,o.uint32(58).fork()).ldelim(),null!=e.cryptoGetAccountRecords&&Object.hasOwnProperty.call(e,"cryptoGetAccountRecords")&&$root.proto.CryptoGetAccountRecordsResponse.encode(e.cryptoGetAccountRecords,o.uint32(66).fork()).ldelim(),null!=e.cryptoGetInfo&&Object.hasOwnProperty.call(e,"cryptoGetInfo")&&$root.proto.CryptoGetInfoResponse.encode(e.cryptoGetInfo,o.uint32(74).fork()).ldelim(),null!=e.cryptoGetLiveHash&&Object.hasOwnProperty.call(e,"cryptoGetLiveHash")&&$root.proto.CryptoGetLiveHashResponse.encode(e.cryptoGetLiveHash,o.uint32(82).fork()).ldelim(),null!=e.cryptoGetProxyStakers&&Object.hasOwnProperty.call(e,"cryptoGetProxyStakers")&&$root.proto.CryptoGetStakersResponse.encode(e.cryptoGetProxyStakers,o.uint32(90).fork()).ldelim(),null!=e.fileGetContents&&Object.hasOwnProperty.call(e,"fileGetContents")&&$root.proto.FileGetContentsResponse.encode(e.fileGetContents,o.uint32(98).fork()).ldelim(),null!=e.fileGetInfo&&Object.hasOwnProperty.call(e,"fileGetInfo")&&$root.proto.FileGetInfoResponse.encode(e.fileGetInfo,o.uint32(106).fork()).ldelim(),null!=e.transactionGetReceipt&&Object.hasOwnProperty.call(e,"transactionGetReceipt")&&$root.proto.TransactionGetReceiptResponse.encode(e.transactionGetReceipt,o.uint32(114).fork()).ldelim(),null!=e.transactionGetRecord&&Object.hasOwnProperty.call(e,"transactionGetRecord")&&$root.proto.TransactionGetRecordResponse.encode(e.transactionGetRecord,o.uint32(122).fork()).ldelim(),null!=e.transactionGetFastRecord&&Object.hasOwnProperty.call(e,"transactionGetFastRecord")&&$root.proto.TransactionGetFastRecordResponse.encode(e.transactionGetFastRecord,o.uint32(130).fork()).ldelim(),null!=e.consensusGetTopicInfo&&Object.hasOwnProperty.call(e,"consensusGetTopicInfo")&&$root.proto.ConsensusGetTopicInfoResponse.encode(e.consensusGetTopicInfo,o.uint32(1202).fork()).ldelim(),null!=e.networkGetVersionInfo&&Object.hasOwnProperty.call(e,"networkGetVersionInfo")&&$root.proto.NetworkGetVersionInfoResponse.encode(e.networkGetVersionInfo,o.uint32(1210).fork()).ldelim(),null!=e.tokenGetInfo&&Object.hasOwnProperty.call(e,"tokenGetInfo")&&$root.proto.TokenGetInfoResponse.encode(e.tokenGetInfo,o.uint32(1218).fork()).ldelim(),null!=e.scheduleGetInfo&&Object.hasOwnProperty.call(e,"scheduleGetInfo")&&$root.proto.ScheduleGetInfoResponse.encode(e.scheduleGetInfo,o.uint32(1226).fork()).ldelim(),null!=e.tokenGetAccountNftInfos&&Object.hasOwnProperty.call(e,"tokenGetAccountNftInfos")&&$root.proto.TokenGetAccountNftInfosResponse.encode(e.tokenGetAccountNftInfos,o.uint32(1234).fork()).ldelim(),null!=e.tokenGetNftInfo&&Object.hasOwnProperty.call(e,"tokenGetNftInfo")&&$root.proto.TokenGetNftInfoResponse.encode(e.tokenGetNftInfo,o.uint32(1242).fork()).ldelim(),null!=e.tokenGetNftInfos&&Object.hasOwnProperty.call(e,"tokenGetNftInfos")&&$root.proto.TokenGetNftInfosResponse.encode(e.tokenGetNftInfos,o.uint32(1250).fork()).ldelim(),null!=e.networkGetExecutionTime&&Object.hasOwnProperty.call(e,"networkGetExecutionTime")&&$root.proto.NetworkGetExecutionTimeResponse.encode(e.networkGetExecutionTime,o.uint32(1258).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Response,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.getByKey=$root.proto.GetByKeyResponse.decode(e,e.uint32());break;case 2:d.getBySolidityID=$root.proto.GetBySolidityIDResponse.decode(e,e.uint32());break;case 3:d.contractCallLocal=$root.proto.ContractCallLocalResponse.decode(e,e.uint32());break;case 5:d.contractGetBytecodeResponse=$root.proto.ContractGetBytecodeResponse.decode(e,e.uint32());break;case 4:d.contractGetInfo=$root.proto.ContractGetInfoResponse.decode(e,e.uint32());break;case 6:d.contractGetRecordsResponse=$root.proto.ContractGetRecordsResponse.decode(e,e.uint32());break;case 7:d.cryptogetAccountBalance=$root.proto.CryptoGetAccountBalanceResponse.decode(e,e.uint32());break;case 8:d.cryptoGetAccountRecords=$root.proto.CryptoGetAccountRecordsResponse.decode(e,e.uint32());break;case 9:d.cryptoGetInfo=$root.proto.CryptoGetInfoResponse.decode(e,e.uint32());break;case 10:d.cryptoGetLiveHash=$root.proto.CryptoGetLiveHashResponse.decode(e,e.uint32());break;case 11:d.cryptoGetProxyStakers=$root.proto.CryptoGetStakersResponse.decode(e,e.uint32());break;case 12:d.fileGetContents=$root.proto.FileGetContentsResponse.decode(e,e.uint32());break;case 13:d.fileGetInfo=$root.proto.FileGetInfoResponse.decode(e,e.uint32());break;case 14:d.transactionGetReceipt=$root.proto.TransactionGetReceiptResponse.decode(e,e.uint32());break;case 15:d.transactionGetRecord=$root.proto.TransactionGetRecordResponse.decode(e,e.uint32());break;case 16:d.transactionGetFastRecord=$root.proto.TransactionGetFastRecordResponse.decode(e,e.uint32());break;case 150:d.consensusGetTopicInfo=$root.proto.ConsensusGetTopicInfoResponse.decode(e,e.uint32());break;case 151:d.networkGetVersionInfo=$root.proto.NetworkGetVersionInfoResponse.decode(e,e.uint32());break;case 152:d.tokenGetInfo=$root.proto.TokenGetInfoResponse.decode(e,e.uint32());break;case 153:d.scheduleGetInfo=$root.proto.ScheduleGetInfoResponse.decode(e,e.uint32());break;case 154:d.tokenGetAccountNftInfos=$root.proto.TokenGetAccountNftInfosResponse.decode(e,e.uint32());break;case 155:d.tokenGetNftInfo=$root.proto.TokenGetNftInfoResponse.decode(e,e.uint32());break;case 156:d.tokenGetNftInfos=$root.proto.TokenGetNftInfosResponse.decode(e,e.uint32());break;case 157:d.networkGetExecutionTime=$root.proto.NetworkGetExecutionTimeResponse.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),CryptoService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createAccount=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"createAccount"}),Object.defineProperty(e.prototype.updateAccount=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"updateAccount"}),Object.defineProperty(e.prototype.cryptoTransfer=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"cryptoTransfer"}),Object.defineProperty(e.prototype.cryptoDelete=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"cryptoDelete"}),Object.defineProperty(e.prototype.approveAllowances=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"approveAllowances"}),Object.defineProperty(e.prototype.adjustAllowance=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"adjustAllowance"}),Object.defineProperty(e.prototype.addLiveHash=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"addLiveHash"}),Object.defineProperty(e.prototype.deleteLiveHash=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"deleteLiveHash"}),Object.defineProperty(e.prototype.getLiveHash=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getLiveHash"}),Object.defineProperty(e.prototype.getAccountRecords=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getAccountRecords"}),Object.defineProperty(e.prototype.cryptoGetBalance=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"cryptoGetBalance"}),Object.defineProperty(e.prototype.getAccountInfo=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getAccountInfo"}),Object.defineProperty(e.prototype.getTransactionReceipts=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getTransactionReceipts"}),Object.defineProperty(e.prototype.getFastTransactionRecord=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getFastTransactionRecord"}),Object.defineProperty(e.prototype.getTxRecordByTxID=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getTxRecordByTxID"}),Object.defineProperty(e.prototype.getStakersByAccountID=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getStakersByAccountID"}),e}(),FileService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createFile=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"createFile"}),Object.defineProperty(e.prototype.updateFile=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"updateFile"}),Object.defineProperty(e.prototype.deleteFile=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"deleteFile"}),Object.defineProperty(e.prototype.appendContent=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"appendContent"}),Object.defineProperty(e.prototype.getFileContent=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getFileContent"}),Object.defineProperty(e.prototype.getFileInfo=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getFileInfo"}),Object.defineProperty(e.prototype.systemDelete=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"systemDelete"}),Object.defineProperty(e.prototype.systemUndelete=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"systemUndelete"}),e}(),FreezeService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.freeze=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"freeze"}),e}(),ConsensusTopicQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.topicID=null,e.prototype.consensusStartTime=null,e.prototype.consensusEndTime=null,e.prototype.limit=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&$root.proto.TopicID.encode(e.topicID,o.uint32(10).fork()).ldelim(),null!=e.consensusStartTime&&Object.hasOwnProperty.call(e,"consensusStartTime")&&$root.proto.Timestamp.encode(e.consensusStartTime,o.uint32(18).fork()).ldelim(),null!=e.consensusEndTime&&Object.hasOwnProperty.call(e,"consensusEndTime")&&$root.proto.Timestamp.encode(e.consensusEndTime,o.uint32(26).fork()).ldelim(),null!=e.limit&&Object.hasOwnProperty.call(e,"limit")&&o.uint32(32).uint64(e.limit),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusTopicQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.topicID=$root.proto.TopicID.decode(e,e.uint32());break;case 2:d.consensusStartTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 3:d.consensusEndTime=$root.proto.Timestamp.decode(e,e.uint32());break;case 4:d.limit=e.uint64();break;default:e.skipType(7&i);}return d},e}(),ConsensusTopicResponse:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.consensusTimestamp=null,e.prototype.message=$util.newBuffer([]),e.prototype.runningHash=$util.newBuffer([]),e.prototype.sequenceNumber=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.runningHashVersion=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.chunkInfo=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.consensusTimestamp&&Object.hasOwnProperty.call(e,"consensusTimestamp")&&$root.proto.Timestamp.encode(e.consensusTimestamp,o.uint32(10).fork()).ldelim(),null!=e.message&&Object.hasOwnProperty.call(e,"message")&&o.uint32(18).bytes(e.message),null!=e.runningHash&&Object.hasOwnProperty.call(e,"runningHash")&&o.uint32(26).bytes(e.runningHash),null!=e.sequenceNumber&&Object.hasOwnProperty.call(e,"sequenceNumber")&&o.uint32(32).uint64(e.sequenceNumber),null!=e.runningHashVersion&&Object.hasOwnProperty.call(e,"runningHashVersion")&&o.uint32(40).uint64(e.runningHashVersion),null!=e.chunkInfo&&Object.hasOwnProperty.call(e,"chunkInfo")&&$root.proto.ConsensusMessageChunkInfo.encode(e.chunkInfo,o.uint32(50).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ConsensusTopicResponse,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.consensusTimestamp=$root.proto.Timestamp.decode(e,e.uint32());break;case 2:d.message=e.bytes();break;case 3:d.runningHash=e.bytes();break;case 4:d.sequenceNumber=e.uint64();break;case 5:d.runningHashVersion=e.uint64();break;case 6:d.chunkInfo=$root.proto.ConsensusMessageChunkInfo.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),MirrorConsensusService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.subscribeTopic=function t(e,o){return this.rpcCall(t,$root.proto.ConsensusTopicQuery,$root.proto.ConsensusTopicResponse,e,o)},"name",{value:"subscribeTopic"}),e}(),AddressBookQuery:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.fileId=null,e.prototype.limit=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.fileId&&Object.hasOwnProperty.call(e,"fileId")&&$root.proto.FileID.encode(e.fileId,o.uint32(10).fork()).ldelim(),null!=e.limit&&Object.hasOwnProperty.call(e,"limit")&&o.uint32(16).int32(e.limit),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.AddressBookQuery,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.fileId=$root.proto.FileID.decode(e,e.uint32());break;case 2:d.limit=e.int32();break;default:e.skipType(7&i);}return d},e}(),MirrorNetworkService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.getNodes=function t(e,o){return this.rpcCall(t,$root.proto.AddressBookQuery,$root.proto.NodeAddress,e,o)},"name",{value:"getNodes"}),e}(),NetworkService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.getVersionInfo=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getVersionInfo"}),Object.defineProperty(e.prototype.getExecutionTime=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getExecutionTime"}),Object.defineProperty(e.prototype.uncheckedSubmit=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"uncheckedSubmit"}),e}(),ScheduleService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createSchedule=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"createSchedule"}),Object.defineProperty(e.prototype.signSchedule=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"signSchedule"}),Object.defineProperty(e.prototype.deleteSchedule=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"deleteSchedule"}),Object.defineProperty(e.prototype.getScheduleInfo=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getScheduleInfo"}),e}(),SmartContractService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createContract=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"createContract"}),Object.defineProperty(e.prototype.updateContract=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"updateContract"}),Object.defineProperty(e.prototype.contractCallMethod=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"contractCallMethod"}),Object.defineProperty(e.prototype.getContractInfo=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getContractInfo"}),Object.defineProperty(e.prototype.contractCallLocalMethod=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"contractCallLocalMethod"}),Object.defineProperty(e.prototype.contractGetBytecode=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"ContractGetBytecode"}),Object.defineProperty(e.prototype.getBySolidityID=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getBySolidityID"}),Object.defineProperty(e.prototype.getTxRecordByContractID=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getTxRecordByContractID"}),Object.defineProperty(e.prototype.deleteContract=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"deleteContract"}),Object.defineProperty(e.prototype.systemDelete=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"systemDelete"}),Object.defineProperty(e.prototype.systemUndelete=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"systemUndelete"}),e}(),ThrottleGroup:function(){function e(e){if(this.operations=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.operations=$util.emptyArray,e.prototype.milliOpsPerSec=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.operations&&e.operations.length){o.uint32(10).fork();for(var t=0;t<e.operations.length;++t)o.int32(e.operations[t]);o.ldelim();}return null!=e.milliOpsPerSec&&Object.hasOwnProperty.call(e,"milliOpsPerSec")&&o.uint32(16).uint64(e.milliOpsPerSec),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThrottleGroup,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:if(d.operations&&d.operations.length||(d.operations=[]),2==(7&i))for(var a=e.uint32()+e.pos;e.pos<a;)d.operations.push(e.int32());else d.operations.push(e.int32());break;case 2:d.milliOpsPerSec=e.uint64();break;default:e.skipType(7&i);}return d},e}(),ThrottleBucket:function(){function e(e){if(this.throttleGroups=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.name="",e.prototype.burstPeriodMs=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.throttleGroups=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.name&&Object.hasOwnProperty.call(e,"name")&&o.uint32(10).string(e.name),null!=e.burstPeriodMs&&Object.hasOwnProperty.call(e,"burstPeriodMs")&&o.uint32(16).uint64(e.burstPeriodMs),null!=e.throttleGroups&&e.throttleGroups.length)for(var t=0;t<e.throttleGroups.length;++t)$root.proto.ThrottleGroup.encode(e.throttleGroups[t],o.uint32(26).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThrottleBucket,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.name=e.string();break;case 2:d.burstPeriodMs=e.uint64();break;case 3:d.throttleGroups&&d.throttleGroups.length||(d.throttleGroups=[]),d.throttleGroups.push($root.proto.ThrottleGroup.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),ThrottleDefinitions:function(){function e(e){if(this.throttleBuckets=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.throttleBuckets=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.throttleBuckets&&e.throttleBuckets.length)for(var t=0;t<e.throttleBuckets.length;++t)$root.proto.ThrottleBucket.encode(e.throttleBuckets[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.ThrottleDefinitions,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.throttleBuckets&&d.throttleBuckets.length||(d.throttleBuckets=[]),d.throttleBuckets.push($root.proto.ThrottleBucket.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),TokenService:function(){function e(e,o,t){$protobuf.rpc.Service.call(this,e,o,t);}return (e.prototype=Object.create($protobuf.rpc.Service.prototype)).constructor=e,e.create=function(e,o,t){return new this(e,o,t)},Object.defineProperty(e.prototype.createToken=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"createToken"}),Object.defineProperty(e.prototype.updateToken=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"updateToken"}),Object.defineProperty(e.prototype.mintToken=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"mintToken"}),Object.defineProperty(e.prototype.burnToken=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"burnToken"}),Object.defineProperty(e.prototype.deleteToken=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"deleteToken"}),Object.defineProperty(e.prototype.wipeTokenAccount=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"wipeTokenAccount"}),Object.defineProperty(e.prototype.freezeTokenAccount=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"freezeTokenAccount"}),Object.defineProperty(e.prototype.unfreezeTokenAccount=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"unfreezeTokenAccount"}),Object.defineProperty(e.prototype.grantKycToTokenAccount=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"grantKycToTokenAccount"}),Object.defineProperty(e.prototype.revokeKycFromTokenAccount=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"revokeKycFromTokenAccount"}),Object.defineProperty(e.prototype.associateTokens=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"associateTokens"}),Object.defineProperty(e.prototype.dissociateTokens=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"dissociateTokens"}),Object.defineProperty(e.prototype.updateTokenFeeSchedule=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"updateTokenFeeSchedule"}),Object.defineProperty(e.prototype.getTokenInfo=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getTokenInfo"}),Object.defineProperty(e.prototype.getAccountNftInfos=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getAccountNftInfos"}),Object.defineProperty(e.prototype.getTokenNftInfo=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getTokenNftInfo"}),Object.defineProperty(e.prototype.getTokenNftInfos=function t(e,o){return this.rpcCall(t,$root.proto.Query,$root.proto.Response,e,o)},"name",{value:"getTokenNftInfos"}),Object.defineProperty(e.prototype.pauseToken=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"pauseToken"}),Object.defineProperty(e.prototype.unpauseToken=function t(e,o){return this.rpcCall(t,$root.proto.Transaction,$root.proto.TransactionResponse,e,o)},"name",{value:"unpauseToken"}),e}(),SignedTransaction:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.bodyBytes=$util.newBuffer([]),e.prototype.sigMap=null,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.bodyBytes&&Object.hasOwnProperty.call(e,"bodyBytes")&&o.uint32(10).bytes(e.bodyBytes),null!=e.sigMap&&Object.hasOwnProperty.call(e,"sigMap")&&$root.proto.SignatureMap.encode(e.sigMap,o.uint32(18).fork()).ldelim(),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.SignedTransaction,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.bodyBytes=e.bytes();break;case 2:d.sigMap=$root.proto.SignatureMap.decode(e,e.uint32());break;default:e.skipType(7&i);}return d},e}(),TransactionList:function(){function e(e){if(this.transactionList=[],e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.transactionList=$util.emptyArray,e.create=function(o){return new e(o)},e.encode=function(e,o){if(o||(o=$Writer.create()),null!=e.transactionList&&e.transactionList.length)for(var t=0;t<e.transactionList.length;++t)$root.proto.Transaction.encode(e.transactionList[t],o.uint32(10).fork()).ldelim();return o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.TransactionList,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.transactionList&&d.transactionList.length||(d.transactionList=[]),d.transactionList.push($root.proto.Transaction.decode(e,e.uint32()));break;default:e.skipType(7&i);}return d},e}(),DoubleValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(9).double(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.DoubleValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.double();break;default:e.skipType(7&i);}return d},e}(),FloatValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(13).float(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.FloatValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.float();break;default:e.skipType(7&i);}return d},e}(),Int64Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).int64(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Int64Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.int64();break;default:e.skipType(7&i);}return d},e}(),UInt64Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).uint64(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.UInt64Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.uint64();break;default:e.skipType(7&i);}return d},e}(),Int32Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).int32(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.Int32Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.int32();break;default:e.skipType(7&i);}return d},e}(),UInt32Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).uint32(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.UInt32Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.uint32();break;default:e.skipType(7&i);}return d},e}(),BoolValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).bool(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.BoolValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.bool();break;default:e.skipType(7&i);}return d},e}(),StringValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(10).string(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.StringValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.string();break;default:e.skipType(7&i);}return d},e}(),BytesValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(10).bytes(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.proto.BytesValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.bytes();break;default:e.skipType(7&i);}return d},e}()};return e})();exports.proto=proto;const google=$root.google=(()=>{const e={protobuf:function(){const e={DoubleValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(9).double(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.DoubleValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.double();break;default:e.skipType(7&i);}return d},e}(),FloatValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(13).float(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.FloatValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.float();break;default:e.skipType(7&i);}return d},e}(),Int64Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=$util.Long?$util.Long.fromBits(0,0,!1):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).int64(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.Int64Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.int64();break;default:e.skipType(7&i);}return d},e}(),UInt64Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=$util.Long?$util.Long.fromBits(0,0,!0):0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).uint64(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.UInt64Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.uint64();break;default:e.skipType(7&i);}return d},e}(),Int32Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).int32(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.Int32Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.int32();break;default:e.skipType(7&i);}return d},e}(),UInt32Value:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=0,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).uint32(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.UInt32Value,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.uint32();break;default:e.skipType(7&i);}return d},e}(),BoolValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=!1,e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(8).bool(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.BoolValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.bool();break;default:e.skipType(7&i);}return d},e}(),StringValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value="",e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(10).string(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.StringValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.string();break;default:e.skipType(7&i);}return d},e}(),BytesValue:function(){function e(e){if(e)for(var o=Object.keys(e),t=0;t<o.length;++t)null!=e[o[t]]&&(this[o[t]]=e[o[t]]);}return e.prototype.value=$util.newBuffer([]),e.create=function(o){return new e(o)},e.encode=function(e,o){return o||(o=$Writer.create()),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&o.uint32(10).bytes(e.value),o},e.decode=function(e,o){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===o?e.len:e.pos+o,d=new $root.google.protobuf.BytesValue,i;e.pos<n;)switch(i=e.uint32(),i>>>3){case 1:d.value=e.bytes();break;default:e.skipType(7&i);}return d},e}()};return e}()};return e})();exports.google=google;
}(proto));

(function (exports) {
Object.defineProperty(exports,"__esModule",{value:!0}),exports.NetworkGetVersionInfoQuery=exports.MirrorNetworkService=exports.MirrorConsensusService=exports.LiveHash=exports.KeyList=exports.Key=exports.HederaFunctionality=exports.GrantedTokenAllowance=exports.GrantedNftAllowance=exports.GrantedCryptoAllowance=exports.GetBySolidityIDResponse=exports.GetBySolidityIDQuery=exports.GetByKeyResponse=exports.GetByKeyQuery=exports.FreezeType=exports.FreezeTransactionBody=exports.FreezeService=exports.FractionalFee=exports.Fraction=exports.FloatValue=exports.FixedFee=exports.FileUpdateTransactionBody=exports.FileService=exports.FileInfo=exports.FileID=exports.FileGetInfoResponse=exports.FileGetInfoQuery=exports.FileGetContentsResponse=exports.FileGetContentsQuery=exports.FileDeleteTransactionBody=exports.FileCreateTransactionBody=exports.FileContents=exports.FileAppendTransactionBody=exports.FeeSchedule=exports.FeeData=exports.FeeComponents=exports.ExchangeRateSet=exports.ExchangeRate=exports.EntityID=exports.Duration=exports.DoubleValue=exports.CustomFee=exports.CurrentAndNextFeeSchedule=exports.CryptoUpdateTransactionBody=exports.CryptoTransferTransactionBody=exports.CryptoService=exports.CryptoGetStakersResponse=exports.CryptoGetStakersQuery=exports.CryptoGetLiveHashResponse=exports.CryptoGetLiveHashQuery=exports.CryptoGetInfoResponse=exports.CryptoGetInfoQuery=exports.CryptoGetAccountRecordsResponse=exports.CryptoGetAccountRecordsQuery=exports.CryptoGetAccountBalanceResponse=exports.CryptoGetAccountBalanceQuery=exports.CryptoDeleteTransactionBody=exports.CryptoDeleteLiveHashTransactionBody=exports.CryptoCreateTransactionBody=exports.CryptoApproveAllowanceTransactionBody=exports.CryptoAllowance=exports.CryptoAdjustAllowanceTransactionBody=exports.CryptoAddLiveHashTransactionBody=exports.ContractUpdateTransactionBody=exports.ContractStateChange=exports.ContractLoginfo=exports.ContractInfo=exports.ContractID=exports.ContractGetRecordsResponse=exports.ContractGetRecordsQuery=exports.ContractGetInfoResponse=exports.ContractGetInfoQuery=exports.ContractGetBytecodeResponse=exports.ContractGetBytecodeQuery=exports.ContractFunctionResult=exports.ContractDeleteTransactionBody=exports.ContractCreateTransactionBody=exports.ContractCallTransactionBody=exports.ContractCallLocalResponse=exports.ContractCallLocalQuery=exports.ConsensusUpdateTopicTransactionBody=exports.ConsensusTopicResponse=exports.ConsensusTopicQuery=exports.ConsensusTopicInfo=exports.ConsensusSubmitMessageTransactionBody=exports.ConsensusService=exports.ConsensusMessageChunkInfo=exports.ConsensusGetTopicInfoResponse=exports.ConsensusGetTopicInfoQuery=exports.ConsensusDeleteTopicTransactionBody=exports.ConsensusCreateTopicTransactionBody=exports.BytesValue=exports.BoolValue=exports.AssessedCustomFee=exports.AllProxyStakers=exports.AllAccountBalances=exports.AddressBookQuery=exports.AccountInfo=exports.AccountID=exports.AccountAmount=void 0,exports.TransactionList=exports.TransactionID=exports.TransactionGetRecordResponse=exports.TransactionGetRecordQuery=exports.TransactionGetReceiptResponse=exports.TransactionGetReceiptQuery=exports.TransactionGetFastRecordResponse=exports.TransactionGetFastRecordQuery=exports.TransactionFeeSchedule=exports.TransactionBody=exports.Transaction=exports.TopicID=exports.TokenWipeAccountTransactionBody=exports.TokenUpdateTransactionBody=exports.TokenUnpauseTransactionBody=exports.TokenUnitBalance=exports.TokenUnfreezeAccountTransactionBody=exports.TokenType=exports.TokenTransferList=exports.TokenSupplyType=exports.TokenService=exports.TokenRevokeKycTransactionBody=exports.TokenRelationship=exports.TokenPauseTransactionBody=exports.TokenPauseStatus=exports.TokenNftInfo=exports.TokenMintTransactionBody=exports.TokenKycStatus=exports.TokenInfo=exports.TokenID=exports.TokenGrantKycTransactionBody=exports.TokenGetNftInfosResponse=exports.TokenGetNftInfosQuery=exports.TokenGetNftInfoResponse=exports.TokenGetNftInfoQuery=exports.TokenGetInfoResponse=exports.TokenGetInfoQuery=exports.TokenGetAccountNftInfosResponse=exports.TokenGetAccountNftInfosQuery=exports.TokenFreezeStatus=exports.TokenFreezeAccountTransactionBody=exports.TokenFeeScheduleUpdateTransactionBody=exports.TokenDissociateTransactionBody=exports.TokenDeleteTransactionBody=exports.TokenCreateTransactionBody=exports.TokenBurnTransactionBody=exports.TokenBalances=exports.TokenBalance=exports.TokenAssociateTransactionBody=exports.TokenAllowance=exports.TimestampSeconds=exports.Timestamp=exports.ThrottleGroup=exports.ThrottleDefinitions=exports.ThrottleBucket=exports.ThresholdSignature=exports.ThresholdKey=exports.SystemUndeleteTransactionBody=exports.SystemDeleteTransactionBody=exports.SubType=exports.StringValue=exports.StorageChange=exports.SmartContractService=exports.SingleAccountBalances=exports.SignedTransaction=exports.SignaturePair=exports.SignatureMap=exports.SignatureList=exports.Signature=exports.ShardID=exports.Setting=exports.ServicesConfigurationList=exports.ServiceEndpoint=exports.SemanticVersion=exports.ScheduleSignTransactionBody=exports.ScheduleService=exports.ScheduleInfo=exports.ScheduleID=exports.ScheduleGetInfoResponse=exports.ScheduleGetInfoQuery=exports.ScheduleDeleteTransactionBody=exports.ScheduleCreateTransactionBody=exports.SchedulableTransactionBody=exports.RoyaltyFee=exports.ResponseType=exports.ResponseHeader=exports.ResponseCodeEnum=exports.Response=exports.RealmID=exports.Reader=exports.QueryHeader=exports.Query=exports.ProxyStaker=exports.NodeAddressBook=exports.NodeAddress=exports.NftTransfer=exports.NftID=exports.NftAllowance=exports.NetworkService=exports.NetworkGetVersionInfoResponse=exports.NetworkGetVersionInfoQuery=exports.MirrorNetworkService=exports.MirrorConsensusService=exports.LiveHash=exports.KeyList=exports.Key=exports.HederaFunctionality=exports.GrantedTokenAllowance=exports.GrantedNftAllowance=exports.GrantedCryptoAllowance=exports.GetBySolidityIDResponse=exports.GetBySolidityIDQuery=exports.GetByKeyResponse=exports.GetByKeyQuery=exports.FreezeType=exports.FreezeTransactionBody=exports.FreezeService=exports.FractionalFee=exports.Fraction=exports.FloatValue=exports.FixedFee=exports.FileUpdateTransactionBody=exports.FileService=exports.FileInfo=exports.FileID=exports.FileGetInfoResponse=exports.FileGetInfoQuery=exports.FileGetContentsResponse=exports.FileGetContentsQuery=exports.FileDeleteTransactionBody=exports.FileCreateTransactionBody=exports.FileContents=exports.FileAppendTransactionBody=exports.FeeSchedule=exports.FeeData=exports.FeeComponents=exports.ExchangeRateSet=exports.ExchangeRate=exports.EntityID=exports.Duration=exports.DoubleValue=exports.CustomFee=exports.CurrentAndNextFeeSchedule=exports.CryptoUpdateTransactionBody=exports.CryptoTransferTransactionBody=exports.CryptoService=exports.CryptoGetStakersResponse=exports.CryptoGetStakersQuery=exports.CryptoGetLiveHashResponse=exports.CryptoGetLiveHashQuery=exports.CryptoGetInfoResponse=exports.CryptoGetInfoQuery=exports.CryptoGetAccountRecordsResponse=exports.CryptoGetAccountRecordsQuery=exports.CryptoGetAccountBalanceResponse=exports.CryptoGetAccountBalanceQuery=exports.CryptoDeleteTransactionBody=exports.CryptoDeleteLiveHashTransactionBody=exports.CryptoCreateTransactionBody=exports.CryptoApproveAllowanceTransactionBody=exports.CryptoAllowance=exports.CryptoAdjustAllowanceTransactionBody=exports.CryptoAddLiveHashTransactionBody=exports.ContractUpdateTransactionBody=exports.ContractStateChange=exports.ContractLoginfo=exports.ContractInfo=exports.ContractID=exports.ContractGetRecordsResponse=exports.ContractGetRecordsQuery=exports.ContractGetInfoResponse=exports.ContractGetInfoQuery=exports.ContractGetBytecodeResponse=exports.ContractGetBytecodeQuery=exports.ContractFunctionResult=exports.ContractDeleteTransactionBody=exports.ContractCreateTransactionBody=exports.ContractCallTransactionBody=exports.ContractCallLocalResponse=exports.ContractCallLocalQuery=exports.ConsensusUpdateTopicTransactionBody=exports.ConsensusTopicResponse=exports.ConsensusTopicQuery=exports.ConsensusTopicInfo=exports.ConsensusSubmitMessageTransactionBody=exports.ConsensusService=exports.ConsensusMessageChunkInfo=exports.ConsensusGetTopicInfoResponse=exports.ConsensusGetTopicInfoQuery=exports.ConsensusDeleteTopicTransactionBody=exports.ConsensusCreateTopicTransactionBody=exports.BytesValue=exports.BoolValue=exports.AssessedCustomFee=exports.AllProxyStakers=exports.AllAccountBalances=exports.AddressBookQuery=exports.AccountInfo=exports.AccountID=exports.AccountAmount=void 0,exports.Writer=exports.UncheckedSubmitBody=exports.UInt64Value=exports.UInt32Value=exports.TransferList=exports.TransactionResponse=exports.TransactionRecord=exports.TransactionReceipt=exports.TransactionList=exports.TransactionID=exports.TransactionGetRecordResponse=exports.TransactionGetRecordQuery=exports.TransactionGetReceiptResponse=exports.TransactionGetReceiptQuery=exports.TransactionGetFastRecordResponse=exports.TransactionGetFastRecordQuery=exports.TransactionFeeSchedule=exports.TransactionBody=exports.Transaction=exports.TopicID=exports.TokenWipeAccountTransactionBody=exports.TokenUpdateTransactionBody=exports.TokenUnpauseTransactionBody=exports.TokenUnitBalance=exports.TokenUnfreezeAccountTransactionBody=exports.TokenType=exports.TokenTransferList=exports.TokenSupplyType=exports.TokenService=exports.TokenRevokeKycTransactionBody=exports.TokenRelationship=exports.TokenPauseTransactionBody=exports.TokenPauseStatus=exports.TokenNftInfo=exports.TokenMintTransactionBody=exports.TokenKycStatus=exports.TokenInfo=exports.TokenID=exports.TokenGrantKycTransactionBody=exports.TokenGetNftInfosResponse=exports.TokenGetNftInfosQuery=exports.TokenGetNftInfoResponse=exports.TokenGetNftInfoQuery=exports.TokenGetInfoResponse=exports.TokenGetInfoQuery=exports.TokenGetAccountNftInfosResponse=exports.TokenGetAccountNftInfosQuery=exports.TokenFreezeStatus=exports.TokenFreezeAccountTransactionBody=exports.TokenFeeScheduleUpdateTransactionBody=exports.TokenDissociateTransactionBody=exports.TokenDeleteTransactionBody=exports.TokenCreateTransactionBody=exports.TokenBurnTransactionBody=exports.TokenBalances=exports.TokenBalance=exports.TokenAssociateTransactionBody=exports.TokenAllowance=exports.TimestampSeconds=exports.Timestamp=exports.ThrottleGroup=exports.ThrottleDefinitions=exports.ThrottleBucket=exports.ThresholdSignature=exports.ThresholdKey=exports.SystemUndeleteTransactionBody=exports.SystemDeleteTransactionBody=exports.SubType=exports.StringValue=exports.StorageChange=exports.SmartContractService=exports.SingleAccountBalances=exports.SignedTransaction=exports.SignaturePair=exports.SignatureMap=exports.SignatureList=exports.Signature=exports.ShardID=exports.Setting=exports.ServicesConfigurationList=exports.ServiceEndpoint=exports.SemanticVersion=exports.ScheduleSignTransactionBody=exports.ScheduleService=exports.ScheduleInfo=exports.ScheduleID=exports.ScheduleGetInfoResponse=exports.ScheduleGetInfoQuery=exports.ScheduleDeleteTransactionBody=exports.ScheduleCreateTransactionBody=exports.SchedulableTransactionBody=exports.RoyaltyFee=exports.ResponseType=exports.ResponseHeader=exports.ResponseCodeEnum=exports.Response=exports.RealmID=exports.Reader=exports.QueryHeader=exports.Query=exports.ProxyStaker=exports.NodeAddressBook=exports.NodeAddress=exports.NftTransfer=exports.NftID=exports.NftAllowance=exports.NetworkService=exports.NetworkGetVersionInfoResponse=exports.NetworkGetVersionInfoQuery=exports.MirrorNetworkService=exports.MirrorConsensusService=exports.LiveHash=exports.KeyList=exports.Key=exports.HederaFunctionality=exports.GrantedTokenAllowance=exports.GrantedNftAllowance=exports.GrantedCryptoAllowance=exports.GetBySolidityIDResponse=exports.GetBySolidityIDQuery=exports.GetByKeyResponse=exports.GetByKeyQuery=exports.FreezeType=exports.FreezeTransactionBody=exports.FreezeService=exports.FractionalFee=exports.Fraction=exports.FloatValue=exports.FixedFee=exports.FileUpdateTransactionBody=exports.FileService=exports.FileInfo=exports.FileID=exports.FileGetInfoResponse=exports.FileGetInfoQuery=exports.FileGetContentsResponse=exports.FileGetContentsQuery=exports.FileDeleteTransactionBody=exports.FileCreateTransactionBody=exports.FileContents=exports.FileAppendTransactionBody=exports.FeeSchedule=exports.FeeData=exports.FeeComponents=exports.ExchangeRateSet=exports.ExchangeRate=exports.EntityID=exports.Duration=exports.DoubleValue=exports.CustomFee=exports.CurrentAndNextFeeSchedule=exports.CryptoUpdateTransactionBody=exports.CryptoTransferTransactionBody=exports.CryptoService=exports.CryptoGetStakersResponse=exports.CryptoGetStakersQuery=exports.CryptoGetLiveHashResponse=exports.CryptoGetLiveHashQuery=exports.CryptoGetInfoResponse=exports.CryptoGetInfoQuery=exports.CryptoGetAccountRecordsResponse=exports.CryptoGetAccountRecordsQuery=exports.CryptoGetAccountBalanceResponse=exports.CryptoGetAccountBalanceQuery=exports.CryptoDeleteTransactionBody=exports.CryptoDeleteLiveHashTransactionBody=exports.CryptoCreateTransactionBody=exports.CryptoApproveAllowanceTransactionBody=exports.CryptoAllowance=exports.CryptoAdjustAllowanceTransactionBody=exports.CryptoAddLiveHashTransactionBody=exports.ContractUpdateTransactionBody=exports.ContractStateChange=exports.ContractLoginfo=exports.ContractInfo=exports.ContractID=exports.ContractGetRecordsResponse=exports.ContractGetRecordsQuery=exports.ContractGetInfoResponse=exports.ContractGetInfoQuery=exports.ContractGetBytecodeResponse=exports.ContractGetBytecodeQuery=exports.ContractFunctionResult=exports.ContractDeleteTransactionBody=exports.ContractCreateTransactionBody=exports.ContractCallTransactionBody=exports.ContractCallLocalResponse=exports.ContractCallLocalQuery=exports.ConsensusUpdateTopicTransactionBody=exports.ConsensusTopicResponse=exports.ConsensusTopicQuery=exports.ConsensusTopicInfo=exports.ConsensusSubmitMessageTransactionBody=exports.ConsensusService=exports.ConsensusMessageChunkInfo=exports.ConsensusGetTopicInfoResponse=exports.ConsensusGetTopicInfoQuery=exports.ConsensusDeleteTopicTransactionBody=exports.ConsensusCreateTopicTransactionBody=exports.BytesValue=exports.BoolValue=exports.AssessedCustomFee=exports.AllProxyStakers=exports.AllAccountBalances=exports.AddressBookQuery=exports.AccountInfo=exports.AccountID=exports.AccountAmount=void 0;var $protobuf=_interopRequireWildcard(minimal),_proto=proto,_long=_interopRequireDefault(long);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function _getRequireWildcardCache(a){if("function"!=typeof WeakMap)return null;var b=new WeakMap,c=new WeakMap;return (_getRequireWildcardCache=function(a){return a?c:b})(a)}function _interopRequireWildcard(a,b){if(!b&&a&&a.__esModule)return a;if(null===a||"object"!=typeof a&&"function"!=typeof a)return {default:a};var c=_getRequireWildcardCache(b);if(c&&c.has(a))return c.get(a);var d={},e=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var f in a)if("default"!=f&&Object.prototype.hasOwnProperty.call(a,f)){var g=e?Object.getOwnPropertyDescriptor(a,f):null;g&&(g.get||g.set)?Object.defineProperty(d,f,g):d[f]=a[f];}return d.default=a,c&&c.set(a,d),d}(()=>{var a=$protobuf.util;null==a.Long&&(console.log(`Patching Protobuf Long.js instance...`),a.Long=_long.default,null!=$protobuf.Reader._configure&&$protobuf.Reader._configure($protobuf.BufferReader));})();const Reader=$protobuf.Reader;exports.Reader=Reader;const Writer=$protobuf.Writer;exports.Writer=Writer;const TokenUnitBalance=_proto.proto.TokenUnitBalance;exports.TokenUnitBalance=TokenUnitBalance;const SingleAccountBalances=_proto.proto.SingleAccountBalances;exports.SingleAccountBalances=SingleAccountBalances;const AllAccountBalances=_proto.proto.AllAccountBalances;exports.AllAccountBalances=AllAccountBalances;const ShardID=_proto.proto.ShardID;exports.ShardID=ShardID;const RealmID=_proto.proto.RealmID;exports.RealmID=RealmID;const AccountID=_proto.proto.AccountID;exports.AccountID=AccountID;const FileID=_proto.proto.FileID;exports.FileID=FileID;const ContractID=_proto.proto.ContractID;exports.ContractID=ContractID;const TransactionID=_proto.proto.TransactionID;exports.TransactionID=TransactionID;const AccountAmount=_proto.proto.AccountAmount;exports.AccountAmount=AccountAmount;const TransferList=_proto.proto.TransferList;exports.TransferList=TransferList;const NftTransfer=_proto.proto.NftTransfer;exports.NftTransfer=NftTransfer;const TokenTransferList=_proto.proto.TokenTransferList;exports.TokenTransferList=TokenTransferList;const Fraction=_proto.proto.Fraction;exports.Fraction=Fraction;const TopicID=_proto.proto.TopicID;exports.TopicID=TopicID;const TokenID=_proto.proto.TokenID;exports.TokenID=TokenID;const ScheduleID=_proto.proto.ScheduleID;exports.ScheduleID=ScheduleID;const TokenType=_proto.proto.TokenType;exports.TokenType=TokenType;const SubType=_proto.proto.SubType;exports.SubType=SubType;const TokenSupplyType=_proto.proto.TokenSupplyType;exports.TokenSupplyType=TokenSupplyType;const TokenFreezeStatus=_proto.proto.TokenFreezeStatus;exports.TokenFreezeStatus=TokenFreezeStatus;const TokenKycStatus=_proto.proto.TokenKycStatus;exports.TokenKycStatus=TokenKycStatus;const Key=_proto.proto.Key;exports.Key=Key;const ThresholdKey=_proto.proto.ThresholdKey;exports.ThresholdKey=ThresholdKey;const KeyList=_proto.proto.KeyList;exports.KeyList=KeyList;const Signature=_proto.proto.Signature;exports.Signature=Signature;const ThresholdSignature=_proto.proto.ThresholdSignature;exports.ThresholdSignature=ThresholdSignature;const SignatureList=_proto.proto.SignatureList;exports.SignatureList=SignatureList;const SignaturePair=_proto.proto.SignaturePair;exports.SignaturePair=SignaturePair;const SignatureMap=_proto.proto.SignatureMap;exports.SignatureMap=SignatureMap;const HederaFunctionality=_proto.proto.HederaFunctionality;exports.HederaFunctionality=HederaFunctionality;const FeeComponents=_proto.proto.FeeComponents;exports.FeeComponents=FeeComponents;const TransactionFeeSchedule=_proto.proto.TransactionFeeSchedule;exports.TransactionFeeSchedule=TransactionFeeSchedule;const FeeData=_proto.proto.FeeData;exports.FeeData=FeeData;const FeeSchedule=_proto.proto.FeeSchedule;exports.FeeSchedule=FeeSchedule;const CurrentAndNextFeeSchedule=_proto.proto.CurrentAndNextFeeSchedule;exports.CurrentAndNextFeeSchedule=CurrentAndNextFeeSchedule;const ServiceEndpoint=_proto.proto.ServiceEndpoint;exports.ServiceEndpoint=ServiceEndpoint;const NodeAddress=_proto.proto.NodeAddress;exports.NodeAddress=NodeAddress;const NodeAddressBook=_proto.proto.NodeAddressBook;exports.NodeAddressBook=NodeAddressBook;const SemanticVersion=_proto.proto.SemanticVersion;exports.SemanticVersion=SemanticVersion;const Setting=_proto.proto.Setting;exports.Setting=Setting;const ServicesConfigurationList=_proto.proto.ServicesConfigurationList;exports.ServicesConfigurationList=ServicesConfigurationList;const TokenRelationship=_proto.proto.TokenRelationship;exports.TokenRelationship=TokenRelationship;const TokenBalance=_proto.proto.TokenBalance;exports.TokenBalance=TokenBalance;const TokenBalances=_proto.proto.TokenBalances;exports.TokenBalances=TokenBalances;const Timestamp=_proto.proto.Timestamp;exports.Timestamp=Timestamp;const TimestampSeconds=_proto.proto.TimestampSeconds;exports.TimestampSeconds=TimestampSeconds;const ConsensusCreateTopicTransactionBody=_proto.proto.ConsensusCreateTopicTransactionBody;exports.ConsensusCreateTopicTransactionBody=ConsensusCreateTopicTransactionBody;const Duration=_proto.proto.Duration;exports.Duration=Duration;const ConsensusDeleteTopicTransactionBody=_proto.proto.ConsensusDeleteTopicTransactionBody;exports.ConsensusDeleteTopicTransactionBody=ConsensusDeleteTopicTransactionBody;const ConsensusGetTopicInfoQuery=_proto.proto.ConsensusGetTopicInfoQuery;exports.ConsensusGetTopicInfoQuery=ConsensusGetTopicInfoQuery;const ConsensusGetTopicInfoResponse=_proto.proto.ConsensusGetTopicInfoResponse;exports.ConsensusGetTopicInfoResponse=ConsensusGetTopicInfoResponse;const ResponseType=_proto.proto.ResponseType;exports.ResponseType=ResponseType;const QueryHeader=_proto.proto.QueryHeader;exports.QueryHeader=QueryHeader;const Transaction=_proto.proto.Transaction;exports.Transaction=Transaction;const TransactionBody=_proto.proto.TransactionBody;exports.TransactionBody=TransactionBody;const SystemDeleteTransactionBody=_proto.proto.SystemDeleteTransactionBody;exports.SystemDeleteTransactionBody=SystemDeleteTransactionBody;const SystemUndeleteTransactionBody=_proto.proto.SystemUndeleteTransactionBody;exports.SystemUndeleteTransactionBody=SystemUndeleteTransactionBody;const FreezeTransactionBody=_proto.proto.FreezeTransactionBody;exports.FreezeTransactionBody=FreezeTransactionBody;const ContractCallTransactionBody=_proto.proto.ContractCallTransactionBody;exports.ContractCallTransactionBody=ContractCallTransactionBody;const ContractCreateTransactionBody=_proto.proto.ContractCreateTransactionBody;exports.ContractCreateTransactionBody=ContractCreateTransactionBody;const ContractUpdateTransactionBody=_proto.proto.ContractUpdateTransactionBody;exports.ContractUpdateTransactionBody=ContractUpdateTransactionBody;const LiveHash=_proto.proto.LiveHash;exports.LiveHash=LiveHash;const CryptoAddLiveHashTransactionBody=_proto.proto.CryptoAddLiveHashTransactionBody;exports.CryptoAddLiveHashTransactionBody=CryptoAddLiveHashTransactionBody;const CryptoCreateTransactionBody=_proto.proto.CryptoCreateTransactionBody;exports.CryptoCreateTransactionBody=CryptoCreateTransactionBody;const CryptoDeleteTransactionBody=_proto.proto.CryptoDeleteTransactionBody;exports.CryptoDeleteTransactionBody=CryptoDeleteTransactionBody;const CryptoDeleteLiveHashTransactionBody=_proto.proto.CryptoDeleteLiveHashTransactionBody;exports.CryptoDeleteLiveHashTransactionBody=CryptoDeleteLiveHashTransactionBody;const CryptoTransferTransactionBody=_proto.proto.CryptoTransferTransactionBody;exports.CryptoTransferTransactionBody=CryptoTransferTransactionBody;const CryptoUpdateTransactionBody=_proto.proto.CryptoUpdateTransactionBody;exports.CryptoUpdateTransactionBody=CryptoUpdateTransactionBody;const CryptoApproveAllowanceTransactionBody=_proto.proto.CryptoApproveAllowanceTransactionBody;exports.CryptoApproveAllowanceTransactionBody=CryptoApproveAllowanceTransactionBody;const CryptoAdjustAllowanceTransactionBody=_proto.proto.CryptoAdjustAllowanceTransactionBody;exports.CryptoAdjustAllowanceTransactionBody=CryptoAdjustAllowanceTransactionBody;const FileAppendTransactionBody=_proto.proto.FileAppendTransactionBody;exports.FileAppendTransactionBody=FileAppendTransactionBody;const FileCreateTransactionBody=_proto.proto.FileCreateTransactionBody;exports.FileCreateTransactionBody=FileCreateTransactionBody;const FileDeleteTransactionBody=_proto.proto.FileDeleteTransactionBody;exports.FileDeleteTransactionBody=FileDeleteTransactionBody;const FileUpdateTransactionBody=_proto.proto.FileUpdateTransactionBody;exports.FileUpdateTransactionBody=FileUpdateTransactionBody;const ContractDeleteTransactionBody=_proto.proto.ContractDeleteTransactionBody;exports.ContractDeleteTransactionBody=ContractDeleteTransactionBody;const ConsensusUpdateTopicTransactionBody=_proto.proto.ConsensusUpdateTopicTransactionBody;exports.ConsensusUpdateTopicTransactionBody=ConsensusUpdateTopicTransactionBody;const ConsensusMessageChunkInfo=_proto.proto.ConsensusMessageChunkInfo;exports.ConsensusMessageChunkInfo=ConsensusMessageChunkInfo;const ConsensusSubmitMessageTransactionBody=_proto.proto.ConsensusSubmitMessageTransactionBody;exports.ConsensusSubmitMessageTransactionBody=ConsensusSubmitMessageTransactionBody;const UncheckedSubmitBody=_proto.proto.UncheckedSubmitBody;exports.UncheckedSubmitBody=UncheckedSubmitBody;const TokenCreateTransactionBody=_proto.proto.TokenCreateTransactionBody;exports.TokenCreateTransactionBody=TokenCreateTransactionBody;const FractionalFee=_proto.proto.FractionalFee;exports.FractionalFee=FractionalFee;const FixedFee=_proto.proto.FixedFee;exports.FixedFee=FixedFee;const CustomFee=_proto.proto.CustomFee;exports.CustomFee=CustomFee;const AssessedCustomFee=_proto.proto.AssessedCustomFee;exports.AssessedCustomFee=AssessedCustomFee;const RoyaltyFee=_proto.proto.RoyaltyFee;exports.RoyaltyFee=RoyaltyFee;const TokenFreezeAccountTransactionBody=_proto.proto.TokenFreezeAccountTransactionBody;exports.TokenFreezeAccountTransactionBody=TokenFreezeAccountTransactionBody;const TokenUnfreezeAccountTransactionBody=_proto.proto.TokenUnfreezeAccountTransactionBody;exports.TokenUnfreezeAccountTransactionBody=TokenUnfreezeAccountTransactionBody;const TokenGrantKycTransactionBody=_proto.proto.TokenGrantKycTransactionBody;exports.TokenGrantKycTransactionBody=TokenGrantKycTransactionBody;const TokenRevokeKycTransactionBody=_proto.proto.TokenRevokeKycTransactionBody;exports.TokenRevokeKycTransactionBody=TokenRevokeKycTransactionBody;const TokenDeleteTransactionBody=_proto.proto.TokenDeleteTransactionBody;exports.TokenDeleteTransactionBody=TokenDeleteTransactionBody;const TokenUpdateTransactionBody=_proto.proto.TokenUpdateTransactionBody;exports.TokenUpdateTransactionBody=TokenUpdateTransactionBody;const TokenMintTransactionBody=_proto.proto.TokenMintTransactionBody;exports.TokenMintTransactionBody=TokenMintTransactionBody;const TokenBurnTransactionBody=_proto.proto.TokenBurnTransactionBody;exports.TokenBurnTransactionBody=TokenBurnTransactionBody;const TokenWipeAccountTransactionBody=_proto.proto.TokenWipeAccountTransactionBody;exports.TokenWipeAccountTransactionBody=TokenWipeAccountTransactionBody;const TokenAssociateTransactionBody=_proto.proto.TokenAssociateTransactionBody;exports.TokenAssociateTransactionBody=TokenAssociateTransactionBody;const TokenDissociateTransactionBody=_proto.proto.TokenDissociateTransactionBody;exports.TokenDissociateTransactionBody=TokenDissociateTransactionBody;const TokenFeeScheduleUpdateTransactionBody=_proto.proto.TokenFeeScheduleUpdateTransactionBody;exports.TokenFeeScheduleUpdateTransactionBody=TokenFeeScheduleUpdateTransactionBody;const ScheduleCreateTransactionBody=_proto.proto.ScheduleCreateTransactionBody;exports.ScheduleCreateTransactionBody=ScheduleCreateTransactionBody;const SchedulableTransactionBody=_proto.proto.SchedulableTransactionBody;exports.SchedulableTransactionBody=SchedulableTransactionBody;const ScheduleDeleteTransactionBody=_proto.proto.ScheduleDeleteTransactionBody;exports.ScheduleDeleteTransactionBody=ScheduleDeleteTransactionBody;const ScheduleSignTransactionBody=_proto.proto.ScheduleSignTransactionBody;exports.ScheduleSignTransactionBody=ScheduleSignTransactionBody;const ResponseHeader=_proto.proto.ResponseHeader;exports.ResponseHeader=ResponseHeader;const TransactionResponse=_proto.proto.TransactionResponse;exports.TransactionResponse=TransactionResponse;const ResponseCodeEnum=_proto.proto.ResponseCodeEnum;exports.ResponseCodeEnum=ResponseCodeEnum;const ConsensusTopicInfo=_proto.proto.ConsensusTopicInfo;exports.ConsensusTopicInfo=ConsensusTopicInfo;const ConsensusService=_proto.proto.ConsensusService;exports.ConsensusService=ConsensusService;const Query=_proto.proto.Query;exports.Query=Query;const GetByKeyQuery=_proto.proto.GetByKeyQuery;exports.GetByKeyQuery=GetByKeyQuery;const EntityID=_proto.proto.EntityID;exports.EntityID=EntityID;const GetByKeyResponse=_proto.proto.GetByKeyResponse;exports.GetByKeyResponse=GetByKeyResponse;const GetBySolidityIDQuery=_proto.proto.GetBySolidityIDQuery;exports.GetBySolidityIDQuery=GetBySolidityIDQuery;const GetBySolidityIDResponse=_proto.proto.GetBySolidityIDResponse;exports.GetBySolidityIDResponse=GetBySolidityIDResponse;const ContractLoginfo=_proto.proto.ContractLoginfo;exports.ContractLoginfo=ContractLoginfo;const ContractFunctionResult=_proto.proto.ContractFunctionResult;exports.ContractFunctionResult=ContractFunctionResult;const ContractCallLocalQuery=_proto.proto.ContractCallLocalQuery;exports.ContractCallLocalQuery=ContractCallLocalQuery;const ContractCallLocalResponse=_proto.proto.ContractCallLocalResponse;exports.ContractCallLocalResponse=ContractCallLocalResponse;const ContractGetInfoQuery=_proto.proto.ContractGetInfoQuery;exports.ContractGetInfoQuery=ContractGetInfoQuery;const ContractGetInfoResponse=_proto.proto.ContractGetInfoResponse;exports.ContractGetInfoResponse=ContractGetInfoResponse;const ContractInfo=_proto.proto.ContractGetInfoResponse.ContractInfo;exports.ContractInfo=ContractInfo;const ContractGetBytecodeQuery=_proto.proto.ContractGetBytecodeQuery;exports.ContractGetBytecodeQuery=ContractGetBytecodeQuery;const ContractGetBytecodeResponse=_proto.proto.ContractGetBytecodeResponse;exports.ContractGetBytecodeResponse=ContractGetBytecodeResponse;const ContractGetRecordsQuery=_proto.proto.ContractGetRecordsQuery;exports.ContractGetRecordsQuery=ContractGetRecordsQuery;const ContractGetRecordsResponse=_proto.proto.ContractGetRecordsResponse;exports.ContractGetRecordsResponse=ContractGetRecordsResponse;const ContractStateChange=_proto.proto.ContractStateChange;exports.ContractStateChange=ContractStateChange;const StorageChange=_proto.proto.StorageChange;exports.StorageChange=StorageChange;const TransactionRecord=_proto.proto.TransactionRecord;exports.TransactionRecord=TransactionRecord;const TransactionReceipt=_proto.proto.TransactionReceipt;exports.TransactionReceipt=TransactionReceipt;const ExchangeRate=_proto.proto.ExchangeRate;exports.ExchangeRate=ExchangeRate;const ExchangeRateSet=_proto.proto.ExchangeRateSet;exports.ExchangeRateSet=ExchangeRateSet;const CryptoGetAccountBalanceQuery=_proto.proto.CryptoGetAccountBalanceQuery;exports.CryptoGetAccountBalanceQuery=CryptoGetAccountBalanceQuery;const CryptoGetAccountBalanceResponse=_proto.proto.CryptoGetAccountBalanceResponse;exports.CryptoGetAccountBalanceResponse=CryptoGetAccountBalanceResponse;const CryptoGetAccountRecordsQuery=_proto.proto.CryptoGetAccountRecordsQuery;exports.CryptoGetAccountRecordsQuery=CryptoGetAccountRecordsQuery;const CryptoGetAccountRecordsResponse=_proto.proto.CryptoGetAccountRecordsResponse;exports.CryptoGetAccountRecordsResponse=CryptoGetAccountRecordsResponse;const CryptoGetInfoQuery=_proto.proto.CryptoGetInfoQuery;exports.CryptoGetInfoQuery=CryptoGetInfoQuery;const CryptoGetInfoResponse=_proto.proto.CryptoGetInfoResponse;exports.CryptoGetInfoResponse=CryptoGetInfoResponse;const AccountInfo=_proto.proto.CryptoGetInfoResponse.AccountInfo;exports.AccountInfo=AccountInfo;const CryptoAllowance=_proto.proto.CryptoAllowance;exports.CryptoAllowance=CryptoAllowance;const TokenAllowance=_proto.proto.TokenAllowance;exports.TokenAllowance=TokenAllowance;const NftAllowance=_proto.proto.NftAllowance;exports.NftAllowance=NftAllowance;const GrantedCryptoAllowance=_proto.proto.GrantedCryptoAllowance;exports.GrantedCryptoAllowance=GrantedCryptoAllowance;const GrantedTokenAllowance=_proto.proto.GrantedTokenAllowance;exports.GrantedTokenAllowance=GrantedTokenAllowance;const GrantedNftAllowance=_proto.proto.GrantedNftAllowance;exports.GrantedNftAllowance=GrantedNftAllowance;const CryptoGetLiveHashQuery=_proto.proto.CryptoGetLiveHashQuery;exports.CryptoGetLiveHashQuery=CryptoGetLiveHashQuery;const CryptoGetLiveHashResponse=_proto.proto.CryptoGetLiveHashResponse;exports.CryptoGetLiveHashResponse=CryptoGetLiveHashResponse;const CryptoGetStakersQuery=_proto.proto.CryptoGetStakersQuery;exports.CryptoGetStakersQuery=CryptoGetStakersQuery;const ProxyStaker=_proto.proto.ProxyStaker;exports.ProxyStaker=ProxyStaker;const AllProxyStakers=_proto.proto.AllProxyStakers;exports.AllProxyStakers=AllProxyStakers;const CryptoGetStakersResponse=_proto.proto.CryptoGetStakersResponse;exports.CryptoGetStakersResponse=CryptoGetStakersResponse;const FileGetContentsQuery=_proto.proto.FileGetContentsQuery;exports.FileGetContentsQuery=FileGetContentsQuery;const FileGetContentsResponse=_proto.proto.FileGetContentsResponse;exports.FileGetContentsResponse=FileGetContentsResponse;const FileContents=_proto.proto.FileGetContentsResponse.FileContents;exports.FileContents=FileContents;const FileGetInfoQuery=_proto.proto.FileGetInfoQuery;exports.FileGetInfoQuery=FileGetInfoQuery;const FileGetInfoResponse=_proto.proto.FileGetInfoResponse;exports.FileGetInfoResponse=FileGetInfoResponse;const FileInfo=_proto.proto.FileGetInfoResponse.FileInfo;exports.FileInfo=FileInfo;const TransactionGetReceiptQuery=_proto.proto.TransactionGetReceiptQuery;exports.TransactionGetReceiptQuery=TransactionGetReceiptQuery;const TransactionGetReceiptResponse=_proto.proto.TransactionGetReceiptResponse;exports.TransactionGetReceiptResponse=TransactionGetReceiptResponse;const TransactionGetRecordQuery=_proto.proto.TransactionGetRecordQuery;exports.TransactionGetRecordQuery=TransactionGetRecordQuery;const TransactionGetRecordResponse=_proto.proto.TransactionGetRecordResponse;exports.TransactionGetRecordResponse=TransactionGetRecordResponse;const TransactionGetFastRecordQuery=_proto.proto.TransactionGetFastRecordQuery;exports.TransactionGetFastRecordQuery=TransactionGetFastRecordQuery;const TransactionGetFastRecordResponse=_proto.proto.TransactionGetFastRecordResponse;exports.TransactionGetFastRecordResponse=TransactionGetFastRecordResponse;const NetworkGetVersionInfoQuery=_proto.proto.NetworkGetVersionInfoQuery;exports.NetworkGetVersionInfoQuery=NetworkGetVersionInfoQuery;const NetworkGetVersionInfoResponse=_proto.proto.NetworkGetVersionInfoResponse;exports.NetworkGetVersionInfoResponse=NetworkGetVersionInfoResponse;const TokenGetInfoQuery=_proto.proto.TokenGetInfoQuery;exports.TokenGetInfoQuery=TokenGetInfoQuery;const TokenInfo=_proto.proto.TokenInfo;exports.TokenInfo=TokenInfo;const TokenGetInfoResponse=_proto.proto.TokenGetInfoResponse;exports.TokenGetInfoResponse=TokenGetInfoResponse;const ScheduleGetInfoQuery=_proto.proto.ScheduleGetInfoQuery;exports.ScheduleGetInfoQuery=ScheduleGetInfoQuery;const ScheduleInfo=_proto.proto.ScheduleInfo;exports.ScheduleInfo=ScheduleInfo;const ScheduleGetInfoResponse=_proto.proto.ScheduleGetInfoResponse;exports.ScheduleGetInfoResponse=ScheduleGetInfoResponse;const TokenGetAccountNftInfosQuery=_proto.proto.TokenGetAccountNftInfosQuery;exports.TokenGetAccountNftInfosQuery=TokenGetAccountNftInfosQuery;const TokenGetAccountNftInfosResponse=_proto.proto.TokenGetAccountNftInfosResponse;exports.TokenGetAccountNftInfosResponse=TokenGetAccountNftInfosResponse;const NftID=_proto.proto.NftID;exports.NftID=NftID;const TokenGetNftInfoQuery=_proto.proto.TokenGetNftInfoQuery;exports.TokenGetNftInfoQuery=TokenGetNftInfoQuery;const TokenNftInfo=_proto.proto.TokenNftInfo;exports.TokenNftInfo=TokenNftInfo;const TokenGetNftInfoResponse=_proto.proto.TokenGetNftInfoResponse;exports.TokenGetNftInfoResponse=TokenGetNftInfoResponse;const TokenGetNftInfosQuery=_proto.proto.TokenGetNftInfosQuery;exports.TokenGetNftInfosQuery=TokenGetNftInfosQuery;const TokenGetNftInfosResponse=_proto.proto.TokenGetNftInfosResponse;exports.TokenGetNftInfosResponse=TokenGetNftInfosResponse;const Response=_proto.proto.Response;exports.Response=Response;const CryptoService=_proto.proto.CryptoService;exports.CryptoService=CryptoService;const FileService=_proto.proto.FileService;exports.FileService=FileService;const FreezeService=_proto.proto.FreezeService;exports.FreezeService=FreezeService;const ConsensusTopicQuery=_proto.proto.ConsensusTopicQuery;exports.ConsensusTopicQuery=ConsensusTopicQuery;const ConsensusTopicResponse=_proto.proto.ConsensusTopicResponse;exports.ConsensusTopicResponse=ConsensusTopicResponse;const MirrorConsensusService=_proto.proto.MirrorConsensusService;exports.MirrorConsensusService=MirrorConsensusService;const NetworkService=_proto.proto.NetworkService;exports.NetworkService=NetworkService;const ScheduleService=_proto.proto.ScheduleService;exports.ScheduleService=ScheduleService;const SmartContractService=_proto.proto.SmartContractService;exports.SmartContractService=SmartContractService;const ThrottleGroup=_proto.proto.ThrottleGroup;exports.ThrottleGroup=ThrottleGroup;const ThrottleBucket=_proto.proto.ThrottleBucket;exports.ThrottleBucket=ThrottleBucket;const ThrottleDefinitions=_proto.proto.ThrottleDefinitions;exports.ThrottleDefinitions=ThrottleDefinitions;const TokenService=_proto.proto.TokenService;exports.TokenService=TokenService;const SignedTransaction=_proto.proto.SignedTransaction;exports.SignedTransaction=SignedTransaction;const TransactionList=_proto.proto.TransactionList;exports.TransactionList=TransactionList;const DoubleValue=_proto.proto.DoubleValue;exports.DoubleValue=DoubleValue;const FloatValue=_proto.proto.FloatValue;exports.FloatValue=FloatValue;const UInt64Value=_proto.proto.UInt64Value;exports.UInt64Value=UInt64Value;const UInt32Value=_proto.proto.UInt32Value;exports.UInt32Value=UInt32Value;const BoolValue=_proto.proto.BoolValue;exports.BoolValue=BoolValue;const StringValue=_proto.proto.StringValue;exports.StringValue=StringValue;const BytesValue=_proto.proto.BytesValue;exports.BytesValue=BytesValue;const TokenPauseTransactionBody=_proto.proto.TokenPauseTransactionBody;exports.TokenPauseTransactionBody=TokenPauseTransactionBody;const TokenUnpauseTransactionBody=_proto.proto.TokenUnpauseTransactionBody;exports.TokenUnpauseTransactionBody=TokenUnpauseTransactionBody;const TokenPauseStatus=_proto.proto.TokenPauseStatus;exports.TokenPauseStatus=TokenPauseStatus;const FreezeType=_proto.proto.FreezeType;exports.FreezeType=FreezeType;const AddressBookQuery=_proto.proto.AddressBookQuery;exports.AddressBookQuery=AddressBookQuery;const MirrorNetworkService=_proto.proto.MirrorNetworkService;exports.MirrorNetworkService=MirrorNetworkService;
}(lib));

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency account on Hedera.
 */
class AccountId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     * @param {(PublicKey)=} aliasKey
     */
    constructor(props, realm, num, aliasKey) {
        const result = constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;
        this.aliasKey = aliasKey != null ? aliasKey : null;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {string} text
     * @returns {AccountId}
     */
    static fromString(text) {
        const result = fromStringSplitter(text);

        if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {
            throw new Error("invalid format for entity ID");
        }

        const shard =
            result.shard != null ? long.fromString(result.shard) : long.ZERO;
        const realm =
            result.realm != null ? long.fromString(result.realm) : long.ZERO;
        const [num, publicKey] =
            result.numOrHex.length < 20
                ? [long.fromString(result.numOrHex), undefined]
                : [long.ZERO, PublicKey.fromString(result.numOrHex)];

        return new AccountId(shard, realm, num, publicKey);
    }

    /**
     * @internal
     * @param {proto.IAccountID} id
     * @returns {AccountId}
     */
    static _fromProtobuf(id) {
        let key =
            id.alias != null && id.alias.length > 0
                ? Key._fromProtobufKey(lib.Key.decode(id.alias))
                : undefined;

        if (!(key instanceof PublicKey)) {
            key = undefined;
        }

        return new AccountId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.accountNum != null ? id.accountNum : 0,
            key
        );
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        if (this.aliasKey != null) {
            throw new Error(
                "cannot calculate checksum with an account ID that has a aliasKey"
            );
        }

        validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {AccountId}
     */
    static fromBytes(bytes) {
        return AccountId._fromProtobuf(lib.AccountID.decode(bytes));
    }

    /**
     * @param {string} address
     * @returns {AccountId}
     */
    static fromSolidityAddress(address) {
        return new AccountId(...fromSolidityAddress(address));
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        return toSolidityAddress([this.shard, this.realm, this.num]);
    }

    /**
     * @internal
     * @returns {proto.IAccountID}
     */
    _toProtobuf() {
        return {
            alias:
                this.aliasKey != null
                    ? lib.Key.encode(this.aliasKey._toProtobufKey()).finish()
                    : null,
            accountNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.AccountID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {string}
     */
    toString() {
        const account =
            this.aliasKey != null
                ? this.aliasKey.toString()
                : this.num.toString();

        return `${this.shard.toString()}.${this.realm.toString()}.${account}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        if (this.aliasKey != null) {
            throw new Error(
                "cannot calculate checksum with an account ID that has a aliasKey"
            );
        }

        return toStringWithChecksum(this.toString(), client);
    }

    /**
     * @param {this} other
     * @returns {boolean}
     */
    equals(other) {
        let account = false;

        if (this.aliasKey != null && other.aliasKey != null) {
            account = this.aliasKey.equals(other.aliasKey);
        } else if (this.aliasKey == null && other.aliasKey == null) {
            account = this.num.eq(other.num);
        }

        return (
            this.shard.eq(other.shard) && this.realm.eq(other.realm) && account
        );
    }

    /**
     * @returns {AccountId}
     */
    clone() {
        const id = new AccountId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @param {AccountId} other
     * @returns {number}
     */
    compare(other) {
        let comparison = this.shard.compare(other.shard);
        if (comparison != 0) {
            return comparison;
        }

        comparison = this.realm.compare(other.realm);
        if (comparison != 0) {
            return comparison;
        }

        if (this.aliasKey != null && other.aliasKey != null) {
            const t = this.aliasKey.toString();
            const o = other.aliasKey.toString();

            if (t > o) {
                return 1;
            } else if (t < o) {
                return -1;
            } else {
                return 0;
            }
        } else if (this.aliasKey == null && other.aliasKey == null) {
            return this.num.compare(other.num);
        } else {
            return 0;
        }
    }
}

CACHE.accountIdConstructor = (shard, realm, key) =>
    new AccountId(shard, realm, long.ZERO, key);

class GrpcStatus {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {number} code
     * @returns {GrpcStatus}
     */
    static _fromValue(code) {
        switch (code) {
            case 0:
                return GrpcStatus.Ok;
            case 1:
                return GrpcStatus.Cancelled;
            case 2:
                return GrpcStatus.Unknown;
            case 3:
                return GrpcStatus.InvalidArgument;
            case 4:
                return GrpcStatus.DeadlineExceeded;
            case 5:
                return GrpcStatus.NotFound;
            case 6:
                return GrpcStatus.AlreadyExists;
            case 7:
                return GrpcStatus.PermissionDenied;
            case 16:
                return GrpcStatus.Unauthenticated;
            case 8:
                return GrpcStatus.ResourceExhausted;
            case 9:
                return GrpcStatus.FailedPrecondition;
            case 10:
                return GrpcStatus.Aborted;
            case 11:
                return GrpcStatus.OutOfRange;
            case 12:
                return GrpcStatus.Unimplemented;
            case 13:
                return GrpcStatus.Internal;
            case 14:
                return GrpcStatus.Unavailable;
            case 15:
                return GrpcStatus.DataLoss;
            default:
                throw new Error(
                    "(BUG) non-exhaustive GrpcStatus switch statement"
                );
        }
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case GrpcStatus.Ok:
                return "OK";
            case GrpcStatus.Cancelled:
                return "CANCELLED";
            case GrpcStatus.Unknown:
                return "UNKNOWN";
            case GrpcStatus.InvalidArgument:
                return "INVALID_ARGUMENT";
            case GrpcStatus.DeadlineExceeded:
                return "DEADLINE_EXCEEDED";
            case GrpcStatus.NotFound:
                return "NOT_FOUND";
            case GrpcStatus.AlreadyExists:
                return "ALREADY_EXISTS";
            case GrpcStatus.PermissionDenied:
                return "PERMISSION_DENIED";
            case GrpcStatus.Unauthenticated:
                return "UNAUTHENTICATED";
            case GrpcStatus.ResourceExhausted:
                return "RESOURCE_EXHAUSTED";
            case GrpcStatus.FailedPrecondition:
                return "FAILED_PRECONDITION";
            case GrpcStatus.Aborted:
                return "ABORTED";
            case GrpcStatus.OutOfRange:
                return "OUT_OF_RANGE";
            case GrpcStatus.Unimplemented:
                return "UNIMPLEMENTED";
            case GrpcStatus.Internal:
                return "INTERNAL";
            case GrpcStatus.Unavailable:
                return "UNAVAILABLE";
            case GrpcStatus.DataLoss:
                return "DATA_LOSS";

            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @returns {number}
     */
    valueOf() {
        return this._code;
    }
}

GrpcStatus.Ok = new GrpcStatus(0);
GrpcStatus.Cancelled = new GrpcStatus(1);
GrpcStatus.Unknown = new GrpcStatus(2);
GrpcStatus.InvalidArgument = new GrpcStatus(3);
GrpcStatus.DeadlineExceeded = new GrpcStatus(4);
GrpcStatus.NotFound = new GrpcStatus(5);
GrpcStatus.AlreadyExists = new GrpcStatus(6);
GrpcStatus.PermissionDenied = new GrpcStatus(7);
GrpcStatus.Unauthenticated = new GrpcStatus(16);
GrpcStatus.ResourceExhausted = new GrpcStatus(8);
GrpcStatus.FailedPrecondition = new GrpcStatus(9);
GrpcStatus.Aborted = new GrpcStatus(10);
GrpcStatus.OutOfRange = new GrpcStatus(11);
GrpcStatus.Unimplemented = new GrpcStatus(12);
GrpcStatus.Internal = new GrpcStatus(13);
GrpcStatus.Unavailable = new GrpcStatus(14);
GrpcStatus.DataLoss = new GrpcStatus(15);

/**
 * Describes how the gRPC request failed.
 *
 * Exists in order for the Hedera JavaScript SDK to produce the same error type for gRPC errors regardless of
 * operating in node or the browser.
 *
 * Definition taken from <https://grpc.github.io/grpc/node/grpc.html#~ServiceError>.
 */
class GrpcServiceError extends Error {
    /**
     * @param {GrpcStatus} status
     */
    constructor(status) {
        super(`gRPC service failed with status: ${status.toString()}`);

        /**
         * @readonly
         */
        this.status = status;

        this.name = "GrpcServiceError";

        if (typeof Error.captureStackTrace !== "undefined") {
            Error.captureStackTrace(this, GrpcServiceError);
        }
    }

    /**
     * @param {Error & { code?: number; details?: string }} obj
     * @returns {Error}
     */
    static _fromResponse(obj) {
        if (obj.code != null && obj.details != null) {
            const status = GrpcStatus._fromValue(obj.code);
            const err = new GrpcServiceError(status);
            err.message = obj.details;
            return err;
        } else {
            return /** @type {Error} */ (obj);
        }
    }
}

/**
 * @template {any} T
 */
class List {
    constructor() {
        /** @type {T[]} */
        this.list = [];
        this.locked = false;
        this.index = 0;
    }

    /**
     * @param {T[]} list
     * @returns {this}
     */
    setList(list) {
        if (this.locked) {
            throw new Error("list is locked");
        }

        this.list = list;
        this.index = 0;

        return this;
    }

    /**
     * @param {T[]} items
     * @returns {this}
     */
    push(...items) {
        if (this.locked) {
            throw new Error("list is locked");
        }

        this.list.push(...items);
        return this;
    }

    /**
     * @returns {this}
     */
    setLocked() {
        this.locked = true;
        return this;
    }

    clear() {
        if (this.locked) {
            throw new Error("list is locked");
        }

        this.list = [];
        this.index = 0;
    }

    /**
     * @param {number} index
     * @returns {T}
     */
    get(index) {
        return this.list[index];
    }

    /**
     * @param {number} index
     * @param {T} item
     * @returns {this}
     */
    set(index, item) {
        if (this.locked) {
            throw new Error("list is locked");
        }

        if (index === this.length) {
            this.list.push(item);
        } else {
            this.list[index] = item;
        }

        return this;
    }

    /**
     * @param {number} index
     * @param {() => T} lambda
     * @returns {this}
     */
    setIfAbsent(index, lambda) {
        if (index == this.length || this.list[index] == null) {
            this.set(index, lambda());
        }

        return this;
    }

    /**
     * @returns {T}
     */
    get next() {
        return this.get(this.advance());
    }

    /**
     * @returns {T}
     */
    get current() {
        return this.get(this.index);
    }

    /**
     * @returns {number}
     */
    advance() {
        const index = this.index;
        this.index = (this.index + 1) % this.list.length;
        return index;
    }

    /**
     * @returns {boolean}
     */
    get isEmpty() {
        return this.length === 0;
    }

    /**
     * @returns {number}
     */
    get length() {
        return this.list.length;
    }
}

var logger$a = {exports: {}};

/*!
 * js-logger - http://github.com/jonnyreeves/js-logger
 * Jonny Reeves, http://jonnyreeves.co.uk/
 * js-logger may be freely distributed under the MIT license.
 */

(function (module) {
(function (global) {

	// Top level module for the global, static logger instance.
	var Logger = { };

	// For those that are at home that are keeping score.
	Logger.VERSION = "1.6.1";

	// Function which handles all incoming log messages.
	var logHandler;

	// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.
	var contextualLoggersByNameMap = {};

	// Polyfill for ES5's Function.bind.
	var bind = function(scope, func) {
		return function() {
			return func.apply(scope, arguments);
		};
	};

	// Super exciting object merger-matron 9000 adding another 100 bytes to your download.
	var merge = function () {
		var args = arguments, target = args[0], key, i;
		for (i = 1; i < args.length; i++) {
			for (key in args[i]) {
				if (!(key in target) && args[i].hasOwnProperty(key)) {
					target[key] = args[i][key];
				}
			}
		}
		return target;
	};

	// Helper to define a logging level object; helps with optimisation.
	var defineLogLevel = function(value, name) {
		return { value: value, name: name };
	};

	// Predefined logging levels.
	Logger.TRACE = defineLogLevel(1, 'TRACE');
	Logger.DEBUG = defineLogLevel(2, 'DEBUG');
	Logger.INFO = defineLogLevel(3, 'INFO');
	Logger.TIME = defineLogLevel(4, 'TIME');
	Logger.WARN = defineLogLevel(5, 'WARN');
	Logger.ERROR = defineLogLevel(8, 'ERROR');
	Logger.OFF = defineLogLevel(99, 'OFF');

	// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently
	// of each other.
	var ContextualLogger = function(defaultContext) {
		this.context = defaultContext;
		this.setLevel(defaultContext.filterLevel);
		this.log = this.info;  // Convenience alias.
	};

	ContextualLogger.prototype = {
		// Changes the current logging level for the logging instance.
		setLevel: function (newLevel) {
			// Ensure the supplied Level object looks valid.
			if (newLevel && "value" in newLevel) {
				this.context.filterLevel = newLevel;
			}
		},
		
		// Gets the current logging level for the logging instance
		getLevel: function () {
			return this.context.filterLevel;
		},

		// Is the logger configured to output messages at the supplied level?
		enabledFor: function (lvl) {
			var filterLevel = this.context.filterLevel;
			return lvl.value >= filterLevel.value;
		},

		trace: function () {
			this.invoke(Logger.TRACE, arguments);
		},

		debug: function () {
			this.invoke(Logger.DEBUG, arguments);
		},

		info: function () {
			this.invoke(Logger.INFO, arguments);
		},

		warn: function () {
			this.invoke(Logger.WARN, arguments);
		},

		error: function () {
			this.invoke(Logger.ERROR, arguments);
		},

		time: function (label) {
			if (typeof label === 'string' && label.length > 0) {
				this.invoke(Logger.TIME, [ label, 'start' ]);
			}
		},

		timeEnd: function (label) {
			if (typeof label === 'string' && label.length > 0) {
				this.invoke(Logger.TIME, [ label, 'end' ]);
			}
		},

		// Invokes the logger callback if it's not being filtered.
		invoke: function (level, msgArgs) {
			if (logHandler && this.enabledFor(level)) {
				logHandler(msgArgs, merge({ level: level }, this.context));
			}
		}
	};

	// Protected instance which all calls to the to level `Logger` module will be routed through.
	var globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });

	// Configure the global Logger instance.
	(function() {
		// Shortcut for optimisers.
		var L = Logger;

		L.enabledFor = bind(globalLogger, globalLogger.enabledFor);
		L.trace = bind(globalLogger, globalLogger.trace);
		L.debug = bind(globalLogger, globalLogger.debug);
		L.time = bind(globalLogger, globalLogger.time);
		L.timeEnd = bind(globalLogger, globalLogger.timeEnd);
		L.info = bind(globalLogger, globalLogger.info);
		L.warn = bind(globalLogger, globalLogger.warn);
		L.error = bind(globalLogger, globalLogger.error);

		// Don't forget the convenience alias!
		L.log = L.info;
	}());

	// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments
	// object with the supplied log messages and the second being a context object which contains a hash of stateful
	// parameters which the logging function can consume.
	Logger.setHandler = function (func) {
		logHandler = func;
	};

	// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.
	// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).
	Logger.setLevel = function(level) {
		// Set the globalLogger's level.
		globalLogger.setLevel(level);

		// Apply this level to all registered contextual loggers.
		for (var key in contextualLoggersByNameMap) {
			if (contextualLoggersByNameMap.hasOwnProperty(key)) {
				contextualLoggersByNameMap[key].setLevel(level);
			}
		}
	};

	// Gets the global logging filter level
	Logger.getLevel = function() {
		return globalLogger.getLevel();
	};

	// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,
	// default context and log handler.
	Logger.get = function (name) {
		// All logger instances are cached so they can be configured ahead of use.
		return contextualLoggersByNameMap[name] ||
			(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));
	};

	// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will
	// write to the window's console object (if present); the optional options object can be used to customise the
	// formatter used to format each log message.
	Logger.createDefaultHandler = function (options) {
		options = options || {};

		options.formatter = options.formatter || function defaultMessageFormatter(messages, context) {
			// Prepend the logger's name to the log message for easy identification.
			if (context.name) {
				messages.unshift("[" + context.name + "]");
			}
		};

		// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments
		// that don't offer a native console method.
		var timerStartTimeByLabelMap = {};

		// Support for IE8+ (and other, slightly more sane environments)
		var invokeConsoleMethod = function (hdlr, messages) {
			Function.prototype.apply.call(hdlr, console, messages);
		};

		// Check for the presence of a logger.
		if (typeof console === "undefined") {
			return function () { /* no console */ };
		}

		return function(messages, context) {
			// Convert arguments object to Array.
			messages = Array.prototype.slice.call(messages);

			var hdlr = console.log;
			var timerLabel;

			if (context.level === Logger.TIME) {
				timerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];

				if (messages[1] === 'start') {
					if (console.time) {
						console.time(timerLabel);
					}
					else {
						timerStartTimeByLabelMap[timerLabel] = new Date().getTime();
					}
				}
				else {
					if (console.timeEnd) {
						console.timeEnd(timerLabel);
					}
					else {
						invokeConsoleMethod(hdlr, [ timerLabel + ': ' +
							(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);
					}
				}
			}
			else {
				// Delegate through to custom warn/error loggers if present on the console.
				if (context.level === Logger.WARN && console.warn) {
					hdlr = console.warn;
				} else if (context.level === Logger.ERROR && console.error) {
					hdlr = console.error;
				} else if (context.level === Logger.INFO && console.info) {
					hdlr = console.info;
				} else if (context.level === Logger.DEBUG && console.debug) {
					hdlr = console.debug;
				} else if (context.level === Logger.TRACE && console.trace) {
					hdlr = console.trace;
				}

				options.formatter(messages, context);
				invokeConsoleMethod(hdlr, messages);
			}
		};
	};

	// Configure and example a Default implementation which writes to the `window.console` (if present).  The
	// `options` hash can be used to configure the default logLevel and provide a custom message formatter.
	Logger.useDefaults = function(options) {
		Logger.setLevel(options && options.defaultLevel || Logger.DEBUG);
		Logger.setHandler(Logger.createDefaultHandler(options));
	};

	// Createa an alias to useDefaults to avoid reaking a react-hooks rule.
	Logger.setDefaults = Logger.useDefaults;

	// Export to popular environments boilerplate.
	if (module.exports) {
		module.exports = Logger;
	}
	else {
		Logger._prevLogger = global.Logger;

		Logger.noConflict = function () {
			global.Logger = Logger._prevLogger;
			return Logger;
		};

		global.Logger = Logger;
	}
}(commonjsGlobal));
}(logger$a));

var Logger$1 = logger$a.exports;

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./client/Client.js").ClientOperator} ClientOperator
 * @typedef {import("./Signer.js").default} Signer
 * @typedef {import("./PublicKey.js").default} PublicKey
 */

/**
 * @enum {string}
 */
const ExecutionState = {
    Finished: "Finished",
    Retry: "Retry",
    Error: "Error",
};

const RST_STREAM = /\brst[^0-9a-zA-Z]stream\b/i;

/**
 * @abstract
 * @internal
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 */
class Executable {
    constructor() {
        /**
         * The number of times we can retry the grpc call
         *
         * @private
         * @type {number}
         */
        this._maxAttempts = 10;

        /**
         * The index of the next transaction to be executed.
         *
         * @protected
         * @type {number}
         */
        this._nextNodeAccountIdIndex = 0;

        /**
         * List of node account IDs for each transaction that has been
         * built.
         *
         * @internal
         * @type {List<AccountId>}
         */
        this._nodeAccountIds = new List();

        this._signOnDemand = false;

        /** @type {number | null} */
        this._minBackoff = null;

        /** @type {number | null} */
        this._maxBackoff = null;

        /**
         * @type {ClientOperator | null}
         */
        this._operator = null;

        /** @type {number | null} */
        this._requestTimeout = null;

        this._grpcDeadline = null;
    }

    /**
     * @returns {?AccountId[]}
     */
    get nodeAccountIds() {
        return this._nodeAccountIds.isEmpty ? null : this._nodeAccountIds.list;
    }

    /**
     * @param {AccountId[]} nodeIds
     * @returns {this}
     */
    setNodeAccountIds(nodeIds) {
        this._nodeAccountIds.setList(nodeIds).setLocked();
        return this;
    }

    /**
     * @deprecated
     * @returns {number}
     */
    get maxRetries() {
        console.warn("Deprecated: use maxAttempts instead");
        return this.maxAttempts;
    }

    /**
     * @param {number} maxRetries
     * @returns {this}
     */
    setMaxRetries(maxRetries) {
        console.warn("Deprecated: use setMaxAttempts() instead");
        return this.setMaxAttempts(maxRetries);
    }

    /**
     * @returns {number}
     */
    get maxAttempts() {
        return this._maxAttempts;
    }

    /**
     * @param {number} maxAttempts
     * @returns {this}
     */
    setMaxAttempts(maxAttempts) {
        this._maxAttempts = maxAttempts;

        return this;
    }

    /**
     * @returns {?number}
     */
    get grpcDeadline() {
        return this._grpcDeadline;
    }

    /**
     * @param {number} grpcDeadline
     * @returns {this}
     */
    setGrpcDeadline(grpcDeadline) {
        this._grpcDeadline = grpcDeadline;

        return this;
    }

    /**
     * @param {number} minBackoff
     * @returns {this}
     */
    setMinBackoff(minBackoff) {
        if (minBackoff == null) {
            throw new Error("minBackoff cannot be null.");
        } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {
            throw new Error("minBackoff cannot be larger than maxBackoff.");
        }
        this._minBackoff = minBackoff;
        return this;
    }

    /**
     * @returns {number | null}
     */
    get minBackoff() {
        return this._minBackoff;
    }

    /**
     * @param {?number} maxBackoff
     * @returns {this}
     */
    setMaxBackoff(maxBackoff) {
        if (maxBackoff == null) {
            throw new Error("maxBackoff cannot be null.");
        } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {
            throw new Error("maxBackoff cannot be smaller than minBackoff.");
        }
        this._maxBackoff = maxBackoff;
        return this;
    }

    /**
     * @returns {number | null}
     */
    get maxBackoff() {
        return this._maxBackoff;
    }

    /**
     * @abstract
     * @protected
     * @param {import("./client/Client.js").default<Channel, *>} client
     * @returns {Promise<void>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _beforeExecute(client) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @protected
     * @returns {Promise<RequestT>}
     */
    _makeRequestAsync() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @internal
     * @param {RequestT} request
     * @param {ResponseT} response
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @protected
     * @param {ResponseT} response
     * @param {AccountId} nodeAccountId
     * @param {RequestT} request
     * @returns {Promise<OutputT>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @internal
     * @param {Channel} channel
     * @param {RequestT} request
     * @returns {Promise<ResponseT>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _execute(channel, request) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @protected
     * @returns {AccountId}
     */
    _getNodeAccountId() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @protected
     * @returns {TransactionId}
     */
    _getTransactionId() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {string}
     */
    _getLogId() {
        throw new Error("not implemented");
    }

    /**
     * @protected
     * @returns {void}
     */
    _advanceRequest() {
        // each time we move our cursor to the next transaction
        // wrapping around to ensure we are cycling
        this._nextNodeAccountIdIndex =
            (this._nextNodeAccountIdIndex + 1) % this._nodeAccountIds.length;
    }

    /**
     * @abstract
     * @protected
     * @param {RequestT} request
     * @param {ResponseT} response
     * @returns {ExecutionState}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        throw new Error("not implemented");
    }

    /**
     * @protected
     * @param {GrpcServiceError} error
     * @returns {boolean}
     */
    _shouldRetryExceptionally(error) {
        return (
            error.status._code === GrpcStatus.Unavailable._code ||
            error.status._code === GrpcStatus.ResourceExhausted._code ||
            (error.status._code === GrpcStatus.Internal._code &&
                RST_STREAM.test(error.message))
        );
    }

    /**
     * @param {AccountId} accountId
     * @param {PublicKey} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {this}
     */
    _setOperatorWith(accountId, publicKey, transactionSigner) {
        this._operator = {
            transactionSigner,
            accountId,
            publicKey,
        };
        return this;
    }

    /**
     * @param {Signer} signer
     * @returns {Promise<OutputT>}
     */
    async executeWithSigner(signer) {
        return signer.sendRequest(this);
    }

    /**
     * @template {Channel} ChannelT
     * @template MirrorChannelT
     * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
     * @param {number=} requestTimeout
     * @returns {Promise<OutputT>}
     */
    async execute(client, requestTimeout) {
        if (this._requestTimeout == null) {
            this._requestTimeout =
                requestTimeout != null ? requestTimeout : client.requestTimeout;
        }

        await this._beforeExecute(client);

        if (this._maxBackoff == null) {
            this._maxBackoff = client.maxBackoff;
        }

        if (this._minBackoff == null) {
            this._minBackoff = client.minBackoff;
        }

        const maxAttempts =
            client._maxAttempts != null
                ? client._maxAttempts
                : this._maxAttempts;

        const startTime = Date.now();

        for (let attempt = 1 /* loop forever */; ; attempt += 1) {
            if (
                this._requestTimeout != null &&
                startTime + this._requestTimeout > Date.now()
            ) {
                throw new Error("timeout exceeded");
            }

            const nodeAccountId = this._getNodeAccountId();
            const node = client._network.getNode(nodeAccountId);

            if (node == null) {
                throw new Error(
                    `NodeAccountId not recognized: ${nodeAccountId.toString()}`
                );
            }

            const logId = this._getLogId();
            Logger$1.debug(
                `[${logId}] Node AccountID: ${node.accountId.toString()}, IP: ${node.address.toString()}`
            );

            const channel = node.getChannel();
            const request = await this._makeRequestAsync();

            // advance the internal index
            // non-free queries and transactions map to more than 1 actual transaction and this will cause
            // the next invocation of makeRequest to return the _next_ transaction
            this._advanceRequest();

            let response;

            if (!node.isHealthy()) {
                Logger$1.debug(
                    `[${logId}] node is not healthy, waiting ${node.getRemainingTime()}`
                );
                await node.wait();
            }

            try {
                const promises = [];
                if (this._grpcDeadline != null) {
                    promises.push(
                        // eslint-disable-next-line ie11/no-loop-func
                        new Promise((_, reject) =>
                            setTimeout(
                                // eslint-disable-next-line ie11/no-loop-func
                                () =>
                                    reject(new Error("grpc deadline exceeded")),
                                /** @type {number=} */ (this._grpcDeadline)
                            )
                        )
                    );
                }
                promises.push(this._execute(channel, request));
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                response = /** @type {ResponseT} */ (
                    await Promise.race(promises)
                );
            } catch (err) {
                const error = GrpcServiceError._fromResponse(
                    /** @type {Error} */ (err)
                );
                Logger$1.debug(
                    `[${logId}] received gRPC error ${JSON.stringify(error)}`
                );

                if (
                    error instanceof GrpcServiceError &&
                    this._shouldRetryExceptionally(error) &&
                    attempt <= maxAttempts
                ) {
                    node.increaseDelay();
                    continue;
                }

                throw err;
            }

            node.decreaseDelay();

            switch (this._shouldRetry(request, response)) {
                case ExecutionState.Retry:
                    await delayForAttempt(
                        attempt,
                        this._minBackoff,
                        this._maxBackoff
                    );
                    continue;
                case ExecutionState.Finished:
                    return this._mapResponse(response, nodeAccountId, request);
                case ExecutionState.Error:
                    throw this._mapStatusError(request, response);
                default:
                    throw new Error(
                        "(BUG) non-exhuastive switch statement for `ExecutionState`"
                    );
            }
        }
    }
}

/**
 * @param {number} attempt
 * @param {number} minBackoff
 * @param {number} maxBackoff
 * @returns {Promise<void>}
 */
function delayForAttempt(attempt, minBackoff, maxBackoff) {
    // 0.1s, 0.2s, 0.4s, 0.8s, ...
    const ms = Math.min(
        Math.floor(minBackoff * Math.pow(2, attempt)),
        maxBackoff
    );
    return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 */

const MAX_NS = long.fromNumber(1000000000);

class Timestamp {
    /**
     * @param {Long | number} seconds
     * @param {Long | number} nanos
     */
    constructor(seconds, nanos) {
        /**
         * @readonly
         * @type {Long}
         */
        this.seconds =
            seconds instanceof long ? seconds : long.fromNumber(seconds);

        /**
         * @readonly
         * @type {Long}
         */
        this.nanos = nanos instanceof long ? nanos : long.fromNumber(nanos);

        Object.freeze(this);
    }

    /**
     * @returns {Timestamp}
     */
    static generate() {
        const jitter = Math.floor(Math.random() * 5000) + 8000;
        const now = Date.now() - jitter;
        const seconds = Math.floor(now / 1000);
        const nanos =
            Math.floor(now % 1000) * 1000000 +
            Math.floor(Math.random() * 1000000);

        return new Timestamp(seconds, nanos);
    }

    /**
     * @param {string | number | Date} date
     * @returns {Timestamp}
     */
    static fromDate(date) {
        let nanos;

        if (typeof date === "number") {
            nanos = long.fromNumber(date);
        } else if (typeof date === "string") {
            nanos = long.fromNumber(Date.parse(date)).mul(1000000);
        } else if (date instanceof Date) {
            nanos = long.fromNumber(date.getTime()).mul(1000000);
        } else {
            throw new TypeError(
                `invalid type '${typeof date}' for 'data', expected 'Date'`
            );
        }

        return new Timestamp(0, 0).plusNanos(nanos);
    }

    /**
     * @returns {Date}
     */
    toDate() {
        return new Date(
            this.seconds.toInt() * 1000 +
                Math.floor(this.nanos.toInt() / 1000000)
        );
    }

    /**
     * @param {Long | number} nanos
     * @returns {Timestamp}
     */
    plusNanos(nanos) {
        const ns = this.nanos.add(nanos);

        return new Timestamp(this.seconds.add(ns.div(MAX_NS)), ns.mod(MAX_NS));
    }

    /**
     * @internal
     * @returns {proto.ITimestamp}
     */
    _toProtobuf() {
        return {
            seconds: this.seconds,
            nanos: this.nanos.toInt(),
        };
    }

    /**
     * @internal
     * @param {proto.ITimestamp} timestamp
     * @returns {Timestamp}
     */
    static _fromProtobuf(timestamp) {
        return new Timestamp(
            timestamp.seconds instanceof long
                ? timestamp.seconds.toInt()
                : timestamp.seconds != null
                ? timestamp.seconds
                : 0,

            timestamp.nanos != null ? timestamp.nanos : 0
        );
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.seconds.toString()}.${this.nanos.toString()}`;
    }

    /**
     * @param {Timestamp} other
     * @returns {number}
     */
    compare(other) {
        const comparison = this.seconds.compare(other.seconds);

        if (comparison != 0) {
            return comparison;
        }

        return this.nanos.compare(other.nanos);
    }
}

/**
 * The client-generated ID for a transaction.
 *
 * This is used for retrieving receipts and records for a transaction, for appending to a file
 * right after creating it, for instantiating a smart contract with bytecode in a file just created,
 * and internally by the network for detecting when duplicate transactions are submitted.
 */
class TransactionId {
    /**
     * Don't use this method directly.
     * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.
     *
     * @param {?AccountId} accountId
     * @param {?Timestamp} validStart
     * @param {?boolean} scheduled
     * @param {?Long | number} nonce
     */
    constructor(accountId, validStart, scheduled = false, nonce = null) {
        /**
         * The Account ID that paid for this transaction.
         *
         * @readonly
         */
        this.accountId = accountId;

        /**
         * The time from when this transaction is valid.
         *
         * When a transaction is submitted there is additionally a validDuration (defaults to 120s)
         * and together they define a time window that a transaction may be processed in.
         *
         * @readonly
         */
        this.validStart = validStart;

        this.scheduled = scheduled;

        this.nonce = null;
        if (nonce != null && nonce != 0) {
            this.setNonce(nonce);
        }

        Object.freeze(this);
    }

    /**
     * @param {Long | number} nonce
     * @returns {TransactionId}
     */
    setNonce(nonce) {
        this.nonce = typeof nonce === "number" ? long.fromNumber(nonce) : nonce;
        return this;
    }

    /**
     * @param {AccountId} accountId
     * @param {Timestamp} validStart
     * @returns {TransactionId}
     */
    static withValidStart(accountId, validStart) {
        return new TransactionId(accountId, validStart);
    }

    /**
     * Generates a new transaction ID for the given account ID.
     *
     * Note that transaction IDs are made of the valid start of the transaction and the account
     * that will be charged the transaction fees for the transaction.
     *
     * @param {AccountId | string} id
     * @returns {TransactionId}
     */
    static generate(id) {
        return new TransactionId(
            typeof id === "string"
                ? AccountId.fromString(id)
                : new AccountId(id),
            Timestamp.generate()
        );
    }

    /**
     * @param {string} wholeId
     * @returns {TransactionId}
     */
    static fromString(wholeId) {
        let account, seconds, nanos, isScheduled, nonce;
        let rest;
        // 1.1.1@5.4?scheduled/117

        [account, rest] = wholeId.split("@");
        [seconds, rest] = rest.split(".");
        if (rest.includes("?")) {
            [nanos, rest] = rest.split("?scheduled");
            isScheduled = true;
            if (rest.includes("/")) {
                nonce = rest.replace("/", "");
            } else {
                nonce = null;
            }
        } else if (rest.includes("/")) {
            [nanos, nonce] = rest.split("/");
            isScheduled = false;
        } else {
            nanos = rest;
        }

        return new TransactionId(
            AccountId.fromString(account),
            new Timestamp(long.fromValue(seconds), long.fromValue(nanos)),
            isScheduled,
            nonce != null ? long.fromString(nonce) : null
        );
    }

    /**
     * @param {boolean} scheduled
     * @returns {this}
     */
    setScheduled(scheduled) {
        this.scheduled = scheduled;
        return this;
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this.accountId != null && this.validStart != null) {
            const nonce =
                this.nonce != null ? "/".concat(this.nonce.toString()) : "";
            const scheduled = this.scheduled ? "?scheduled" : "";
            return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${this.validStart.nanos.toString()}${scheduled}${nonce}`;
        } else {
            throw new Error("neither `accountId` nor `validStart` are set");
        }
    }

    /**
     * @internal
     * @param {proto.ITransactionID} id
     * @returns {TransactionId}
     */
    static _fromProtobuf(id) {
        if (id.accountID != null && id.transactionValidStart != null) {
            return new TransactionId(
                AccountId._fromProtobuf(id.accountID),
                Timestamp._fromProtobuf(id.transactionValidStart),
                id.scheduled != null ? id.scheduled : undefined,
                id.nonce != null ? id.nonce : undefined
            );
        } else {
            throw new Error(
                "Neither `nonce` or `accountID` and `transactionValidStart` are set"
            );
        }
    }

    /**
     * @internal
     * @returns {proto.ITransactionID}
     */
    _toProtobuf() {
        return {
            accountID:
                this.accountId != null ? this.accountId._toProtobuf() : null,
            transactionValidStart:
                this.validStart != null ? this.validStart._toProtobuf() : null,
            scheduled: this.scheduled,
            nonce: this.nonce != null ? this.nonce.toInt() : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TransactionId}
     */
    static fromBytes(bytes) {
        return TransactionId._fromProtobuf(lib.TransactionID.decode(bytes));
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.TransactionID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {TransactionId}
     */
    clone() {
        return new TransactionId(
            this.accountId,
            this.validStart,
            this.scheduled,
            this.nonce
        );
    }

    /**
     * @param {TransactionId} other
     * @returns {number}
     */
    compare(other) {
        const comparison = /** @type {AccountId} */ (this.accountId).compare(
            /** @type {AccountId} */ (other.accountId)
        );

        if (comparison != 0) {
            return comparison;
        }

        return /** @type {Timestamp} */ (this.validStart).compare(
            /** @type {Timestamp} */ (other.validStart)
        );
    }
}

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 */

class PrecheckStatusError extends StatusError {
    /**
     * @param {object} props
     * @param {Status} props.status
     * @param {TransactionId} props.transactionId
     */
    constructor(props) {
        super(
            props,
            `transaction ${props.transactionId.toString()} failed precheck with status ${props.status.toString()}`
        );
    }
}

/**
 * @typedef {import("./Hbar.js").default} Hbar
 */

class MaxQueryPaymentExceeded extends Error {
    /**
     * @param {Hbar} queryCost
     * @param {Hbar} maxQueryPayment
     */
    constructor(queryCost, maxQueryPayment) {
        super();

        this.message = `query cost of ${queryCost.toString()} HBAR exceeds max set on client: ${maxQueryPayment.toString()} HBAR`;
        this.name = "MaxQueryPaymentExceededError";
        this.queryCost = queryCost;
        this.maxQueryPayment = maxQueryPayment;
    }
}

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../PublicKey.js").default} PublicKey
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 */

/**
 * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @type {Map<ProtoQuery["query"], (query: proto.IQuery) => Query<*>>}
 */
const QUERY_REGISTRY = new Map();

/**
 * Base class for all queries that can be submitted to Hedera.
 *
 * @abstract
 * @template OutputT
 * @augments {Executable<proto.IQuery, proto.IResponse, OutputT>}
 */
class Query extends Executable {
    constructor() {
        super();

        /** @type {?TransactionId} */
        this._paymentTransactionId = null;

        /** @type {proto.ITransaction[]} */
        this._paymentTransactions = [];

        /** @type {?Hbar} */
        this._queryPayment = null;

        /** @type {?Hbar} */
        this._maxQueryPayment = null;

        this._timestamp = Date.now();
    }

    /**
     * @template T
     * @param {Uint8Array} bytes
     * @returns {Query<T>}
     */
    static fromBytes(bytes) {
        const query = lib.Query.decode(bytes);

        if (query.query == null) {
            throw new Error("(BUG) query.query was not set in the protobuf");
        }

        const fromProtobuf = /** @type {(query: proto.IQuery) => Query<T>} */ (
            QUERY_REGISTRY.get(query.query)
        );

        if (fromProtobuf == null) {
            throw new Error(
                `(BUG) Query.fromBytes() not implemented for type ${query.query}`
            );
        }

        return fromProtobuf(query);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.Query.encode(this._makeRequest()).finish();
    }

    /**
     * Set an explicit payment amount for this query.
     *
     * The client will submit exactly this amount for the payment of this query. Hedera
     * will not return any remainder.
     *
     * @param {Hbar} queryPayment
     * @returns {this}
     */
    setQueryPayment(queryPayment) {
        this._queryPayment = queryPayment;

        return this;
    }

    /**
     * Set the maximum payment allowable for this query.
     *
     * @param {Hbar} maxQueryPayment
     * @returns {this}
     */
    setMaxQueryPayment(maxQueryPayment) {
        this._maxQueryPayment = maxQueryPayment;

        return this;
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    getCost(client) {
        if (this._nodeAccountIds.isEmpty) {
            this._nodeAccountIds.setList(
                client._network.getNodeAccountIdsForExecute()
            );
        }

        if (COST_QUERY.length != 1) {
            throw new Error("CostQuery has not been loaded yet");
        }

        this._timestamp = Date.now();

        return COST_QUERY[0](this).execute(client);
    }

    /**
     * @param {TransactionId} paymentTransactionId
     * @returns {this}
     */
    setPaymentTransactionId(paymentTransactionId) {
        this._paymentTransactionId = paymentTransactionId;
        return this;
    }

    /**
     * @returns {?TransactionId}
     */
    get paymentTransactionId() {
        return this._paymentTransactionId;
    }

    /**
     * @returns {TransactionId}
     */
    _getTransactionId() {
        if (this._paymentTransactionId == null) {
            throw new Error(
                "Query.PaymentTransactionId was not set duration execution"
            );
        }

        return this._paymentTransactionId;
    }

    /**
     * @protected
     * @returns {boolean}
     */
    _isPaymentRequired() {
        return true;
    }

    /**
     * @param {Client} client
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
    _validateChecksums(client) {
        // Do nothing
    }

    /**
     * @template MirrorChannelT
     * @param {import("../client/Client.js").default<Channel, MirrorChannelT>} client
     * @returns {Promise<void>}
     */
    async _beforeExecute(client) {
        if (this._paymentTransactions.length > 0) {
            return;
        }

        if (client.isAutoValidateChecksumsEnabled()) {
            this._validateChecksums(client);
        }

        if (this._nodeAccountIds.isEmpty) {
            this._nodeAccountIds.setList(
                client._network.getNodeAccountIdsForExecute()
            );
        }

        const operator =
            this._operator != null ? this._operator : client._operator;

        if (this._paymentTransactionId == null) {
            if (this._isPaymentRequired()) {
                if (operator != null) {
                    this._paymentTransactionId = TransactionId.generate(
                        operator.accountId
                    );
                } else {
                    throw new Error(
                        "`client` must have an `operator` or an explicit payment transaction must be provided"
                    );
                }
            } else {
                this._paymentTransactionId = TransactionId.generate(
                    new AccountId(0)
                );
            }
        }

        let cost =
            this._queryPayment != null
                ? this._queryPayment
                : client.maxQueryPayment;

        if (
            this._paymentTransactions.length !== 0 ||
            !this._isPaymentRequired()
        ) {
            cost = new Hbar(0);
        } else {
            if (this._queryPayment == null) {
                const actualCost = await this.getCost(client);

                if (
                    cost.toTinybars().toInt() < actualCost.toTinybars().toInt()
                ) {
                    throw new MaxQueryPaymentExceeded(cost, actualCost);
                }

                cost = actualCost;
            }
        }

        for (const node of this._nodeAccountIds.list) {
            this._paymentTransactions.push(
                await _makePaymentTransaction(
                    /** @type {import("../transaction/TransactionId.js").default} */ (
                        this._paymentTransactionId
                    ),
                    node,
                    this._isPaymentRequired() ? operator : null,
                    /** @type {Hbar} */ (cost)
                )
            );
        }

        this._timestamp = Date.now();
    }

    /**
     * @abstract
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponseHeader(response) {
        throw new Error("not implemented");
    }

    /**
     * @protected
     * @returns {proto.IQueryHeader}
     */
    _makeRequestHeader() {
        /** @type {proto.IQueryHeader} */
        let header = {};

        if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {
            header = {
                responseType: lib.ResponseType.ANSWER_ONLY,
                payment:
                    this._paymentTransactions[this._nextNodeAccountIdIndex],
            };
        }

        return header;
    }

    /**
     * @abstract
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _onMakeRequest(header) {
        throw new Error("not implemented");
    }

    /**
     * @internal
     * @returns {proto.IQuery}
     */
    _makeRequest() {
        /** @type {proto.IQueryHeader} */
        let header = {};

        if (this._isPaymentRequired() && this._paymentTransactions != null) {
            header = {
                payment:
                    this._paymentTransactions[this._nextNodeAccountIdIndex],
                responseType: lib.ResponseType.ANSWER_ONLY,
            };
        }

        return this._onMakeRequest(header);
    }

    /**
     * @override
     * @internal
     * @returns {Promise<proto.IQuery>}
     */
    _makeRequestAsync() {
        return Promise.resolve(this._makeRequest());
    }

    /**
     * @override
     * @internal
     * @param {proto.IQuery} request
     * @param {proto.IResponse} response
     * @returns {ExecutionState}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        const status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : lib.ResponseCodeEnum.OK
        );

        Logger$1.debug(
            `[${this._getLogId()}] received status ${status.toString()}`
        );

        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.PlatformTransactionNotCreated:
                return ExecutionState.Retry;
            case Status.Ok:
                return ExecutionState.Finished;
            default:
                return ExecutionState.Error;
        }
    }

    /**
     * @override
     * @internal
     * @param {proto.IQuery} request
     * @param {proto.IResponse} response
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        const status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : lib.ResponseCodeEnum.OK
        );

        return new PrecheckStatusError({
            status,
            transactionId: this._getTransactionId(),
        });
    }

    /**
     * @returns {AccountId}
     */
    _getNodeAccountId() {
        if (!this._nodeAccountIds.isEmpty) {
            // if there are payment transactions,
            // we need to use the node of the current payment transaction
            return this._nodeAccountIds.list[this._nextNodeAccountIdIndex];
        } else {
            throw new Error(
                "(BUG) nodeAccountIds were not set for query before executing"
            );
        }
    }

    /**
     * @override
     * @protected
     * @returns {void}
     */
    _advanceRequest() {
        if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {
            // each time we move our cursor to the next transaction
            // wrapping around to ensure we are cycling
            super._nextNodeAccountIdIndex =
                (this._nextNodeAccountIdIndex + 1) %
                this._paymentTransactions.length;
        } else {
            super._advanceRequest();
        }
    }
}

/**
 * @param {TransactionId} paymentTransactionId
 * @param {AccountId} nodeId
 * @param {?ClientOperator} operator
 * @param {Hbar} paymentAmount
 * @returns {Promise<proto.ITransaction>}
 */
async function _makePaymentTransaction(
    paymentTransactionId,
    nodeId,
    operator,
    paymentAmount
) {
    const accountAmounts = [];

    if (operator != null) {
        accountAmounts.push({
            accountID: operator.accountId._toProtobuf(),
            amount: paymentAmount.negated().toTinybars(),
        });
        accountAmounts.push({
            accountID: nodeId._toProtobuf(),
            amount: paymentAmount.toTinybars(),
        });
    } else {
        accountAmounts.push({
            accountID: new AccountId(0)._toProtobuf(),
            amount: paymentAmount.negated().toTinybars(),
        });
        accountAmounts.push({
            accountID: nodeId._toProtobuf(),
            amount: paymentAmount.toTinybars(),
        });
    }
    /**
     * @type {proto.ITransactionBody}
     */
    const body = {
        transactionID: paymentTransactionId._toProtobuf(),
        nodeAccountID: nodeId._toProtobuf(),
        transactionFee: new Hbar(1).toTinybars(),
        transactionValidDuration: {
            seconds: long.fromNumber(120),
        },
        cryptoTransfer: {
            transfers: {
                accountAmounts,
            },
        },
    };

    /** @type {proto.ISignedTransaction} */
    const signedTransaction = {
        bodyBytes: lib.TransactionBody.encode(body).finish(),
    };

    if (operator != null) {
        const signature = await operator.transactionSigner(
            /** @type {Uint8Array} */ (signedTransaction.bodyBytes)
        );

        signedTransaction.sigMap = {
            sigPair: [operator.publicKey._toProtobufSignature(signature)],
        };
    }

    return {
        signedTransactionBytes:
            lib.SignedTransaction.encode(signedTransaction).finish(),
    };
}

/**
 * @type {((query: Query<*>) => import("./CostQuery.js").default<*>)[]}
 */
const COST_QUERY = [];

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency contract on Hedera.
 */
class ContractId extends Key {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     * @param {Uint8Array=} evmAddress
     */
    constructor(props, realm, num, evmAddress) {
        super();

        const result = constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        this.evmAddress = evmAddress != null ? evmAddress : null;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {Long | number} shard
     * @param {Long | number} realm
     * @param {string} evmAddress
     * @returns {ContractId}
     */
    static fromEvmAddress(shard, realm, evmAddress) {
        return new ContractId(shard, realm, 0, decode$1(evmAddress));
    }

    /**
     * @param {string} text
     * @returns {ContractId}
     */
    static fromString(text) {
        const result = fromStringSplitter(text);

        if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {
            throw new Error("invalid format for entity ID");
        }

        const shard =
            result.shard != null ? long.fromString(result.shard) : long.ZERO;
        const realm =
            result.realm != null ? long.fromString(result.realm) : long.ZERO;
        const [num, evmAddress] =
            result.numOrHex.length < 40
                ? [long.fromString(result.numOrHex), undefined]
                : [long.ZERO, decode$1(result.numOrHex)];

        return new ContractId(shard, realm, num, evmAddress);
    }

    /**
     * @internal
     * @param {proto.IContractID} id
     * @returns {ContractId}
     */
    static _fromProtobuf(id) {
        const contractId = new ContractId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.contractNum != null ? id.contractNum : 0
        );

        return contractId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {ContractId}
     */
    static fromBytes(bytes) {
        return ContractId._fromProtobuf(lib.ContractID.decode(bytes));
    }

    /**
     * @deprecated - Use `ContractId.fromEvmAddress()` instead
     * @param {string} address
     * @returns {ContractId}
     */
    static fromSolidityAddress(address) {
        console.warn("Deprecated: use `ContractId.fromEvmAdress()` instead");

        const [shard, realm, contract] = fromSolidityAddress(address);
        return new ContractId(shard, realm, contract);
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        if (this.evmAddress != null) {
            return encode$1(this.evmAddress);
        } else {
            return toSolidityAddress([
                this.shard,
                this.realm,
                this.num,
            ]);
        }
    }

    /**
     * @internal
     * @returns {proto.IContractID}
     */
    _toProtobuf() {
        return {
            contractNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
            evmAddress: this.evmAddress,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this.evmAddress != null) {
            return `${this.shard.toString()}.${this.realm.toString()}.${encode$1(
                this.evmAddress
            )}`;
        } else {
            return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
        }
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.ContractID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {ContractId}
     */
    clone() {
        const id = new ContractId(this);
        id._checksum = this._checksum;
        id.evmAddress = this.evmAddress;
        return id;
    }

    /**
     * @param {ContractId} other
     * @returns {number}
     */
    compare(other) {
        return compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num]
        );
    }

    /**
     * @returns {proto.IKey}
     */
    _toProtobufKey() {
        return {
            contractID: this._toProtobuf(),
        };
    }

    /**
     * @param {proto.IContractID} key
     * @returns {ContractId}
     */
    static __fromProtobufKey(key) {
        return ContractId._fromProtobuf(key);
    }
}

CACHE.contractId = (key) => ContractId.__fromProtobufKey(key);

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency file on Hedera.
 */
class FileId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     */
    constructor(props, realm, num) {
        const result = constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {string} text
     * @returns {FileId}
     */
    static fromString(text) {
        const result = fromString(text);
        const id = new FileId(result);
        id._checksum = result.checksum;
        return id;
    }

    /**
     * @internal
     * @param {proto.IFileID} id
     * @returns {FileId}
     */
    static _fromProtobuf(id) {
        const fileId = new FileId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.fileNum != null ? id.fileNum : 0
        );

        return fileId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {FileId}
     */
    static fromBytes(bytes) {
        return FileId._fromProtobuf(lib.FileID.decode(bytes));
    }

    /**
     * @param {string} address
     * @returns {FileId}
     */
    static fromSolidityAddress(address) {
        const [shard, realm, file] = fromSolidityAddress(address);
        return new FileId(shard, realm, file);
    }

    /**
     * @returns {string} solidity address
     */
    toSolidityAddress() {
        return toSolidityAddress([this.shard, this.realm, this.num]);
    }

    /**
     * @internal
     * @returns {proto.IFileID}
     */
    _toProtobuf() {
        return {
            fileNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.FileID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {FileId}
     */
    clone() {
        const id = new FileId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @param {FileId} other
     * @returns {number}
     */
    compare(other) {
        return compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num]
        );
    }
}

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITopicID} proto.ITopicID
 */

/**
 * Unique identifier for a topic (used by the consensus service).
 */
class TopicId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     */
    constructor(props, realm, num) {
        const result = constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {string} text
     * @returns {TopicId}
     */
    static fromString(text) {
        const result = fromString(text);
        const id = new TopicId(result);
        id._checksum = result.checksum;
        return id;
    }

    /**
     * @internal
     * @param {proto.ITopicID} id
     * @returns {TopicId}
     */
    static _fromProtobuf(id) {
        const topicId = new TopicId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.topicNum != null ? id.topicNum : 0
        );

        return topicId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TopicId}
     */
    static fromBytes(bytes) {
        return TopicId._fromProtobuf(lib.TopicID.decode(bytes));
    }

    /**
     * @param {string} address
     * @returns {TopicId}
     */
    static fromSolidityAddress(address) {
        const [shard, realm, topic] = fromSolidityAddress(address);
        return new TopicId(shard, realm, topic);
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        return toSolidityAddress([this.shard, this.realm, this.num]);
    }

    /**
     * @returns {proto.ITopicID}
     */
    _toProtobuf() {
        return {
            topicNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.TopicID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {TopicId}
     */
    clone() {
        const id = new TopicId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @param {TopicId} other
     * @returns {number}
     */
    compare(other) {
        return compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num]
        );
    }
}

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency token on Hedera.
 */
class TokenId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     */
    constructor(props, realm, num) {
        const result = constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {string} text
     * @returns {TokenId}
     */
    static fromString(text) {
        const result = fromString(text);
        const id = new TokenId(result);
        id._checksum = result.checksum;
        return id;
    }

    /**
     * @internal
     * @param {proto.ITokenID} id
     * @returns {TokenId}
     */
    static _fromProtobuf(id) {
        const tokenId = new TokenId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.tokenNum != null ? id.tokenNum : 0
        );

        return tokenId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TokenId}
     */
    static fromBytes(bytes) {
        return TokenId._fromProtobuf(lib.TokenID.decode(bytes));
    }

    /**
     * @param {string} address
     * @returns {TokenId}
     */
    static fromSolidityAddress(address) {
        return new TokenId(...fromSolidityAddress(address));
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        return toSolidityAddress([this.shard, this.realm, this.num]);
    }

    /**
     * @internal
     * @returns {proto.ITokenID}
     */
    _toProtobuf() {
        return {
            tokenNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.TokenID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {TokenId}
     */
    clone() {
        const id = new TokenId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @param {TokenId} other
     * @returns {number}
     */
    compare(other) {
        return compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num]
        );
    }
}

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 *
 * @augments {EntityId<proto.IScheduleID>}
 */

class ScheduleId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     */
    constructor(props, realm, num) {
        const result = constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {string} text
     * @returns {ScheduleId}
     */
    static fromString(text) {
        const result = fromString(text);
        const id = new ScheduleId(result);
        id._checksum = result.checksum;
        return id;
    }

    /**
     * @internal
     * @param {proto.IScheduleID} id
     * @returns {ScheduleId}
     */
    static _fromProtobuf(id) {
        const scheduleId = new ScheduleId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.scheduleNum != null ? id.scheduleNum : 0
        );

        return scheduleId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {ScheduleId}
     */
    static fromBytes(bytes) {
        return ScheduleId._fromProtobuf(lib.ScheduleID.decode(bytes));
    }

    /**
     * @param {string} address
     * @returns {ScheduleId}
     */
    static fromSolidityAddress(address) {
        return new ScheduleId(...fromSolidityAddress(address));
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        return toSolidityAddress([this.shard, this.realm, this.num]);
    }

    /**
     * @internal
     * @returns {proto.ScheduleID}
     */
    _toProtobuf() {
        return {
            scheduleNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.ScheduleID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {ScheduleId}
     */
    clone() {
        const id = new ScheduleId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @param {ScheduleId} other
     * @returns {number}
     */
    compare(other) {
        return compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num]
        );
    }
}

class ExchangeRate {
    /**
     * @private
     * @param {object} props
     * @param {number} props.hbars
     * @param {number} props.cents
     * @param {Date} props.expirationTime
     */
    constructor(props) {
        /**
         * Denotes Hbar equivalent to cents (USD)
         *
         * @readonly
         * @type {number}
         */
        this.hbars = props.hbars;

        /**
         * Denotes cents (USD) equivalent to Hbar
         *
         * @readonly
         * @type {number}
         */
        this.cents = props.cents;

        /**
         * Expiration time of this exchange rate
         *
         * @readonly
         * @type {Date}
         */
        this.expirationTime = props.expirationTime;

        /**
         * Calculated exchange rate
         *
         * @readonly
         * @type {number}
         */
        this.exchangeRateInCents = props.cents / props.hbars;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {import("@hashgraph/proto").IExchangeRate} rate
     * @returns {ExchangeRate}
     */
    static _fromProtobuf(rate) {
        return new ExchangeRate({
            hbars: /** @type {number} */ (rate.hbarEquiv),
            cents: /** @type {number} */ (rate.centEquiv),
            expirationTime: new Date(
                rate.expirationTime != null
                    ? rate.expirationTime.seconds != null
                        ? long.isLong(rate.expirationTime.seconds)
                            ? rate.expirationTime.seconds.toInt()
                            : rate.expirationTime.seconds
                        : 0 * 1000
                    : 0 * 1000
            ),
        });
    }

    /**
     * @internal
     * @returns {import("@hashgraph/proto").IExchangeRate}
     */
    _toProtobuf() {
        return {
            hbarEquiv: this.hbars,
            centEquiv: this.cents,
            expirationTime: {
                seconds: long.fromNumber(this.expirationTime.getSeconds()),
            },
        };
    }
}

/**
 * The consensus result for a transaction, which might not be currently known,
 * or may succeed or fail.
 */
class TransactionReceipt {
    /**
     * @private
     * @param {object} props
     * @param {Status} props.status
     * @param {?AccountId} props.accountId
     * @param {?FileId} props.fileId
     * @param {?ContractId} props.contractId
     * @param {?TopicId} props.topicId
     * @param {?TokenId} props.tokenId
     * @param {?ScheduleId} props.scheduleId
     * @param {?ExchangeRate} props.exchangeRate
     * @param {?Long} props.topicSequenceNumber
     * @param {?Uint8Array} props.topicRunningHash
     * @param {?Long} props.totalSupply
     * @param {?TransactionId} props.scheduledTransactionId
     * @param {Long[]} props.serials
     * @param {TransactionReceipt[]} props.duplicates
     * @param {TransactionReceipt[]} props.children
     */
    constructor(props) {
        /**
         * Whether the transaction succeeded or failed (or is unknown).
         *
         * @readonly
         */
        this.status = props.status;

        /**
         * The account ID, if a new account was created.
         *
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * The file ID, if a new file was created.
         *
         * @readonly
         */
        this.fileId = props.fileId;

        /**
         * The contract ID, if a new contract was created.
         *
         * @readonly
         */
        this.contractId = props.contractId;

        /**
         * The topic ID, if a new topic was created.
         *
         * @readonly
         */
        this.topicId = props.topicId;

        /**
         * The token ID, if a new token was created.
         *
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The schedule ID, if a new schedule was created.
         *
         * @readonly
         */
        this.scheduleId = props.scheduleId;

        /**
         * The exchange rate of Hbars to cents (USD).
         *
         * @readonly
         */
        this.exchangeRate = props.exchangeRate;

        /**
         * Updated sequence number for a consensus service topic.
         *
         * @readonly
         */
        this.topicSequenceNumber = props.topicSequenceNumber;

        /**
         * Updated running hash for a consensus service topic.
         *
         * @readonly
         */
        this.topicRunningHash = props.topicRunningHash;

        /**
         * Updated total supply for a token
         *
         * @readonly
         */
        this.totalSupply = props.totalSupply;

        this.scheduledTransactionId = props.scheduledTransactionId;

        this.serials = props.serials;

        /**
         * @readonly
         */
        this.duplicates = props.duplicates;

        /**
         * @readonly
         */
        this.children = props.children;

        Object.freeze(this);
    }

    /**
     * @internal
     * @returns {proto.ITransactionGetReceiptResponse}
     */
    _toProtobuf() {
        const duplicates = this.duplicates.map(
            (receipt) =>
                /** @type {proto.ITransactionReceipt} */ (
                    receipt._toProtobuf().receipt
                )
        );
        const children = this.children.map(
            (receipt) =>
                /** @type {proto.ITransactionReceipt} */ (
                    receipt._toProtobuf().receipt
                )
        );

        return {
            duplicateTransactionReceipts: duplicates,
            childTransactionReceipts: children,
            receipt: {
                status: this.status.valueOf(),

                accountID:
                    this.accountId != null
                        ? this.accountId._toProtobuf()
                        : null,
                fileID: this.fileId != null ? this.fileId._toProtobuf() : null,
                contractID:
                    this.contractId != null
                        ? this.contractId._toProtobuf()
                        : null,
                topicID:
                    this.topicId != null ? this.topicId._toProtobuf() : null,
                tokenID:
                    this.tokenId != null ? this.tokenId._toProtobuf() : null,
                scheduleID:
                    this.scheduleId != null
                        ? this.scheduleId._toProtobuf()
                        : null,

                topicRunningHash:
                    this.topicRunningHash == null
                        ? null
                        : this.topicRunningHash,

                topicSequenceNumber: this.topicSequenceNumber,

                exchangeRate: {
                    nextRate: null,
                    currentRate:
                        this.exchangeRate != null
                            ? this.exchangeRate._toProtobuf()
                            : null,
                },

                scheduledTransactionID:
                    this.scheduledTransactionId != null
                        ? this.scheduledTransactionId._toProtobuf()
                        : null,

                serialNumbers: this.serials,
                newTotalSupply: this.totalSupply,
            },
        };
    }

    /**
     * @internal
     * @param {proto.ITransactionGetReceiptResponse} response
     * @returns {TransactionReceipt}
     */
    static _fromProtobuf(response) {
        const receipt = /** @type {proto.ITransactionReceipt} */ (
            response.receipt
        );

        const exchangeRateSet = /** @type {proto.IExchangeRateSet} */ (
            receipt.exchangeRate
        );

        const children =
            response.childTransactionReceipts != null
                ? response.childTransactionReceipts.map((child) =>
                      TransactionReceipt._fromProtobuf({ receipt: child })
                  )
                : [];

        const duplicates =
            response.duplicateTransactionReceipts != null
                ? response.duplicateTransactionReceipts.map((duplicate) =>
                      TransactionReceipt._fromProtobuf({ receipt: duplicate })
                  )
                : [];

        return new TransactionReceipt({
            status: Status._fromCode(
                receipt.status != null ? receipt.status : 0
            ),

            accountId:
                receipt.accountID != null
                    ? AccountId._fromProtobuf(receipt.accountID)
                    : null,

            fileId:
                receipt.fileID != null
                    ? FileId._fromProtobuf(receipt.fileID)
                    : null,

            contractId:
                receipt.contractID != null
                    ? ContractId._fromProtobuf(receipt.contractID)
                    : null,

            topicId:
                receipt.topicID != null
                    ? TopicId._fromProtobuf(receipt.topicID)
                    : null,

            tokenId:
                receipt.tokenID != null
                    ? TokenId._fromProtobuf(receipt.tokenID)
                    : null,

            scheduleId:
                receipt.scheduleID != null
                    ? ScheduleId._fromProtobuf(receipt.scheduleID)
                    : null,

            exchangeRate:
                receipt.exchangeRate != null
                    ? ExchangeRate._fromProtobuf(
                          /** @type {proto.IExchangeRate} */
                          (exchangeRateSet.currentRate)
                      )
                    : null,

            topicSequenceNumber:
                receipt.topicSequenceNumber == null
                    ? null
                    : long.fromString(receipt.topicSequenceNumber.toString()),

            topicRunningHash:
                receipt.topicRunningHash != null
                    ? new Uint8Array(receipt.topicRunningHash)
                    : null,

            totalSupply:
                receipt.newTotalSupply != null
                    ? long.fromString(receipt.newTotalSupply.toString())
                    : null,

            scheduledTransactionId:
                receipt.scheduledTransactionID != null
                    ? TransactionId._fromProtobuf(
                          receipt.scheduledTransactionID
                      )
                    : null,
            serials:
                receipt.serialNumbers != null
                    ? receipt.serialNumbers.map((serial) =>
                          long.fromValue(serial)
                      )
                    : [],
            children,
            duplicates,
        });
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TransactionReceipt}
     */
    static fromBytes(bytes) {
        return TransactionReceipt._fromProtobuf(
            lib.TransactionGetReceiptResponse.decode(bytes)
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.TransactionGetReceiptResponse.encode(
            this._toProtobuf()
        ).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ITransactionReceipt} proto.ITransactionReceipt
 * @typedef {import("@hashgraph/proto").ITransactionGetReceiptQuery} proto.ITransactionGetReceiptQuery
 * @typedef {import("@hashgraph/proto").ITransactionGetReceiptResponse} proto.ITransactionGetReceiptResponse
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 */

/**
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @augments {Query<TransactionReceipt>}
 */
class TransactionReceiptQuery extends Query {
    /**
     * @param {object} [props]
     * @param {TransactionId | string} [props.transactionId]
     * @param {boolean} [props.includeDuplicates]
     * @param {boolean} [props.includeChildren]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TransactionId}
         */
        this._transactionId = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._includeChildren = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._includeDuplicates = null;

        if (props.transactionId != null) {
            this.setTransactionId(props.transactionId);
        }

        if (props.includeChildren != null) {
            this.setIncludeChildren(props.includeChildren);
        }

        if (props.includeDuplicates != null) {
            this.setIncludeDuplicates(props.includeDuplicates);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {TransactionReceiptQuery}
     */
    static _fromProtobuf(query) {
        const receipt = /** @type {proto.ITransactionGetReceiptQuery} */ (
            query.transactionGetReceipt
        );

        return new TransactionReceiptQuery({
            transactionId: receipt.transactionID
                ? TransactionId._fromProtobuf(receipt.transactionID)
                : undefined,
            includeDuplicates:
                receipt.includeDuplicates != null
                    ? receipt.includeDuplicates
                    : undefined,
            includeChildren:
                receipt.includeChildReceipts != null
                    ? receipt.includeChildReceipts
                    : undefined,
        });
    }

    /**
     * @returns {?TransactionId}
     */
    get transactionId() {
        return this._transactionId;
    }

    /**
     * Set the transaction ID for which the receipt is being requested.
     *
     * @param {TransactionId | string} transactionId
     * @returns {this}
     */
    setTransactionId(transactionId) {
        this._transactionId =
            typeof transactionId === "string"
                ? TransactionId.fromString(transactionId)
                : transactionId.clone();

        return this;
    }

    /**
     * @param {boolean} includeDuplicates
     * @returns {TransactionReceiptQuery}
     */
    setIncludeDuplicates(includeDuplicates) {
        this._includeDuplicates = includeDuplicates;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get includeDuplicates() {
        return this._includeDuplicates != null
            ? this._includeDuplicates
            : false;
    }

    /**
     * @param {boolean} includeChildren
     * @returns {TransactionReceiptQuery}
     */
    setIncludeChildren(includeChildren) {
        this._includeChildren = includeChildren;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get includeChildren() {
        return this._includeChildren != null ? this._includeChildren : false;
    }

    /**
     * @override
     * @protected
     * @returns {boolean}
     */
    _isPaymentRequired() {
        return false;
    }

    /**
     * @override
     * @internal
     * @param {proto.IQuery} request
     * @param {proto.IResponse} response
     * @returns {ExecutionState}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        let status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : lib.ResponseCodeEnum.OK
        );

        Logger$1.debug(
            `[${this._getLogId()}] received node precheck status ${status.toString()}`
        );

        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.ReceiptNotFound:
                return ExecutionState.Retry;
            case Status.Ok:
                break;
            default:
                return ExecutionState.Error;
        }

        const transactionGetReceipt =
            /** @type {proto.ITransactionGetReceiptResponse} */ (
                response.transactionGetReceipt
            );
        const receipt = /** @type {proto.ITransactionReceipt} */ (
            transactionGetReceipt.receipt
        );
        const receiptStatusCode = /** @type {proto.ResponseCodeEnum} */ (
            receipt.status
        );

        status = Status._fromCode(receiptStatusCode);

        Logger$1.debug(
            `[${this._getLogId()}] received receipt status ${status.toString()}`
        );

        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.ReceiptNotFound:
                return ExecutionState.Retry;
            case Status.Success:
                return ExecutionState.Finished;
            default:
                return ExecutionState.Error;
        }
    }

    /**
     * @override
     * @internal
     * @param {proto.IQuery} request
     * @param {proto.IResponse} response
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        let status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : lib.ResponseCodeEnum.OK
        );

        switch (status) {
            case Status.Ok:
                // Do nothing
                break;

            default:
                return new PrecheckStatusError({
                    status,
                    transactionId: this._getTransactionId(),
                });
        }

        const transactionGetReceipt =
            /** @type {proto.ITransactionGetReceiptResponse} */ (
                response.transactionGetReceipt
            );
        const receipt = /** @type {proto.ITransactionReceipt} */ (
            transactionGetReceipt.receipt
        );
        const receiptStatusCode = /** @type {proto.ResponseCodeEnum} */ (
            receipt.status
        );

        status = Status._fromCode(receiptStatusCode);

        return new ReceiptStatusError({
            status,
            transactionId: this._getTransactionId(),
            transactionReceipt: TransactionReceipt._fromProtobuf(
                transactionGetReceipt
            ),
        });
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (
            this._transactionId != null &&
            this._transactionId.accountId != null
        ) {
            this._transactionId.accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getTransactionReceipts(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const transactionGetReceipt =
            /** @type {proto.ITransactionGetReceiptResponse} */ (
                response.transactionGetReceipt
            );
        return /** @type {proto.IResponseHeader} */ (
            transactionGetReceipt.header
        );
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<TransactionReceipt>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const transactionGetReceipt =
            /** @type {proto.ITransactionGetReceiptResponse} */ (
                response.transactionGetReceipt
            );

        return Promise.resolve(
            TransactionReceipt._fromProtobuf(transactionGetReceipt)
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            transactionGetReceipt: {
                header,
                transactionID:
                    this._transactionId != null
                        ? this._transactionId._toProtobuf()
                        : null,
                includeDuplicates: this._includeDuplicates,
                includeChildReceipts: this._includeChildren,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        return `TransactionReceiptQuery:${this._timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "transactionGetReceipt",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TransactionReceiptQuery._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IAccountAmount} proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("long")} Long
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency transfer.
 */
class Transfer {
    /**
     * @internal
     * @param {object} props
     * @param {AccountId | string} props.accountId
     * @param {number | string | Long | BigNumber | Hbar} props.amount
     * @param {boolean} props.isApproved
     */
    constructor(props) {
        /**
         * The Account ID that sends or receives cryptocurrency.
         *
         * @readonly
         */
        this.accountId =
            props.accountId instanceof AccountId
                ? props.accountId
                : AccountId.fromString(props.accountId);

        /**
         * The amount of tinybars that the account sends(negative) or receives(positive).
         */
        this.amount =
            props.amount instanceof Hbar
                ? props.amount
                : new Hbar(props.amount);

        this.isApproved = props.isApproved;
    }

    /**
     * @internal
     * @param {proto.IAccountAmount[]} accountAmounts
     * @returns {Transfer[]}
     */
    static _fromProtobuf(accountAmounts) {
        const transfers = [];

        for (const transfer of accountAmounts) {
            transfers.push(
                new Transfer({
                    accountId: AccountId._fromProtobuf(
                        /** @type {proto.IAccountID} */ (transfer.accountID)
                    ),
                    amount: Hbar.fromTinybars(
                        transfer.amount != null ? transfer.amount : 0
                    ),
                    isApproved: /** @type {boolean} */ (transfer.isApproval),
                })
            );
        }

        return transfers;
    }

    /**
     * @internal
     * @returns {proto.IAccountAmount}
     */
    _toProtobuf() {
        return {
            accountID: this.accountId._toProtobuf(),
            amount: this.amount.toTinybars(),
            isApproval: this.isApproved,
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IContractLoginfo} proto.IContractLoginfo
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 */

/**
 * The log information for an event returned by a smart contract function call. One function call
 * may return several such events.
 */
class ContractLogInfo {
    /**
     * @param {object} props
     * @param {ContractId} props.contractId
     * @param {Uint8Array} props.bloom
     * @param {Uint8Array[]} props.topics
     * @param {Uint8Array} props.data
     */
    constructor(props) {
        /**
         * Address of a contract that emitted the event.
         *
         * @readonly
         */
        this.contractId = props.contractId;

        /**
         * Bloom filter for a particular log.
         *
         * @readonly
         */
        this.bloom = props.bloom;

        /**
         * Topics of a particular event.
         *
         * @readonly
         */
        this.topics = props.topics;

        /**
         * Event data.
         *
         * @readonly
         */
        this.data = props.data;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.IContractLoginfo} info
     * @returns {ContractLogInfo}
     */
    static _fromProtobuf(info) {
        return new ContractLogInfo({
            contractId: ContractId._fromProtobuf(
                /** @type {proto.IContractID} */ (info.contractID)
            ),
            bloom: info.bloom != null ? info.bloom : new Uint8Array(),
            topics: info.topic != null ? info.topic : [],
            data: info.data != null ? info.data : new Uint8Array(),
        });
    }

    /**
     * @internal
     * @returns {proto.IContractLoginfo}
     */
    _toProtobuf() {
        return {
            contractID: this.contractId._toProtobuf(),
            bloom: this.bloom,
            topic: this.topics,
            data: this.data,
        };
    }
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
function decode(data) {
    // eslint-disable-next-line node/no-unsupported-features/node-builtins
    return new TextDecoder().decode(data);
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
function encode(text) {
    // eslint-disable-next-line node/no-unsupported-features/node-builtins
    return new TextEncoder().encode(text);
}

class StorageChange {
    /**
     * @private
     * @param {object} props
     * @param {Uint8Array} props.slot
     * @param {Uint8Array} props.valueRead
     * @param {Uint8Array?} props.valueWritten
     */
    constructor(props) {
        this.slot = props.slot;
        this.valueRead = props.valueRead;
        this.valueWritten = props.valueWritten;
    }

    /**
     * @internal
     * @param {proto.IStorageChange} change
     * @returns {StorageChange}
     */
    static _fromProtobuf(change) {
        return new StorageChange({
            slot: /** @type {Uint8Array} */ (change.slot),
            valueRead: /** @type {Uint8Array} */ (change.valueRead),
            valueWritten:
                change.valueWritten != null && change.valueWritten.value != null
                    ? change.valueWritten.value
                    : null,
        });
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {StorageChange}
     */
    static fromBytes(bytes) {
        return StorageChange._fromProtobuf(lib.StorageChange.decode(bytes));
    }

    /**
     * @internal
     * @returns {proto.IStorageChange}
     */
    _toProtobuf() {
        return {
            slot: this.slot,
            valueRead: this.valueRead,
            valueWritten:
                this.valueWritten != null ? { value: this.valueWritten } : null,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.StorageChange.encode(this._toProtobuf()).finish();
    }
}

class ContractStateChange {
    /**
     * @private
     * @param {object} props
     * @param {ContractId} props.contractId
     * @param {StorageChange[]} props.storageChanges
     */
    constructor(props) {
        this.contractId = props.contractId;
        this.storageChanges = props.storageChanges;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.IContractStateChange} change
     * @returns {ContractStateChange}
     */
    static _fromProtobuf(change) {
        return new ContractStateChange({
            contractId: ContractId._fromProtobuf(
                /** @type {proto.IContractID} */ (change.contractID)
            ),
            storageChanges: (change.storageChanges != null
                ? change.storageChanges
                : []
            ).map((change) => StorageChange._fromProtobuf(change)),
        });
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {ContractStateChange}
     */
    static fromBytes(bytes) {
        return ContractStateChange._fromProtobuf(
            lib.ContractStateChange.decode(bytes)
        );
    }

    /**
     * @internal
     * @returns {proto.IContractStateChange} change
     */
    _toProtobuf() {
        const storageChanges = this.storageChanges.map((storageChange) =>
            storageChange._toProtobuf()
        );
        return {
            contractID: this.contractId._toProtobuf(),
            storageChanges,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.ContractStateChange.encode(this._toProtobuf()).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IContractFunctionResult} proto.IContractFunctionResult
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 */
/**
 * The result returned by a call to a smart contract function. This is part of the response to
 * a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance
 * transaction. The ContractCreateInstance transaction record has the results of the call to
 * the constructor.
 */
class ContractFunctionResult {
    /**
     * Constructor isn't part of the stable API
     *
     * @param {object} result
     * @param {?ContractId} result.contractId
     * @param {?string} result.errorMessage
     * @param {Uint8Array} result.bloom
     * @param {Long} result.gasUsed
     * @param {ContractLogInfo[]} result.logs
     * @param {ContractId[]} result.createdContractIds
     * @param {Uint8Array | null} result.evmAddress
     * @param {ContractStateChange[]} result.stateChanges
     * @param {Uint8Array} result.bytes
     */
    constructor(result) {
        /**
         * The smart contract instance whose function was called.
         */
        this.contractId = result.contractId;

        this.bytes = result.bytes;

        /**
         * Message In case there was an error during smart contract execution.
         */
        this.errorMessage = result.errorMessage;

        /**
         * Bloom filter for record
         */
        this.bloom = result.bloom;

        /**
         * Units of gas used  to execute contract.
         */
        this.gasUsed = result.gasUsed;

        /**
         * The log info for events returned by the function.
         */
        this.logs = result.logs;

        /**
         * @deprecated the list of smart contracts that were created by the function call.
         *
         * The created ids will now _also_ be externalized through internal transaction
         * records, where each record has its alias field populated with the new contract's
         * EVM address. (This is needed for contracts created with CREATE2, since
         * there is no longer a simple relationship between the new contract's 0.0.X id
         * and its Solidity address.)
         */
        // eslint-disable-next-line deprecation/deprecation
        this.createdContractIds = result.createdContractIds;

        this.evmAddress = result.evmAddress;

        this.stateChanges = result.stateChanges;
    }

    /**
     * @param {proto.IContractFunctionResult} result
     * @returns {ContractFunctionResult}
     */
    static _fromProtobuf(result) {
        const contractId = /** @type {proto.IContractID | null} */ (
            result.contractID
        );
        const gas = /** @type {Long | number} */ (result.gasUsed);

        return new ContractFunctionResult({
            bytes: /** @type {Uint8Array} */ (result.contractCallResult),
            contractId:
                contractId != null
                    ? ContractId._fromProtobuf(contractId)
                    : null,
            errorMessage:
                result.errorMessage != null ? result.errorMessage : null,
            bloom: /** @type {Uint8Array} */ (result.bloom),
            gasUsed: gas instanceof long ? gas : long.fromValue(gas),
            logs: (result.logInfo != null ? result.logInfo : []).map((info) =>
                ContractLogInfo._fromProtobuf(info)
            ),
            createdContractIds: (result.createdContractIDs != null
                ? result.createdContractIDs
                : []
            ).map((contractId) => ContractId._fromProtobuf(contractId)),
            evmAddress:
                result.evmAddress != null && result.evmAddress.value != null
                    ? result.evmAddress.value
                    : null,
            stateChanges: (result.stateChanges != null
                ? result.stateChanges
                : []
            ).map((change) => ContractStateChange._fromProtobuf(change)),
        });
    }

    /**
     * @returns {Uint8Array}
     */
    asBytes() {
        return this.bytes;
    }

    /**
     * @param {number} [index]
     * @returns {string}
     */
    getString(index) {
        return decode(this.getBytes(index));
    }

    /**
     * @private
     * @param {number} [index]
     * @returns {Uint8Array}
     */
    getBytes(index) {
        // Len should never be larger than Number.MAX
        // index * 32 is the position of the lenth
        // (index + 1) * 32 onward to (index + 1) * 32 + len will be the elements of the array
        // Arrays in solidity cannot be longer than 1024:
        // https://solidity.readthedocs.io/en/v0.4.21/introduction-to-smart-contracts.html
        const offset = this.getInt32(index);
        const len = safeView(this.bytes).getInt32(offset + 28);

        return this.bytes.subarray(offset + 32, offset + 32 + len);
    }

    /**
     * @param {number} [index]
     * @returns {Uint8Array}
     */
    getBytes32(index) {
        return this.bytes.subarray(
            (index != null ? index : 0) * 32,
            (index != null ? index : 0) * 32 + 32
        );
    }

    /**
     * @param {number} [index]
     * @returns {boolean}
     */
    getBool(index) {
        return this.bytes[(index != null ? index : 0) * 32 + 31] !== 0;
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getInt8(index) {
        return this.bytes[(index != null ? index : 0) * 32 + 31];
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getInt32(index) {
        // .getInt32() interprets as big-endian
        // Using DataView instead of Uint32Array because the latter interprets
        // using platform endianness which is little-endian on x86
        const position = (index != null ? index : 0) * 32 + 28;
        return safeView(this.bytes).getInt32(position);
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt64(index) {
        return new BigNumber$1(
            encode$1(
                this._getBytes32(index != null ? index : 0).subarray(24, 32)
            ),
            16
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt256(index) {
        return new BigNumber$1(
            encode$1(this._getBytes32(index != null ? index : 0)),
            16
        );
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getUint8(index) {
        return this.bytes[(index != null ? index : 0) * 32 + 31];
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getUint32(index) {
        // .getUint32() interprets as big-endian
        // Using DataView instead of Uint32Array because the latter interprets
        // using platform endianness which is little-endian on x86
        const position = (index != null ? index : 0) * 32 + 28;
        return safeView(this.bytes).getUint32(position);
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint64(index) {
        return new BigNumber$1(
            encode$1(this._getBytes32(index).subarray(24, 32)),
            16
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint256(index) {
        return new BigNumber$1(encode$1(this._getBytes32(index)), 16);
    }

    /**
     * @param {number} [index]
     * @returns {string}
     */
    getAddress(index) {
        return encode$1(
            this.bytes.subarray(
                (index != null ? index : 0) * 32 + 12,
                (index != null ? index : 0) * 32 + 32
            )
        );
    }

    /**
     * @param {number} [index]
     * @returns {Uint8Array}
     */
    _getBytes32(index) {
        return this.bytes.subarray(
            (index != null ? index : 0) * 32,
            (index != null ? index : 0) * 32 + 32
        );
    }
}

/**
 * @abstract
 * @template {{ toString(): string }} KeyT
 * @template {any} ValueT
 */
class ObjectMap {
    /**
     * @param {(s: string) => KeyT} fromString
     */
    constructor(fromString) {
        /** @type {Map<string, ValueT>} */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this._map = new Map();

        /** @type {Map<KeyT, ValueT>} */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.__map = new Map();

        this._fromString = fromString;
    }

    /**
     * @param {KeyT | string} key
     * @returns {?ValueT}
     */
    get(key) {
        const k = typeof key === "string" ? key : key.toString();

        const value = this._map.get(k);
        return value != null ? value : null;
    }

    /**
     * @internal
     * @param {KeyT} key
     * @param {ValueT} value
     */
    _set(key, value) {
        const k = typeof key === "string" ? key : key.toString();

        this._map.set(k, value);
        this.__map.set(key, value);
    }

    /**
     * @returns {IterableIterator<ValueT>}
     */
    values() {
        return this._map.values();
    }

    /**
     * @returns {number}
     */
    get size() {
        return this._map.size;
    }

    /**
     * @returns {IterableIterator<KeyT>}
     */
    keys() {
        return this.__map.keys();
    }

    /**
     * @returns {IterableIterator<[KeyT, ValueT]>}
     */
    [Symbol.iterator]() {
        return this.__map[Symbol.iterator]();
    }

    /**
     * @returns {string}
     */
    toString() {
        /** @type {Object.<string, any>} */
        const map = {};

        for (const [key, value] of this._map) {
            map[key] = value;
        }

        return JSON.stringify(map);
    }
}

/**
 * @augments {ObjectMap<AccountId, Long>}
 */
class TokenTransferAccountMap extends ObjectMap {
    constructor() {
        super((s) => AccountId.fromString(s));
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenTransferList} proto.ITokenTransferList
 * @typedef {import("@hashgraph/proto").IAccountAmount} proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @augments {ObjectMap<TokenId, TokenTransferAccountMap>}
 */
class TokenTransferMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }

    /**
     * @internal
     * @param {TokenId} tokenId
     * @param {AccountId} accountId
     * @param {Long} amount
     */
    __set(tokenId, accountId, amount) {
        const token = tokenId.toString();

        let _map = this._map.get(token);
        if (_map == null) {
            _map = new TokenTransferAccountMap();
            this._map.set(token, _map);
            this.__map.set(tokenId, _map);
        }

        _map._set(accountId, amount);
    }

    /**
     * @param {proto.ITokenTransferList[]} transfers
     * @returns {TokenTransferMap}
     */
    static _fromProtobuf(transfers) {
        const tokenTransfersMap = new TokenTransferMap();

        for (const transfer of transfers) {
            const token = TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (transfer.token)
            );

            for (const aa of transfer.transfers != null
                ? transfer.transfers
                : []) {
                const account = AccountId._fromProtobuf(
                    /** @type {proto.IAccountID} */ (aa.accountID)
                );

                tokenTransfersMap.__set(
                    token,
                    account,
                    /** @type {Long} */ (aa.amount)
                );
            }
        }

        return tokenTransfersMap;
    }

    /**
     * @returns {proto.ITokenTransferList[]}
     */
    _toProtobuf() {
        /** @type {proto.ITokenTransferList[]} */
        const tokenTransferList = [];

        for (const [tokenId, value] of this) {
            /** @type {proto.IAccountAmount[]} */
            const transfers = [];

            for (const [accountId, amount] of value) {
                transfers.push({
                    accountID: accountId._toProtobuf(),
                    amount: amount,
                });
            }

            tokenTransferList.push({
                token: tokenId._toProtobuf(),
                transfers: transfers,
            });
        }

        return tokenTransferList;
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenTransferList} proto.ITokenTransferList
 * @typedef {import("@hashgraph/proto").INftTransfer} proto.INftTransfer
 * @typedef {import("@hashgraph/proto").IAccountAmount} proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {object} NftTransfer
 * @property {AccountId} sender
 * @property {AccountId} recipient
 * @property {Long} serial
 * @property {boolean} isApproved
 */

/**
 * @augments {ObjectMap<TokenId, NftTransfer[]>}
 */
class TokenNftTransferMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }

    /**
     * @internal
     * @param {TokenId} tokenId
     * @param {NftTransfer} nftTransfer
     */
    __set(tokenId, nftTransfer) {
        const token = tokenId.toString();

        let _map = this._map.get(token);
        if (_map == null) {
            _map = [];
            this._map.set(token, _map);
            this.__map.set(tokenId, _map);
        }

        _map.push(nftTransfer);
    }

    /**
     * @param {proto.ITokenTransferList[]} transfers
     * @returns {TokenNftTransferMap}
     */
    static _fromProtobuf(transfers) {
        const tokenTransfersMap = new TokenNftTransferMap();

        for (const transfer of transfers) {
            const token = TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (transfer.token)
            );

            for (const aa of transfer.nftTransfers != null
                ? transfer.nftTransfers
                : []) {
                const sender = AccountId._fromProtobuf(
                    /** @type {proto.IAccountID} */ (aa.senderAccountID)
                );
                const recipient = AccountId._fromProtobuf(
                    /** @type {proto.IAccountID} */ (aa.receiverAccountID)
                );

                tokenTransfersMap.__set(token, {
                    sender,
                    recipient,
                    serial: long.fromValue(
                        /** @type {Long} */ (aa.serialNumber)
                    ),
                    isApproved: false,
                });
            }
        }

        return tokenTransfersMap;
    }

    /**
     * @returns {proto.ITokenTransferList[]}
     */
    _toProtobuf() {
        /** @type {proto.ITokenTransferList[]} */
        const tokenTransferList = [];

        for (const [tokenId, value] of this) {
            /** @type {proto.INftTransfer[]} */
            const transfers = [];

            for (const transfer of value) {
                transfers.push({
                    senderAccountID: transfer.sender._toProtobuf(),
                    receiverAccountID: transfer.recipient._toProtobuf(),
                    serialNumber: transfer.serial,
                });
            }

            tokenTransferList.push({
                token: tokenId._toProtobuf(),
                nftTransfers: transfers,
            });
        }

        return tokenTransferList;
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IAssessedCustomFee} proto.IAssessedCustomFee
 */

class AssessedCustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     * @param {TokenId | string} [props.tokenId]
     * @param {Long | number} [props.amount]
     * @param {AccountId[]} [props.payerAccountIds]
     */
    constructor(props = {}) {
        /**
         * @type {?AccountId}
         */
        this._feeCollectorAccountId;

        if (props.feeCollectorAccountId != null) {
            this.setFeeCollectorAccountId(props.feeCollectorAccountId);
        }

        /**
         * @type {?TokenId}
         */
        this._tokenId;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        /**
         * @type {?Long}
         */
        this._amount;

        if (props.amount != null) {
            this.setAmount(props.amount);
        }

        /**
         * @type {?AccountId[]}
         */
        this._payerAccountIds;

        if (props.payerAccountIds != null) {
            this.setPayerAccountIds(props.payerAccountIds);
        }
    }

    /**
     * @returns {?AccountId}
     */
    get feeCollectorAccountId() {
        return this._feeCollectorAccountId;
    }

    /**
     * @param {AccountId | string} feeCollectorAccountId
     * @returns {this}
     */
    setFeeCollectorAccountId(feeCollectorAccountId) {
        this._feeCollectorAccountId =
            typeof feeCollectorAccountId === "string"
                ? AccountId.fromString(feeCollectorAccountId)
                : feeCollectorAccountId;
        return this;
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._tokenId =
            typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {AssessedCustomFee}
     */
    setAmount(amount) {
        this._amount =
            typeof amount === "number" ? long.fromNumber(amount) : amount;
        return this;
    }

    /**
     * @returns {?AccountId[]}
     */
    get payerAccountIds() {
        return this._payerAccountIds;
    }

    /**
     * @param {AccountId[]} payerAccountIds
     * @returns {AssessedCustomFee}
     */
    setPayerAccountIds(payerAccountIds) {
        this._payerAccountIds = payerAccountIds;
        return this;
    }

    /**
     * @internal
     * @param {proto.IAssessedCustomFee} fee
     * @returns {AssessedCustomFee}
     */
    static _fromProtobuf(fee) {
        return new AssessedCustomFee({
            feeCollectorAccountId:
                fee.feeCollectorAccountId != null
                    ? AccountId._fromProtobuf(fee.feeCollectorAccountId)
                    : undefined,
            tokenId:
                fee.tokenId != null
                    ? TokenId._fromProtobuf(fee.tokenId)
                    : undefined,
            amount: fee.amount != null ? fee.amount : undefined,
            payerAccountIds:
                fee.effectivePayerAccountId != null
                    ? fee.effectivePayerAccountId.map((id) =>
                          AccountId._fromProtobuf(id)
                      )
                    : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {proto.IAssessedCustomFee}
     */
    _toProtobuf() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId != null
                    ? this.feeCollectorAccountId._toProtobuf()
                    : null,
            tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            amount: this._amount,
            effectivePayerAccountId:
                this._payerAccountIds != null
                    ? this._payerAccountIds.map((id) => id._toProtobuf())
                    : null,
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenAssociation} proto.ITokenAssociation
 */

class TokenAssociation {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.accountId]
     * @param {TokenId | string} [props.tokenId]
     */
    constructor(props = {}) {
        /**
         * @type {?AccountId}
         */
        this._accountId;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        /**
         * @type {?TokenId}
         */
        this._tokenId;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        this._defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId;
        return this;
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._tokenId =
            typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
        return this;
    }

    /**
     * @internal
     * @abstract
     * @param {proto.ITokenAssociation} association
     * @returns {TokenAssociation}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(association) {
        return new TokenAssociation({
            accountId:
                association.accountId != null
                    ? AccountId._fromProtobuf(association.accountId)
                    : undefined,
            tokenId:
                association.tokenId != null
                    ? TokenId._fromProtobuf(association.tokenId)
                    : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {proto.ITokenAssociation}
     */
    _toProtobuf() {
        return {
            accountId:
                this._accountId != null
                    ? this._accountId._toProtobuf()
                    : undefined,
            tokenId:
                this._tokenId != null ? this._tokenId._toProtobuf() : undefined,
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenTransferList} proto.ITokenTransferList
 * @typedef {import("@hashgraph/proto").IAccountAmount} proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency tokentransfer.
 */
class TokenTransfer {
    /**
     * @internal
     * @param {object} props
     * @param {TokenId | string} props.tokenId
     * @param {AccountId | string} props.accountId
     * @param {number | null} props.expectedDecimals
     * @param {Long | number} props.amount
     * @param {boolean} props.isApproved
     */
    constructor(props) {
        /**
         * The Token ID that sends or receives cryptocurrency.
         *
         * @readonly
         */
        this.tokenId =
            props.tokenId instanceof TokenId
                ? props.tokenId
                : TokenId.fromString(props.tokenId);

        /**
         * The Account ID that sends or receives cryptocurrency.
         *
         * @readonly
         */
        this.accountId =
            props.accountId instanceof AccountId
                ? props.accountId
                : AccountId.fromString(props.accountId);

        this.expectedDecimals = props.expectedDecimals;
        this.amount = long.fromValue(props.amount);
        this.isApproved = props.isApproved;
    }

    /**
     * @internal
     * @param {proto.ITokenTransferList[]} tokenTransfers
     * @returns {TokenTransfer[]}
     */
    static _fromProtobuf(tokenTransfers) {
        const transfers = [];

        for (const tokenTransfer of tokenTransfers) {
            const tokenId = TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (tokenTransfer.token)
            );
            const expectedDecimals =
                tokenTransfer.expectedDecimals != null
                    ? /** @type {number | null } */ (
                          tokenTransfer.expectedDecimals.value
                      )
                    : null;

            for (const transfer of tokenTransfer.transfers != null
                ? tokenTransfer.transfers
                : []) {
                transfers.push(
                    new TokenTransfer({
                        tokenId,
                        accountId: AccountId._fromProtobuf(
                            /** @type {proto.IAccountID} */ (transfer.accountID)
                        ),
                        expectedDecimals,
                        amount:
                            transfer.amount != null
                                ? transfer.amount
                                : long.ZERO,
                        isApproved: transfer.isApproval == true,
                    })
                );
            }
        }

        return transfers;
    }

    /**
     * @internal
     * @returns {proto.IAccountAmount}
     */
    _toProtobuf() {
        return {
            accountID: this.accountId._toProtobuf(),
            amount: this.amount,
            isApproval: this.isApproved,
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ICryptoAllowance} proto.ICryptoAllowance
 * @typedef {import("@hashgraph/proto").IGrantedCryptoAllowance} proto.IGrantedCryptoAllowance
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("long")} Long
 */

class HbarAllowance {
    /**
     * @internal
     * @param {object} props
     * @param {AccountId} props.spenderAccountId
     * @param {AccountId | null} props.ownerAccountId
     * @param {Hbar} props.amount
     */
    constructor(props) {
        /**
         * The account ID of the hbar allowance spender.
         *
         * @readonly
         */
        this.spenderAccountId = props.spenderAccountId;

        /**
         * The account ID of the hbar allowance owner.
         *
         * @readonly
         */
        this.ownerAccountId = props.ownerAccountId;

        /**
         * The current balance of the spender's allowance in tinybars.
         *
         * @readonly
         */
        this.amount = props.amount;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.ICryptoAllowance} approval
     * @returns {HbarAllowance}
     */
    static _fromProtobuf(approval) {
        return new HbarAllowance({
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (approval.spender)
            ),
            ownerAccountId:
                approval.owner != null
                    ? AccountId._fromProtobuf(
                          /**@type {proto.IAccountID}*/ (approval.owner)
                      )
                    : null,
            amount: Hbar.fromTinybars(
                approval.amount != null ? approval.amount : 0
            ),
        });
    }

    /**
     * @internal
     * @param {proto.IGrantedCryptoAllowance} approval
     * @returns {HbarAllowance}
     */
    static _fromGrantedProtobuf(approval) {
        return new HbarAllowance({
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (approval.spender)
            ),
            ownerAccountId: null,
            amount: Hbar.fromTinybars(
                approval.amount != null ? approval.amount : 0
            ),
        });
    }

    /**
     * @internal
     * @returns {proto.ICryptoAllowance}
     */
    _toProtobuf() {
        return {
            spender: this.spenderAccountId._toProtobuf(),
            owner:
                this.ownerAccountId != null
                    ? this.ownerAccountId._toProtobuf()
                    : null,
            amount: this.amount.toTinybars(),
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenAllowance} proto.ITokenAllowance
 * @typedef {import("@hashgraph/proto").IGrantedTokenAllowance} proto.IGrantedTokenAllowance
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

class TokenAllowance {
    /**
     * @internal
     * @param {object} props
     * @param {TokenId} props.tokenId
     * @param {AccountId} props.spenderAccountId
     * @param {AccountId | null} props.ownerAccountId
     * @param {Long | null} props.amount
     */
    constructor(props) {
        /**
         * The token that the allowance pertains to.
         *
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The account ID of the spender of the hbar allowance.
         *
         * @readonly
         */
        this.spenderAccountId = props.spenderAccountId;

        /**
         * The account ID of the owner of the hbar allowance.
         *
         * @readonly
         */
        this.ownerAccountId = props.ownerAccountId;

        /**
         * The current balance of the spender's token allowance.
         * **NOTE**: If `null`, the spender has access to all of the account owner's NFT instances
         * (currently owned and any in the future).
         *
         * @readonly
         */
        this.amount = props.amount;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.ITokenAllowance} allowance
     * @returns {TokenAllowance}
     */
    static _fromProtobuf(allowance) {
        return new TokenAllowance({
            tokenId: TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (allowance.tokenId)
            ),
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (allowance.spender)
            ),
            ownerAccountId:
                allowance.owner != null
                    ? AccountId._fromProtobuf(
                          /**@type {proto.IAccountID}*/ (allowance.owner)
                      )
                    : null,
            amount:
                allowance.amount != null
                    ? long.fromValue(/** @type {Long} */ (allowance.amount))
                    : null,
        });
    }

    /**
     * @internal
     * @param {proto.IGrantedTokenAllowance} allowance
     * @returns {TokenAllowance}
     */
    static _fromGrantedProtobuf(allowance) {
        return new TokenAllowance({
            tokenId: TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (allowance.tokenId)
            ),
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (allowance.spender)
            ),
            ownerAccountId: null,
            amount:
                allowance.amount != null
                    ? long.fromValue(/** @type {Long} */ (allowance.amount))
                    : null,
        });
    }

    /**
     * @internal
     * @returns {proto.ITokenAllowance}
     */
    _toProtobuf() {
        return {
            tokenId: this.tokenId._toProtobuf(),
            spender: this.spenderAccountId._toProtobuf(),
            owner:
                this.ownerAccountId != null
                    ? this.ownerAccountId._toProtobuf()
                    : null,
            amount: this.amount,
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IGrantedNftAllowance} proto.IGrantedNftAllowance
 * @typedef {import("@hashgraph/proto").INftAllowance} proto.INftAllowance
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

class TokenNftAllowance {
    /**
     * @internal
     * @param {object} props
     * @param {TokenId} props.tokenId
     * @param {AccountId} props.spenderAccountId
     * @param {AccountId | null} props.ownerAccountId
     * @param {Long[] | null} props.serialNumbers
     * @param {boolean} props.allSerials
     */
    constructor(props) {
        /**
         * The token that the allowance pertains to.
         *
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The account ID of the spender of the hbar allowance.
         *
         * @readonly
         */
        this.spenderAccountId = props.spenderAccountId;

        /**
         * The account ID of the owner of the hbar allowance.
         *
         * @readonly
         */
        this.ownerAccountId = props.ownerAccountId;

        /**
         * The current balance of the spender's token allowance.
         * **NOTE**: If `null`, the spender has access to all of the account owner's NFT instances
         * (currently owned and any in the future).
         *
         * @readonly
         */
        this.serialNumbers = props.serialNumbers;

        /**
         * @readonly
         */
        this.allSerials = props.allSerials;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.INftAllowance} allowance
     * @returns {TokenNftAllowance}
     */
    static _fromProtobuf(allowance) {
        const allSerials =
            allowance.approvedForAll != null &&
            allowance.approvedForAll.value == true;
        return new TokenNftAllowance({
            tokenId: TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (allowance.tokenId)
            ),
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (allowance.spender)
            ),
            ownerAccountId:
                allowance.owner != null
                    ? AccountId._fromProtobuf(
                          /**@type {proto.IAccountID}*/ (allowance.owner)
                      )
                    : null,
            serialNumbers: allSerials
                ? null
                : allowance.serialNumbers != null
                ? allowance.serialNumbers.map((serialNumber) =>
                      long.fromValue(serialNumber)
                  )
                : [],
            allSerials,
        });
    }

    /**
     * @internal
     * @param {proto.IGrantedNftAllowance} allowance
     * @returns {TokenNftAllowance}
     */
    static _fromGrantedProtobuf(allowance) {
        return new TokenNftAllowance({
            tokenId: TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (allowance.tokenId)
            ),
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (allowance.spender)
            ),
            ownerAccountId: null,
            serialNumbers:
                allowance.approvedForAll != null && allowance.approvedForAll
                    ? null
                    : allowance.serialNumbers != null
                    ? allowance.serialNumbers.map((serialNumber) =>
                          long.fromValue(serialNumber)
                      )
                    : [],
            allSerials:
                allowance.approvedForAll != null && allowance.approvedForAll,
        });
    }

    /**
     * @internal
     * @returns {proto.INftAllowance}
     */
    _toProtobuf() {
        return {
            tokenId: this.tokenId._toProtobuf(),
            spender: this.spenderAccountId._toProtobuf(),
            owner:
                this.ownerAccountId != null
                    ? this.ownerAccountId._toProtobuf()
                    : null,
            approvedForAll:
                this.serialNumbers == null ? { value: this.allSerials } : null,
            serialNumbers: this.serialNumbers,
        };
    }
}

/**
 * @typedef {import("../token/TokenId.js").default} TokenId
 */

/**
 * Response when the client sends the node TransactionGetRecordResponse.
 */
class TransactionRecord {
    /**
     * @private
     * @param {object} props
     * @param {ContractFunctionResult} [props.contractFunctionResult]
     * @param {TransactionReceipt} props.receipt
     * @param {Uint8Array} props.transactionHash
     * @param {Timestamp} props.consensusTimestamp
     * @param {TransactionId} props.transactionId
     * @param {string} props.transactionMemo
     * @param {Hbar} props.transactionFee
     * @param {Transfer[]} props.transfers
     * @param {TokenTransferMap} props.tokenTransfers
     * @param {TokenTransfer[]} props.tokenTransfersList
     * @param {?ScheduleId} props.scheduleRef
     * @param {AssessedCustomFee[]} props.assessedCustomFees
     * @param {TokenNftTransferMap} props.nftTransfers
     * @param {TokenAssocation[]} props.automaticTokenAssociations
     * @param {Timestamp | null} props.parentConsensusTimestamp
     * @param {PublicKey | null} props.aliasKey
     * @param {TransactionRecord[]} props.duplicates
     * @param {TransactionRecord[]} props.children
     * @param {HbarAllowance[]} props.hbarAllowanceAdjustments
     * @param {TokenAllowance[]} props.tokenAllowanceAdjustments
     * @param {TokenNftAllowance[]} props.nftAllowanceAdjustments
     */
    constructor(props) {
        /**
         * The status (reach consensus, or failed, or is unknown) and the ID of
         * any new account/file/instance created.
         *
         * @readonly
         */
        this.receipt = props.receipt;

        /**
         * The hash of the Transaction that executed (not the hash of any Transaction that failed
         * for having a duplicate TransactionID).
         *
         * @readonly
         */
        this.transactionHash = props.transactionHash;

        /**
         * The consensus timestamp (or null if didn't reach consensus yet).
         *
         * @readonly
         */
        this.consensusTimestamp = props.consensusTimestamp;

        /**
         * The ID of the transaction this record represents.
         *
         * @readonly
         */
        this.transactionId = props.transactionId;

        /**
         * The memo that was submitted as part of the transaction (max 100 bytes).
         *
         * @readonly
         */
        this.transactionMemo = props.transactionMemo;

        /**
         * The actual transaction fee charged,
         * not the original transactionFee value from TransactionBody.
         *
         * @readonly
         */
        this.transactionFee = props.transactionFee;

        /**
         * All hbar transfers as a result of this transaction, such as fees, or transfers performed
         * by the transaction, or by a smart contract it calls, or by the creation of threshold
         * records that it triggers.
         *
         * @readonly
         */
        this.transfers = props.transfers;

        /**
         * Record of the value returned by the smart contract function or constructor.
         *
         * @readonly
         */
        this.contractFunctionResult =
            props.contractFunctionResult != null
                ? props.contractFunctionResult
                : null;

        /**
         * All the token transfers from this account
         *
         * @readonly
         */
        this.tokenTransfers = props.tokenTransfers;

        /**
         * All the token transfers from this account
         *
         * @readonly
         */
        this.tokenTransfersList = props.tokenTransfersList;

        /**
         * Reference to the scheduled transaction ID that this transaction record represent
         *
         * @readonly
         */
        this.scheduleRef = props.scheduleRef;

        /**
         * All custom fees that were assessed during a CryptoTransfer, and must be paid if the
         * transaction status resolved to SUCCESS
         *
         * @readonly
         */
        this.assessedCustomFees = props.assessedCustomFees;

        /** @readonly */
        this.nftTransfers = props.nftTransfers;

        /**
         * All token associations implicitly created while handling this transaction
         *
         * @readonly
         */
        this.automaticTokenAssociations = props.automaticTokenAssociations;

        /**
         * The parent consensus timestamp
         *
         * @readonly
         */
        this.parentConsensusTimestamp = props.parentConsensusTimestamp;

        this.aliasKey = props.aliasKey;

        /**
         * @readonly
         */
        this.duplicates = props.duplicates;

        /**
         * @readonly
         */
        this.children = props.children;

        /**
         * @readonly
         */
        this.hbarAllowanceAdjustments = props.hbarAllowanceAdjustments;

        /**
         * @readonly
         */
        this.tokenAllowanceAdjustments = props.tokenAllowanceAdjustments;

        /**
         * @readonly
         */
        this.nftAllowanceAdjustments = props.nftAllowanceAdjustments;

        Object.freeze(this);
    }

    /**
     * @internal
     * @returns {proto.ITransactionGetRecordResponse}
     */
    _toProtobuf() {
        const tokenTransfers = this.tokenTransfers._toProtobuf();
        const nftTransfers = this.nftTransfers._toProtobuf();

        const tokenTransferLists = [];

        for (const tokenTransfer of tokenTransfers) {
            for (const nftTransfer of nftTransfers) {
                if (
                    tokenTransfer.token != null &&
                    nftTransfer.token != null &&
                    tokenTransfer.token.shardNum ===
                        nftTransfer.token.shardNum &&
                    tokenTransfer.token.realmNum ===
                        nftTransfer.token.realmNum &&
                    tokenTransfer.token.tokenNum === nftTransfer.token.tokenNum
                ) {
                    tokenTransferLists.push({
                        token: tokenTransfer.token,
                        transfers: tokenTransfer.transfers,
                        nftTransfers: tokenTransfer.nftTransfers,
                    });
                } else {
                    tokenTransferLists.push(tokenTransfer);
                    tokenTransferLists.push(nftTransfer);
                }
            }
        }

        const duplicates = this.duplicates.map(
            (record) =>
                /** @type {proto.ITransactionRecord} */ (
                    record._toProtobuf().transactionRecord
                )
        );
        const children = this.children.map(
            (record) =>
                /** @type {proto.ITransactionRecord} */ (
                    record._toProtobuf().transactionRecord
                )
        );

        return {
            duplicateTransactionRecords: duplicates,
            childTransactionRecords: children,
            transactionRecord: {
                receipt: this.receipt._toProtobuf().receipt,

                transactionHash:
                    this.transactionHash != null ? this.transactionHash : null,
                consensusTimestamp:
                    this.consensusTimestamp != null
                        ? this.consensusTimestamp._toProtobuf()
                        : null,
                transactionID:
                    this.transactionId != null
                        ? this.transactionId._toProtobuf()
                        : null,
                memo:
                    this.transactionMemo != null ? this.transactionMemo : null,

                transactionFee:
                    this.transactionFee != null
                        ? this.transactionFee.toTinybars()
                        : null,

                // TODO: Implement `ContractFunctionResult._toProtobuf()`
                //                 contractCallResult:
                //                     this.contractFunctionResult != null
                //                         ? this.contractFunctionResult
                //                         : null,
                //
                //                 contractCreateResult:
                //                     this.contractFunctionResult != null
                //                         ? this.contractFunctionResult
                //                         : null,

                transferList:
                    this.transfers != null
                        ? {
                              accountAmounts: this.transfers.map((transfer) =>
                                  transfer._toProtobuf()
                              ),
                          }
                        : null,
                tokenTransferLists,
                scheduleRef:
                    this.scheduleRef != null
                        ? this.scheduleRef._toProtobuf()
                        : null,
                assessedCustomFees: this.assessedCustomFees.map((fee) =>
                    fee._toProtobuf()
                ),
                automaticTokenAssociations: this.automaticTokenAssociations.map(
                    (association) => association._toProtobuf()
                ),
                parentConsensusTimestamp:
                    this.parentConsensusTimestamp != null
                        ? this.parentConsensusTimestamp._toProtobuf()
                        : null,
                alias:
                    this.aliasKey != null
                        ? lib.Key.encode(
                              this.aliasKey._toProtobufKey()
                          ).finish()
                        : null,
                cryptoAdjustments: this.hbarAllowanceAdjustments.map(
                    (allowance) => {
                        return allowance._toProtobuf();
                    }
                ),

                tokenAdjustments: this.tokenAllowanceAdjustments.map(
                    (allowance) => {
                        return allowance._toProtobuf();
                    }
                ),

                nftAdjustments: this.nftAllowanceAdjustments.map(
                    (allowance) => {
                        return allowance._toProtobuf();
                    }
                ),
            },
        };
    }

    /**
     * @internal
     * @param {proto.ITransactionGetRecordResponse} response
     * @returns {TransactionRecord}
     */
    static _fromProtobuf(response) {
        const record = /** @type {proto.ITransactionRecord} */ (
            response.transactionRecord
        );

        let aliasKey =
            record.alias != null && record.alias.length > 0
                ? Key._fromProtobufKey(lib.Key.decode(record.alias))
                : null;

        if (!(aliasKey instanceof PublicKey)) {
            aliasKey = null;
        }

        const children =
            response.childTransactionRecords != null
                ? response.childTransactionRecords.map((child) =>
                      TransactionRecord._fromProtobuf({
                          transactionRecord: child,
                      })
                  )
                : [];

        const duplicates =
            response.duplicateTransactionRecords != null
                ? response.duplicateTransactionRecords.map((duplicate) =>
                      TransactionRecord._fromProtobuf({
                          transactionRecord: duplicate,
                      })
                  )
                : [];

        const contractFunctionResult =
            record.contractCallResult != null
                ? ContractFunctionResult._fromProtobuf(
                      record.contractCallResult
                  )
                : record.contractCreateResult != null
                ? ContractFunctionResult._fromProtobuf(
                      record.contractCreateResult
                  )
                : undefined;

        return new TransactionRecord({
            receipt: TransactionReceipt._fromProtobuf({
                receipt: /** @type {proto.ITransactionReceipt} */ (
                    record.receipt
                ),
            }),
            transactionHash:
                record.transactionHash != null
                    ? record.transactionHash
                    : new Uint8Array(),
            consensusTimestamp: Timestamp._fromProtobuf(
                /** @type {proto.ITimestamp} */
                (record.consensusTimestamp)
            ),
            transactionId: TransactionId._fromProtobuf(
                /** @type {proto.ITransactionID} */ (record.transactionID)
            ),
            transactionMemo: record.memo != null ? record.memo : "",
            transactionFee: Hbar.fromTinybars(
                record.transactionFee != null ? record.transactionFee : 0
            ),
            transfers: Transfer._fromProtobuf(
                record.transferList != null
                    ? record.transferList.accountAmounts != null
                        ? record.transferList.accountAmounts
                        : []
                    : []
            ),
            contractFunctionResult,
            tokenTransfers: TokenTransferMap._fromProtobuf(
                record.tokenTransferLists != null
                    ? record.tokenTransferLists
                    : []
            ),
            tokenTransfersList: TokenTransfer._fromProtobuf(
                record.tokenTransferLists != null
                    ? record.tokenTransferLists
                    : []
            ),
            scheduleRef:
                record.scheduleRef != null
                    ? ScheduleId._fromProtobuf(record.scheduleRef)
                    : null,
            assessedCustomFees:
                record.assessedCustomFees != null
                    ? record.assessedCustomFees.map((fee) =>
                          AssessedCustomFee._fromProtobuf(fee)
                      )
                    : [],
            nftTransfers: TokenNftTransferMap._fromProtobuf(
                record.tokenTransferLists != null
                    ? record.tokenTransferLists
                    : []
            ),
            automaticTokenAssociations:
                record.automaticTokenAssociations != null
                    ? record.automaticTokenAssociations.map((association) =>
                          TokenAssociation._fromProtobuf(association)
                      )
                    : [],
            parentConsensusTimestamp:
                record.parentConsensusTimestamp != null
                    ? Timestamp._fromProtobuf(record.parentConsensusTimestamp)
                    : null,
            aliasKey,
            duplicates,
            children,
            hbarAllowanceAdjustments: (record.cryptoAdjustments != null
                ? record.cryptoAdjustments
                : []
            ).map((allowance) => {
                return HbarAllowance._fromProtobuf(allowance);
            }),
            tokenAllowanceAdjustments: (record.tokenAdjustments != null
                ? record.tokenAdjustments
                : []
            ).map((allowance) => {
                return TokenAllowance._fromProtobuf(allowance);
            }),
            nftAllowanceAdjustments: (record.nftAdjustments != null
                ? record.nftAdjustments
                : []
            ).map((allowance) => {
                return TokenNftAllowance._fromProtobuf(allowance);
            }),
        });
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TransactionRecord}
     */
    static fromBytes(bytes) {
        return TransactionRecord._fromProtobuf(
            lib.TransactionGetRecordResponse.decode(bytes)
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.TransactionGetRecordResponse.encode(
            this._toProtobuf()
        ).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").ITransactionRecord} proto.ITransactionRecord
 * @typedef {import("@hashgraph/proto").ITransactionReceipt} proto.ITransactionReceipt
 * @typedef {import("@hashgraph/proto").ITransactionGetRecordResponse} proto.ITransactionGetRecordResponse
 * @typedef {import("@hashgraph/proto").ITransactionGetRecordQuery} proto.ITransactionGetRecordQuery
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<TransactionRecord>}
 */
class TransactionRecordQuery extends Query {
    /**
     * @param {object} [props]
     * @param {TransactionId} [props.transactionId]
     * @param {boolean} [props.includeChildren]
     * @param {boolean} [props.includeDuplicates]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TransactionId}
         */
        this._transactionId = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._includeChildren = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._includeDuplicates = null;

        if (props.transactionId != null) {
            this.setTransactionId(props.transactionId);
        }

        if (props.includeChildren != null) {
            this.setIncludeChildren(props.includeChildren);
        }

        if (props.includeDuplicates != null) {
            this.setIncludeDuplicates(props.includeDuplicates);
        }
    }

    /**
     * @returns {?TransactionId}
     */
    get transactionId() {
        return this._transactionId;
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {TransactionRecordQuery}
     */
    static _fromProtobuf(query) {
        const record = /** @type {proto.ITransactionGetRecordQuery} */ (
            query.transactionGetRecord
        );

        return new TransactionRecordQuery({
            transactionId: record.transactionID
                ? TransactionId._fromProtobuf(record.transactionID)
                : undefined,
            includeChildren:
                record.includeChildRecords != null
                    ? record.includeChildRecords
                    : undefined,
            includeDuplicates:
                record.includeDuplicates != null
                    ? record.includeDuplicates
                    : undefined,
        });
    }

    /**
     * Set the transaction ID for which the record is being requested.
     *
     * @param {TransactionId | string} transactionId
     * @returns {TransactionRecordQuery}
     */
    setTransactionId(transactionId) {
        this._transactionId =
            typeof transactionId === "string"
                ? TransactionId.fromString(transactionId)
                : transactionId.clone();

        return this;
    }

    /**
     * @param {boolean} includeChildren
     * @returns {TransactionRecordQuery}
     */
    setIncludeChildren(includeChildren) {
        this._includeChildren = includeChildren;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get includeChildren() {
        return this._includeChildren != null ? this._includeChildren : false;
    }

    /**
     * @param {boolean} includeDuplicates
     * @returns {TransactionRecordQuery}
     */
    setIncludeDuplicates(includeDuplicates) {
        this._duplicates = includeDuplicates;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get includeDuplicates() {
        return this._duplicates != null ? this._duplicates : false;
    }

    /**
     * @override
     * @internal
     * @param {proto.IQuery} request
     * @param {proto.IResponse} response
     * @returns {ExecutionState}
     */
    _shouldRetry(request, response) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        let status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : lib.ResponseCodeEnum.OK
        );

        Logger$1.debug(
            `[${this._getLogId()}] received node precheck status ${status.toString()}`
        );

        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.ReceiptNotFound:
            case Status.RecordNotFound:
                return ExecutionState.Retry;

            case Status.Ok:
                break;

            default:
                return ExecutionState.Error;
        }

        const transactionGetRecord =
            /** @type {proto.ITransactionGetRecordResponse} */ (
                response.transactionGetRecord
            );
        const header = /** @type {proto.IResponseHeader} */ (
            transactionGetRecord.header
        );

        if (header.responseType === lib.ResponseType.COST_ANSWER) {
            return ExecutionState.Finished;
        }

        const record = /** @type {proto.ITransactionRecord} */ (
            transactionGetRecord.transactionRecord
        );
        const receipt = /** @type {proto.ITransactionReceipt} */ (
            record.receipt
        );
        const receiptStatusCode = /** @type {proto.ResponseCodeEnum} */ (
            receipt.status
        );
        status = Status._fromCode(receiptStatusCode);

        Logger$1.debug(
            `[${this._getLogId()}] received record's receipt ${status.toString()}`
        );

        switch (status) {
            case Status.Ok:
            case Status.Busy:
            case Status.Unknown:
            case Status.ReceiptNotFound:
            case Status.RecordNotFound:
                return ExecutionState.Retry;

            case Status.Success:
                return ExecutionState.Finished;

            default:
                return ExecutionState.Error;
        }
    }

    /**
     * @override
     * @internal
     * @param {proto.IQuery} request
     * @param {proto.IResponse} response
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        let status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : lib.ResponseCodeEnum.OK
        );

        switch (status) {
            case Status.Ok:
                // Do nothing
                break;

            default:
                return new PrecheckStatusError({
                    status,
                    transactionId: this._getTransactionId(),
                });
        }

        const transactionGetRecord =
            /** @type {proto.ITransactionGetRecordResponse} */ (
                response.transactionGetRecord
            );
        const record = /** @type {proto.ITransactionRecord} */ (
            transactionGetRecord.transactionRecord
        );
        const receipt = /** @type {proto.ITransactionReceipt} */ (
            record.receipt
        );
        const receiptStatusError = /** @type {proto.ResponseCodeEnum} */ (
            receipt.status
        );

        status = Status._fromCode(receiptStatusError);

        return new ReceiptStatusError({
            status,
            transactionId: this._getTransactionId(),
            transactionReceipt: TransactionReceipt._fromProtobuf({ receipt }),
        });
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (
            this._transactionId != null &&
            this._transactionId.accountId != null
        ) {
            this._transactionId.accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getTxRecordByTxID(request);
    }

    /**
     * @override
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const transactionGetRecord =
            /** @type {proto.ITransactionGetRecordResponse} */ (
                response.transactionGetRecord
            );
        return /** @type {proto.IResponseHeader} */ (
            transactionGetRecord.header
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<TransactionRecord>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const record = /** @type {proto.ITransactionGetRecordResponse} */ (
            response.transactionGetRecord
        );

        return Promise.resolve(TransactionRecord._fromProtobuf(record));
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            transactionGetRecord: {
                header,
                transactionID:
                    this._transactionId != null
                        ? this._transactionId._toProtobuf()
                        : null,
                includeChildRecords: this._includeChildren,
                includeDuplicates: this._includeDuplicates,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `TransactionRecordQuery:${timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "transactionGetRecord",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TransactionRecordQuery._fromProtobuf
);

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("./TransactionId.js").default} TransactionId
 * @typedef {import("./TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./TransactionRecord.js").default} TransactionRecord
 */

class TransactionResponse {
    /**
     * @internal
     * @param {object} props
     * @param {AccountId} props.nodeId
     * @param {Uint8Array} props.transactionHash
     * @param {TransactionId} props.transactionId
     */
    constructor(props) {
        /** @readonly */
        this.nodeId = props.nodeId;

        /** @readonly */
        this.transactionHash = props.transactionHash;

        /** @readonly */
        this.transactionId = props.transactionId;

        Object.freeze(this);
    }

    /**
     * @param {Client} client
     * @returns {Promise<TransactionReceipt>}
     */
    async getReceipt(client) {
        const receipt = await new TransactionReceiptQuery()
            .setTransactionId(this.transactionId)
            .setNodeAccountIds([this.nodeId])
            .execute(client);

        if (receipt.status !== Status.Success) {
            throw new ReceiptStatusError({
                transactionReceipt: receipt,
                status: receipt.status,
                transactionId: this.transactionId,
            });
        }

        return receipt;
    }

    /**
     * @param {Client} client
     * @returns {Promise<TransactionRecord>}
     */
    async getRecord(client) {
        await this.getReceipt(client);

        return new TransactionRecordQuery()
            .setTransactionId(this.transactionId)
            .setNodeAccountIds([this.nodeId])
            .execute(client);
    }
}

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
async function digest(data) {
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
    return new Uint8Array(await window.crypto.subtle.digest("SHA-384", data));
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 */

/**
 * @augments {ObjectMap<AccountId, Uint8Array>}
 */
class TransactionHashMap extends ObjectMap {
    constructor() {
        super((s) => AccountId.fromString(s));
    }

    /**
     * @param {import("./Transaction.js").default} transaction
     * @returns {Promise<TransactionHashMap>}
     */
    static async _fromTransaction(transaction) {
        const hashes = new TransactionHashMap();

        for (let i = 0; i < transaction._nodeAccountIds.length; i++) {
            const nodeAccountId = transaction._nodeAccountIds.list[i];
            const tx = /** @type {proto.ITransaction} */ (
                transaction._transactions.get(i)
            );
            const hash = await digest(
                /** @type {Uint8Array} */ (tx.signedTransactionBytes)
            );

            hashes._set(nodeAccountId, hash);
        }

        return hashes;
    }
}

/**
 * @augments {ObjectMap<PublicKey, Uint8Array>}
 */
class NodeAccountIdSignatureMap extends ObjectMap {
    constructor() {
        super((s) => PublicKey.fromString(s));
    }

    /**
     * @param {import("@hashgraph/proto").ISignatureMap} sigMap
     * @returns {NodeAccountIdSignatureMap}
     */
    static _fromTransactionSigMap(sigMap) {
        const signatures = new NodeAccountIdSignatureMap();

        const sigPairs = sigMap.sigPair != null ? sigMap.sigPair : [];

        for (const sigPair of sigPairs) {
            if (sigPair.pubKeyPrefix != null) {
                if (sigPair.ed25519 != null) {
                    signatures._set(
                        PublicKey.fromBytesED25519(sigPair.pubKeyPrefix),
                        sigPair.ed25519
                    );
                } else if (sigPair.ECDSASecp256k1 != null) {
                    signatures._set(
                        PublicKey.fromBytesECDSA(sigPair.pubKeyPrefix),
                        sigPair.ECDSASecp256k1
                    );
                }
            }
        }

        return signatures;
    }
}

/**
 * @augments {ObjectMap<AccountId, NodeAccountIdSignatureMap>}
 */
class SignatureMap extends ObjectMap {
    constructor() {
        super((s) => AccountId.fromString(s));
    }

    /**
     * @param {import("./Transaction.js").default} transaction
     * @returns {SignatureMap}
     */
    static _fromTransaction(transaction) {
        const signatures = new SignatureMap();

        for (let i = 0; i < transaction._nodeAccountIds.length; i++) {
            const sigMap = transaction._signedTransactions.get(i).sigMap;

            if (sigMap != null) {
                signatures._set(
                    transaction._nodeAccountIds.list[i],
                    NodeAccountIdSignatureMap._fromTransactionSigMap(sigMap)
                );
            }
        }

        return signatures;
    }
}

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignatureMap} proto.ISignatureMap
 * @typedef {import("@hashgraph/proto").ISignaturePair} proto.ISignaturePair
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").ITransactionList} proto.ITransactionList
 * @typedef {import("@hashgraph/proto").ITransactionID} proto.ITransactionID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ResponseCodeEnum} proto.ResponseCodeEnum
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ISchedulableTransactionBody} proto.ISchedulableTransactionBody
 */

/**
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 * @typedef {import("../PrivateKey.js").default} PrivateKey
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Signer.js").default} Signer
 */

// 90 days (in seconds)
const DEFAULT_AUTO_RENEW_PERIOD = long.fromValue(7776000);

// maximum value of i64 (so there is never a record generated)
const DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(
    long.fromString("9223372036854775807")
);

// 120 seconds
const DEFAULT_TRANSACTION_VALID_DURATION = 120;

const CHUNK_SIZE = 1024;

/**
 * @type {Map<NonNullable<proto.TransactionBody["data"]>, (transactions: proto.ITransaction[], signedTransactions: proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: proto.TransactionBody[]) => Transaction>}
 */
const TRANSACTION_REGISTRY = new Map();

/**
 * Base class for all transactions that may be submitted to Hedera.
 *
 * @abstract
 * @augments {Executable<proto.ITransaction, proto.ITransactionResponse, TransactionResponse>}
 */
class Transaction extends Executable {
    // A SDK transaction is composed of multiple, raw protobuf transactions.
    // These should be functionally identicasl, with the exception of pointing to
    // different nodes.

    // When retrying a transaction after a network error or retry-able
    // status response, we try a different transaction and thus a different node.

    constructor() {
        super();

        /**
         * List of proto transactions that have been built from this SDK
         * transaction. Each one should share the same transaction ID.
         *
         * @internal
         * @type {List<proto.ITransaction | null>}
         */
        this._transactions = new List();

        /**
         * List of proto transactions that have been built from this SDK
         * transaction. Each one should share the same transaction ID.
         *
         * @internal
         * @type {List<proto.ISignedTransaction>}
         */
        this._signedTransactions = new List();

        /**
         * Set of public keys (as string) who have signed this transaction so
         * we do not allow them to sign it again.
         *
         * @internal
         * @type {Set<string>}
         */
        this._signerPublicKeys = new Set();

        /**
         * @private
         * @type {number}
         */
        this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;

        /**
         * @protected
         * @type {Hbar}
         */
        this._defaultMaxTransactionFee = new Hbar(2);

        /**
         * @private
         * @type {Hbar | null}
         */
        this._maxTransactionFee = null;

        /**
         * @private
         * @type {string}
         */
        this._transactionMemo = "";

        /**
         * @protected
         * @type {List<TransactionId>}
         */
        this._transactionIds = new List();

        /**
         * @private
         * @type {AccountId | null}
         */
        this._operatorAccountId = null;

        /**
         * @private
         * @type {PublicKey[]}
         */
        this._publicKeys = [];

        /**
         * @private
         * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}
         */
        this._transactionSigners = [];

        /**
         * @private
         * @type {?boolean}
         */
        this._regenerateTransactionId = null;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {Transaction}
     */
    static fromBytes(bytes) {
        const signedTransactions = [];
        const transactionIds = [];
        const nodeIds = [];

        /** @type {string[]} */
        const transactionIdStrings = [];

        /** @type {string[]} */
        const nodeIdStrings = [];

        const bodies = [];

        const list = lib.TransactionList.decode(bytes).transactionList;

        if (list.length === 0) {
            const transaction = lib.Transaction.decode(bytes);

            if (transaction.signedTransactionBytes.length !== 0) {
                list.push(transaction);
            } else {
                list.push({
                    signedTransactionBytes: lib.SignedTransaction.encode({
                        bodyBytes: transaction.bodyBytes,
                        sigMap: transaction.sigMap,
                    }).finish(),
                });
            }
        }

        for (const transaction of list) {
            if (transaction.signedTransactionBytes == null) {
                throw new Error("Transaction.signedTransactionBytes are null");
            }

            const signedTransaction = lib.SignedTransaction.decode(
                transaction.signedTransactionBytes
            );
            signedTransactions.push(signedTransaction);

            const body = lib.TransactionBody.decode(
                signedTransaction.bodyBytes
            );

            if (body.data == null) {
                throw new Error("(BUG) body.data was not set in the protobuf");
            }

            bodies.push(body);

            if (body.transactionID != null) {
                const transactionId = TransactionId._fromProtobuf(
                    /** @type {proto.ITransactionID} */ (body.transactionID)
                );

                if (!transactionIdStrings.includes(transactionId.toString())) {
                    transactionIds.push(transactionId);
                    transactionIdStrings.push(transactionId.toString());
                }
            }

            if (body.nodeAccountID != null) {
                const nodeAccountId = AccountId._fromProtobuf(
                    /** @type {proto.IAccountID} */ (body.nodeAccountID)
                );

                if (!nodeIdStrings.includes(nodeAccountId.toString())) {
                    nodeIds.push(nodeAccountId);
                    nodeIdStrings.push(nodeAccountId.toString());
                }
            }
        }

        const body = bodies[0];

        if (body == null || body.data == null) {
            throw new Error(
                "No transaction found in bytes or failed to decode TransactionBody"
            );
        }

        const fromProtobuf = TRANSACTION_REGISTRY.get(body.data);

        if (fromProtobuf == null) {
            throw new Error(
                `(BUG) Transaction.fromBytes() not implemented for type ${body.data}`
            );
        }

        return fromProtobuf(
            list,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {ScheduleCreateTransaction}
     */
    schedule() {
        this._requireNotFrozen();

        if (SCHEDULE_CREATE_TRANSACTION.length != 1) {
            throw new Error(
                "ScheduleCreateTransaction has not been loaded yet"
            );
        }

        return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);
    }

    /**
     * @template {Transaction} TransactionT
     * @param {TransactionT} transaction
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TransactionT}
     */
    static _fromProtobufTransactions(
        transaction,
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];

        const zero = new AccountId(0);
        for (let i = 0; i < nodeIds.length; i++) {
            if (nodeIds[i].equals(zero)) {
                nodeIds.splice(i--, 1);
            }
        }

        transaction._transactions.setList(transactions);
        transaction._signedTransactions.setList(signedTransactions).setLocked();
        transaction._transactionIds.setList(transactionIds).setLocked();
        transaction._nodeAccountIds.setList(nodeIds).setLocked();

        transaction._nextNodeAccountIdIndex = 0;
        transaction._transactionValidDuration =
            body.transactionValidDuration != null &&
            body.transactionValidDuration.seconds != null
                ? long.fromValue(body.transactionValidDuration.seconds).toInt()
                : DEFAULT_TRANSACTION_VALID_DURATION;
        transaction._maxTransactionFee =
            body.transactionFee != null
                ? Hbar.fromTinybars(body.transactionFee)
                : new Hbar(0);
        transaction._transactionMemo = body.memo != null ? body.memo : "";

        for (let i = 0; i < nodeIds.length; i++) {
            const signedTransaction = signedTransactions[i];
            if (
                signedTransaction.sigMap != null &&
                signedTransaction.sigMap.sigPair != null
            ) {
                for (const sigPair of signedTransaction.sigMap.sigPair) {
                    transaction._signerPublicKeys.add(
                        encode$1(
                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix)
                        )
                    );

                    transaction._publicKeys.push(
                        PublicKey.fromBytes(
                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix)
                        )
                    );
                    transaction._transactionSigners.push(null);
                }
            }
        }

        return transaction;
    }

    /**
     * @override
     * @param {AccountId[]} nodeIds
     * @returns {this}
     */
    setNodeAccountIds(nodeIds) {
        this._requireNotFrozen();
        super.setNodeAccountIds(nodeIds);
        return this;
    }

    /**
     * @returns {number}
     */
    get transactionValidDuration() {
        return this._transactionValidDuration;
    }

    /**
     * Sets the duration (in seconds) that this transaction is valid for.
     *
     * This is defaulted to 120 seconds (from the time its executed).
     *
     * @param {number} validDuration
     * @returns {this}
     */
    setTransactionValidDuration(validDuration) {
        this._requireNotFrozen();
        this._transactionValidDuration = validDuration;

        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get maxTransactionFee() {
        return this._maxTransactionFee;
    }

    /**
     * Set the maximum transaction fee the operator (paying account)
     * is willing to pay.
     *
     * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee
     * @returns {this}
     */
    setMaxTransactionFee(maxTransactionFee) {
        this._requireNotFrozen();
        this._maxTransactionFee =
            maxTransactionFee instanceof Hbar
                ? maxTransactionFee
                : new Hbar(maxTransactionFee);

        return this;
    }

    /**
     * @returns {?boolean}
     */
    get regenerateTransactionId() {
        return this._regenerateTransactionId;
    }

    /**
     * Set the maximum transaction fee the operator (paying account)
     * is willing to pay.
     *
     * @param {boolean} regenerateTransactionId
     * @returns {this}
     */
    setRegenerateTransactionId(regenerateTransactionId) {
        this._requireNotFrozen();
        this._regenerateTransactionId = regenerateTransactionId;

        return this;
    }

    /**
     * @returns {string}
     */
    get transactionMemo() {
        return this._transactionMemo;
    }

    /**
     * Set a note or description to be recorded in the transaction
     * record (maximum length of 100 bytes).
     *
     * @param {string} transactionMemo
     * @returns {this}
     */
    setTransactionMemo(transactionMemo) {
        this._requireNotFrozen();
        this._transactionMemo = transactionMemo;

        return this;
    }

    /**
     * @returns {TransactionId}
     */
    get transactionId() {
        this._transactionIds.setLocked();

        if (this._transactionIds.isEmpty) {
            throw new Error(
                "transaction must have been frozen before getting the transaction ID, try calling `freeze`"
            );
        }

        return this._transactionIds.current;
    }

    /**
     * Set the ID for this transaction.
     *
     * The transaction ID includes the operator's account ( the account paying the transaction
     * fee). If two transactions have the same transaction ID, they won't both have an effect. One
     * will complete normally and the other will fail with a duplicate transaction status.
     *
     * Normally, you should not use this method. Just before a transaction is executed, a
     * transaction ID will be generated from the operator on the client.
     *
     * @param {TransactionId} transactionId
     * @returns {this}
     */
    setTransactionId(transactionId) {
        this._requireNotFrozen();
        this._transactionIds.setList([transactionId]).setLocked();

        return this;
    }

    /**
     * @param {PrivateKey} privateKey
     * @returns {Promise<this>}
     */
    sign(privateKey) {
        return this.signWith(privateKey.publicKey, (message) =>
            Promise.resolve(privateKey.sign(message))
        );
    }

    /**
     * @param {PublicKey} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {Promise<this>}
     */
    async signWith(publicKey, transactionSigner) {
        if (!this._signOnDemand) {
            this._requireFrozen();
        }

        const publicKeyData = publicKey.toBytesRaw();

        // note: this omits the DER prefix on purpose because Hedera doesn't
        // support that in the protobuf. this means that we would fail
        // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER
        // prefixes here
        const publicKeyHex = encode$1(publicKeyData);

        if (this._signerPublicKeys.has(publicKeyHex)) {
            // this public key has already signed this transaction
            return this;
        }

        this._transactions.clear();
        this._signerPublicKeys.add(publicKeyHex);

        if (this._signOnDemand) {
            this._publicKeys.push(publicKey);
            this._transactionSigners.push(transactionSigner);

            return this;
        }

        for (const signedTransaction of this._signedTransactions.list) {
            const bodyBytes = /** @type {Uint8Array} */ (
                signedTransaction.bodyBytes
            );
            const signature = await transactionSigner(bodyBytes);

            if (signedTransaction.sigMap == null) {
                signedTransaction.sigMap = {};
            }

            if (signedTransaction.sigMap.sigPair == null) {
                signedTransaction.sigMap.sigPair = [];
            }

            signedTransaction.sigMap.sigPair.push(
                publicKey._toProtobufSignature(signature)
            );
        }

        return this;
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<this>}
     */
    signWithOperator(client) {
        const operator = client._operator;

        if (operator == null) {
            throw new Error(
                "`client` must have an operator to sign with the operator"
            );
        }

        if (!this._isFrozen()) {
            this.freezeWith(client);
        }

        return this.signWith(operator.publicKey, operator.transactionSigner);
    }

    /**
     * @param {PublicKey} publicKey
     * @param {Uint8Array} signature
     * @returns {this}
     */
    addSignature(publicKey, signature) {
        this._requireOneNodeAccountId();

        if (!this.isFrozen()) {
            this.freeze();
        }

        const publicKeyData = publicKey.toBytesRaw();
        const publicKeyHex = encode$1(publicKeyData);

        if (this._signerPublicKeys.has(publicKeyHex)) {
            // this public key has already signed this transaction
            return this;
        }

        this._transactions.clear();

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();
        this._signedTransactions.setLocked();

        for (const transaction of this._signedTransactions.list) {
            if (transaction.sigMap == null) {
                transaction.sigMap = {};
            }

            if (transaction.sigMap.sigPair == null) {
                transaction.sigMap.sigPair = [];
            }

            transaction.sigMap.sigPair.push(
                publicKey._toProtobufSignature(signature)
            );
        }

        this._signerPublicKeys.add(publicKeyHex);
        this._publicKeys.push(publicKey);
        this._transactionSigners.push(null);

        return this;
    }

    /**
     * @returns {SignatureMap}
     */
    getSignatures() {
        this._requireFrozen();
        this._requireNotSignOnDemand();

        this._buildAllTransactions();

        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();

        return SignatureMap._fromTransaction(this);
    }

    /**
     * @returns {Promise<SignatureMap>}
     */
    async getSignaturesAsync() {
        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        if (!this._transactionIds.isEmpty) {
            this._transactionIds.setLocked();
        }

        if (!this._nodeAccountIds.isEmpty) {
            this._nodeAccountIds.setLocked();
        }

        await this._buildAllTransactionsAsync();

        this._transactions.setLocked();
        this._signedTransactions.setLocked();

        return SignatureMap._fromTransaction(this);
    }

    _setTransactionId() {
        if (this._operator == null && this._transactionIds.isEmpty) {
            throw new Error(
                "`transactionId` must be set or `client` must be provided with `freezeWith`"
            );
        }
    }

    /**
     * @param {?import("../client/Client.js").default<Channel, *>} client
     */
    _setNodeAccountIds(client) {
        if (!this._nodeAccountIds.isEmpty) {
            return;
        }

        if (client == null) {
            throw new Error(
                "`nodeAccountId` must be set or `client` must be provided with `freezeWith`"
            );
        }

        this._nodeAccountIds.setList(
            client._network.getNodeAccountIdsForExecute()
        );
    }

    _buildSignedTransactions() {
        if (this._signedTransactions.locked) {
            return;
        }

        this._signedTransactions.setList(
            this._nodeAccountIds.list.map((nodeId) =>
                this._makeSignedTransaction(nodeId)
            )
        );
    }

    /**
     * Freeze this transaction from future modification to prepare for
     * signing or serialization.
     *
     * @returns {this}
     */
    freeze() {
        return this.freezeWith(null);
    }

    /**
     * Freeze this transaction from further modification to prepare for
     * signing or serialization.
     *
     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
     * nodes to prepare this transaction for.
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client) {
        this._signOnDemand = client != null ? client._signOnDemand : false;
        this._operator = client != null ? client._operator : null;
        this._maxTransactionFee =
            this._maxTransactionFee == null
                ? client != null && client.defaultMaxTransactionFee != null
                    ? client.defaultMaxTransactionFee
                    : this._defaultMaxTransactionFee
                : this._maxTransactionFee;
        this._regenerateTransactionId =
            client != null && this._regenerateTransactionId == null
                ? client.defaultRegenerateTransactionId
                : this._regenerateTransactionId;

        this._setNodeAccountIds(client);
        this._setTransactionId();

        if (client != null) {
            for (const transactionId of this._transactionIds.list) {
                if (transactionId.accountId != null) {
                    transactionId.accountId.validateChecksum(client);
                }
            }
        }

        this._buildNewTransactionIdList();

        if (!this._signOnDemand) {
            this._buildSignedTransactions();
        }

        return this;
    }

    /**
     * @param {Signer} signer
     * @returns {Promise<this>}
     */
    async signWithSigner(signer) {
        await signer.signTransaction(this);
        return this;
    }

    /**
     * @param {Signer} signer
     * @returns {Promise<this>}
     */
    async freezeWithSigner(signer) {
        await signer.populateTransaction(this);
        await this.signWithSigner(signer);
        return this;
    }

    /**
     * Will error if sign-on-demand is enabled
     *
     * @returns {Uint8Array}
     */
    toBytes() {
        this._requireFrozen();
        this._requireNotSignOnDemand();

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();

        this._buildAllTransactions();

        return lib.TransactionList.encode({
            transactionList: /** @type {proto.ITransaction[]} */ (
                this._transactions.list
            ),
        }).finish();
    }

    /**
     * @returns {Promise<Uint8Array>}
     */
    async toBytesAsync() {
        this._requireFrozen();

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();

        await this._buildAllTransactionsAsync();

        this._transactions.setLocked();
        this._signedTransactions.setLocked();

        return lib.TransactionList.encode({
            transactionList: /** @type {proto.ITransaction[]} */ (
                this._transactions.list
            ),
        }).finish();
    }

    /**
     * @returns {Promise<Uint8Array>}
     */
    async getTransactionHash() {
        this._requireFrozen();

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        if (!this._transactionIds.isEmpty) {
            this._transactionIds.setLocked();
        }

        if (!this._nodeAccountIds.isEmpty) {
            this._nodeAccountIds.setLocked();
        }

        await this._buildAllTransactionsAsync();

        this._transactions.setLocked();
        this._signedTransactions.setLocked();

        return digest(
            /** @type {Uint8Array} */ (
                /** @type {proto.ITransaction} */ (this._transactions.get(0))
                    .signedTransactionBytes
            )
        );
    }

    /**
     * @returns {Promise<TransactionHashMap>}
     */
    async getTransactionHashPerNode() {
        this._requireFrozen();

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        if (!this._transactionIds.isEmpty) {
            this._transactionIds.setLocked();
        }

        if (!this._nodeAccountIds.isEmpty) {
            this._nodeAccountIds.setLocked();
        }

        await this._buildAllTransactionsAsync();

        return await TransactionHashMap._fromTransaction(this);
    }

    isFrozen() {
        return this._signedTransactions.length > 0;
    }

    /**
     * @returns {TransactionId}
     */
    _getTransactionId() {
        return this.transactionId;
    }

    /**
     * @param {Client} client
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
    _validateChecksums(client) {
        // Do nothing
    }

    /**
     * @override
     * @protected
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<void>}
     */
    async _beforeExecute(client) {
        if (!this._isFrozen()) {
            this.freezeWith(client);
        }

        if (client.isAutoValidateChecksumsEnabled()) {
            this._validateChecksums(client);
        }

        this._operator = client != null ? client._operator : null;

        if (this._operator != null) {
            await this.signWith(
                this._operator.publicKey,
                this._operator.transactionSigner
            );
        }
    }

    /**
     * @override
     * @internal
     * @returns {Promise<proto.ITransaction>}
     */
    async _makeRequestAsync() {
        const index =
            this._transactionIds.index * this._nodeAccountIds.length +
            this._nodeAccountIds.index;

        if (!this._signOnDemand) {
            this._buildTransaction(index);
            return /** @type {proto.ITransaction} */ (
                this._transactions.get(index)
            );
        }

        // Nothing is locked we can build a new transaction
        return await this._buildTransactionAsync();
    }

    /**
     * @internal
     * @returns {Promise<proto.ISignedTransaction>}
     */
    async _signTransaction() {
        const signedTransaction = this._makeSignedTransaction(
            this._nodeAccountIds.next
        );

        const bodyBytes = /** @type {Uint8Array} */ (
            signedTransaction.bodyBytes
        );

        for (let j = 0; j < this._publicKeys.length; j++) {
            const publicKey = this._publicKeys[j];
            const transactionSigner = this._transactionSigners[j];

            if (transactionSigner == null) {
                continue;
            }

            const signature = await transactionSigner(bodyBytes);

            if (signedTransaction.sigMap == null) {
                signedTransaction.sigMap = {};
            }

            if (signedTransaction.sigMap.sigPair == null) {
                signedTransaction.sigMap.sigPair = [];
            }

            signedTransaction.sigMap.sigPair.push(
                publicKey._toProtobufSignature(signature)
            );
        }

        return signedTransaction;
    }

    _buildNewTransactionIdList() {
        if (this._transactionIds.locked || this._operator == null) {
            return;
        }

        const transactionId = TransactionId.withValidStart(
            this._operator.accountId,
            Timestamp.generate()
        );

        this._transactionIds.set(this._transactionIds.index, transactionId);
    }

    _buildAllTransactions() {
        for (let i = 0; i < this._signedTransactions.length; i++) {
            this._buildTransaction(i);
        }
    }

    async _buildAllTransactionsAsync() {
        if (!this._signOnDemand) {
            this._buildAllTransactions();
            return;
        }

        this._buildSignedTransactions();

        if (this._transactions.locked) {
            return;
        }

        for (let i = 0; i < this._signedTransactions.length; i++) {
            this._transactions.push(await this._buildTransactionAsync());
        }
    }

    /**
     * @internal
     * @param {number} index
     */
    _buildTransaction(index) {
        if (this._transactions.length < index) {
            for (let i = this._transactions.length; i < index; i++) {
                this._transactions.push(null);
            }
        }

        this._transactions.setIfAbsent(index, () => {
            return {
                signedTransactionBytes: lib.SignedTransaction.encode(
                    this._signedTransactions.get(index)
                ).finish(),
            };
        });
    }

    /**
     * @internal
     * @returns {Promise<proto.ITransaction>}
     */
    async _buildTransactionAsync() {
        return {
            signedTransactionBytes: lib.SignedTransaction.encode(
                await this._signTransaction()
            ).finish(),
        };
    }

    /**
     * @override
     * @internal
     * @param {proto.ITransaction} request
     * @param {proto.ITransactionResponse} response
     * @returns {ExecutionState}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        const { nodeTransactionPrecheckCode } = response;

        const status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : lib.ResponseCodeEnum.OK
        );

        Logger$1.debug(
            `[${this._getLogId()}] received status ${status.toString()}`
        );

        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.PlatformTransactionNotCreated:
                return ExecutionState.Retry;
            case Status.Ok:
                return ExecutionState.Finished;
            case Status.TransactionExpired:
                if (
                    this._regenerateTransactionId == null ||
                    this._regenerateTransactionId
                ) {
                    this._buildNewTransactionIdList();
                    return ExecutionState.Retry;
                } else {
                    return ExecutionState.Error;
                }
            default:
                return ExecutionState.Error;
        }
    }

    /**
     * @override
     * @internal
     * @param {proto.ITransaction} request
     * @param {proto.ITransactionResponse} response
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response) {
        const { nodeTransactionPrecheckCode } = response;

        const status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : lib.ResponseCodeEnum.OK
        );

        return new PrecheckStatusError({
            status,
            transactionId: this._getTransactionId(),
        });
    }

    /**
     * @override
     * @protected
     * @param {proto.ITransactionResponse} response
     * @param {AccountId} nodeId
     * @param {proto.ITransaction} request
     * @returns {Promise<TransactionResponse>}
     */
    async _mapResponse(response, nodeId, request) {
        const transactionHash = await digest(
            /** @type {Uint8Array} */ (request.signedTransactionBytes)
        );
        const transactionId = this.transactionId;

        this._transactionIds.advance();

        return new TransactionResponse({
            nodeId,
            transactionHash,
            transactionId,
        });
    }

    /**
     * @override
     * @returns {AccountId}
     */
    _getNodeAccountId() {
        if (this._nodeAccountIds.isEmpty) {
            throw new Error(
                "(BUG) Transaction::_getNodeAccountId called before transaction has been frozen"
            );
        }

        return this._nodeAccountIds.current;
    }

    /**
     * @internal
     * @param {?AccountId} nodeId
     * @returns {proto.ISignedTransaction}
     */
    _makeSignedTransaction(nodeId) {
        const body = this._makeTransactionBody(nodeId);
        const bodyBytes = lib.TransactionBody.encode(body).finish();

        return {
            bodyBytes,
            sigMap: {
                sigPair: [],
            },
        };
    }

    /**
     * @private
     * @param {?AccountId} nodeId
     * @returns {proto.ITransactionBody}
     */
    _makeTransactionBody(nodeId) {
        return {
            [this._getTransactionDataCase()]: this._makeTransactionData(),
            transactionFee:
                this._maxTransactionFee != null
                    ? this._maxTransactionFee.toTinybars()
                    : null,
            memo: this._transactionMemo,
            transactionID: this._transactionIds.current._toProtobuf(),
            nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,
            transactionValidDuration: {
                seconds: long.fromNumber(this._transactionValidDuration),
            },
        };
    }

    /**
     * @abstract
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        throw new Error("not implemented");
    }

    /**
     * @internal
     * @returns {proto.ISchedulableTransactionBody}
     */
    _getScheduledTransactionBody() {
        return {
            memo: this.transactionMemo,
            transactionFee:
                this._maxTransactionFee == null
                    ? this._defaultMaxTransactionFee.toTinybars()
                    : this._maxTransactionFee.toTinybars(),
            [this._getTransactionDataCase()]: this._makeTransactionData(),
        };
    }

    /**
     * @abstract
     * @protected
     * @returns {object}
     */
    _makeTransactionData() {
        throw new Error("not implemented");
    }

    /**
     * @protected
     * @returns {boolean}
     */
    _isFrozen() {
        return (
            this._signOnDemand ||
            this._signedTransactions.length > 0 ||
            this._transactions.length > 0
        );
    }

    /**
     * @internal
     */
    _requireNotFrozen() {
        if (this._isFrozen()) {
            throw new Error(
                "transaction is immutable; it has at least one signature or has been explicitly frozen"
            );
        }
    }

    /**
     * @internal
     */
    _requireNotSignOnDemand() {
        if (this._signOnDemand) {
            throw new Error(
                "Please use `toBytesAsync()` if `signOnDemand` is enabled"
            );
        }
    }

    /**
     * @internal
     */
    _requireFrozen() {
        if (!this._isFrozen()) {
            throw new Error(
                "transaction must have been frozen before calculating the hash will be stable, try calling `freeze`"
            );
        }
    }

    /**
     * @internal
     * @protected
     */
    _requireOneNodeAccountId() {
        if (this._nodeAccountIds.length != 1) {
            throw "transaction did not have exactly one node ID set";
        }
    }
}

/**
 * @type {(() => ScheduleCreateTransaction)[]}
 */
const SCHEDULE_CREATE_TRANSACTION = [];

/**
 * The ID for a crypto-currency token on Hedera.
 *
 * @augments {EntityId<proto.INftID>}
 */
class NftId {
    /**
     * @param {TokenId} token
     * @param {number | Long} serial
     */
    constructor(token, serial) {
        this.tokenId = token;
        this.serial =
            typeof serial === "number" ? long.fromNumber(serial) : serial;

        Object.freeze(this);
    }

    /**
     * @param {string} text
     * @returns {NftId}
     */
    static fromString(text) {
        const strings =
            text.split("/").length > 1 ? text.split("/") : text.split("@");

        for (const string of strings) {
            if (string === "") {
                throw new Error(
                    "invalid format for NftId: use [token]/[serial] or [token]@[serial]"
                );
            }
        }

        const token = TokenId.fromString(strings[0]);
        const serial = long.fromString(strings[1]);

        return new NftId(token, serial);
    }

    /**
     * @internal
     * @param {proto.INftID} id
     * @returns {NftId}
     */
    static _fromProtobuf(id) {
        return new NftId(
            TokenId._fromProtobuf(/** @type {proto.ITokenID} */ (id.tokenID)),
            id.serialNumber != null ? id.serialNumber : long.ZERO
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {NftId}
     */
    static fromBytes(bytes) {
        return NftId._fromProtobuf(lib.NftID.decode(bytes));
    }

    /**
     * @internal
     * @returns {proto.INftID}
     */
    _toProtobuf() {
        return {
            tokenID: this.tokenId._toProtobuf(),
            serialNumber: long.fromValue(
                this.serial !== undefined ? this.serial : 0
            ),
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.serial.toString()}@${this.tokenId.toString()}`;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.NftID.encode(this._toProtobuf()).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoAdjustAllowanceTransactionBody} proto.ICryptoAdjustAllowanceTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../long.js").LongObject} LongObject
 */

/**
 * Change properties for the given account.
 */
class AccountAllowanceAdjustTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {HbarAllowance[]} [props.hbarAllowances]
     * @param {TokenAllowance[]} [props.tokenAllowances]
     * @param {TokenNftAllowance[]} [props.nftAllowances]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {HbarAllowance[]}
         */
        this._hbarAllowances =
            props.hbarAllowances != null ? props.hbarAllowances : [];

        /**
         * @private
         * @type {TokenAllowance[]}
         */
        this._tokenAllowances =
            props.tokenAllowances != null ? props.tokenAllowances : [];

        /**
         * @private
         * @type {TokenNftAllowance[]}
         */
        this._nftAllowances =
            props.nftAllowances != null ? props.nftAllowances : [];
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {AccountAllowanceAdjustTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const allowanceAdjust =
            /** @type {proto.ICryptoAdjustAllowanceTransactionBody} */ (
                body.cryptoAdjustAllowance
            );

        return Transaction._fromProtobufTransactions(
            new AccountAllowanceAdjustTransaction({
                hbarAllowances: (allowanceAdjust.cryptoAllowances != null
                    ? allowanceAdjust.cryptoAllowances
                    : []
                ).map((adjust) => HbarAllowance._fromProtobuf(adjust)),
                tokenAllowances: (allowanceAdjust.tokenAllowances != null
                    ? allowanceAdjust.tokenAllowances
                    : []
                ).map((adjust) => TokenAllowance._fromProtobuf(adjust)),
                nftAllowances: (allowanceAdjust.nftAllowances != null
                    ? allowanceAdjust.nftAllowances
                    : []
                ).map((adjust) => TokenNftAllowance._fromProtobuf(adjust)),
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {HbarAllowance[]}
     */
    get hbarAllowances() {
        return this._hbarAllowances;
    }

    /**
     * @deprecated
     * @param {AccountId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    addHbarAllowance(spenderAccountId, amount) {
        const value = amount instanceof Hbar ? amount : new Hbar(amount);
        return this._adjustHbarAllowance(
            null,
            spenderAccountId,
            requireNotNegative(value)
        );
    }

    /**
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {Hbar} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    _adjustHbarAllowance(ownerAccountId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._hbarAllowances.push(
            new HbarAllowance({
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId,
                amount: amount,
            })
        );

        return this;
    }

    /**
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    grantHbarAllowance(ownerAccountId, spenderAccountId, amount) {
        const value = amount instanceof Hbar ? amount : new Hbar(amount);
        return this._adjustHbarAllowance(
            ownerAccountId,
            spenderAccountId,
            requireNotNegative(value)
        );
    }

    /**
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    revokeHbarAllowance(ownerAccountId, spenderAccountId, amount) {
        const value = amount instanceof Hbar ? amount : new Hbar(amount);
        return this._adjustHbarAllowance(
            ownerAccountId,
            spenderAccountId,
            requireNotNegative(value).negated()
        );
    }

    /**
     * @returns {TokenAllowance[]}
     */
    get tokenAllowances() {
        return this._tokenAllowances;
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    addTokenAllowance(tokenId, spenderAccountId, amount) {
        return this._adjustTokenAllowance(
            tokenId,
            null,
            spenderAccountId,
            requireNotNegative(long.fromValue(amount))
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    _adjustTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._tokenAllowances.push(
            new TokenAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId,
                amount:
                    typeof amount === "number"
                        ? long.fromNumber(amount)
                        : amount,
            })
        );

        return this;
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    grantTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
        return this._adjustTokenAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            requireNotNegative(long.fromValue(amount))
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    revokeTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
        return this._adjustTokenAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            requireNotNegative(long.fromValue(amount))
        );
    }

    /**
     * @deprecated
     * @param {NftId | string} nftId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    addTokenNftAllowance(nftId, spenderAccountId) {
        const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
        return this._adjustTokenNftAllowance(id, null, spenderAccountId);
    }

    /**
     * @param {NftId} nftId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    _adjustTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
        this._requireNotFrozen();

        const spender =
            typeof spenderAccountId === "string"
                ? AccountId.fromString(spenderAccountId)
                : spenderAccountId;
        const owner =
            typeof ownerAccountId === "string"
                ? AccountId.fromString(ownerAccountId)
                : ownerAccountId;
        let found = false;

        for (const allowance of this._nftAllowances) {
            if (
                allowance.tokenId.compare(nftId.tokenId) === 0 &&
                allowance.spenderAccountId.compare(spender) === 0
            ) {
                if (allowance.serialNumbers != null) {
                    allowance.serialNumbers.push(nftId.serial);
                }
                found = true;
                break;
            }
        }

        if (!found) {
            this._nftAllowances.push(
                new TokenNftAllowance({
                    tokenId: nftId.tokenId,
                    spenderAccountId: spender,
                    serialNumbers: [nftId.serial],
                    ownerAccountId: owner,
                    allSerials: false,
                })
            );
        }

        return this;
    }

    /**
     * @param {NftId | string} nftId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    grantTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
        const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

        requireNotNegative(id.serial);

        return this._adjustTokenNftAllowance(
            id,
            ownerAccountId,
            spenderAccountId
        );
    }

    /**
     * @param {NftId | string} nftId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    revokeTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
        const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

        requireNotNegative(id.serial);
        id.serial = id.serial.negate();

        return this._adjustTokenNftAllowance(
            id,
            ownerAccountId,
            spenderAccountId
        );
    }

    /**
     * @deprecated - use `grantTokenNftAllowanceAllSerials()` instead
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    addAllTokenNftAllowance(tokenId, spenderAccountId) {
        return this._adjustTokenNftAllowanceAllSerials(
            tokenId,
            null,
            spenderAccountId,
            true
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    grantTokenNftAllowanceAllSerials(
        tokenId,
        ownerAccountId,
        spenderAccountId
    ) {
        return this._adjustTokenNftAllowanceAllSerials(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            true
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    revokeTokenNftAllowanceAllSerials(
        tokenId,
        ownerAccountId,
        spenderAccountId
    ) {
        return this._adjustTokenNftAllowanceAllSerials(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            false
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {boolean} allSerials
     * @returns {AccountAllowanceAdjustTransaction}
     */
    _adjustTokenNftAllowanceAllSerials(
        tokenId,
        ownerAccountId,
        spenderAccountId,
        allSerials
    ) {
        this._requireNotFrozen();

        this._nftAllowances.push(
            new TokenNftAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                ownerAccountId:
                    ownerAccountId != null
                        ? typeof ownerAccountId === "string"
                            ? AccountId.fromString(ownerAccountId)
                            : ownerAccountId
                        : null,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                serialNumbers: null,
                allSerials,
            })
        );

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        this._hbarAllowances.map((allowance) =>
            allowance.spenderAccountId.validateChecksum(client)
        );
        this._tokenAllowances.map((allowance) => {
            allowance.tokenId.validateChecksum(client);
            allowance.spenderAccountId.validateChecksum(client);
        });
        this._nftAllowances.map((allowance) => {
            allowance.tokenId.validateChecksum(client);
            allowance.spenderAccountId.validateChecksum(client);

            if (allowance.ownerAccountId != null) {
                allowance.ownerAccountId.validateChecksum(client);
            }
        });
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.adjustAllowance(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoAdjustAllowance";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ICryptoAdjustAllowanceTransactionBody}
     */
    _makeTransactionData() {
        return {
            cryptoAllowances: this._hbarAllowances.map((adjust) =>
                adjust._toProtobuf()
            ),
            tokenAllowances: this._tokenAllowances.map((adjust) =>
                adjust._toProtobuf()
            ),
            nftAllowances: this._nftAllowances.map((adjust) =>
                adjust._toProtobuf()
            ),
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountAllowanceAdjustTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoAdjustAllowance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountAllowanceAdjustTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoApproveAllowanceTransactionBody} proto.ICryptoApproveAllowanceTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../long.js").LongObject} LongObject
 */

/**
 * Change properties for the given account.
 */
class AccountAllowanceApproveTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {HbarAllowance[]} [props.hbarApprovals]
     * @param {TokenAllowance[]} [props.tokenApprovals]
     * @param {TokenNftAllowance[]} [props.nftApprovals]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {HbarAllowance[]}
         */
        this._hbarApprovals =
            props.hbarApprovals != null ? props.hbarApprovals : [];

        /**
         * @private
         * @type {TokenAllowance[]}
         */
        this._tokenApprovals =
            props.tokenApprovals != null ? props.tokenApprovals : [];

        /**
         * @private
         * @type {TokenNftAllowance[]}
         */
        this._nftApprovals =
            props.nftApprovals != null ? props.nftApprovals : [];
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {AccountAllowanceApproveTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const allowanceApproval =
            /** @type {proto.ICryptoApproveAllowanceTransactionBody} */ (
                body.cryptoApproveAllowance
            );

        return Transaction._fromProtobufTransactions(
            new AccountAllowanceApproveTransaction({
                hbarApprovals: (allowanceApproval.cryptoAllowances != null
                    ? allowanceApproval.cryptoAllowances
                    : []
                ).map((approval) => HbarAllowance._fromProtobuf(approval)),
                tokenApprovals: (allowanceApproval.tokenAllowances != null
                    ? allowanceApproval.tokenAllowances
                    : []
                ).map((approval) => TokenAllowance._fromProtobuf(approval)),
                nftApprovals: (allowanceApproval.nftAllowances != null
                    ? allowanceApproval.nftAllowances
                    : []
                ).map((approval) => TokenNftAllowance._fromProtobuf(approval)),
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {HbarAllowance[]}
     */
    get hbarApprovals() {
        return this._hbarApprovals;
    }

    /**
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceApproveTransaction}
     */
    approveHbarAllowance(ownerAccountId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._hbarApprovals.push(
            new HbarAllowance({
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId,
                amount: amount instanceof Hbar ? amount : new Hbar(amount),
            })
        );

        return this;
    }

    /**
     * @deprecated
     * @param {AccountId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceApproveTransaction}
     */
    addHbarAllowance(spenderAccountId, amount) {
        this._requireNotFrozen();

        this._hbarApprovals.push(
            new HbarAllowance({
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                amount: amount instanceof Hbar ? amount : new Hbar(amount),
                ownerAccountId: null,
            })
        );

        return this;
    }

    /**
     * @returns {TokenAllowance[]}
     */
    get tokenApprovals() {
        return this._tokenApprovals;
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceApproveTransaction}
     */
    approveTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._tokenApprovals.push(
            new TokenAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId,
                amount:
                    typeof amount === "number"
                        ? long.fromNumber(amount)
                        : amount,
            })
        );

        return this;
    }

    /**
     * @deprecated
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceApproveTransaction}
     */
    addTokenAllowance(tokenId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._tokenApprovals.push(
            new TokenAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                amount:
                    typeof amount === "number"
                        ? long.fromNumber(amount)
                        : amount,
                ownerAccountId: null,
            })
        );

        return this;
    }

    /**
     * @deprecated
     * @param {NftId | string} nftId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    addTokenNftAllowance(nftId, spenderAccountId) {
        return this._approveTokenNftAllowance(nftId, null, spenderAccountId);
    }

    /**
     * @param {NftId | string} nftId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    _approveTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
        this._requireNotFrozen();

        const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
        const spender =
            typeof spenderAccountId === "string"
                ? AccountId.fromString(spenderAccountId)
                : spenderAccountId;
        let found = false;

        for (const allowance of this._nftApprovals) {
            if (
                allowance.tokenId.compare(id.tokenId) === 0 &&
                allowance.spenderAccountId.compare(spender) === 0
            ) {
                if (allowance.serialNumbers != null) {
                    allowance.serialNumbers.push(id.serial);
                }
                found = true;
                break;
            }
        }

        if (!found) {
            this._nftApprovals.push(
                new TokenNftAllowance({
                    tokenId: id.tokenId,
                    spenderAccountId:
                        typeof spenderAccountId === "string"
                            ? AccountId.fromString(spenderAccountId)
                            : spenderAccountId,
                    ownerAccountId:
                        typeof ownerAccountId === "string"
                            ? AccountId.fromString(ownerAccountId)
                            : ownerAccountId,
                    serialNumbers: [id.serial],
                    allSerials: false,
                })
            );
        }

        return this;
    }

    /**
     * @param {NftId | string} nftId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    approveTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
        return this._approveTokenNftAllowance(
            nftId,
            ownerAccountId,
            spenderAccountId
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {boolean} allSerials
     * @returns {AccountAllowanceApproveTransaction}
     */
    _approveAllTokenNftAllowance(
        tokenId,
        ownerAccountId,
        spenderAccountId,
        allSerials
    ) {
        this._requireNotFrozen();

        this._nftApprovals.push(
            new TokenNftAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId,
                serialNumbers: null,
                allSerials,
            })
        );

        return this;
    }

    /**
     * @deprecated
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    addAllTokenNftAllowance(tokenId, ownerAccountId, spenderAccountId) {
        return this._approveAllTokenNftAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            true
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    approveTokenNftAllowanceAllSerials(
        tokenId,
        ownerAccountId,
        spenderAccountId
    ) {
        return this._approveAllTokenNftAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            true
        );
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        this._hbarApprovals.map((approval) =>
            approval.spenderAccountId.validateChecksum(client)
        );
        this._tokenApprovals.map((approval) => {
            approval.tokenId.validateChecksum(client);
            approval.spenderAccountId.validateChecksum(client);
        });
        this._nftApprovals.map((approval) => {
            approval.tokenId.validateChecksum(client);
            approval.spenderAccountId.validateChecksum(client);

            if (approval.ownerAccountId != null) {
                approval.ownerAccountId.validateChecksum(client);
            }
        });
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.approveAllowances(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoApproveAllowance";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ICryptoApproveAllowanceTransactionBody}
     */
    _makeTransactionData() {
        return {
            cryptoAllowances: this._hbarApprovals.map((approval) =>
                approval._toProtobuf()
            ),
            tokenAllowances: this._tokenApprovals.map((approval) =>
                approval._toProtobuf()
            ),
            nftAllowances: this._nftApprovals.map((approval) =>
                approval._toProtobuf()
            ),
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountAllowanceApproveTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoApproveAllowance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountAllowanceApproveTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenBalance} proto.ITokenBalance
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("long")} Long
 */

/**
 * @augments {ObjectMap<TokenId, Long>}
 */
class TokenBalanceMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenBalance} proto.ITokenBalance
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @augments {ObjectMap<TokenId, number>}
 */
class TokenDecimalMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountBalanceResponse} proto.ICryptoGetAccountBalanceResponse
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").ITokenBalance} proto.ITokenBalance
 */

/**
 * @typedef {object} TokenBalanceJson
 * @property {string} tokenId
 * @property {string} balance
 * @property {number} decimals
 */

/**
 * @typedef {object} AccountBalanceJson
 * @property {string} hbars
 * @property {TokenBalanceJson[]} tokens
 */

class AccountBalance {
    /**
     * @private
     * @param {object} props
     * @param {Hbar} props.hbars
     * @param {?TokenBalanceMap} props.tokens
     * @param {?TokenDecimalMap} props.tokenDecimals
     */
    constructor(props) {
        /**
         * The account ID for which this balancermation applies.
         *
         * @readonly
         */
        this.hbars = props.hbars;

        /** @readonly */
        this.tokens = props.tokens;

        /** @readonly */
        this.tokenDecimals = props.tokenDecimals;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.ICryptoGetAccountBalanceResponse} accountBalance
     * @returns {AccountBalance}
     */
    static _fromProtobuf(accountBalance) {
        const tokenBalances = new TokenBalanceMap();
        const tokenDecimals = new TokenDecimalMap();

        if (accountBalance.tokenBalances != null) {
            for (const balance of accountBalance.tokenBalances) {
                const tokenId = TokenId._fromProtobuf(
                    /** @type {proto.ITokenID} */ (balance.tokenId)
                );

                tokenDecimals._set(
                    tokenId,
                    balance.decimals != null ? balance.decimals : 0
                );
                tokenBalances._set(
                    tokenId,
                    long.fromValue(/** @type {Long} */ (balance.balance))
                );
            }
        }

        return new AccountBalance({
            hbars: Hbar.fromTinybars(
                /** @type {Long} */ (accountBalance.balance)
            ),
            tokens: tokenBalances,
            tokenDecimals,
        });
    }

    /**
     * @returns {proto.ICryptoGetAccountBalanceResponse}
     */
    _toProtobuf() {
        /** @type {proto.ITokenBalance[]} */
        const list = [];

        for (const [key, value] of this.tokens != null ? this.tokens : []) {
            list.push({
                tokenId: key._toProtobuf(),
                balance: value,
                decimals:
                    this.tokenDecimals != null
                        ? this.tokenDecimals.get(key)
                        : null,
            });
        }

        return {
            balance: this.hbars.toTinybars(),
            tokenBalances: list,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {AccountBalanceJson}
     */
    toJSON() {
        const tokens = [];
        for (const [key, value] of this.tokens != null ? this.tokens : []) {
            const decimals =
                this.tokenDecimals != null ? this.tokenDecimals.get(key) : null;

            tokens.push({
                tokenId: key.toString(),
                balance: value.toString(),
                decimals: decimals != null ? decimals : 0,
            });
        }

        return {
            hbars: this.hbars.toString(),
            tokens,
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountBalanceQuery} proto.ICryptoGetAccountBalanceQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountBalanceResponse} proto.ICryptoGetAccountBalanceResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Get the balance of a Hedera crypto-currency account.
 *
 * This returns only the balance, so its a smaller and faster reply
 * than AccountInfoQuery.
 *
 * This query is free.
 *
 * @augments {Query<AccountBalance>}
 */
class AccountBalanceQuery extends Query {
    /**
     * @param {object} [props]
     * @param {AccountId | string} [props.accountId]
     * @param {ContractId | string} [props.contractId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?AccountId}
         * @private
         */
        this._accountId = null;

        /**
         * @type {?ContractId}
         * @private
         */
        this._contractId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {AccountBalanceQuery}
     */
    static _fromProtobuf(query) {
        const balance = /** @type {proto.ICryptoGetAccountBalanceQuery} */ (
            query.cryptogetAccountBalance
        );

        return new AccountBalanceQuery({
            accountId:
                balance.accountID != null
                    ? AccountId._fromProtobuf(balance.accountID)
                    : undefined,
            contractId:
                balance.contractID != null
                    ? ContractId._fromProtobuf(balance.contractID)
                    : undefined,
        });
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account ID for which the balance is being requested.
     *
     * This is mutually exclusive with `setContractId`.
     *
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Set the contract ID for which the balance is being requested.
     *
     * This is mutually exclusive with `setAccountId`.
     *
     * @param {ContractId | string} contractId
     * @returns {this}
     */
    setContractId(contractId) {
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @protected
     * @override
     * @returns {boolean}
     */
    _isPaymentRequired() {
        return false;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.cryptoGetBalance(request);
    }

    /**
     * @override
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const cryptogetAccountBalance =
            /** @type {proto.ICryptoGetAccountBalanceResponse} */ (
                response.cryptogetAccountBalance
            );
        return /** @type {proto.IResponseHeader} */ (
            cryptogetAccountBalance.header
        );
    }

    /**
     * @override
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<AccountBalance>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const cryptogetAccountBalance =
            /** @type {proto.ICryptoGetAccountBalanceResponse} */ (
                response.cryptogetAccountBalance
            );
        return Promise.resolve(
            AccountBalance._fromProtobuf(cryptogetAccountBalance)
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            cryptogetAccountBalance: {
                header,
                accountID:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
                contractID:
                    this._contractId != null
                        ? this._contractId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        return `AccountBalanceQuery:${this._timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "cryptogetAccountBalance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountBalanceQuery._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IDuration} proto.IDuration
 */

class Duration {
    /**
     * @param {Long | number} seconds
     */
    constructor(seconds) {
        /**
         * @readonly
         * @type {Long}
         */
        this.seconds =
            seconds instanceof long ? seconds : long.fromNumber(seconds);

        Object.freeze(this);
    }

    /**
     * @internal
     * @returns {proto.IDuration}
     */
    _toProtobuf() {
        return {
            seconds: this.seconds,
        };
    }

    /**
     * @internal
     * @param {proto.IDuration} duration
     * @returns {Duration}
     */
    static _fromProtobuf(duration) {
        return new Duration(/** @type {Long} */ (duration.seconds));
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoCreateTransactionBody} proto.ICryptoCreateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a new Hedera crypto-currency account.
 */
class AccountCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Key} [props.key]
     * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
     * @param {boolean} [props.receiverSignatureRequired]
     * @param {AccountId} [props.proxyAccountId]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {string} [props.accountMemo]
     * @param {Long | number} [props.maxAutomaticTokenAssociations]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Key}
         */
        this._key = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._initialBalance = null;

        /**
         * @private
         * @type {Hbar}
         */
        this._sendRecordThreshold = DEFAULT_RECORD_THRESHOLD;

        /**
         * @private
         * @type {Hbar}
         */
        this._receiveRecordThreshold = DEFAULT_RECORD_THRESHOLD;

        /**
         * @private
         * @type {boolean}
         */
        this._receiverSignatureRequired = false;

        /**
         * @private
         * @type {?AccountId}
         */
        this._proxyAccountId = null;

        /**
         * @private
         * @type {Duration}
         */
        this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

        /**
         * @private
         * @type {?string}
         */
        this._accountMemo = null;

        /**
         * @private
         * @type {?Long}
         */
        this._maxAutomaticTokenAssociations = null;

        if (props.key != null) {
            this.setKey(props.key);
        }

        if (props.receiverSignatureRequired != null) {
            this.setReceiverSignatureRequired(props.receiverSignatureRequired);
        }

        if (props.initialBalance != null) {
            this.setInitialBalance(props.initialBalance);
        }

        if (props.proxyAccountId != null) {
            this.setProxyAccountId(props.proxyAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.accountMemo != null) {
            this.setAccountMemo(props.accountMemo);
        }

        if (props.maxAutomaticTokenAssociations != null) {
            this.setMaxAutomaticTokenAssociations(
                props.maxAutomaticTokenAssociations
            );
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {AccountCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const create = /** @type {proto.ICryptoCreateTransactionBody} */ (
            body.cryptoCreateAccount
        );

        return Transaction._fromProtobufTransactions(
            new AccountCreateTransaction({
                key:
                    create.key != null
                        ? Key._fromProtobufKey(create.key)
                        : undefined,
                initialBalance:
                    create.initialBalance != null
                        ? create.initialBalance
                        : undefined,
                receiverSignatureRequired:
                    create.receiverSigRequired != null
                        ? create.receiverSigRequired
                        : undefined,
                proxyAccountId:
                    create.proxyAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {proto.IAccountID} */ (
                                  create.proxyAccountID
                              )
                          )
                        : undefined,
                autoRenewPeriod:
                    create.autoRenewPeriod != null
                        ? create.autoRenewPeriod.seconds != null
                            ? create.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                accountMemo: create.memo != null ? create.memo : undefined,
                maxAutomaticTokenAssociations:
                    create.maxAutomaticTokenAssociations != null
                        ? create.maxAutomaticTokenAssociations
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?Key}
     */
    get key() {
        return this._key;
    }

    /**
     * Set the key for this account.
     *
     * This is the key that must sign each transfer out of the account.
     *
     * If `receiverSignatureRequired` is true, then the key must also sign
     * any transfer into the account.
     *
     * @param {Key} key
     * @returns {this}
     */
    setKey(key) {
        this._requireNotFrozen();
        this._key = key;

        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get initialBalance() {
        return this._initialBalance;
    }

    /**
     * Set the initial amount to transfer into this account.
     *
     * @param {number | string | Long | BigNumber | Hbar} initialBalance
     * @returns {this}
     */
    setInitialBalance(initialBalance) {
        this._requireNotFrozen();
        this._initialBalance =
            initialBalance instanceof Hbar
                ? initialBalance
                : new Hbar(initialBalance);

        return this;
    }

    /**
     * @returns {boolean}
     */
    get receiverSignatureRequired() {
        return this._receiverSignatureRequired;
    }

    /**
     * Set to true to require the key for this account to sign any transfer of
     * hbars to this account.
     *
     * @param {boolean} receiverSignatureRequired
     * @returns {this}
     */
    setReceiverSignatureRequired(receiverSignatureRequired) {
        this._requireNotFrozen();
        this._receiverSignatureRequired = receiverSignatureRequired;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get proxyAccountId() {
        return this._proxyAccountId;
    }

    /**
     * Set the ID of the account to which this account is proxy staked.
     *
     * @param {AccountId} proxyAccountId
     * @returns {this}
     */
    setProxyAccountId(proxyAccountId) {
        this._requireNotFrozen();
        this._proxyAccountId = proxyAccountId;

        return this;
    }

    /**
     * @returns {Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this account.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?string}
     */
    get accountMemo() {
        return this._accountMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setAccountMemo(memo) {
        this._requireNotFrozen();
        this._accountMemo = memo;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get maxAutomaticTokenAssociations() {
        return this._maxAutomaticTokenAssociations;
    }

    /**
     * @param {Long | number} maxAutomaticTokenAssociations
     * @returns {this}
     */
    setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
        this._requireNotFrozen();
        this._maxAutomaticTokenAssociations =
            typeof maxAutomaticTokenAssociations === "number"
                ? long.fromNumber(maxAutomaticTokenAssociations)
                : maxAutomaticTokenAssociations;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._proxyAccountId != null) {
            this._proxyAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.createAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoCreateAccount";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ICryptoCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            key: this._key != null ? this._key._toProtobufKey() : null,
            initialBalance:
                this._initialBalance != null
                    ? this._initialBalance.toTinybars()
                    : null,
            autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
            proxyAccountID:
                this._proxyAccountId != null
                    ? this._proxyAccountId._toProtobuf()
                    : null,
            receiveRecordThreshold: this._receiveRecordThreshold.toTinybars(),
            sendRecordThreshold: this._sendRecordThreshold.toTinybars(),
            receiverSigRequired: this._receiverSignatureRequired,
            memo: this._accountMemo,
            maxAutomaticTokenAssociations:
                this._maxAutomaticTokenAssociations != null
                    ? this._maxAutomaticTokenAssociations.toInt()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoCreateAccount",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountCreateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoDeleteTransactionBody} proto.ICryptoDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Marks an account as deleted, moving all its current hbars to another account.
 *
 * It will remain in the ledger, marked as deleted, until it expires.
 * Transfers into it a deleted account fail. But a deleted account can still have its
 * expiration extended in the normal way.
 */
class AccountDeleteTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {AccountId} [props.accountId]
     * @param {AccountId} [props.transferAccountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._transferAccountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        if (props.transferAccountId != null) {
            this.setTransferAccountId(props.transferAccountId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {AccountDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const accountDelete =
            /** @type {proto.ICryptoDeleteTransactionBody} */ (
                body.cryptoDelete
            );

        return Transaction._fromProtobufTransactions(
            new AccountDeleteTransaction({
                accountId:
                    accountDelete.deleteAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {proto.IAccountID} */ (
                                  accountDelete.deleteAccountID
                              )
                          )
                        : undefined,
                transferAccountId:
                    accountDelete.transferAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {proto.IAccountID} */ (
                                  accountDelete.transferAccountID
                              )
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account ID which is being deleted in this transaction.
     *
     * @param {AccountId | string} accountId
     * @returns {AccountDeleteTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get transferAccountId() {
        return this._transferAccountId;
    }

    /**
     * Set the account ID which will receive all remaining hbars.
     *
     * @param {AccountId | string} transferAccountId
     * @returns {AccountDeleteTransaction}
     */
    setTransferAccountId(transferAccountId) {
        this._requireNotFrozen();
        this._transferAccountId =
            typeof transferAccountId === "string"
                ? AccountId.fromString(transferAccountId)
                : transferAccountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        if (this._transferAccountId != null) {
            this._transferAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.cryptoDelete(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoDelete";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ICryptoDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            deleteAccountID:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            transferAccountID:
                this._transferAccountId != null
                    ? this._transferAccountId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoDelete",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountDeleteTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ILiveHash} proto.ILiveHash
 * @typedef {import("@hashgraph/proto").IDuration} proto.IDuration
 */

/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
class LiveHash {
    /**
     * @private
     * @param {object} props
     * @param {AccountId} props.accountId
     * @param {Uint8Array} props.hash
     * @param {KeyList} props.keys
     * @param {Duration} props.duration
     */
    constructor(props) {
        /** @readonly */
        this.accountId = props.accountId;

        /** @readonly */
        this.hash = props.hash;

        /** @readonly */
        this.keys = props.keys;

        /** @readonly */
        this.duration = props.duration;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.ILiveHash} liveHash
     * @returns {LiveHash}
     */
    static _fromProtobuf(liveHash) {
        const liveHash_ = /** @type {proto.ILiveHash} */ (liveHash);

        return new LiveHash({
            accountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (liveHash_.accountId)
            ),
            hash: liveHash_.hash != null ? liveHash_.hash : new Uint8Array(),
            keys:
                liveHash_.keys != null
                    ? KeyList.__fromProtobufKeyList(liveHash_.keys)
                    : new KeyList(),
            duration: Duration._fromProtobuf(
                /** @type {proto.IDuration} */ (liveHash_.duration)
            ),
        });
    }

    /**
     * @internal
     * @returns {proto.ILiveHash}
     */
    _toProtobuf() {
        return {
            accountId: this.accountId._toProtobuf(),
            hash: this.hash,
            keys: this.keys._toProtobufKey().keyList,
            duration: this.duration._toProtobuf(),
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenRelationship} proto.ITokenRelationship
 * @typedef {import("@hashgraph/proto").TokenKycStatus} proto.TokenKycStatus
 * @typedef {import("@hashgraph/proto").TokenFreezeStatus} proto.TokenFreezeStatus
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * Token's information related to the given Account
 */
class TokenRelationship {
    /**
     * @param {object} props
     * @param {TokenId} props.tokenId
     * @param {string} props.symbol
     * @param {Long} props.balance
     * @param {boolean | null} props.isKycGranted
     * @param {boolean | null} props.isFrozen
     * @param {boolean | null} props.automaticAssociation
     */
    constructor(props) {
        /**
         * The ID of the token
         *
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The Symbol of the token
         *
         * @readonly
         */
        this.symbol = props.symbol;

        /**
         * The balance that the Account holds in the smallest denomination
         *
         * @readonly
         */
        this.balance = props.balance;

        /**
         * The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does
         * not have KYC key, KycNotApplicable is returned
         *
         * @readonly
         */
        this.isKycGranted = props.isKycGranted;

        /**
         * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token
         * does not have Freeze key, FreezeNotApplicable is returned
         *
         * @readonly
         */
        this.isFrozen = props.isFrozen;

        /**
         * Specifies if the relationship is created implicitly. False : explicitly associated, True :
         * implicitly associated.
         *
         * @readonly
         */
        this.automaticAssociation = props.automaticAssociation;

        Object.freeze(this);
    }

    /**
     * @param {proto.ITokenRelationship} relationship
     * @returns {TokenRelationship}
     */
    static _fromProtobuf(relationship) {
        const tokenId = TokenId._fromProtobuf(
            /** @type {proto.ITokenID} */ (relationship.tokenId)
        );
        const isKycGranted =
            relationship.kycStatus == null || relationship.kycStatus === 0
                ? null
                : relationship.kycStatus === 1;
        const isFrozen =
            relationship.freezeStatus == null || relationship.freezeStatus === 0
                ? null
                : relationship.freezeStatus === 1;

        return new TokenRelationship({
            tokenId,
            symbol: /** @type {string} */ (relationship.symbol),
            balance:
                relationship.balance != null
                    ? relationship.balance instanceof long
                        ? relationship.balance
                        : long.fromValue(relationship.balance)
                    : long.ZERO,
            isKycGranted,
            isFrozen,
            automaticAssociation:
                relationship.automaticAssociation != null
                    ? relationship.automaticAssociation
                    : null,
        });
    }

    /**
     * @returns {proto.ITokenRelationship}
     */
    _toProtobuf() {
        return {
            tokenId: this.tokenId._toProtobuf(),
            symbol: this.symbol,
            balance: this.balance,
            kycStatus:
                this.isKycGranted == null ? 0 : this.isKycGranted ? 1 : 2,
            freezeStatus: this.isFrozen == null ? 0 : this.isFrozen ? 1 : 2,
            automaticAssociation: this.automaticAssociation,
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenRelationship} proto.ITokenRelationship
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("long")} Long
 */

/**
 * @augments {ObjectMap<TokenId, TokenRelationship>}
 */
class TokenRelationshipMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }

    /**
     * @param {proto.ITokenRelationship[]} relationships
     * @returns {TokenRelationshipMap}
     */
    static _fromProtobuf(relationships) {
        const tokenRelationships = new TokenRelationshipMap();

        for (const relationship of relationships) {
            const tokenId = TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (relationship.tokenId)
            );

            tokenRelationships._set(
                tokenId,
                TokenRelationship._fromProtobuf(relationship)
            );
        }

        return tokenRelationships;
    }

    /**
     * @returns {proto.ITokenRelationship[]}
     */
    _toProtobuf() {
        const list = [];

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [_, relationship] of this) {
            list.push(relationship._toProtobuf());
        }

        return list;
    }
}

class LedgerId {
    /**
     * @hideconstructor
     * @internal
     * @param {Uint8Array} ledgerId
     */
    constructor(ledgerId) {
        /**
         * @readonly
         * @type {Uint8Array}
         */
        this._ledgerId = ledgerId;

        Object.freeze(this);
    }

    /**
     * @param {string} ledgerId
     * @returns {LedgerId}
     */
    static fromString(ledgerId) {
        switch (ledgerId) {
            case NETNAMES[0]:
            case "0":
                return LedgerId.MAINNET;
            case NETNAMES[1]:
            case "1":
                return LedgerId.TESTNET;
            case NETNAMES[2]:
            case "2":
                return LedgerId.PREVIEWNET;
            default: {
                let ledgerIdDecoded = decode$1(ledgerId);
                if (ledgerIdDecoded.length == 0 && ledgerId.length != 0) {
                    throw new Error("Default reached for fromString");
                } else {
                    return new LedgerId(ledgerIdDecoded);
                }
            }
        }
    }

    /**
     * If the ledger ID is a known value such as `[0]`, `[1]`, `[2]` this method
     * will instead return "mainnet", "testnet", or "previewnet", otherwise it will
     * hex encode the bytes.
     *
     * @returns {string}
     */
    toString() {
        if (this._ledgerId.length == 1) {
            switch (this._ledgerId[0]) {
                case 0:
                    return NETNAMES[0];
                case 1:
                    return NETNAMES[1];
                case 2:
                    return NETNAMES[2];
                default:
                    return encode$1(this._ledgerId);
            }
        } else {
            return encode$1(this._ledgerId);
        }
    }

    /**
     * @returns {string}
     */
    _toStringForChecksum() {
        // legacy checksum logic from NetworkName
        if (this._ledgerId.length == 1) {
            switch (this._ledgerId[0]) {
                case 0:
                    return "0";
                case 1:
                    return "1";
                case 2:
                    return "2";
                default:
                    return encode$1(this._ledgerId);
            }
        } else {
            return encode$1(this._ledgerId);
        }
    }

    /**
     * Using the UTF-8 byte representation of "mainnet", "testnet",
     * or "previewnet" is NOT supported.
     *
     * @param {Uint8Array} bytes
     * @returns {LedgerId}
     */
    static fromBytes(bytes) {
        return new LedgerId(bytes);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return this._ledgerId;
    }

    /**
     * @returns {boolean}
     */
    isMainnet() {
        return this.toString() == NETNAMES[0];
    }

    /**
     * @returns {boolean}
     */
    isTestnet() {
        return this.toString() == NETNAMES[1];
    }

    /**
     * @returns {boolean}
     */
    isPreviewnet() {
        return this.toString() == NETNAMES[2];
    }
}

const NETNAMES = ["mainnet", "testnet", "previewnet"];

LedgerId.MAINNET = new LedgerId(new Uint8Array([0]));

LedgerId.TESTNET = new LedgerId(new Uint8Array([1]));

LedgerId.PREVIEWNET = new LedgerId(new Uint8Array([2]));

/**
 * Current information about an account, including the balance.
 */
class AccountInfo {
    /**
     * @private
     * @param {object} props
     * @param {AccountId} props.accountId
     * @param {?string} props.contractAccountId
     * @param {boolean} props.isDeleted
     * @param {?AccountId} props.proxyAccountId
     * @param {Hbar} props.proxyReceived
     * @param {Key} props.key
     * @param {Hbar} props.balance
     * @param {Hbar} props.sendRecordThreshold
     * @param {Hbar} props.receiveRecordThreshold
     * @param {boolean} props.isReceiverSignatureRequired
     * @param {Timestamp} props.expirationTime
     * @param {Duration} props.autoRenewPeriod
     * @param {LiveHash[]} props.liveHashes
     * @param {TokenRelationshipMap} props.tokenRelationships
     * @param {string} props.accountMemo
     * @param {Long} props.ownedNfts
     * @param {Long} props.maxAutomaticTokenAssociations
     * @param {PublicKey | null} props.aliasKey
     * @param {LedgerId | null} props.ledgerId
     * @param {HbarAllowance[]} props.hbarAllowances
     * @param {TokenAllowance[]} props.tokenAllowances
     * @param {TokenNftAllowance[]} props.nftAllowances
     */
    constructor(props) {
        /**
         * The account ID for which this information applies.
         *
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * The Contract Account ID comprising of both the contract instance and the cryptocurrency
         * account owned by the contract instance, in the format used by Solidity.
         *
         * @readonly
         */
        this.contractAccountId = props.contractAccountId;

        /**
         * If true, then this account has been deleted, it will disappear when it expires, and
         * all transactions for it will fail except the transaction to extend its expiration date.
         *
         * @readonly
         */
        this.isDeleted = props.isDeleted;

        /**
         * The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
         * or is an invalid account, or is an account that isn't a node, then this account is
         * automatically proxy staked to a node chosen by the network, but without earning payments.
         * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
         * running a node, then it will behave as if proxyAccountID was null.
         *
         * @readonly
         */
        this.proxyAccountId = props.proxyAccountId;

        /**
         * The total number of tinybars proxy staked to this account.
         *
         * @readonly
         */
        this.proxyReceived = props.proxyReceived;

        /**
         * The key for the account, which must sign in order to transfer out, or to modify the account
         * in any way other than extending its expiration date.
         *
         * @readonly
         */
        this.key = props.key;

        /**
         * The current balance of account.
         *
         * @readonly
         */
        this.balance = props.balance;

        /**
         * The threshold amount (in tinybars) for which an account record is created (and this account
         * charged for them) for any send/withdraw transaction.
         *
         * @readonly
         */
        this.sendRecordThreshold = props.sendRecordThreshold;

        /**
         * The threshold amount (in tinybars) for which an account record is created
         * (and this account charged for them) for any transaction above this amount.
         *
         * @readonly
         */
        this.receiveRecordThreshold = props.receiveRecordThreshold;

        /**
         * If true, no transaction can transfer to this account unless signed by this account's key.
         *
         * @readonly
         */
        this.isReceiverSignatureRequired = props.isReceiverSignatureRequired;

        /**
         * The TimeStamp time at which this account is set to expire.
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * The duration for expiration time will extend every this many seconds. If there are
         * insufficient funds, then it extends as long as possible. If it is empty when it
         * expires, then it is deleted.
         *
         * @readonly
         */
        this.autoRenewPeriod = props.autoRenewPeriod;

        /** @readonly */
        this.liveHashes = props.liveHashes;

        /** @readonly */
        this.tokenRelationships = props.tokenRelationships;

        /** @readonly */
        this.accountMemo = props.accountMemo;

        /** @readonly */
        this.ownedNfts = props.ownedNfts;

        /** @readonly */
        this.maxAutomaticTokenAssociations =
            props.maxAutomaticTokenAssociations;

        this.aliasKey = props.aliasKey;

        this.ledgerId = props.ledgerId;

        this.hbarAllowances = props.hbarAllowances;

        this.tokenAllowances = props.tokenAllowances;

        this.nftAllowances = props.nftAllowances;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.IAccountInfo} info
     * @returns {AccountInfo}
     */
    static _fromProtobuf(info) {
        let aliasKey =
            info.alias != null && info.alias.length > 0
                ? Key._fromProtobufKey(lib.Key.decode(info.alias))
                : null;

        if (!(aliasKey instanceof PublicKey)) {
            aliasKey = null;
        }

        return new AccountInfo({
            accountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (info.accountID)
            ),
            contractAccountId:
                info.contractAccountID != null ? info.contractAccountID : null,
            isDeleted: info.deleted != null ? info.deleted : false,
            key: Key._fromProtobufKey(/** @type {proto.IKey} */ (info.key)),
            balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
            sendRecordThreshold: Hbar.fromTinybars(
                info.generateSendRecordThreshold != null
                    ? info.generateSendRecordThreshold
                    : 0
            ),
            receiveRecordThreshold: Hbar.fromTinybars(
                info.generateReceiveRecordThreshold != null
                    ? info.generateReceiveRecordThreshold
                    : 0
            ),
            isReceiverSignatureRequired:
                info.receiverSigRequired != null
                    ? info.receiverSigRequired
                    : false,
            expirationTime: Timestamp._fromProtobuf(
                /** @type {proto.ITimestamp} */ (info.expirationTime)
            ),
            autoRenewPeriod:
                info.autoRenewPeriod != null
                    ? new Duration(
                          /** @type {Long} */ (info.autoRenewPeriod.seconds)
                      )
                    : new Duration(0),
            proxyAccountId:
                info.proxyAccountID != null &&
                long.fromValue(
                    /** @type {Long | number} */ (info.proxyAccountID.shardNum)
                ).toInt() !== 0 &&
                long.fromValue(
                    /** @type {Long | number} */ (info.proxyAccountID.realmNum)
                ).toInt() !== 0 &&
                long.fromValue(
                    /** @type {Long | number} */ (
                        info.proxyAccountID.accountNum
                    )
                ).toInt() !== 0
                    ? AccountId._fromProtobuf(info.proxyAccountID)
                    : null,
            proxyReceived: Hbar.fromTinybars(
                info.proxyReceived != null ? info.proxyReceived : 0
            ),
            liveHashes: (info.liveHashes != null ? info.liveHashes : []).map(
                (hash) => LiveHash._fromProtobuf(hash)
            ),
            tokenRelationships: TokenRelationshipMap._fromProtobuf(
                info.tokenRelationships != null ? info.tokenRelationships : []
            ),
            accountMemo: info.memo != null ? info.memo : "",
            ownedNfts: info.ownedNfts ? info.ownedNfts : long.ZERO,
            maxAutomaticTokenAssociations: info.maxAutomaticTokenAssociations
                ? long.fromNumber(info.maxAutomaticTokenAssociations)
                : long.ZERO,
            aliasKey,
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,

            hbarAllowances: (info.grantedCryptoAllowances != null
                ? info.grantedCryptoAllowances
                : []
            ).map((allowance) => HbarAllowance._fromGrantedProtobuf(allowance)),
            tokenAllowances: (info.grantedTokenAllowances != null
                ? info.grantedTokenAllowances
                : []
            ).map((allowance) =>
                TokenAllowance._fromGrantedProtobuf(allowance)
            ),
            nftAllowances: (info.grantedNftAllowances != null
                ? info.grantedNftAllowances
                : []
            ).map((allowance) =>
                TokenNftAllowance._fromGrantedProtobuf(allowance)
            ),
        });
    }

    /**
     * @returns {proto.IAccountInfo}
     */
    _toProtobuf() {
        return {
            accountID: this.accountId._toProtobuf(),
            contractAccountID: this.contractAccountId,
            deleted: this.isDeleted,
            proxyAccountID:
                this.proxyAccountId != null
                    ? this.proxyAccountId._toProtobuf()
                    : null,
            proxyReceived: this.proxyReceived.toTinybars(),
            key: this.key._toProtobufKey(),
            balance: this.balance.toTinybars(),
            generateSendRecordThreshold: this.sendRecordThreshold.toTinybars(),
            generateReceiveRecordThreshold:
                this.receiveRecordThreshold.toTinybars(),
            receiverSigRequired: this.isReceiverSignatureRequired,
            expirationTime: this.expirationTime._toProtobuf(),
            autoRenewPeriod: this.autoRenewPeriod._toProtobuf(),
            liveHashes: this.liveHashes.map((hash) => hash._toProtobuf()),
            tokenRelationships:
                this.tokenRelationships != null
                    ? this.tokenRelationships._toProtobuf()
                    : null,
            memo: this.accountMemo,
            ownedNfts: this.ownedNfts,
            maxAutomaticTokenAssociations:
                this.maxAutomaticTokenAssociations.toInt(),
            alias:
                this.aliasKey != null
                    ? lib.Key.encode(this.aliasKey._toProtobufKey()).finish()
                    : null,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {AccountInfo}
     */
    static fromBytes(bytes) {
        return AccountInfo._fromProtobuf(
            lib.CryptoGetInfoResponse.AccountInfo.decode(bytes)
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.CryptoGetInfoResponse.AccountInfo.encode(
            this._toProtobuf()
        ).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IAccountInfo} proto.IAccountInfo
 * @typedef {import("@hashgraph/proto").ICryptoGetInfoQuery} proto.ICryptoGetInfoQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetInfoResponse} proto.ICryptoGetInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @augments {Query<AccountInfo>}
 */
class AccountInfoQuery extends Query {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;
        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {AccountInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {proto.ICryptoGetInfoQuery} */ (
            query.cryptoGetInfo
        );

        return new AccountInfoQuery({
            accountId:
                info.accountID != null
                    ? AccountId._fromProtobuf(info.accountID)
                    : undefined,
        });
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account ID for which the info is being requested.
     *
     * @param {AccountId | string} accountId
     * @returns {AccountInfoQuery}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getAccountInfo(request);
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        let cost = await super.getCost(client);

        if (cost.toTinybars().greaterThan(25)) {
            return cost;
        } else {
            return Hbar.fromTinybars(25);
        }
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const cryptoGetInfo = /** @type {proto.ICryptoGetInfoResponse} */ (
            response.cryptoGetInfo
        );
        return /** @type {proto.IResponseHeader} */ (cryptoGetInfo.header);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<AccountInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {proto.ICryptoGetInfoResponse} */ (
            response.cryptoGetInfo
        );

        return Promise.resolve(
            AccountInfo._fromProtobuf(
                /** @type {proto.IAccountInfo} */ (info.accountInfo)
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            cryptoGetInfo: {
                header,
                accountID:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;
        return `AccountInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("cryptoGetInfo", AccountInfoQuery._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountRecordsQuery} proto.ICryptoGetAccountRecordsQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetAccountRecordsResponse} proto.ICryptoGetAccountRecordsResponse
 * @typedef {import("@hashgraph/proto").ITransactionRecord} proto.ITransactionRecord
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Get all the records for an account for any transfers into it and out of it,
 * that were above the threshold, during the last 25 hours.
 *
 * @augments {Query<TransactionRecord[]>}
 */
class AccountRecordsQuery extends Query {
    /**
     * @param {object} [props]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?AccountId}
         * @private
         */
        this._accountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {AccountRecordsQuery}
     */
    static _fromProtobuf(query) {
        const records = /** @type {proto.ICryptoGetAccountRecordsQuery} */ (
            query.cryptoGetAccountRecords
        );

        return new AccountRecordsQuery({
            accountId:
                records.accountID != null
                    ? AccountId._fromProtobuf(records.accountID)
                    : undefined,
        });
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account ID for which the records are being requested.
     *
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getAccountRecords(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const cryptoGetAccountRecords =
            /** @type {proto.ICryptoGetAccountRecordsResponse} */ (
                response.cryptoGetAccountRecords
            );
        return /** @type {proto.IResponseHeader} */ (
            cryptoGetAccountRecords.header
        );
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<TransactionRecord[]>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const cryptoGetAccountRecords =
            /** @type {proto.ICryptoGetAccountRecordsResponse} */ (
                response.cryptoGetAccountRecords
            );
        const records = /** @type {proto.ITransactionRecord[]} */ (
            cryptoGetAccountRecords.records
        );

        return Promise.resolve(
            records.map((record) =>
                TransactionRecord._fromProtobuf({ transactionRecord: record })
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            cryptoGetAccountRecords: {
                header,
                accountID:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `AccountRecordsQuery:${timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "cryptoGetAccountRecords",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountRecordsQuery._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IProxyStaker} proto.IProxyStaker
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency transfer.
 */
class ProxyStaker {
    /**
     * @private
     * @param {object} props
     * @param {AccountId} props.accountId
     * @param {number | string | Long | BigNumber | Hbar} props.amount
     */
    constructor(props) {
        /**
         * The Account ID that sends or receives cryptocurrency.
         *
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * The amount of tinybars that the account sends(negative)
         * or receives(positive).
         *
         * @readonly
         */
        this.amount =
            props.amount instanceof Hbar
                ? props.amount
                : new Hbar(props.amount);

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.IProxyStaker} transfer
     * @returns {ProxyStaker}
     */
    static _fromProtobuf(transfer) {
        return new ProxyStaker({
            accountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (transfer.accountID)
            ),
            amount: Hbar.fromTinybars(
                transfer.amount != null ? transfer.amount : 0
            ),
        });
    }

    /**
     * @internal
     * @returns {proto.IProxyStaker}
     */
    _toProtobuf() {
        return {
            accountID: this.accountId._toProtobuf(),
            amount: this.amount.toTinybars(),
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ICryptoGetStakersQuery} proto.ICryptoGetStakersQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetStakersResponse} proto.ICryptoGetStakersResponse
 * @typedef {import("@hashgraph/proto").IAllProxyStakers} proto.IAllProxyStakers
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Get all the accounts that are proxy staking to this account.
 * For each of them, give the amount currently staked.
 *
 * This is not yet implemented, but will be in a future version of the API.
 *
 * @augments {Query<ProxyStaker[]>}
 */
class AccountStakersQuery extends Query {
    /**
     * @param {object} [props]
     * @param {(AccountId | string)=} props.accountId
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?AccountId}
         * @private
         */
        this._accountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {AccountStakersQuery}
     */
    static _fromProtobuf(query) {
        const stakers = /** @type {proto.ICryptoGetStakersQuery} */ (
            query.cryptoGetProxyStakers
        );

        return new AccountStakersQuery({
            accountId:
                stakers.accountID != null
                    ? AccountId._fromProtobuf(stakers.accountID)
                    : undefined,
        });
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account ID for which the stakers are being requested.
     *
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getStakersByAccountID(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const cryptoGetProxyStakers =
            /** @type {proto.ICryptoGetStakersResponse} */ (
                response.cryptoGetProxyStakers
            );
        return /** @type {proto.IResponseHeader} */ (
            cryptoGetProxyStakers.header
        );
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @returns {Promise<ProxyStaker[]>}
     */
    _mapResponse(response) {
        const cryptoGetProxyStakers =
            /** @type {proto.ICryptoGetStakersResponse} */ (
                response.cryptoGetProxyStakers
            );
        const stakers = /** @type {proto.IAllProxyStakers} */ (
            cryptoGetProxyStakers.stakers
        );

        return Promise.resolve(
            (stakers.proxyStaker != null ? stakers.proxyStaker : []).map(
                (staker) => ProxyStaker._fromProtobuf(staker)
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            cryptoGetProxyStakers: {
                header,
                accountID:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `AccountStakersQuery:${timestamp.toString()}`;
    }
}

// @ts-ignore
// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("cryptoGetProxyStakers", AccountStakersQuery._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoUpdateTransactionBody} proto.ICryptoUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Change properties for the given account.
 */
class AccountUpdateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {AccountId} [props.accountId]
     * @param {Key} [props.key]
     * @param {boolean} [props.receiverSignatureRequired]
     * @param {AccountId} [props.proxyAccountId]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {string} [props.accountMemo]
     * @param {Long | number} [props.maxAutomaticTokenAssociations]
     * @param {Key} [props.aliasKey]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        /**
         * @private
         * @type {?Key}
         */
        this._key = null;

        /**
         * @private
         * @type {boolean}
         */
        this._receiverSignatureRequired = false;

        /**
         * @private
         * @type {?AccountId}
         */
        this._proxyAccountId = null;

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?string}
         */
        this._accountMemo = null;

        /**
         * @private
         * @type {?Long}
         */
        this._maxAutomaticTokenAssociations = null;

        /**
         * @private
         * @type {?Key}
         */
        this._aliasKey = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        if (props.key != null) {
            this.setKey(props.key);
        }

        if (props.receiverSignatureRequired != null) {
            this.setReceiverSignatureRequired(props.receiverSignatureRequired);
        }

        if (props.proxyAccountId != null) {
            this.setProxyAccountId(props.proxyAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.accountMemo != null) {
            this.setAccountMemo(props.accountMemo);
        }

        if (props.maxAutomaticTokenAssociations != null) {
            this.setMaxAutomaticTokenAssociations(
                props.maxAutomaticTokenAssociations
            );
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {AccountUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const update = /** @type {proto.ICryptoUpdateTransactionBody} */ (
            body.cryptoUpdateAccount
        );

        return Transaction._fromProtobufTransactions(
            new AccountUpdateTransaction({
                accountId:
                    update.accountIDToUpdate != null
                        ? AccountId._fromProtobuf(
                              /** @type {proto.IAccountID} */ (
                                  update.accountIDToUpdate
                              )
                          )
                        : undefined,
                key:
                    update.key != null
                        ? Key._fromProtobufKey(update.key)
                        : undefined,
                receiverSignatureRequired:
                    update.receiverSigRequired != null
                        ? update.receiverSigRequired
                        : undefined,
                proxyAccountId:
                    update.proxyAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {proto.IAccountID} */ (
                                  update.proxyAccountID
                              )
                          )
                        : undefined,
                autoRenewPeriod:
                    update.autoRenewPeriod != null
                        ? update.autoRenewPeriod.seconds != null
                            ? update.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                expirationTime:
                    update.expirationTime != null
                        ? Timestamp._fromProtobuf(update.expirationTime)
                        : undefined,
                accountMemo:
                    update.memo != null
                        ? update.memo.value != null
                            ? update.memo.value
                            : undefined
                        : undefined,
                maxAutomaticTokenAssociations:
                    update.maxAutomaticTokenAssociations != null &&
                    update.maxAutomaticTokenAssociations.value != null
                        ? long.fromNumber(
                              update.maxAutomaticTokenAssociations.value
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Sets the account ID which is being updated in this transaction.
     *
     * @param {AccountId | string} accountId
     * @returns {AccountUpdateTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @returns {?Key}
     */
    get key() {
        return this._key;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setKey(key) {
        this._requireNotFrozen();
        this._key = key;

        return this;
    }

    /**
     * @returns {boolean}
     */
    get receiverSignatureRequired() {
        return this._receiverSignatureRequired;
    }

    /**
     * @param {boolean} receiverSignatureRequired
     * @returns {this}
     */
    setReceiverSignatureRequired(receiverSignatureRequired) {
        this._requireNotFrozen();
        this._receiverSignatureRequired = receiverSignatureRequired;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get proxyAccountId() {
        return this._proxyAccountId;
    }

    /**
     * @param {AccountId} proxyAccountId
     * @returns {this}
     */
    setProxyAccountId(proxyAccountId) {
        this._requireNotFrozen();
        this._proxyAccountId = proxyAccountId;

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * @param {Timestamp | Date} expirationTime
     * @returns {this}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime =
            expirationTime instanceof Date
                ? Timestamp.fromDate(expirationTime)
                : expirationTime;

        return this;
    }

    /**
     * @returns {?string}
     */
    get accountMemo() {
        return this._accountMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setAccountMemo(memo) {
        this._requireNotFrozen();
        this._accountMemo = memo;

        return this;
    }

    /**
     * @returns {this}
     */
    clearAccountMemo() {
        this._requireNotFrozen();
        this._accountMemo = null;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get maxAutomaticTokenAssociations() {
        return this._maxAutomaticTokenAssociations;
    }

    /**
     * @param {Long | number} maxAutomaticTokenAssociations
     * @returns {this}
     */
    setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
        this._requireNotFrozen();
        this._maxAutomaticTokenAssociations =
            typeof maxAutomaticTokenAssociations === "number"
                ? long.fromNumber(maxAutomaticTokenAssociations)
                : maxAutomaticTokenAssociations;

        return this;
    }

    /**
     * @deprecated - no longer supported
     * @returns {?Key}
     */
    get aliasKey() {
        return null;
    }

    /**
     * @deprecated - no longer supported
     * @param {Key} _
     * @returns {this}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setAliasKey(_) {
        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        if (this._proxyAccountId != null) {
            this._proxyAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.updateAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoUpdateAccount";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ICryptoUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            accountIDToUpdate:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            key: this._key != null ? this._key._toProtobufKey() : null,
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            proxyAccountID:
                this._proxyAccountId != null
                    ? this._proxyAccountId._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
            receiverSigRequiredWrapper:
                this._receiverSignatureRequired == null
                    ? null
                    : {
                          value: this._receiverSignatureRequired,
                      },
            memo:
                this._accountMemo != null
                    ? {
                          value: this._accountMemo,
                      }
                    : null,
            maxAutomaticTokenAssociations:
                this._maxAutomaticTokenAssociations != null
                    ? { value: this._maxAutomaticTokenAssociations.toInt() }
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoUpdateAccount",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountUpdateTransaction._fromProtobuf
);

class IPv4AddressPart {
    /**
     * @param {object} props
     * @param {number} [props.left]
     * @param {number} [props.right]
     */
    constructor(props = {}) {
        /**
         * @type {number | null}
         */
        this._left = null;

        if (props.left != null) {
            this.setLeft(props.left);
        }

        /**
         * @type {number | null}
         */
        this._right = null;

        if (props.right != null) {
            this.setRight(props.right);
        }
    }

    /**
     * @returns {?number}
     */
    get left() {
        return this._left;
    }

    /**
     * @param {number} part
     * @returns {this}
     */
    setLeft(part) {
        this._left = part;
        return this;
    }

    /**
     * @returns {?number}
     */
    get right() {
        return this._right;
    }

    /**
     * @param {number} part
     * @returns {this}
     */
    setRight(part) {
        this._right = part;
        return this;
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this._left != null && this._right != null) {
            return `${this._left.toString()}.${this._right.toString()}`;
        } else {
            return "";
        }
    }
}

class IPv4Address {
    /**
     * @param {object} props
     * @param {IPv4AddressPart} [props.network]
     * @param {IPv4AddressPart} [props.host]
     */
    constructor(props = {}) {
        /**
         * @type {IPv4AddressPart | null}
         */
        this._network = null;

        if (props.network != null) {
            this.setNetwork(props.network);
        }

        /**
         * @type {IPv4AddressPart | null}
         */
        this._host = null;

        if (props.host != null) {
            this.setHost(props.host);
        }
    }

    /**
     * @returns {?IPv4AddressPart}
     */
    get newtork() {
        return this._network;
    }

    /**
     * @param {IPv4AddressPart} part
     * @returns {this}
     */
    setNetwork(part) {
        this._network = part;
        return this;
    }

    /**
     * @returns {?IPv4AddressPart}
     */
    get host() {
        return this._host;
    }

    /**
     * @param {IPv4AddressPart} part
     * @returns {this}
     */
    setHost(part) {
        this._host = part;
        return this;
    }

    /**
     * @internal
     * @param {Uint8Array} bytes
     * @returns {IPv4Address}
     */
    static _fromProtobuf(bytes) {
        return new IPv4Address({
            network: new IPv4AddressPart().setLeft(bytes[0]).setRight(bytes[1]),
            host: new IPv4AddressPart().setLeft(bytes[2]).setRight(bytes[3]),
        });
    }

    /**
     * @returns {Uint8Array}
     */
    _toProtobuf() {
        return Uint8Array.of(
            this._network != null && this._network._left != null
                ? this._network._left
                : 0,
            this._network != null && this._network.right != null
                ? this._network.right
                : 0,
            this._host != null && this._host.left != null ? this._host.left : 0,
            this._host != null && this._host.right != null
                ? this._host.right
                : 0
        );
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this._network != null && this._host != null) {
            return `${this._network.toString()}.${this._host.toString()}`;
        } else {
            return "";
        }
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IServiceEndpoint} proto.IServiceEndpoint
 */

/**
 * @typedef {object} EndPointJson
 * @property {string | null} address
 * @property {string | null} port
 */

class EndPoint {
    /**
     * @param {object} props
     * @param {IPv4Address} [props.address]
     * @param {number} [props.port]
     */
    constructor(props = {}) {
        /**
         * @type {IPv4Address | null}
         */
        this._address = null;

        if (props.address != null) {
            this.setAddress(props.address);
        }

        /**
         * @type {number | null}
         */
        this._port = null;

        if (props.port != null) {
            this.setPort(props.port);
        }
    }

    /**
     * @returns {?IPv4Address}
     */
    get address() {
        return this.address;
    }

    /**
     * @param {IPv4Address} address
     * @returns {this}
     */
    setAddress(address) {
        this._address = address;
        return this;
    }

    /**
     * @returns {?number}
     */
    get port() {
        return this._port;
    }

    /**
     * @param {number} port
     * @returns {this}
     */
    setPort(port) {
        this._port = port;
        return this;
    }

    /**
     * @internal
     * @param {proto.IServiceEndpoint} endpoint
     * @returns {EndPoint}
     */
    static _fromProtobuf(endpoint) {
        return new EndPoint({
            address:
                endpoint.ipAddressV4 != null
                    ? IPv4Address._fromProtobuf(endpoint.ipAddressV4)
                    : undefined,
            port: endpoint.port != null ? endpoint.port : undefined,
        });
    }

    /**
     * @returns {proto.IServiceEndpoint}
     */
    _toProtobuf() {
        return {
            ipAddressV4:
                this._address != null ? this._address._toProtobuf() : null,
            port: this._port,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {EndPointJson}
     */
    toJSON() {
        return {
            address: this._address != null ? this._address.toString() : null,
            port: this._port != null ? this._port.toString() : null,
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").INodeAddress} proto.INodeAddress
 */

/**
 * @typedef {import("./Endpoint.js").EndPointJson} EndpointJson
 * @typedef {import("long").Long} Long
 */

/**
 * @typedef {object} NodeAddressJson
 * @property {string | null} publicKey
 * @property {string | null} nodeId
 * @property {string | null} accountId
 * @property {string | null} certHash
 * @property {EndpointJson[] | null} addresses
 * @property {string | null} description
 * @property {string | null} stake
 */

class NodeAddress {
    /**
     * @param {object} props
     * @param {string} [props.publicKey]
     * @param {Long} [props.nodeId]
     * @param {AccountId | string} [props.accountId]
     * @param {Uint8Array} [props.certHash]
     * @param {Endpoint[]} [props.addresses]
     * @param {string} [props.description]
     * @param {Long} [props.stake]
     */
    constructor(props = {}) {
        /**
         * @type {string | null}
         */
        this._publicKey = null;

        if (props.publicKey != null) {
            this.setPublicKey(props.publicKey);
        }

        /**
         * @type {Long |null}
         */
        this._nodeId = null;

        if (props.nodeId != null) {
            this.setNodeId(props.nodeId);
        }

        /**
         * @type {AccountId | null}
         */
        this._accountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        /**
         * @type {Uint8Array | null}
         */
        this._certHash = null;

        if (props.certHash != null) {
            this.setCertHash(props.certHash);
        }

        /**
         * @type {Endpoint[]}
         */
        this._addresses = [];

        if (props.addresses != null) {
            this.setAddresses(props.addresses);
        }

        /**
         * @type {string | null}
         */
        this._description = null;

        if (props.description != null) {
            this.setDescription(props.description);
        }

        /**
         * @type {Long | null}
         */
        this._stake = null;

        if (props.stake != null) {
            this.setStake(props.stake);
        }
    }

    /**
     * @returns {?string}
     */
    get publicKey() {
        return this._publicKey;
    }

    /**
     * @param {string} publicKey
     * @returns {this}
     */
    setPublicKey(publicKey) {
        this._publicKey = publicKey;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get nodeId() {
        return this._nodeId;
    }

    /**
     * @param {Long} nodeId
     * @returns {this}
     */
    setNodeId(nodeId) {
        this._nodeId = nodeId;
        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();
        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get certHash() {
        return this._certHash;
    }

    /**
     * @param {Uint8Array} certHash
     * @returns {this}
     */
    setCertHash(certHash) {
        this._certHash = certHash;
        return this;
    }

    /**
     * @returns {Endpoint[]}
     */
    get addresses() {
        return this._addresses;
    }

    /**
     * @param {Endpoint[]} addresses
     * @returns {this}
     */
    setAddresses(addresses) {
        this._addresses = addresses;
        return this;
    }

    /**
     * @returns {?string}
     */
    get description() {
        return this._description;
    }

    /**
     * @param {string} description
     * @returns {this}
     */
    setDescription(description) {
        this._description = description;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get stake() {
        return this._stake;
    }

    /**
     * @param {Long} stake
     * @returns {this}
     */
    setStake(stake) {
        this._stake = stake;
        return this;
    }

    /**
     * @internal
     * @param {proto.INodeAddress} nodeAddress
     * @returns {NodeAddress}
     */
    static _fromProtobuf(nodeAddress) {
        return new NodeAddress({
            publicKey:
                nodeAddress.RSA_PubKey != null
                    ? nodeAddress.RSA_PubKey
                    : undefined,
            nodeId: nodeAddress.nodeId != null ? nodeAddress.nodeId : undefined,
            accountId:
                nodeAddress.nodeAccountId != null
                    ? AccountId._fromProtobuf(nodeAddress.nodeAccountId)
                    : undefined,
            certHash:
                nodeAddress.nodeCertHash != null
                    ? nodeAddress.nodeCertHash
                    : undefined,
            addresses:
                nodeAddress.serviceEndpoint != null
                    ? nodeAddress.serviceEndpoint.map((address) =>
                          EndPoint._fromProtobuf(address)
                      )
                    : undefined,
            description:
                nodeAddress.description != null
                    ? nodeAddress.description
                    : undefined,
            stake: nodeAddress.stake != null ? nodeAddress.stake : undefined,
        });
    }

    /**
     * @returns {proto.INodeAddress}
     */
    _toProtobuf() {
        return {
            RSA_PubKey: this._publicKey,
            nodeId: this._nodeId,
            nodeAccountId:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            nodeCertHash: this._certHash,
            serviceEndpoint: this._addresses.map((address) =>
                address._toProtobuf()
            ),
            description: this._description,
            stake: this._stake,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {NodeAddressJson}
     */
    toJSON() {
        return {
            publicKey: this._publicKey,
            nodeId: this._nodeId != null ? this._nodeId.toString() : null,
            accountId:
                this._accountId != null ? this._accountId.toString() : null,
            certHash:
                this._certHash != null ? decode(this._certHash) : null,
            addresses: this._addresses.map((address) => address.toJSON()),
            description: this._description,
            stake: this._stake != null ? this._stake.toString() : null,
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").INodeAddressBook} proto.INodeAddressBook
 */

/**
 * @typedef {import("./NodeAddress.js").NodeAddressJson} NodeAddressJson
 */

/**
 * @typedef {object} NodeAddressBookJson
 * @property {NodeAddressJson[]} nodeAddresses
 */

class NodeAddressBook {
    /**
     * @param {object} props
     * @param {NodeAddress[]} [props.nodeAddresses]
     */
    constructor(props = {}) {
        /**
         * @type {NodeAddress[]}
         */
        this._nodeAddresses = [];

        if (props.nodeAddresses != null) {
            this.setNodeAddresses(props.nodeAddresses);
        }
    }

    /**
     * @returns {NodeAddress[]}
     */
    get nodeAddresses() {
        return this._nodeAddresses;
    }

    /**
     * @param {NodeAddress[]} nodeAddresses
     * @returns {this}
     */
    setNodeAddresses(nodeAddresses) {
        this._nodeAddresses = nodeAddresses;
        return this;
    }

    /**
     * @internal
     * @param {proto.INodeAddressBook} nodeAddressBook
     * @returns {NodeAddressBook}
     */
    static _fromProtobuf(nodeAddressBook) {
        return new NodeAddressBook({
            nodeAddresses:
                nodeAddressBook.nodeAddress != null
                    ? nodeAddressBook.nodeAddress.map((nodeAddress) =>
                          NodeAddress._fromProtobuf(nodeAddress)
                      )
                    : undefined,
        });
    }

    /**
     * @returns {proto.INodeAddressBook}
     */
    _toProtobuf() {
        return {
            nodeAddress: this._nodeAddresses.map((nodeAddress) =>
                nodeAddress._toProtobuf()
            ),
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {NodeAddressBookJson}
     */
    toJSON() {
        return {
            nodeAddresses: this._nodeAddresses.map((nodeAddress) =>
                nodeAddress.toJSON()
            ),
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IContractGetBytecodeQuery} proto.IContractGetBytecodeQuery
 * @typedef {import("@hashgraph/proto").IContractGetBytecodeResponse} proto.IContractGetBytecodeResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<Uint8Array>}
 */
class ContractByteCodeQuery extends Query {
    /**
     * @param {object} props
     * @param {ContractId | string} [props.contractId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?ContractId}
         * @private
         */
        this._contractId = null;
        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {ContractByteCodeQuery}
     */
    static _fromProtobuf(query) {
        const bytecode = /** @type {proto.IContractGetBytecodeQuery} */ (
            query.contractGetBytecode
        );

        return new ContractByteCodeQuery({
            contractId:
                bytecode.contractID != null
                    ? ContractId._fromProtobuf(bytecode.contractID)
                    : undefined,
        });
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Set the contract ID for which the info is being requested.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractByteCodeQuery}
     */
    setContractId(contractId) {
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.contractGetBytecode(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const contractGetBytecodeResponse =
            /** @type {proto.IContractGetBytecodeResponse} */ (
                response.contractGetBytecodeResponse
            );
        return /** @type {proto.IResponseHeader} */ (
            contractGetBytecodeResponse.header
        );
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @returns {Promise<Uint8Array>}
     */
    _mapResponse(response) {
        const contractGetBytecodeResponse =
            /** @type {proto.IContractGetBytecodeResponse} */ (
                response.contractGetBytecodeResponse
            );

        return Promise.resolve(
            contractGetBytecodeResponse.bytecode != null
                ? contractGetBytecodeResponse.bytecode
                : new Uint8Array()
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            contractGetBytecode: {
                header,
                contractID:
                    this._contractId != null
                        ? this._contractId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `ContractByteCodeQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("contractGetBytecode", ContractByteCodeQuery._fromProtobuf);

// Originally sourced from:
// https://github.com/MaiaVictor/eth-lib/blob/da0971f5b09964d9c8449975fa87933f0c9fef35/src/hash.js
//  - added type declarations
//  - switched to es6 module syntax
//
// Disable linting for entire file because it's nearly all pure JS
// eslint-disable

const HEX_CHARS = "0123456789abcdef".split("");
const KECCAK_PADDING = [1, 256, 65536, 16777216];
const SHIFT = [0, 8, 16, 24];
const RC = [
    1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
    2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0,
    2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
    2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0,
    2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648,
    2147483649, 0, 2147516424, 2147483648,
];

/**
 * @typedef {object} KeccakT
 * @property {number[]} blocks
 * @property {number} blockCount
 * @property {number} outputBlocks
 * @property {number[]} s
 * @property {number} start
 * @property {number} block
 * @property {boolean} reset
 * @property {number=} lastByteIndex
 */

/** @type {(bits: number) => KeccakT} */
const Keccak = (bits) => ({
    blocks: [],
    reset: true,
    block: 0,
    start: 0,
    blockCount: (1600 - (bits << 1)) >> 5,
    outputBlocks: bits >> 5,
    // @ts-ignore
    s: ((s) => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
});

/** @type {(state: KeccakT, message: string | number[]) => string} */
const update = (state, /** @type {string | number[]} */ message) => {
    var length = message.length,
        blocks = state.blocks,
        byteCount = state.blockCount << 2,
        blockCount = state.blockCount,
        outputBlocks = state.outputBlocks,
        s = state.s,
        index = 0,
        i,
        code;

    // update
    while (index < length) {
        if (state.reset) {
            state.reset = false;
            blocks[0] = state.block;
            for (i = 1; i < blockCount + 1; ++i) {
                blocks[i] = 0;
            }
        }
        if (typeof message !== "string") {
            for (i = state.start; index < length && i < byteCount; ++index) {
                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
        } else {
            for (i = state.start; index < length && i < byteCount; ++index) {
                code = message.charCodeAt(index);
                if (code < 0x80) {
                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 0x800) {
                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                } else if (code < 0xd800 || code >= 0xe000) {
                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                } else {
                    code =
                        0x10000 +
                        (((code & 0x3ff) << 10) |
                            (message.charCodeAt(++index) & 0x3ff));
                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                }
            }
        }
        state.lastByteIndex = i;
        if (i >= byteCount) {
            state.start = i - byteCount;
            state.block = blocks[blockCount];
            for (i = 0; i < blockCount; ++i) {
                s[i] ^= blocks[i];
            }
            f(s);
            state.reset = true;
        } else {
            state.start = i;
        }
    }

    // finalize
    i = state.lastByteIndex;
    // @ts-ignore
    blocks[i >> 2] |= KECCAK_PADDING[i & 3];
    if (state.lastByteIndex === byteCount) {
        blocks[0] = blocks[blockCount];
        for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
        }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
    }
    f(s);

    // toString
    var hex = "";
    var block;
    var j = 0;
    i = 0;
    while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
            block = s[i];
            hex +=
                HEX_CHARS[(block >> 4) & 0x0f] +
                HEX_CHARS[block & 0x0f] +
                HEX_CHARS[(block >> 12) & 0x0f] +
                HEX_CHARS[(block >> 8) & 0x0f] +
                HEX_CHARS[(block >> 20) & 0x0f] +
                HEX_CHARS[(block >> 16) & 0x0f] +
                HEX_CHARS[(block >> 28) & 0x0f] +
                HEX_CHARS[(block >> 24) & 0x0f];
        }
        if (j % blockCount === 0) {
            f(s);
            i = 0;
        }
    }
    // @ts-ignore
    return "0x" + hex;
};

/** @type {(s: number[]) => void} */
const f = (s) => {
    var h,
        l,
        n,
        c0,
        c1,
        c2,
        c3,
        c4,
        c5,
        c6,
        c7,
        c8,
        c9,
        b0,
        b1,
        b2,
        b3,
        b4,
        b5,
        b6,
        b7,
        b8,
        b9,
        b10,
        b11,
        b12,
        b13,
        b14,
        b15,
        b16,
        b17,
        b18,
        b19,
        b20,
        b21,
        b22,
        b23,
        b24,
        b25,
        b26,
        b27,
        b28,
        b29,
        b30,
        b31,
        b32,
        b33,
        b34,
        b35,
        b36,
        b37,
        b38,
        b39,
        b40,
        b41,
        b42,
        b43,
        b44,
        b45,
        b46,
        b47,
        b48,
        b49;

    for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

        h = c8 ^ ((c2 << 1) | (c3 >>> 31));
        l = c9 ^ ((c3 << 1) | (c2 >>> 31));
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ ((c4 << 1) | (c5 >>> 31));
        l = c1 ^ ((c5 << 1) | (c4 >>> 31));
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ ((c6 << 1) | (c7 >>> 31));
        l = c3 ^ ((c7 << 1) | (c6 >>> 31));
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ ((c8 << 1) | (c9 >>> 31));
        l = c5 ^ ((c9 << 1) | (c8 >>> 31));
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ ((c0 << 1) | (c1 >>> 31));
        l = c7 ^ ((c1 << 1) | (c0 >>> 31));
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;

        b0 = s[0];
        b1 = s[1];
        b32 = (s[11] << 4) | (s[10] >>> 28);
        b33 = (s[10] << 4) | (s[11] >>> 28);
        b14 = (s[20] << 3) | (s[21] >>> 29);
        b15 = (s[21] << 3) | (s[20] >>> 29);
        b46 = (s[31] << 9) | (s[30] >>> 23);
        b47 = (s[30] << 9) | (s[31] >>> 23);
        b28 = (s[40] << 18) | (s[41] >>> 14);
        b29 = (s[41] << 18) | (s[40] >>> 14);
        b20 = (s[2] << 1) | (s[3] >>> 31);
        b21 = (s[3] << 1) | (s[2] >>> 31);
        b2 = (s[13] << 12) | (s[12] >>> 20);
        b3 = (s[12] << 12) | (s[13] >>> 20);
        b34 = (s[22] << 10) | (s[23] >>> 22);
        b35 = (s[23] << 10) | (s[22] >>> 22);
        b16 = (s[33] << 13) | (s[32] >>> 19);
        b17 = (s[32] << 13) | (s[33] >>> 19);
        b48 = (s[42] << 2) | (s[43] >>> 30);
        b49 = (s[43] << 2) | (s[42] >>> 30);
        b40 = (s[5] << 30) | (s[4] >>> 2);
        b41 = (s[4] << 30) | (s[5] >>> 2);
        b22 = (s[14] << 6) | (s[15] >>> 26);
        b23 = (s[15] << 6) | (s[14] >>> 26);
        b4 = (s[25] << 11) | (s[24] >>> 21);
        b5 = (s[24] << 11) | (s[25] >>> 21);
        b36 = (s[34] << 15) | (s[35] >>> 17);
        b37 = (s[35] << 15) | (s[34] >>> 17);
        b18 = (s[45] << 29) | (s[44] >>> 3);
        b19 = (s[44] << 29) | (s[45] >>> 3);
        b10 = (s[6] << 28) | (s[7] >>> 4);
        b11 = (s[7] << 28) | (s[6] >>> 4);
        b42 = (s[17] << 23) | (s[16] >>> 9);
        b43 = (s[16] << 23) | (s[17] >>> 9);
        b24 = (s[26] << 25) | (s[27] >>> 7);
        b25 = (s[27] << 25) | (s[26] >>> 7);
        b6 = (s[36] << 21) | (s[37] >>> 11);
        b7 = (s[37] << 21) | (s[36] >>> 11);
        b38 = (s[47] << 24) | (s[46] >>> 8);
        b39 = (s[46] << 24) | (s[47] >>> 8);
        b30 = (s[8] << 27) | (s[9] >>> 5);
        b31 = (s[9] << 27) | (s[8] >>> 5);
        b12 = (s[18] << 20) | (s[19] >>> 12);
        b13 = (s[19] << 20) | (s[18] >>> 12);
        b44 = (s[29] << 7) | (s[28] >>> 25);
        b45 = (s[28] << 7) | (s[29] >>> 25);
        b26 = (s[38] << 8) | (s[39] >>> 24);
        b27 = (s[39] << 8) | (s[38] >>> 24);
        b8 = (s[48] << 14) | (s[49] >>> 18);
        b9 = (s[49] << 14) | (s[48] >>> 18);

        s[0] = b0 ^ (~b2 & b4);
        s[1] = b1 ^ (~b3 & b5);
        s[10] = b10 ^ (~b12 & b14);
        s[11] = b11 ^ (~b13 & b15);
        s[20] = b20 ^ (~b22 & b24);
        s[21] = b21 ^ (~b23 & b25);
        s[30] = b30 ^ (~b32 & b34);
        s[31] = b31 ^ (~b33 & b35);
        s[40] = b40 ^ (~b42 & b44);
        s[41] = b41 ^ (~b43 & b45);
        s[2] = b2 ^ (~b4 & b6);
        s[3] = b3 ^ (~b5 & b7);
        s[12] = b12 ^ (~b14 & b16);
        s[13] = b13 ^ (~b15 & b17);
        s[22] = b22 ^ (~b24 & b26);
        s[23] = b23 ^ (~b25 & b27);
        s[32] = b32 ^ (~b34 & b36);
        s[33] = b33 ^ (~b35 & b37);
        s[42] = b42 ^ (~b44 & b46);
        s[43] = b43 ^ (~b45 & b47);
        s[4] = b4 ^ (~b6 & b8);
        s[5] = b5 ^ (~b7 & b9);
        s[14] = b14 ^ (~b16 & b18);
        s[15] = b15 ^ (~b17 & b19);
        s[24] = b24 ^ (~b26 & b28);
        s[25] = b25 ^ (~b27 & b29);
        s[34] = b34 ^ (~b36 & b38);
        s[35] = b35 ^ (~b37 & b39);
        s[44] = b44 ^ (~b46 & b48);
        s[45] = b45 ^ (~b47 & b49);
        s[6] = b6 ^ (~b8 & b0);
        s[7] = b7 ^ (~b9 & b1);
        s[16] = b16 ^ (~b18 & b10);
        s[17] = b17 ^ (~b19 & b11);
        s[26] = b26 ^ (~b28 & b20);
        s[27] = b27 ^ (~b29 & b21);
        s[36] = b36 ^ (~b38 & b30);
        s[37] = b37 ^ (~b39 & b31);
        s[46] = b46 ^ (~b48 & b40);
        s[47] = b47 ^ (~b49 & b41);
        s[8] = b8 ^ (~b0 & b2);
        s[9] = b9 ^ (~b1 & b3);
        s[18] = b18 ^ (~b10 & b12);
        s[19] = b19 ^ (~b11 & b13);
        s[28] = b28 ^ (~b20 & b22);
        s[29] = b29 ^ (~b21 & b23);
        s[38] = b38 ^ (~b30 & b32);
        s[39] = b39 ^ (~b31 & b33);
        s[48] = b48 ^ (~b40 & b42);
        s[49] = b49 ^ (~b41 & b43);

        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
    }
};

const keccak = (/** @type {number} */ bits) => (/** @type {string} */ str) => {
    var msg;
    if (str.slice(0, 2) === "0x") {
        msg = [];
        for (var i = 2, l = str.length; i < l; i += 2)
            msg.push(parseInt(str.slice(i, i + 2), 16));
    } else {
        msg = str;
    }
    // @ts-ignore
    return update(Keccak(bits), msg);
};

/**
 * @type {(message: string) => string}
 */
const keccak256$1 = keccak(256);

/**
 * @enum {number}
 */
const ArgumentType = {
    uint8: 0,
    int8: 1,
    uint16: 2,
    int16: 3,
    uint32: 4,
    int32: 5,
    uint64: 6,
    int64: 7,
    uint256: 8,
    int256: 9,
    string: 10,
    bool: 11,
    bytes: 12,
    bytes32: 13,
    address: 14,
    func: 15,
};

/**
 * @typedef {object} Argument
 * @property {boolean} dynamic
 * @property {Uint8Array} value
 */

/**
 * @typedef {object} SolidityType
 * @property {ArgumentType} ty
 * @property {boolean} array
 */

class ContractFunctionSelector {
    /**
     * @param {string} [name]
     */
    constructor(name) {
        /**
         * @type {?string}
         */
        this.name = null;

        /**
         * @type {string}
         */
        this._params = "";

        /**
         * @type {SolidityType[]}
         */
        this._paramTypes = [];

        if (name != null) {
            this._name = name;
        }
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addString() {
        return this._addParam({ ty: ArgumentType.string, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addStringArray() {
        return this._addParam({ ty: ArgumentType.string, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBytes() {
        return this._addParam({ ty: ArgumentType.bytes, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBytes32() {
        return this._addParam({ ty: ArgumentType.bytes32, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBytesArray() {
        return this._addParam({ ty: ArgumentType.bytes, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBytes32Array() {
        return this._addParam({ ty: ArgumentType.bytes32, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt8() {
        return this._addParam({ ty: ArgumentType.int8, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt32() {
        return this._addParam({ ty: ArgumentType.int32, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt64() {
        return this._addParam({ ty: ArgumentType.int64, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt256() {
        return this._addParam({ ty: ArgumentType.int256, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt8Array() {
        return this._addParam({ ty: ArgumentType.int8, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt32Array() {
        return this._addParam({ ty: ArgumentType.int32, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt64Array() {
        return this._addParam({ ty: ArgumentType.int64, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt256Array() {
        return this._addParam({ ty: ArgumentType.int256, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint8() {
        return this._addParam({ ty: ArgumentType.uint8, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint32() {
        return this._addParam({ ty: ArgumentType.uint32, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint64() {
        return this._addParam({ ty: ArgumentType.uint64, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint256() {
        return this._addParam({ ty: ArgumentType.uint256, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint8Array() {
        return this._addParam({ ty: ArgumentType.uint8, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint32Array() {
        return this._addParam({ ty: ArgumentType.uint32, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint64Array() {
        return this._addParam({ ty: ArgumentType.uint64, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint256Array() {
        return this._addParam({ ty: ArgumentType.uint256, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBool() {
        return this._addParam({ ty: ArgumentType.bool, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addAddress() {
        return this._addParam({ ty: ArgumentType.address, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addAddressArray() {
        return this._addParam({ ty: ArgumentType.address, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addFunction() {
        return this._addParam({ ty: ArgumentType.func, array: false });
    }

    /**
     * @param {SolidityType} ty
     * @returns {ContractFunctionSelector}
     */
    _addParam(ty) {
        if (this._paramTypes.length > 0) {
            this._params += ",";
        }

        this._params += solidityTypeToString(ty);
        this._paramTypes.push(ty);

        return this;
    }

    /**
     * @param {string} [name]
     * @returns {Uint8Array}
     */
    _build(name) {
        if (name != null) {
            this._name = name;
        } else if (this._name == null) {
            throw new Error("`name` required for ContractFunctionSelector");
        }

        const func = encode$1(encode(this.toString()));
        return decode$1(keccak256$1(`0x${func}`)).slice(0, 4);
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this._name != null ? this._name.toString() : ""}(${
            this._params
        })`;
    }
}

/**
 * @param {SolidityType} ty
 * @returns {string}
 */
function solidityTypeToString(ty) {
    let s = "";
    switch (ty.ty) {
        case ArgumentType.uint8:
            s = "uint8";
            break;
        case ArgumentType.int8:
            s = "int8";
            break;
        case ArgumentType.uint16:
            s = "uint16";
            break;
        case ArgumentType.int16:
            s = "int16";
            break;
        case ArgumentType.uint32:
            s = "uint32";
            break;
        case ArgumentType.int32:
            s = "int32";
            break;
        case ArgumentType.uint64:
            s = "uint64";
            break;
        case ArgumentType.int64:
            s = "int64";
            break;
        case ArgumentType.uint256:
            s = "uint256";
            break;
        case ArgumentType.int256:
            s = "int256";
            break;
        case ArgumentType.string:
            s = "string";
            break;
        case ArgumentType.bool:
            s = "bool";
            break;
        case ArgumentType.bytes:
            s = "bytes";
            break;
        case ArgumentType.bytes32:
            s = "bytes32";
            break;
        case ArgumentType.address:
            s = "address";
            break;
        case ArgumentType.func:
            s = "function";
            break;
        default:
            s = "";
            break;
    }

    if (ty.array) {
        s += "[]";
    }

    return s;
}

class ContractFunctionParameters$1 {
    constructor() {
        /**
         * @type {ContractFunctionSelector}
         */
        this._selector = new ContractFunctionSelector();

        /**
         * @type {import("./ContractFunctionSelector.js").Argument[]}
         */
        this._arguments = [];
    }

    /**
     * @param {string} value
     * @returns {ContractFunctionParameters}
     */
    addString(value) {
        this._selector.addString();

        return this._addParam(value, true);
    }

    /**
     * @param {string[]} value
     * @returns {ContractFunctionParameters}
     */
    addStringArray(value) {
        this._selector.addStringArray();

        return this._addParam(value, true);
    }

    /**
     * @param {Uint8Array} value
     * @returns {ContractFunctionParameters}
     */
    addBytes(value) {
        this._selector.addBytes();

        return this._addParam(value, true);
    }

    /**
     * @param {Uint8Array} value
     * @returns {ContractFunctionParameters}
     */
    addBytes32(value) {
        if (value.length !== 32) {
            throw new Error(
                `addBytes32 expected array to be of length 32, but received ${value.length}`
            );
        }

        this._selector.addBytes32();
        return this._addParam(value, false);
    }

    /**
     * @param {Uint8Array[]} value
     * @returns {ContractFunctionParameters}
     */
    addBytesArray(value) {
        this._selector.addBytesArray();

        return this._addParam(value, true);
    }

    /**
     * @param {Uint8Array[]} value
     * @returns {ContractFunctionParameters}
     */
    addBytes32Array(value) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [_, entry] of value.entries()) {
            if (entry.length !== 32) {
                throw new Error(
                    `addBytes32 expected array to be of length 32, but received ${entry.length}`
                );
            }
        }

        this._selector.addBytes32Array();

        return this._addParam(value, true);
    }

    /**
     * @param {boolean} value
     * @returns {ContractFunctionParameters}
     */
    addBool(value) {
        this._selector.addBool();

        return this._addParam(value, false);
    }

    /**
     * @param {number} value
     * @returns {ContractFunctionParameters}
     */
    addInt8(value) {
        this._selector.addInt8();

        return this._addParam(convertToBigNumber(value), false);
    }

    /**
     * @param {number} value
     * @returns {ContractFunctionParameters}
     */
    addInt32(value) {
        this._selector.addInt32();

        return this._addParam(convertToBigNumber(value), false);
    }

    /**
     * @param {BigNumber} value
     * @returns {ContractFunctionParameters}
     */
    addInt64(value) {
        this._selector.addInt64();

        return this._addParam(convertToBigNumber(value), false);
    }

    /**
     * @param {BigNumber} value
     * @returns {ContractFunctionParameters}
     */
    addInt256(value) {
        this._selector.addInt256();

        return this._addParam(convertToBigNumber(value), false);
    }

    /**
     * @param {number[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt8Array(value) {
        this._selector.addInt8Array();

        return this._addParam(convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt32Array(value) {
        this._selector.addInt32Array();

        return this._addParam(convertToBigNumberArray(value), true);
    }

    /**
     * @param {BigNumber[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt64Array(value) {
        this._selector.addInt64Array();

        return this._addParam(convertToBigNumberArray(value), true);
    }

    /**
     * @param {BigNumber[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt256Array(value) {
        this._selector.addInt256Array();
        return this._addParam(convertToBigNumberArray(value), true);
    }

    /**
     * @param {number} value
     * @returns {ContractFunctionParameters}
     */
    addUint8(value) {
        this._selector.addUint8();

        return this._addParam(convertToBigNumber(value), false);
    }

    /**
     * @param {number} value
     * @returns {ContractFunctionParameters}
     */
    addUint32(value) {
        this._selector.addUint32();

        return this._addParam(convertToBigNumber(value), false);
    }

    /**
     * @param {BigNumber} value
     * @returns {ContractFunctionParameters}
     */
    addUint64(value) {
        this._selector.addUint64();

        return this._addParam(convertToBigNumber(value), false);
    }

    /**
     * @param {BigNumber | number} value
     * @returns {ContractFunctionParameters}
     */
    addUint256(value) {
        this._selector.addUint256();

        return this._addParam(convertToBigNumber(value), false);
    }

    /**
     * @param {number[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint8Array(value) {
        this._selector.addUint8Array();

        return this._addParam(convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint32Array(value) {
        this._selector.addUint32Array();

        return this._addParam(convertToBigNumberArray(value), true);
    }

    /**
     * @param {BigNumber[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint64Array(value) {
        this._selector.addUint64Array();

        return this._addParam(convertToBigNumberArray(value), true);
    }

    /**
     * @param {BigNumber[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint256Array(value) {
        this._selector.addUint256Array();

        return this._addParam(convertToBigNumberArray(value), true);
    }

    /**
     * @param {string} value
     * @returns {ContractFunctionParameters}
     */
    addAddress(value) {
        // Allow `0x` prefix
        if (value.length !== 40 && value.length !== 42) {
            throw new Error(
                "`address` type requires parameter to be 40 or 42 characters"
            );
        }

        const par =
            value.length === 40
                ? decode$1(value)
                : decode$1(value.substring(2));

        this._selector.addAddress();

        return this._addParam(par, false);
    }

    /**
     * @param {string[]} value
     * @returns {ContractFunctionParameters}
     */
    addAddressArray(value) {
        /**
         * @type {Uint8Array[]}
         */
        const par = [];

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [_, entry] of value.entries()) {
            if (entry.length !== 40 && entry.length !== 42) {
                throw new Error(
                    "`address` type requires parameter to be 40 or 42 characters"
                );
            }

            const buf =
                entry.length === 40
                    ? decode$1(entry)
                    : decode$1(entry.substring(2));

            par.push(buf);
        }

        this._selector.addAddressArray();

        return this._addParam(par, true);
    }

    /**
     * @param {string} address
     * @param {ContractFunctionSelector} selector
     * @returns {ContractFunctionParameters}
     */
    addFunction(address, selector) {
        const addressParam = decode$1(address);
        const functionSelector = selector._build();

        if (addressParam.length !== 20) {
            throw new Error(
                "`function` type requires parameter `address` to be exactly 20 bytes"
            );
        }

        this._selector.addFunction();

        const proto = new Uint8Array(24);
        proto.set(addressParam, 0);
        proto.set(functionSelector, 20);

        return this._addParam(proto, false);
    }

    /**
     * @internal
     * @param {string | boolean | number | Uint8Array | BigNumber | string[] | boolean[] | number[] | Uint8Array[] | BigNumber[]} param
     * @param {boolean} dynamic
     * @returns {ContractFunctionParameters}
     */
    _addParam(param, dynamic) {
        const index = this._selector._paramTypes.length - 1;
        const value = argumentToBytes(param, this._selector._paramTypes[index]);

        this._arguments.push({ dynamic, value });

        return this;
    }

    /**
     * @internal
     * @param {string=} name
     * @returns {Uint8Array}
     */
    _build(name) {
        const includeId = name != null;
        const nameOffset = includeId ? 4 : 0;

        const length =
            this._arguments.length === 0
                ? nameOffset
                : this._arguments.length * 32 +
                  this._arguments
                      .map((arg) => (arg.dynamic ? arg.value.length : 0))
                      .reduce((sum, value) => sum + value) +
                  nameOffset;

        const func = new Uint8Array(length);

        if (includeId) {
            func.set(this._selector._build(name), 0);
        }

        let offset = 32 * this._arguments.length;

        for (const [i, { dynamic, value }] of this._arguments.entries()) {
            if (dynamic) {
                const view = safeView(func, nameOffset + i * 32 + 28);
                view.setUint32(0, offset);
                func.set(value, view.getUint32(0) + nameOffset);
                offset += value.length;
            } else {
                func.set(value, nameOffset + i * 32);
            }
        }

        return func;
    }
}

/**
 * @param {string | boolean | number | Uint8Array | BigNumber | string[] | boolean[] | number[] | Uint8Array[] | BigNumber[]} param
 * @param {import("./ContractFunctionSelector.js").SolidityType} ty
 * @returns {Uint8Array}
 */
function argumentToBytes(param, ty) {
    let value = new Uint8Array(32);
    let valueView = safeView(value);
    /** @type {Uint8Array} */
    let par;

    if (ty.array) {
        if (!Array.isArray(param)) {
            throw new TypeError(
                "SolidityType indicates type is array, but parameter is not an array"
            );
        }

        /**
         * @type {Uint8Array[]}
         */
        const values = [];

        // Generic over any type of array
        // Destructuring required so the first variable must be assigned
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [_, p] of param.entries()) {
            const arg = argumentToBytes(p, { ty: ty.ty, array: false });
            values.push(arg);
        }

        const totalLengthOfValues = values
            .map((a) => a.length)
            .reduce((total, current) => total + current);

        switch (ty.ty) {
            case ArgumentType.uint8:
            case ArgumentType.int8:
            case ArgumentType.uint16:
            case ArgumentType.int16:
            case ArgumentType.uint32:
            case ArgumentType.int32:
            case ArgumentType.uint64:
            case ArgumentType.int64:
            case ArgumentType.uint256:
            case ArgumentType.int256:
            case ArgumentType.bool:
            case ArgumentType.bytes32:
            case ArgumentType.address:
            case ArgumentType.func:
                value = new Uint8Array(totalLengthOfValues + 32);
                break;
            case ArgumentType.bytes:
            case ArgumentType.string:
                value = new Uint8Array(
                    values.length * 32 + totalLengthOfValues + 32
                );
                break;
            default:
                throw new TypeError(
                    `Expected param type to be ArgumentType, but received ${ty.ty}`
                );
        }

        valueView = safeView(value, 28);
        valueView.setUint32(0, values.length);

        let offset = 32 * values.length;

        for (const [i, e] of values.entries()) {
            switch (ty.ty) {
                case ArgumentType.uint8:
                case ArgumentType.int8:
                case ArgumentType.uint16:
                case ArgumentType.int16:
                case ArgumentType.uint32:
                case ArgumentType.int32:
                case ArgumentType.uint64:
                case ArgumentType.int64:
                case ArgumentType.uint256:
                case ArgumentType.int256:
                case ArgumentType.bool:
                case ArgumentType.bytes32:
                case ArgumentType.address:
                case ArgumentType.func:
                    value.set(e, i * 32 + 32);
                    break;
                case ArgumentType.bytes:
                case ArgumentType.string:
                    // eslint-disable-next-line no-case-declarations
                    const view = safeView(value, (i + 1) * 32 + 28);
                    view.setUint32(0, offset);
                    value.set(e, view.getUint32(0) + 32);
                    offset += e.length;
                    break;
                default:
                    throw new TypeError(
                        `Expected param type to be ArgumentType, but received ${ty.ty}`
                    );
            }
        }

        return value;
    }

    switch (ty.ty) {
        case ArgumentType.uint8:
            numberToBytes(
                /** @type {number | BigNumber } */ (param),
                31,
                valueView.setUint8.bind(valueView)
            );
            return value;
        case ArgumentType.int8:
            numberToBytes(
                /** @type {number | BigNumber } */ (param),
                31,
                valueView.setInt8.bind(valueView)
            );
            return value;
        case ArgumentType.uint16:
            numberToBytes(
                /** @type {number | BigNumber } */ (param),
                30,
                valueView.setUint16.bind(valueView)
            );
            return value;
        case ArgumentType.int16:
            numberToBytes(
                /** @type {number | BigNumber } */ (param),
                30,
                valueView.setInt16.bind(valueView)
            );
            return value;
        case ArgumentType.uint32:
            numberToBytes(
                /** @type {number | BigNumber } */ (param),
                28,
                valueView.setUint32.bind(valueView)
            );
            return value;
        case ArgumentType.int32:
            numberToBytes(
                /** @type {number | BigNumber } */ (param),
                28,
                valueView.setInt32.bind(valueView)
            );
            return value;
        // int64, uint64, and int256 both expect the parameter to be an Uint8Array instead of number
        case ArgumentType.uint64:
        case ArgumentType.int64:
            if (BigNumber$1.isBigNumber(param)) {
                // eslint-disable-next-line no-case-declarations
                let par = param.toString(16);
                if (par.length > 16) {
                    throw new TypeError(
                        "uint64/int64 requires BigNumber to be less than or equal to 8 bytes"
                    );
                } else if (!param.isInteger()) {
                    throw new TypeError(
                        "uint64/int64 requires BigNumber to be an integer"
                    );
                }

                if (par.length % 2 === 1) {
                    par = `0${par}`;
                }

                // eslint-disable-next-line no-case-declarations
                const buf = decode$1(par);
                value.set(buf, 32 - buf.length);
            }
            return value;
        case ArgumentType.int256:
        case ArgumentType.uint256:
            if (BigNumber$1.isBigNumber(param)) {
                let par = param.toString(16);
                if (par.length % 2 === 1) {
                    par = `0${par}`;
                }

                const buf = decode$1(par);
                value.set(buf, 32 - buf.length);
            }
            return value;
        case ArgumentType.address:
            value.set(/** @type {Uint8Array} */ (param), 32 - 20);
            return value;
        case ArgumentType.bool:
            value[31] = /** @type {boolean} */ (param) ? 1 : 0;
            return value;
        case ArgumentType.func:
            value.set(/** @type {Uint8Array} */ (param), 32 - 24);
            return value;
        case ArgumentType.bytes32:
            value.set(/** @type {Uint8Array} */ (param), 0);
            return value;
        // Bytes should have not the length already encoded
        // JS String type is encoded as UTF-16 whilst Solidity `string` type is UTF-8 encoded.
        // So if will assume is already correctly updated to being a Uint8Array of UTF-8 string
        case ArgumentType.bytes:
        case ArgumentType.string:
            // If value is of type string, encode it in UTF-8 format and conver it to Uint8Array
            // Required because JS Strings are UTF-16
            // eslint-disable-next-line no-case-declarations
            par =
                param instanceof Uint8Array
                    ? param
                    : encode(/** @type {string} */ (param));

            // Resize value to a 32 byte boundary if needed
            if (
                Math.floor(par.length / 32) >= 0 &&
                Math.floor(par.length % 32) !== 0
            ) {
                value = new Uint8Array(
                    (Math.floor(par.length / 32) + 1) * 32 + 32
                );
            } else {
                value = new Uint8Array(64);
            }

            value.set(par, 32);

            valueView = safeView(value, 28);
            valueView.setUint32(0, par.length);
            return value;
        default:
            throw new Error(`Unsupported argument type: ${ty.toString()}`);
    }
}

/**
 * @param {number | BigNumber} param
 * @param {number} byteoffset
 * @param {(byteOffset: number, value: number) => void} func
 * @returns {void}
 */
function numberToBytes(param, byteoffset, func) {
    const value = BigNumber$1.isBigNumber(param) ? param.toNumber() : param;

    func(byteoffset, value);
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IContractCallLocalQuery} proto.IContractCallLocalQuery
 * @typedef {import("@hashgraph/proto").IContractCallLocalResponse} proto.IContractCallLocalResponse
 * @typedef {import("@hashgraph/proto").IContractFunctionResult} proto.IContractFunctionResult
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @typedef {object} FunctionParameters
 * @property {ContractFunctionParameters} parameters
 * @property {string} name
 */

/**
 * @augments {Query<ContractFunctionResult>}
 */
class ContractCallQuery extends Query {
    /**
     * @param {object} [props]
     * @param {ContractId | string} [props.contractId]
     * @param {number | Long} [props.gas]
     * @param {FunctionParameters | Uint8Array} [props.functionParameters]
     * @param {number | Long} [props.maxResultSize]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;
        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        /**
         * @private
         * @type {?Long}
         */
        this._gas = null;
        if (props.gas != null) {
            this.setGas(props.gas);
        }

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._functionParameters = null;
        if (props.functionParameters != null) {
            if (props.functionParameters instanceof Uint8Array) {
                this.setFunctionParameters(props.functionParameters);
            } else {
                this.setFunction(
                    props.functionParameters.name,
                    props.functionParameters.parameters
                );
            }
        }

        /**
         * @private
         * @type {?Long}
         */
        this._maxResultSize = null;
        if (props.maxResultSize != null) {
            this.setMaxResultSize(props.maxResultSize);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {ContractCallQuery}
     */
    static _fromProtobuf(query) {
        const call = /** @type {proto.IContractCallLocalQuery} */ (
            query.contractCallLocal
        );

        return new ContractCallQuery({
            contractId:
                call.contractID != null
                    ? ContractId._fromProtobuf(call.contractID)
                    : undefined,
            gas: call.gas != null ? call.gas : undefined,
            functionParameters:
                call.functionParameters != null
                    ? call.functionParameters
                    : undefined,
            maxResultSize:
                call.maxResultSize != null ? call.maxResultSize : undefined,
        });
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Set the contract ID for which the call is being requested.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractCallQuery}
     */
    setContractId(contractId) {
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get gas() {
        return this._gas;
    }

    /**
     * @param {number | Long} gas
     * @returns {ContractCallQuery}
     */
    setGas(gas) {
        this._gas = gas instanceof long ? gas : long.fromValue(gas);
        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get functionParameters() {
        return this._functionParameters;
    }

    /**
     * @param {Uint8Array} params
     * @returns {ContractCallQuery}
     */
    setFunctionParameters(params) {
        this._functionParameters = params;
        return this;
    }

    /**
     * @param {string} name
     * @param {?ContractFunctionParameters} [params]
     * @returns {ContractCallQuery}
     */
    setFunction(name, params) {
        this._functionParameters = (
            params != null ? params : new ContractFunctionParameters$1()
        )._build(name);

        return this;
    }

    /**
     * @param {number | Long} size
     * @returns {ContractCallQuery}
     */
    setMaxResultSize(size) {
        this._maxResultSize =
            size instanceof long ? size : long.fromValue(size);
        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.contractCallLocalMethod(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const contractCallLocal =
            /** @type {proto.IContractCallLocalResponse} */ (
                response.contractCallLocal
            );
        return /** @type {proto.IResponseHeader} */ (contractCallLocal.header);
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @returns {Promise<ContractFunctionResult>}
     */
    _mapResponse(response) {
        const call =
            /**
             *@type {proto.IContractCallLocalResponse}
             */
            (response.contractCallLocal);

        return Promise.resolve(
            ContractFunctionResult._fromProtobuf(
                /**
                 * @type {proto.IContractFunctionResult}
                 */
                (call.functionResult)
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            contractCallLocal: {
                header,
                contractID:
                    this._contractId != null
                        ? this._contractId._toProtobuf()
                        : null,
                gas: this._gas,
                maxResultSize: this._maxResultSize,
                functionParameters: this._functionParameters,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `ContractCallQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("contractCallLocal", ContractCallQuery._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFileCreateTransactionBody} proto.IFileCreateTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a new Hedera crypto-currency file.
 */
class FileCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Key[] | KeyList} [props.keys]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Uint8Array | string} [props.contents]
     * @param {string} [props.fileMemo]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Key[]}
         */
        this._keys = null;

        /**
         * @private
         * @type {Timestamp}
         */
        this._expirationTime = new Timestamp(0, 0).plusNanos(
            long.fromNumber(Date.now())
                .mul(1000000)
                .add(DEFAULT_AUTO_RENEW_PERIOD.mul(1000000000))
        );

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._contents = null;

        /**
         * @private
         * @type {?string}
         */
        this._fileMemo = null;

        this._defaultMaxTransactionFee = new Hbar(5);

        if (props.keys != null) {
            this.setKeys(props.keys);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.contents != null) {
            this.setContents(props.contents);
        }

        if (props.fileMemo != null) {
            this.setFileMemo(props.fileMemo);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {FileCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const create = /** @type {proto.IFileCreateTransactionBody} */ (
            body.fileCreate
        );

        return Transaction._fromProtobufTransactions(
            new FileCreateTransaction({
                keys:
                    create.keys != null
                        ? create.keys.keys != null
                            ? create.keys.keys.map((key) =>
                                  Key._fromProtobufKey(key)
                              )
                            : undefined
                        : undefined,
                expirationTime:
                    create.expirationTime != null
                        ? Timestamp._fromProtobuf(create.expirationTime)
                        : undefined,
                contents: create.contents != null ? create.contents : undefined,
                fileMemo: create.memo != null ? create.memo : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?Key[]}
     */
    get keys() {
        return this._keys;
    }

    /**
     * Set the keys which must sign any transactions modifying this file. Required.
     *
     * All keys must sign to modify the file's contents or keys. No key is required
     * to sign for extending the expiration time (except the one for the operator account
     * paying for the transaction). Only one key must sign to delete the file, however.
     *
     * To require more than one key to sign to delete a file, add them to a
     * KeyList and pass that here.
     *
     * The network currently requires a file to have at least one key (or key list or threshold key)
     * but this requirement may be lifted in the future.
     *
     * @param {Key[] | KeyList} keys
     * @returns {this}
     */
    setKeys(keys) {
        this._requireNotFrozen();
        if (keys instanceof KeyList && keys.threshold != null) {
            throw new Error("Cannot set threshold key as file key");
        }

        this._keys = keys instanceof KeyList ? keys.toArray() : keys;

        return this;
    }

    /**
     * @returns {Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * Set the instant at which this file will expire, after which its contents will no longer be
     * available.
     *
     * Defaults to 1/4 of a Julian year from the instant FileCreateTransaction
     * was invoked.
     *
     * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
     *
     * @param {Timestamp | Date} expirationTime
     * @returns {this}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime =
            expirationTime instanceof Timestamp
                ? expirationTime
                : Timestamp.fromDate(expirationTime);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get contents() {
        return this._contents;
    }

    /**
     * Set the given byte array as the file's contents.
     *
     * This may be omitted to create an empty file.
     *
     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a HederaPreCheckStatusException
     * with Status#TransactionOversize.
     *
     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
     * transaction with the first chunk and then use FileAppendTransaction with
     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
     *
     * @param {Uint8Array | string} contents
     * @returns {this}
     */
    setContents(contents) {
        this._requireNotFrozen();
        this._contents =
            contents instanceof Uint8Array ? contents : encode(contents);

        return this;
    }

    /**
     * @returns {?string}
     */
    get fileMemo() {
        return this._fileMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setFileMemo(memo) {
        this._requireNotFrozen();
        this._fileMemo = memo;

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.file.createFile(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "fileCreate";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IFileCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            keys:
                this._keys != null
                    ? {
                          keys: this._keys.map((key) => key._toProtobufKey()),
                      }
                    : null,
            expirationTime: this._expirationTime._toProtobuf(),
            contents: this._contents,
            memo: this._fileMemo,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FileCreateTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("fileCreate", FileCreateTransaction._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFileAppendTransactionBody} proto.IFileAppendTransactionBody
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<Channel, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 */

/**
 * A transaction specifically to append data to a file on the network.
 *
 * If a file has multiple keys, all keys must sign to modify its contents.
 */
class FileAppendTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     * @param {Uint8Array | string} [props.contents]
     * @param {number} [props.maxChunks]
     * @param {number} [props.chunkSize]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._contents = null;

        /**
         * @private
         * @type {number}
         */
        this._maxChunks = 20;

        /**
         * @private
         * @type {number}
         */
        this._chunkSize = 2048;

        this._defaultMaxTransactionFee = new Hbar(5);

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.contents != null) {
            this.setContents(props.contents);
        }

        if (props.maxChunks != null) {
            this.setMaxChunks(props.maxChunks);
        }

        if (props.chunkSize != null) {
            this.setChunkSize(props.chunkSize);
        }

        /** @type {List<TransactionId>} */
        this._transactionIds = new List();
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {FileAppendTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const append = /** @type {proto.IFileAppendTransactionBody} */ (
            body.fileAppend
        );

        let contents;
        for (let i = 0; i < bodies.length; i += nodeIds.length) {
            const fileAppend = /** @type {proto.IFileAppendTransactionBody} */ (
                bodies[i].fileAppend
            );
            if (fileAppend.contents == null) {
                break;
            }

            if (contents == null) {
                contents = new Uint8Array(
                    /** @type {Uint8Array} */ (fileAppend.contents)
                );
                continue;
            }

            /** @type {Uint8Array} */
            const concat = new Uint8Array(
                contents.length +
                    /** @type {Uint8Array} */ (fileAppend.contents).length
            );
            concat.set(contents, 0);
            concat.set(
                /** @type {Uint8Array} */ (fileAppend.contents),
                contents.length
            );
            contents = concat;
        }

        return Transaction._fromProtobufTransactions(
            new FileAppendTransaction({
                fileId:
                    append.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {proto.IFileID} */ (append.fileID)
                          )
                        : undefined,
                contents: contents,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @param {TransactionId} transactionId
     * @returns {this}
     */
    setTransactionId(transactionId) {
        this._requireNotFrozen();

        if (
            transactionId.accountId == null ||
            transactionId.validStart == null
        ) {
            throw new Error(
                "`FileAppendTransaction` does not support `TransactionId` built from `nonce`"
            );
        }

        this._transactionIds.setList([transactionId]);

        return this;
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the keys which must sign any transactions modifying this file. Required.
     *
     * All keys must sign to modify the file's contents or keys. No key is required
     * to sign for extending the expiration time (except the one for the operator account
     * paying for the transaction). Only one key must sign to delete the file, however.
     *
     * To require more than one key to sign to delete a file, add them to a
     * KeyList and pass that here.
     *
     * The network currently requires a file to have at least one key (or key list or threshold key)
     * but this requirement may be lifted in the future.
     *
     * @param {FileId | string} fileId
     * @returns {this}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get contents() {
        return this._contents;
    }

    /**
     * Set the given byte array as the file's contents.
     *
     * This may be omitted to append an empty file.
     *
     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a HederaPreCheckStatusException
     * with Status#TransactionOversize.
     *
     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
     * transaction with the first chunk and then use FileAppendTransaction with
     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
     *
     * @param {Uint8Array | string} contents
     * @returns {this}
     */
    setContents(contents) {
        this._requireNotFrozen();
        this._contents =
            contents instanceof Uint8Array ? contents : encode(contents);

        return this;
    }

    /**
     * @returns {?number}
     */
    get maxChunks() {
        return this._maxChunks;
    }

    /**
     * @param {number} maxChunks
     * @returns {this}
     */
    setMaxChunks(maxChunks) {
        this._requireNotFrozen();
        this._maxChunks = maxChunks;
        return this;
    }

    /**
     * @returns {?number}
     */
    get chunkSize() {
        return this._chunkSize;
    }

    /**
     * @param {number} chunkSize
     * @returns {this}
     */
    setChunkSize(chunkSize) {
        this._chunkSize = chunkSize;
        return this;
    }

    /**
     * Freeze this transaction from further modification to prepare for
     * signing or serialization.
     *
     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
     * nodes to prepare this transaction for.
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client) {
        super.freezeWith(client);

        if (this._contents == null) {
            return this;
        }

        const chunks = Math.floor(
            (this._contents.length + (this._chunkSize - 1)) / this._chunkSize
        );

        if (chunks > this._maxChunks) {
            throw new Error(
                `Contents with size ${this._contents.length} too long for ${this._maxChunks} chunks`
            );
        }

        let nextTransactionId = this.transactionId;

        // Hack around the locked list. Should refactor a bit to remove such code
        this._transactionIds.locked = false;

        this._transactions.clear();
        this._transactionIds.clear();
        this._signedTransactions.clear();

        for (let chunk = 0; chunk < chunks; chunk++) {
            this._transactionIds.push(nextTransactionId);
            this._transactionIds.advance();

            for (const nodeAccountId of this._nodeAccountIds.list) {
                this._signedTransactions.push(
                    this._makeSignedTransaction(nodeAccountId)
                );
            }

            nextTransactionId = new TransactionId(
                /** @type {AccountId} */ (nextTransactionId.accountId),
                new Timestamp(
                    /** @type {Timestamp} */ (
                        nextTransactionId.validStart
                    ).seconds,
                    /** @type {Timestamp} */ (
                        nextTransactionId.validStart
                    ).nanos.add(1)
                )
            );
        }

        this._transactionIds.advance();
        this._transactionIds.setLocked();

        return this;
    }

    /**
     * @returns {ScheduleCreateTransaction}
     */
    schedule() {
        this._requireNotFrozen();

        if (this._contents != null && this._contents.length > this._chunkSize) {
            throw new Error(
                `cannot schedule \`FileAppendTransaction\` with message over ${this._chunkSize} bytes`
            );
        }

        return super.schedule();
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @param {number=} requestTimeout
     * @returns {Promise<TransactionResponse>}
     */
    async execute(client, requestTimeout) {
        return (await this.executeAll(client, requestTimeout))[0];
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @param {number=} requestTimeout
     * @returns {Promise<TransactionResponse[]>}
     */
    async executeAll(client, requestTimeout) {
        if (!super._isFrozen()) {
            this.freezeWith(client);
        }

        // on execute, sign each transaction with the operator, if present
        // and we are signing a transaction that used the default transaction ID

        const transactionId = this.transactionId;
        const operatorAccountId = client.operatorAccountId;

        if (
            operatorAccountId != null &&
            operatorAccountId.equals(
                /** @type {AccountId} */ (transactionId.accountId)
            )
        ) {
            await super.signWithOperator(client);
        }

        const responses = [];
        let remainingTimeout = requestTimeout;

        for (let i = 0; i < this._transactionIds.length; i++) {
            const startTimestamp = Date.now();
            const response = await super.execute(client, remainingTimeout);

            if (remainingTimeout != null) {
                remainingTimeout = Date.now() - startTimestamp;
            }

            await response.getReceipt(client);
            responses.push(response);
        }

        return responses;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.file.appendContent(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "fileAppend";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IFileAppendTransactionBody}
     */
    _makeTransactionData() {
        const length = this._contents != null ? this._contents.length : 0;
        const startIndex = this._transactionIds.index * this._chunkSize;
        const endIndex = Math.min(startIndex + this._chunkSize, length);

        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
            contents:
                this._contents != null
                    ? this._contents.slice(startIndex, endIndex)
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FileAppendTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("fileAppend", FileAppendTransaction._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFileDeleteTransactionBody} proto.IFileDeleteTransactionBody
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * A transaction to delete a file on the Hedera network.
 *
 * When deleted, a file's contents are truncated to zero length and it can no longer be updated
 * or appended to, or its expiration time extended. FileContentsQuery and FileInfoQuery
 * will throw HederaPreCheckStatusException with a status of Status#FileDeleted.
 *
 * Only one of the file's keys needs to sign to delete the file, unless the key you have is part
 * of a KeyList.
 */
class FileDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {FileDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const fileDelete = /** @type {proto.IFileDeleteTransactionBody} */ (
            body.fileDelete
        );

        return Transaction._fromProtobufTransactions(
            new FileDeleteTransaction({
                fileId:
                    fileDelete.fileID != null
                        ? FileId._fromProtobuf(fileDelete.fileID)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the file ID which is being deleted in this transaction.
     *
     * @param {FileId | string} fileId
     * @returns {FileDeleteTransaction}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.file.deleteFile(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "fileDelete";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IFileDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FileDeleteTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("fileDelete", FileDeleteTransaction._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IContractCreateTransactionBody} proto.IContractCreateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

class ContractCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.bytecodeFileId]
     * @param {Key} [props.adminKey]
     * @param {number | Long} [props.gas]
     * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
     * @param {AccountId | string} [props.proxyAccountId]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {Uint8Array} [props.constructorParameters]
     * @param {string} [props.contractMemo]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._bytecodeFileId = null;

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Long}
         */
        this._gas = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._initialBalance = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._proxyAccountId = null;

        /**
         * @private
         * @type {Duration}
         */
        this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._constructorParameters = null;

        /**
         * @private
         * @type {?string}
         */
        this._contractMemo = null;

        this._defaultMaxTransactionFee = new Hbar(20);

        if (props.bytecodeFileId != null) {
            this.setBytecodeFileId(props.bytecodeFileId);
        }

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.gas != null) {
            this.setGas(props.gas);
        }

        if (props.initialBalance != null) {
            this.setInitialBalance(props.initialBalance);
        }

        if (props.proxyAccountId != null) {
            this.setProxyAccountId(props.proxyAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.constructorParameters != null) {
            this.setConstructorParameters(props.constructorParameters);
        }

        if (props.contractMemo != null) {
            this.setContractMemo(props.contractMemo);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {ContractCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const create = /** @type {proto.IContractCreateTransactionBody} */ (
            body.contractCreateInstance
        );

        return Transaction._fromProtobufTransactions(
            new ContractCreateTransaction({
                bytecodeFileId:
                    create.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {proto.IFileID} */ (create.fileID)
                          )
                        : undefined,
                adminKey:
                    create.adminKey != null
                        ? Key._fromProtobufKey(create.adminKey)
                        : undefined,
                gas: create.gas != null ? create.gas : undefined,
                initialBalance:
                    create.initialBalance != null
                        ? create.initialBalance
                        : undefined,
                proxyAccountId:
                    create.proxyAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {proto.IAccountID} */ (
                                  create.proxyAccountID
                              )
                          )
                        : undefined,
                autoRenewPeriod:
                    create.autoRenewPeriod != null
                        ? create.autoRenewPeriod.seconds != null
                            ? create.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                constructorParameters:
                    create.constructorParameters != null
                        ? create.constructorParameters
                        : undefined,
                contractMemo: create.memo != null ? create.memo : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?FileId}
     */
    get bytecodeFileId() {
        return this._bytecodeFileId;
    }

    /**
     * @param {FileId | string} bytecodeFileId
     * @returns {this}
     */
    setBytecodeFileId(bytecodeFileId) {
        this._requireNotFrozen();
        this._bytecodeFileId =
            typeof bytecodeFileId === "string"
                ? FileId.fromString(bytecodeFileId)
                : bytecodeFileId.clone();

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} adminKey
     * @returns {this}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get gas() {
        return this._gas;
    }

    /**
     * @param {number | Long} gas
     * @returns {this}
     */
    setGas(gas) {
        this._requireNotFrozen();
        this._gas = gas instanceof long ? gas : long.fromValue(gas);

        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get initialBalance() {
        return this._initialBalance;
    }

    /**
     * Set the initial amount to transfer into this contract.
     *
     * @param {number | string | Long | BigNumber | Hbar} initialBalance
     * @returns {this}
     */
    setInitialBalance(initialBalance) {
        this._requireNotFrozen();
        this._initialBalance =
            initialBalance instanceof Hbar
                ? initialBalance
                : new Hbar(initialBalance);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get proxyAccountId() {
        return this._proxyAccountId;
    }

    /**
     * @param {AccountId | string} proxyAccountId
     * @returns {this}
     */
    setProxyAccountId(proxyAccountId) {
        this._requireNotFrozen();
        this._proxyAccountId =
            proxyAccountId instanceof AccountId
                ? proxyAccountId
                : AccountId.fromString(proxyAccountId);

        return this;
    }

    /**
     * @returns {Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get constructorParameters() {
        return this._constructorParameters;
    }

    /**
     * @param {Uint8Array | ContractFunctionParameters} constructorParameters
     * @returns {this}
     */
    setConstructorParameters(constructorParameters) {
        this._requireNotFrozen();
        this._constructorParameters =
            constructorParameters instanceof ContractFunctionParameters$1
                ? constructorParameters._build()
                : constructorParameters;

        return this;
    }

    /**
     * @returns {?string}
     */
    get contractMemo() {
        return this._contractMemo;
    }

    /**
     * @param {string} contractMemo
     * @returns {this}
     */
    setContractMemo(contractMemo) {
        this._requireNotFrozen();
        this._contractMemo = contractMemo;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._bytecodeFileId != null) {
            this._bytecodeFileId.validateChecksum(client);
        }

        if (this._proxyAccountId != null) {
            this._proxyAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.createContract(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "contractCreateInstance";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IContractCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID:
                this._bytecodeFileId != null
                    ? this._bytecodeFileId._toProtobuf()
                    : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            gas: this._gas,
            initialBalance:
                this._initialBalance != null
                    ? this._initialBalance.toTinybars()
                    : null,
            proxyAccountID:
                this._proxyAccountId != null
                    ? this._proxyAccountId._toProtobuf()
                    : null,
            autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
            constructorParameters: this._constructorParameters,
            memo: this._contractMemo,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ContractCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "contractCreateInstance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ContractCreateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IContractDeleteTransactionBody} proto.IContractDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

class ContractDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {ContractId | string} [props.contractId]
     * @param {ContractId | string} [props.transferContractId]
     * @param {AccountId | string} [props.transferAccountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._transferAccountId = null;

        /**
         * @private
         * @type {?ContractId}
         */
        this._transferContractId = null;

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        if (props.transferAccountId != null) {
            this.setTransferAccountId(props.transferAccountId);
        }

        if (props.transferContractId != null) {
            this.setTransferContractId(props.transferContractId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {ContractDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const contractDelete =
            /** @type {proto.IContractDeleteTransactionBody} */ (
                body.contractDeleteInstance
            );

        return Transaction._fromProtobufTransactions(
            new ContractDeleteTransaction({
                contractId:
                    contractDelete.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {proto.IContractID} */ (
                                  contractDelete.contractID
                              )
                          )
                        : undefined,
                transferAccountId:
                    contractDelete.transferAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {proto.IAccountID} */ (
                                  contractDelete.transferAccountID
                              )
                          )
                        : undefined,
                transferContractId:
                    contractDelete.transferContractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {proto.IContractID} */ (
                                  contractDelete.transferContractID
                              )
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Sets the contract ID which is being deleted in this transaction.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractDeleteTransaction}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @returns {?ContractId}
     */
    get transferContractId() {
        return this._transferContractId;
    }

    /**
     * Sets the contract ID which will receive all remaining hbars.
     *
     * @param {ContractId | string} transferContractId
     * @returns {ContractDeleteTransaction}
     */
    setTransferContractId(transferContractId) {
        this._requireNotFrozen();
        this._transferContractId =
            transferContractId instanceof ContractId
                ? transferContractId
                : ContractId.fromString(transferContractId);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get transferAccountId() {
        return this._transferAccountId;
    }

    /**
     * Sets the account ID which will receive all remaining hbars.
     *
     * @param {AccountId | string} transferAccountId
     * @returns {ContractDeleteTransaction}
     */
    setTransferAccountId(transferAccountId) {
        this._requireNotFrozen();
        this._transferAccountId =
            transferAccountId instanceof AccountId
                ? transferAccountId
                : AccountId.fromString(transferAccountId);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }

        if (this._transferAccountId != null) {
            this._transferAccountId.validateChecksum(client);
        }

        if (this._transferContractId != null) {
            this._transferContractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.deleteContract(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "contractDeleteInstance";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IContractDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
            transferAccountID: this._transferAccountId
                ? this._transferAccountId._toProtobuf()
                : null,
            transferContractID:
                this._transferContractId != null
                    ? this._transferContractId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ContractDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "contractDeleteInstance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ContractDeleteTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IContractCallTransactionBody} proto.IContractCallTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} FunctionParameters
 * @property {string} name
 * @property {ContractFunctionParameters} parameters
 */

class ContractExecuteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {ContractId | string} [props.contractId]
     * @param {number | Long} [props.gas]
     * @param {number | string | Long | BigNumber | Hbar} [props.amount]
     * @param {Uint8Array} [props.functionParameters]
     * @param {FunctionParameters} [props.function]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._gas = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._amount = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._functionParameters = null;

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        if (props.gas != null) {
            this.setGas(props.gas);
        }

        if (props.amount != null) {
            this.setPayableAmount(props.amount);
        }

        if (props.functionParameters != null) {
            this.setFunctionParameters(props.functionParameters);
        } else if (props.function != null) {
            this.setFunction(props.function.name, props.function.parameters);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {ContractExecuteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const call = /** @type {proto.IContractCallTransactionBody} */ (
            body.contractCall
        );

        return Transaction._fromProtobufTransactions(
            new ContractExecuteTransaction({
                contractId:
                    call.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {proto.IContractID} */ (call.contractID)
                          )
                        : undefined,
                gas: call.gas != null ? call.gas : undefined,
                amount: call.amount ? call.amount : undefined,
                functionParameters:
                    call.functionParameters != null
                        ? call.functionParameters
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Sets the contract ID which is being executed in this transaction.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractExecuteTransaction}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get gas() {
        return this._gas;
    }

    /**
     * Sets the contract ID which is being executed in this transaction.
     *
     * @param {number | Long} gas
     * @returns {ContractExecuteTransaction}
     */
    setGas(gas) {
        this._requireNotFrozen();
        this._gas = gas instanceof long ? gas : long.fromValue(gas);

        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get payableAmount() {
        return this._amount;
    }

    /**
     * Sets the contract ID which is being executed in this transaction.
     *
     * @param {number | string | Long | BigNumber | Hbar} amount
     * @returns {ContractExecuteTransaction}
     */
    setPayableAmount(amount) {
        this._requireNotFrozen();
        this._amount = amount instanceof Hbar ? amount : new Hbar(amount);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get functionParameters() {
        return this._functionParameters;
    }

    /**
     * @param {Uint8Array} functionParameters
     * @returns {this}
     */
    setFunctionParameters(functionParameters) {
        this._requireNotFrozen();
        this._functionParameters = functionParameters;

        return this;
    }

    /**
     * @param {string} name
     * @param {ContractFunctionParameters} [functionParameters]
     * @returns {this}
     */
    setFunction(name, functionParameters) {
        this._requireNotFrozen();
        this._functionParameters =
            functionParameters != null
                ? functionParameters._build(name)
                : new ContractFunctionParameters$1()._build(name);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.contractCallMethod(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "contractCall";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IContractCallTransactionBody}
     */
    _makeTransactionData() {
        return {
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
            gas: this._gas,
            amount: this._amount != null ? this._amount.toTinybars() : null,
            functionParameters: this._functionParameters,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ContractExecuteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "contractCall",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ContractExecuteTransaction._fromProtobuf
);

/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
class ContractInfo {
    /**
     * @private
     * @param {object} props
     * @param {ContractId} props.contractId
     * @param {AccountId} props.accountId
     * @param {string} props.contractAccountId
     * @param {?Key} props.adminKey
     * @param {Timestamp} props.expirationTime
     * @param {Duration} props.autoRenewPeriod
     * @param {Long} props.storage
     * @param {string} props.contractMemo
     * @param {Hbar} props.balance
     * @param {boolean} props.isDeleted
     * @param {TokenRelationshipMap} props.tokenRelationships
     * @param {LedgerId|null} props.ledgerId
     */
    constructor(props) {
        /**
         * ID of the contract instance, in the format used in transactions.
         *
         * @readonly
         */
        this.contractId = props.contractId;

        /**
         * ID of the cryptocurrency account owned by the contract instance,
         * in the format used in transactions.
         *
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * ID of both the contract instance and the cryptocurrency account owned by the contract
         * instance, in the format used by Solidity.
         *
         * @readonly
         */
        this.contractAccountId = props.contractAccountId;

        /**
         * The state of the instance and its fields can be modified arbitrarily if this key signs a
         * transaction to modify it. If this is null, then such modifications are not possible,
         * and there is no administrator that can override the normal operation of this smart
         * contract instance. Note that if it is created with no admin keys, then there is no
         * administrator to authorize changing the admin keys, so there can never be any admin keys
         * for that instance.
         *
         * @readonly
         */
        this.adminKey = props.adminKey != null ? props.adminKey : null;

        /**
         * The current time at which this contract instance (and its account) is set to expire.
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * The expiration time will extend every this many seconds. If there are insufficient funds,
         * then it extends as long as possible. If the account is empty when it expires,
         * then it is deleted.
         *
         * @readonly
         */
        this.autoRenewPeriod = props.autoRenewPeriod;

        /**
         * Number of bytes of storage being used by this instance (which affects the cost to
         * extend the expiration time).
         *
         * @readonly
         */
        this.storage = props.storage;

        /**
         * The memo associated with the contract (max 100 bytes).
         *
         * @readonly
         */
        this.contractMemo = props.contractMemo;

        /**
         * The current balance of the contract.
         *
         * @readonly
         */
        this.balance = props.balance;

        /**
         * Whether the contract has been deleted
         *
         * @readonly
         */
        this.isDeleted = props.isDeleted;

        /**
         * The tokens associated to the contract
         *
         * @readonly
         */
        this.tokenRelationships = props.tokenRelationships;

        this.ledgerId = props.ledgerId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.IContractInfo} info
     * @returns {ContractInfo}
     */
    static _fromProtobuf(info) {
        const autoRenewPeriod = /** @type {Long | number} */ (
            /** @type {proto.IDuration} */ (info.autoRenewPeriod).seconds
        );

        return new ContractInfo({
            contractId: ContractId._fromProtobuf(
                /** @type {proto.IContractID} */ (info.contractID)
            ),
            accountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (info.accountID)
            ),
            contractAccountId:
                info.contractAccountID != null ? info.contractAccountID : "",
            adminKey:
                info.adminKey != null
                    ? Key._fromProtobufKey(info.adminKey)
                    : null,
            expirationTime: Timestamp._fromProtobuf(
                /** @type {proto.ITimestamp} */ (info.expirationTime)
            ),
            autoRenewPeriod: new Duration(autoRenewPeriod),
            storage:
                info.storage != null
                    ? info.storage instanceof long
                        ? info.storage
                        : long.fromValue(info.storage)
                    : long.ZERO,
            contractMemo: info.memo != null ? info.memo : "",
            balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
            isDeleted: /** @type {boolean} */ (info.deleted),
            tokenRelationships: TokenRelationshipMap._fromProtobuf(
                info.tokenRelationships != null ? info.tokenRelationships : []
            ),
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
        });
    }

    /**
     * @internal
     * @returns {proto.IContractInfo}
     */
    _toProtobuf() {
        return {
            contractID: this.contractId._toProtobuf(),
            accountID: this.accountId._toProtobuf(),
            contractAccountID: this.contractAccountId,
            adminKey:
                this.adminKey != null ? this.adminKey._toProtobufKey() : null,
            expirationTime: this.expirationTime._toProtobuf(),
            autoRenewPeriod:
                this.autoRenewPeriod != null
                    ? this.autoRenewPeriod._toProtobuf()
                    : null,
            storage: this.storage,
            memo: this.contractMemo,
            balance: this.balance.toTinybars(),
            deleted: this.isDeleted,
            tokenRelationships:
                this.tokenRelationships != null
                    ? this.tokenRelationships._toProtobuf()
                    : null,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {ContractInfo}
     */
    static fromBytes(bytes) {
        return ContractInfo._fromProtobuf(
            lib.ContractGetInfoResponse.ContractInfo.decode(bytes)
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.ContractGetInfoResponse.ContractInfo.encode(
            this._toProtobuf()
        ).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IContractGetInfoQuery} proto.IContractGetInfoQuery
 * @typedef {import("@hashgraph/proto").IContractGetInfoResponse} proto.IContractGetInfoResponse
 * @typedef {import("@hashgraph/proto").IContractInfo} proto.IContractInfo
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<ContractInfo>}
 */
class ContractInfoQuery extends Query {
    /**
     * @param {object} [props]
     * @param {ContractId | string} [props.contractId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?ContractId}
         * @private
         */
        this._contractId = null;
        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {ContractInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {proto.IContractGetInfoQuery} */ (
            query.contractGetInfo
        );

        return new ContractInfoQuery({
            contractId:
                info.contractID != null
                    ? ContractId._fromProtobuf(info.contractID)
                    : undefined,
        });
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Set the contract ID for which the info is being requested.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractInfoQuery}
     */
    setContractId(contractId) {
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.getContractInfo(request);
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        let cost = await super.getCost(client);

        if (cost.toTinybars().greaterThan(25)) {
            return cost;
        } else {
            return Hbar.fromTinybars(25);
        }
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const contractGetInfo = /** @type {proto.IContractGetInfoResponse} */ (
            response.contractGetInfo
        );
        return /** @type {proto.IResponseHeader} */ (contractGetInfo.header);
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<ContractInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {proto.IContractGetInfoResponse} */ (
            response.contractGetInfo
        );

        return Promise.resolve(
            ContractInfo._fromProtobuf(
                /** @type {proto.IContractInfo} */ (info.contractInfo)
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            contractGetInfo: {
                header,
                contractID:
                    this._contractId != null
                        ? this._contractId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `ContractInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("contractGetInfo", ContractInfoQuery._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IContractUpdateTransactionBody} proto.IContractUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

class ContractUpdateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {ContractId | string} [props.contractId]
     * @param {FileId | string} [props.bytecodeFileId]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Key} [props.adminKey]
     * @param {AccountId | string} [props.proxyAccountId]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {string} [props.contractMemo]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._proxyAccountId = null;

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = null;

        /**
         * @private
         * @type {?FileId}
         */
        this._bytecodeFileId = null;

        /**
         * @private
         * @type {?string}
         */
        this._contractMemo = null;

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.proxyAccountId != null) {
            this.setProxyAccountId(props.proxyAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.bytecodeFileId != null) {
            this.setBytecodeFileId(props.bytecodeFileId);
        }

        if (props.contractMemo != null) {
            this.setContractMemo(props.contractMemo);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {ContractUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const update = /** @type {proto.IContractUpdateTransactionBody} */ (
            body.contractUpdateInstance
        );

        let autoRenewPeriod = undefined;
        if (
            update.autoRenewPeriod != null &&
            update.autoRenewPeriod.seconds != null
        ) {
            autoRenewPeriod = update.autoRenewPeriod.seconds;
        }

        let contractMemo = undefined;
        if (update.memoWrapper != null && update.memoWrapper.value != null) {
            contractMemo = update.memoWrapper.value;
        }

        return Transaction._fromProtobufTransactions(
            new ContractUpdateTransaction({
                contractId:
                    update.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {proto.IContractID} */ (
                                  update.contractID
                              )
                          )
                        : undefined,
                bytecodeFileId:
                    update.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {proto.IFileID} */ (update.fileID)
                          )
                        : undefined,
                expirationTime:
                    update.expirationTime != null
                        ? Timestamp._fromProtobuf(update.expirationTime)
                        : undefined,
                adminKey:
                    update.adminKey != null
                        ? Key._fromProtobufKey(update.adminKey)
                        : undefined,
                proxyAccountId:
                    update.proxyAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {proto.IAccountID} */ (
                                  update.proxyAccountID
                              )
                          )
                        : undefined,
                autoRenewPeriod,
                contractMemo,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Sets the contract ID which is being deleted in this transaction.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractUpdateTransaction}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * Sets the contract ID which is being deleted in this transaction.
     *
     * @param {Timestamp | Date} expirationTime
     * @returns {ContractUpdateTransaction}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime =
            expirationTime instanceof Timestamp
                ? expirationTime
                : Timestamp.fromDate(expirationTime);

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} adminKey
     * @returns {this}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get proxyAccountId() {
        return this._proxyAccountId;
    }

    /**
     * @param {AccountId | string} proxyAccountId
     * @returns {this}
     */
    setProxyAccountId(proxyAccountId) {
        this._requireNotFrozen();
        this._proxyAccountId =
            typeof proxyAccountId === "string"
                ? AccountId.fromString(proxyAccountId)
                : proxyAccountId.clone();

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?FileId}
     */
    get bytecodeFileId() {
        return this._bytecodeFileId;
    }

    /**
     * @param {FileId | string} bytecodeFileId
     * @returns {this}
     */
    setBytecodeFileId(bytecodeFileId) {
        console.warn("Deprecated: there is no replacement");
        this._requireNotFrozen();
        this._bytecodeFileId =
            typeof bytecodeFileId === "string"
                ? FileId.fromString(bytecodeFileId)
                : bytecodeFileId.clone();

        return this;
    }

    /**
     * @returns {?string}
     */
    get contractMemo() {
        return this._contractMemo;
    }

    /**
     * @param {string} contractMemo
     * @returns {this}
     */
    setContractMemo(contractMemo) {
        this._requireNotFrozen();
        this._contractMemo = contractMemo;

        return this;
    }

    /**
     * @returns {this}
     */
    clearContractMemo() {
        this._requireNotFrozen();
        this._contractMemo = null;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }

        if (this._bytecodeFileId != null) {
            this._bytecodeFileId.validateChecksum(client);
        }

        if (this._proxyAccountId != null) {
            this._proxyAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.updateContract(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "contractUpdateInstance";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IContractUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            proxyAccountID:
                this._proxyAccountId != null
                    ? this._proxyAccountId._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
            fileID: this._bytecodeFileId
                ? this._bytecodeFileId._toProtobuf()
                : null,
            memoWrapper:
                this._contractMemo != null
                    ? {
                          value: this._contractMemo,
                      }
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ContractUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "contractUpdateInstance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ContractUpdateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ICustomFee} proto.ICustomFee
 */

class CustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     */
    constructor(props = {}) {
        /**
         * @type {?AccountId}
         */
        this._feeCollectorAccountId;

        if (props.feeCollectorAccountId != null) {
            this.setFeeCollectorAccountId(props.feeCollectorAccountId);
        }
    }

    /**
     * @returns {?AccountId}
     */
    get feeCollectorAccountId() {
        return this._feeCollectorAccountId;
    }

    /**
     * @param {AccountId | string} feeCollectorAccountId
     * @returns {this}
     */
    setFeeCollectorAccountId(feeCollectorAccountId) {
        this._feeCollectorAccountId =
            typeof feeCollectorAccountId === "string"
                ? AccountId.fromString(feeCollectorAccountId)
                : feeCollectorAccountId;
        return this;
    }

    /**
     * @internal
     * @abstract
     * @param {proto.ICustomFee} info
     * @returns {CustomFee}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(info) {
        throw new Error("not implemented");
    }

    /**
     * @internal
     * @abstract
     * @returns {proto.ICustomFee}
     */
    _toProtobuf() {
        throw new Error("not implemented");
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ICustomFee} proto.ICustomFee
 * @typedef {import("@hashgraph/proto").IFixedFee} proto.IFixedFee
 */

class CustomFixedFee extends CustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     * @param {TokenId | string} [props.denominatingTokenId]
     * @param {Long | number} [props.amount]
     */
    constructor(props = {}) {
        super(props);

        /**
         * @type {?TokenId}
         */
        this._denominatingTokenId;

        if (props.denominatingTokenId != null) {
            this.setDenominatingTokenId(props.denominatingTokenId);
        }

        /**
         * @type {?Long}
         */
        this._amount;

        if (props.amount != null) {
            this.setAmount(props.amount);
        }
    }

    /**
     * @param {Hbar} amount
     * @returns {CustomFixedFee}
     */
    setHbarAmount(amount) {
        this._amount = amount.toTinybars();
        this._denominatingTokenId = null;
        return this;
    }

    /**
     * @returns {TokenId | Hbar | null}
     */
    get hbarAmount() {
        return this._denominatingTokenId != null
            ? null
            : Hbar.fromTinybars(this._amount != null ? this._amount : 0);
    }

    /**
     * @returns {CustomFixedFee}
     */
    setDenominatingTokenToSameToken() {
        this._denominatingTokenId = new TokenId(0, 0, 0);
        return this;
    }

    /**
     * @returns {?TokenId}
     */
    get denominatingTokenId() {
        return this._denominatingTokenId;
    }

    /**
     * @param {TokenId | string} denominatingTokenId
     * @returns {CustomFixedFee}
     */
    setDenominatingTokenId(denominatingTokenId) {
        this._denominatingTokenId =
            typeof denominatingTokenId === "string"
                ? TokenId.fromString(denominatingTokenId)
                : denominatingTokenId;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {CustomFixedFee}
     */
    setAmount(amount) {
        this._amount =
            typeof amount === "number" ? long.fromNumber(amount) : amount;
        return this;
    }

    /**
     * @internal
     * @override
     * @param {proto.ICustomFee} info
     * @returns {CustomFee}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(info) {
        const fee = /** @type {proto.IFixedFee} */ (info.fixedFee);

        return new CustomFixedFee({
            feeCollectorAccountId:
                info.feeCollectorAccountId != null
                    ? AccountId._fromProtobuf(info.feeCollectorAccountId)
                    : undefined,
            denominatingTokenId:
                fee.denominatingTokenId != null
                    ? TokenId._fromProtobuf(fee.denominatingTokenId)
                    : undefined,
            amount: fee.amount != null ? fee.amount : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {proto.ICustomFee}
     */
    _toProtobuf() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId != null
                    ? this.feeCollectorAccountId._toProtobuf()
                    : null,
            fixedFee: {
                denominatingTokenId:
                    this._denominatingTokenId != null
                        ? this._denominatingTokenId._toProtobuf()
                        : null,
                amount: this._amount,
            },
        };
    }
}

/**
 * @typedef {import("./FeeAssessmentMethod.js").default} FeeAssessmentMethod
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ICustomFee} proto.ICustomFee
 * @typedef {import("@hashgraph/proto").IFractionalFee} proto.IFractionalFee
 * @typedef {import("@hashgraph/proto").IFraction} proto.IFraction
 */

class CustomFractionalFee extends CustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     * @param {Long | number} [props.numerator]
     * @param {Long | number} [props.denominator]
     * @param {Long | number} [props.min]
     * @param {Long | number} [props.max]
     * @param {FeeAssessmentMethod} [props.assessmentMethod]
     */
    constructor(props = {}) {
        super(props);

        /**
         * @type {?Long}
         */
        this._numerator;

        if (props.numerator != null) {
            this.setNumerator(props.numerator);
        }

        /**
         * @type {?Long}
         */
        this._denominator;

        if (props.denominator != null) {
            this.setDenominator(props.denominator);
        }

        /**
         * @type {?Long}
         */
        this._min;

        if (props.min != null) {
            this.setMin(props.min);
        }

        /**
         * @type {?Long}
         */
        this._max;

        if (props.max != null) {
            this.setMax(props.max);
        }

        /**
         * @type {?FeeAssessmentMethod}
         */
        this._assessmentMethod;

        if (props.assessmentMethod != null) {
            this.setAssessmentMethod(props.assessmentMethod);
        }
    }

    /**
     * @returns {?Long}
     */
    get numerator() {
        return this._numerator;
    }

    /**
     * @param {Long | number} numerator
     * @returns {CustomFractionalFee}
     */
    setNumerator(numerator) {
        this._numerator =
            typeof numerator === "number"
                ? long.fromNumber(numerator)
                : numerator;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get denominator() {
        return this._denominator;
    }

    /**
     * @param {Long | number} denominator
     * @returns {CustomFractionalFee}
     */
    setDenominator(denominator) {
        this._denominator =
            typeof denominator === "number"
                ? long.fromNumber(denominator)
                : denominator;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get min() {
        return this._min;
    }

    /**
     * @param {Long | number} min
     * @returns {CustomFractionalFee}
     */
    setMin(min) {
        this._min = typeof min === "number" ? long.fromNumber(min) : min;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get max() {
        return this._max;
    }

    /**
     * @param {Long | number} max
     * @returns {CustomFractionalFee}
     */
    setMax(max) {
        this._max = typeof max === "number" ? long.fromNumber(max) : max;
        return this;
    }

    /**
     * @returns {?FeeAssessmentMethod}
     */
    get assessmentMethod() {
        return this._assessmentMethod;
    }

    /**
     * @param {FeeAssessmentMethod} assessmentMethod
     * @returns {CustomFractionalFee}
     */
    setAssessmentMethod(assessmentMethod) {
        this._assessmentMethod = assessmentMethod;
        return this;
    }

    /**
     * @internal
     * @override
     * @param {proto.ICustomFee} info
     * @returns {CustomFee}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(info) {
        const fee = /** @type {proto.IFractionalFee} */ (info.fractionalFee);
        const fractional = /** @type {proto.IFraction} */ (
            fee.fractionalAmount
        );

        return new CustomFractionalFee({
            feeCollectorAccountId:
                info.feeCollectorAccountId != null
                    ? AccountId._fromProtobuf(info.feeCollectorAccountId)
                    : undefined,
            numerator:
                fractional.numerator != null ? fractional.numerator : undefined,
            denominator:
                fractional.denominator != null
                    ? fractional.denominator
                    : undefined,
            min: fee.minimumAmount != null ? fee.minimumAmount : undefined,
            max: fee.maximumAmount != null ? fee.maximumAmount : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {proto.ICustomFee}
     */
    _toProtobuf() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId != null
                    ? this.feeCollectorAccountId._toProtobuf()
                    : null,
            fractionalFee: {
                fractionalAmount: {
                    numerator: this._numerator,
                    denominator: this._denominator,
                },
                minimumAmount: this._min,
                maximumAmount: this._max,
            },
        };
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IFraction} proto.IFraction
 * @typedef {import("@hashgraph/proto").IRoyaltyFee} proto.IRoyaltyFee
 * @typedef {import("@hashgraph/proto").ICustomFee} proto.ICustomFee
 * @typedef {import("@hashgraph/proto").IFixedFee} proto.IFixedFee
 */

class CustomRoyalyFee extends CustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     * @param {Long | number} [props.numerator]
     * @param {Long | number} [props.denominator]
     * @param {CustomFixedFee} [props.fallbackFee]
     */
    constructor(props = {}) {
        super(props);

        /**
         * @type {?CustomFixedFee}
         */
        this._fallbackFee;

        if (props.fallbackFee != null) {
            this.setFallbackFee(props.fallbackFee);
        }

        /**
         * @type {?Long}
         */
        this._numerator;

        if (props.numerator != null) {
            this.setNumerator(props.numerator);
        }

        /**
         * @type {?Long}
         */
        this._denominator;

        if (props.denominator != null) {
            this.setDenominator(props.denominator);
        }
    }

    /**
     * @returns {?CustomFixedFee}
     */
    get fallbackFee() {
        return this._fallbackFee;
    }

    /**
     * @param {CustomFixedFee} fallbackFee
     * @returns {CustomRoyalyFee}
     */
    setFallbackFee(fallbackFee) {
        this._fallbackFee = fallbackFee;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get numerator() {
        return this._numerator;
    }

    /**
     * @param {Long | number} numerator
     * @returns {CustomRoyalyFee}
     */
    setNumerator(numerator) {
        this._numerator =
            typeof numerator === "number"
                ? long.fromNumber(numerator)
                : numerator;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get denominator() {
        return this._denominator;
    }

    /**
     * @param {Long | number} denominator
     * @returns {CustomRoyalyFee}
     */
    setDenominator(denominator) {
        this._denominator =
            typeof denominator === "number"
                ? long.fromNumber(denominator)
                : denominator;
        return this;
    }

    /**
     * @internal
     * @override
     * @param {proto.ICustomFee} info
     * @returns {CustomFee}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(info) {
        const fee = /** @type {proto.IRoyaltyFee} */ (info.royaltyFee);
        const fraction = /** @type {proto.IFraction} */ (
            fee.exchangeValueFraction
        );

        return new CustomRoyalyFee({
            feeCollectorAccountId:
                info.feeCollectorAccountId != null
                    ? AccountId._fromProtobuf(info.feeCollectorAccountId)
                    : undefined,
            fallbackFee:
                fee.fallbackFee != null
                    ? /** @type {CustomFixedFee} */ (
                          CustomFixedFee._fromProtobuf({
                              fixedFee: fee.fallbackFee,
                          })
                      )
                    : undefined,
            numerator:
                fraction.numerator != null ? fraction.numerator : undefined,
            denominator:
                fraction.denominator != null ? fraction.denominator : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {proto.ICustomFee}
     */
    _toProtobuf() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId != null
                    ? this.feeCollectorAccountId._toProtobuf()
                    : null,
            royaltyFee: {
                exchangeValueFraction: {
                    numerator: this._numerator,
                    denominator: this._denominator,
                },
                fallbackFee:
                    this._fallbackFee != null
                        ? this._fallbackFee._toProtobuf().fixedFee
                        : null,
            },
        };
    }
}

/**
 * @namespace {proto}
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 */

/**
 * @typedef {import("long").Long} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

class DelegateContractId extends ContractId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     * @param {Uint8Array=} evmAddress
     */
    constructor(props, realm, num, evmAddress) {
        super(props, realm, num, evmAddress);
    }

    /**
     * @param {Long | number} shard
     * @param {Long | number} realm
     * @param {string} evmAddress
     * @returns {ContractId}
     */
    static fromEvmAddress(shard, realm, evmAddress) {
        return new DelegateContractId(shard, realm, 0, decode$1(evmAddress));
    }

    /**
     * @param {string} text
     * @returns {DelegateContractId}
     */
    static fromString(text) {
        return new DelegateContractId(ContractId.fromString(text));
    }

    /**
     * @internal
     * @param {proto.IContractID} id
     * @returns {DelegateContractId}
     */
    static _fromProtobuf(id) {
        return new DelegateContractId(ContractId._fromProtobuf(id));
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {DelegateContractId}
     */
    static fromBytes(bytes) {
        return new DelegateContractId(ContractId.fromBytes(bytes));
    }

    /**
     * @deprecated - Use `DelegateContractId.fromEvmAddress()` instead
     * @param {string} address
     * @returns {DelegateContractId}
     */
    static fromSolidityAddress(address) {
        // eslint-disable-next-line deprecation/deprecation
        return new DelegateContractId(ContractId.fromSolidityAddress(address));
    }

    /**
     * @returns {DelegateContractId}
     */
    clone() {
        const id = new DelegateContractId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @returns {proto.IKey}
     */
    _toProtobufKey() {
        return {
            delegatableContractId: this._toProtobuf(),
        };
    }

    /**
     * @param {proto.IContractID} key
     * @returns {DelegateContractId}
     */
    static __fromProtobufKey(key) {
        return DelegateContractId._fromProtobuf(key);
    }
}

CACHE.delegateContractId = (key) => DelegateContractId.__fromProtobufKey(key);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IFileGetContentsQuery} proto.IFileGetContentsQuery
 * @typedef {import("@hashgraph/proto").IFileGetContentsResponse} proto.IFileGetContentsResponse
 * @typedef {import("@hashgraph/proto").IFileContents} proto.IFileContents
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<Uint8Array>}
 */
class FileContentsQuery extends Query {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?FileId}
         * @private
         */
        this._fileId = null;
        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {FileContentsQuery}
     */
    static _fromProtobuf(query) {
        const contents = /** @type {proto.IFileGetContentsQuery} */ (
            query.fileGetContents
        );

        return new FileContentsQuery({
            fileId:
                contents.fileID != null
                    ? FileId._fromProtobuf(contents.fileID)
                    : undefined,
        });
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.file.getFileContent(request);
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the file ID for which the info is being requested.
     *
     * @param {FileId | string} fileId
     * @returns {FileContentsQuery}
     */
    setFileId(fileId) {
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const fileGetContents = /** @type {proto.IFileGetContentsResponse} */ (
            response.fileGetContents
        );
        return /** @type {proto.IResponseHeader} */ (fileGetContents.header);
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @returns {Promise<Uint8Array>}
     */
    _mapResponse(response) {
        const fileContentsResponse =
            /** @type {proto.IFileGetContentsResponse} */ (
                response.fileGetContents
            );
        const fileConents = /** @type {proto.IFileContents} */ (
            fileContentsResponse.fileContents
        );
        const contents = /** @type {Uint8Array} */ (fileConents.contents);

        return Promise.resolve(contents);
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            fileGetContents: {
                header,
                fileID:
                    this._fileId != null ? this._fileId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `FileContentsQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("fileGetContents", FileContentsQuery._fromProtobuf);

/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
class FileInfo {
    /**
     * @private
     * @param {object} props
     * @param {FileId} props.fileId
     * @param {Long} props.size
     * @param {Timestamp} props.expirationTime
     * @param {boolean} props.isDeleted
     * @param {KeyList} props.keys
     * @param {string} props.fileMemo
     * @param {LedgerId|null} props.ledgerId
     */
    constructor(props) {
        /**
         * The ID of the file for which information is requested.
         *
         * @readonly
         */
        this.fileId = props.fileId;

        /**
         * Number of bytes in contents.
         *
         * @readonly
         */
        this.size = props.size;

        /**
         * The current time at which this account is set to expire.
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * True if deleted but not yet expired.
         *
         * @readonly
         */
        this.isDeleted = props.isDeleted;

        /**
         * One of these keys must sign in order to delete the file.
         * All of these keys must sign in order to update the file.
         *
         * @readonly
         */
        this.keys = props.keys;

        this.fileMemo = props.fileMemo;

        this.ledgerId = props.ledgerId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.IFileInfo} info
     * @returns {FileInfo}
     */
    static _fromProtobuf(info) {
        const size = /** @type {Long | number} */ (info.size);

        return new FileInfo({
            fileId: FileId._fromProtobuf(
                /** @type {proto.IFileID} */ (info.fileID)
            ),
            size: size instanceof long ? size : long.fromValue(size),
            expirationTime: Timestamp._fromProtobuf(
                /** @type {proto.ITimestamp} */ (info.expirationTime)
            ),
            isDeleted: /** @type {boolean} */ (info.deleted),
            keys:
                info.keys != null
                    ? KeyList.__fromProtobufKeyList(info.keys)
                    : new KeyList(),
            fileMemo: info.memo != null ? info.memo : "",
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
        });
    }

    /**
     * @internal
     * @returns {proto.IFileInfo}
     */
    _toProtobuf() {
        return {
            fileID: this.fileId._toProtobuf(),
            size: this.size,
            expirationTime: this.expirationTime._toProtobuf(),
            deleted: this.isDeleted,
            keys: this.keys._toProtobufKey().keyList,
            memo: this.fileMemo,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {FileInfo}
     */
    static fromBytes(bytes) {
        return FileInfo._fromProtobuf(
            lib.FileGetInfoResponse.FileInfo.decode(bytes)
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.FileGetInfoResponse.FileInfo.encode(
            this._toProtobuf()
        ).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IFileGetInfoQuery} proto.IFileGetInfoQuery
 * @typedef {import("@hashgraph/proto").IFileGetInfoResponse} proto.IFileGetInfoResponse
 * @typedef {import("@hashgraph/proto").IFileInfo} proto.IFileInfo
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<FileInfo>}
 */
class FileInfoQuery extends Query {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?FileId}
         * @private
         */
        this._fileId = null;
        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {FileInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {proto.IFileGetInfoQuery} */ (query.fileGetInfo);

        return new FileInfoQuery({
            fileId:
                info.fileID != null
                    ? FileId._fromProtobuf(info.fileID)
                    : undefined,
        });
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the file ID for which the info is being requested.
     *
     * @param {FileId | string} fileId
     * @returns {FileInfoQuery}
     */
    setFileId(fileId) {
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        let cost = await super.getCost(client);

        if (cost.toTinybars().greaterThan(25)) {
            return cost;
        } else {
            return Hbar.fromTinybars(25);
        }
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.file.getFileInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const fileGetInfo = /** @type {proto.IFileGetInfoResponse} */ (
            response.fileGetInfo
        );
        return /** @type {proto.IResponseHeader} */ (fileGetInfo.header);
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<FileInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {proto.IFileGetInfoResponse} */ (
            response.fileGetInfo
        );

        return Promise.resolve(
            FileInfo._fromProtobuf(
                /** @type {proto.IFileInfo} */ (info.fileInfo)
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            fileGetInfo: {
                header,
                fileID:
                    this._fileId != null ? this._fileId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `FileInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("fileGetInfo", FileInfoQuery._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFileUpdateTransactionBody} proto.IFileUpdateTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Update a new Hedera crypto-currency file.
 */
class FileUpdateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {FileId | string} [props.fileId]
     * @param {Key[] | KeyList} [props.keys]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Uint8Array | string} [props.contents]
     * @param {string} [props.fileMemo]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?Key[]}
         */
        this._keys = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._contents = null;

        /**
         * @private
         * @type {?string}
         */
        this._fileMemo = null;

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.keys != null) {
            this.setKeys(props.keys);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.contents != null) {
            this.setContents(props.contents);
        }

        if (props.fileMemo != null) {
            this.setFileMemo(props.fileMemo);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {FileUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const update = /** @type {proto.IFileUpdateTransactionBody} */ (
            body.fileUpdate
        );

        return Transaction._fromProtobufTransactions(
            new FileUpdateTransaction({
                fileId:
                    update.fileID != null
                        ? FileId._fromProtobuf(update.fileID)
                        : undefined,
                keys:
                    update.keys != null
                        ? update.keys.keys != null
                            ? update.keys.keys.map((key) =>
                                  Key._fromProtobufKey(key)
                              )
                            : undefined
                        : undefined,
                expirationTime:
                    update.expirationTime != null
                        ? Timestamp._fromProtobuf(update.expirationTime)
                        : undefined,
                contents: update.contents != null ? update.contents : undefined,
                fileMemo:
                    update.memo != null
                        ? update.memo.value != null
                            ? update.memo.value
                            : undefined
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the keys which must sign any transactions modifying this file. Required.
     *
     * All keys must sign to modify the file's contents or keys. No key is required
     * to sign for extending the expiration time (except the one for the operator account
     * paying for the transaction). Only one key must sign to delete the file, however.
     *
     * To require more than one key to sign to delete a file, add them to a
     * KeyList and pass that here.
     *
     * The network currently requires a file to have at least one key (or key list or threshold key)
     * but this requirement may be lifted in the future.
     *
     * @param {FileId | string} fileId
     * @returns {this}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @returns {?Key[]}
     */
    get keys() {
        return this._keys;
    }

    /**
     * Set the keys which must sign any transactions modifying this file. Required.
     *
     * All keys must sign to modify the file's contents or keys. No key is required
     * to sign for extending the expiration time (except the one for the operator account
     * paying for the transaction). Only one key must sign to delete the file, however.
     *
     * To require more than one key to sign to delete a file, add them to a
     * KeyList and pass that here.
     *
     * The network currently requires a file to have at least one key (or key list or threshold key)
     * but this requirement may be lifted in the future.
     *
     * @param {Key[] | KeyList} keys
     * @returns {this}
     */
    setKeys(keys) {
        this._requireNotFrozen();
        if (keys instanceof KeyList && keys.threshold != null) {
            throw new Error("Cannot set threshold key as file key");
        }

        this._keys = keys instanceof KeyList ? keys.toArray() : keys;

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * Set the instant at which this file will expire, after which its contents will no longer be
     * available.
     *
     * Defaults to 1/4 of a Julian year from the instant FileUpdateTransaction
     * was invoked.
     *
     * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
     *
     * @param {Timestamp | Date} expirationTime
     * @returns {this}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime =
            expirationTime instanceof Timestamp
                ? expirationTime
                : Timestamp.fromDate(expirationTime);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get contents() {
        return this._contents;
    }

    /**
     * Set the given byte array as the file's contents.
     *
     * This may be omitted to update an empty file.
     *
     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a HederaPreCheckStatusException
     * with Status#TransactionOversize.
     *
     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
     * transaction with the first chunk and then use FileAppendTransaction with
     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
     *
     * @param {Uint8Array | string} contents
     * @returns {this}
     */
    setContents(contents) {
        this._requireNotFrozen();
        this._contents =
            contents instanceof Uint8Array ? contents : encode(contents);

        return this;
    }

    /**
     * @returns {?string}
     */
    get fileMemo() {
        return this._fileMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setFileMemo(memo) {
        this._requireNotFrozen();
        this._fileMemo = memo;

        return this;
    }

    /**
     * @returns {this}
     */
    clearFileMemo() {
        this._requireNotFrozen();
        this._fileMemo = null;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.file.updateFile(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "fileUpdate";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IFileUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
            keys:
                this._keys != null
                    ? {
                          keys: this._keys.map((key) => key._toProtobufKey()),
                      }
                    : null,
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            contents: this._contents,
            memo:
                this._fileMemo != null
                    ? {
                          value: this._fileMemo,
                      }
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FileUpdateTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("fileUpdate", FileUpdateTransaction._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").FreezeType} proto.FreezeType
 */

class FreezeType {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case FreezeType.UnknownFreezeType:
                return "UNKNOWN_FREEZE_TYPE";
            case FreezeType.FreezeOnly:
                return "FREEZE_ONLY";
            case FreezeType.PrepareUpgrade:
                return "PREPARE_UPGRADE";
            case FreezeType.FreezeUpgrade:
                return "FREEZE_UPGRADE";
            case FreezeType.FreezeAbort:
                return "FREEZE_ABORT";
            case FreezeType.TelemetryUpgrade:
                return "TELEMETRY_UPGRADE";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {FreezeType}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return FreezeType.UnknownFreezeType;
            case 1:
                return FreezeType.FreezeOnly;
            case 2:
                return FreezeType.PrepareUpgrade;
            case 3:
                return FreezeType.FreezeUpgrade;
            case 4:
                return FreezeType.FreezeAbort;
            case 5:
                return FreezeType.TelemetryUpgrade;
            default:
                throw new Error(
                    `(BUG) Status.fromCode() does not handle code: ${code}`
                );
        }
    }

    /**
     * @returns {proto.FreezeType}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * An (invalid) default value for this enum, to ensure the client explicitly sets
 * the intended type of freeze transaction.
 */
FreezeType.UnknownFreezeType = new FreezeType(0);

/**
 * Freezes the network at the specified time. The start_time field must be provided and
 * must reference a future time. Any values specified for the update_file and file_hash
 * fields will be ignored. This transaction does not perform any network changes or
 * upgrades and requires manual intervention to restart the network.
 */
FreezeType.FreezeOnly = new FreezeType(1);

/**
 * A non-freezing operation that initiates network wide preparation in advance of a
 * scheduled freeze upgrade. The update_file and file_hash fields must be provided and
 * valid. The start_time field may be omitted and any value present will be ignored.
 */
FreezeType.PrepareUpgrade = new FreezeType(2);

/**
 * Freezes the network at the specified time and performs the previously prepared
 * automatic upgrade across the entire network.
 */
FreezeType.FreezeUpgrade = new FreezeType(3);

/**
 * Aborts a pending network freeze operation.
 */
FreezeType.FreezeAbort = new FreezeType(4);

/**
 * Performs an immediate upgrade on auxilary services and containers providing
 * telemetry/metrics. Does not impact network operations.
 */
FreezeType.TelemetryUpgrade = new FreezeType(5);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IFreezeTransactionBody} proto.IFreezeTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} HourMinute
 * @property {number} hour
 * @property {number} minute
 */

class FreezeTransaction extends Transaction {
    /**
     * @param {Object} [props]
     * @param {HourMinute} [props.startTime]
     * @param {HourMinute} [props.endTime]
     * @param {Timestamp} [props.startTimestamp]
     * @param {FileId} [props.updateFileId]
     * @param {FileId} [props.fileId]
     * @param {Uint8Array | string} [props.fileHash]
     * @param { FreezeType } [props.freezeType]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?HourMinute}
         */
        this._startTime = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._startTimestamp = null;

        /**
         * @private
         * @type {?HourMinute}
         */
        this._endTime = null;

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._fileHash = null;

        /**
         * @private
         * @type {?FreezeType}
         */
        this._freezeType = null;

        if (props.startTime != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setStartTime(props.startTime.hour, props.startTime.minute);
        }

        if (props.endTime != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setEndTime(props.endTime.hour, props.endTime.minute);
        }

        if (props.startTimestamp != null) {
            this.setStartTimestamp(props.startTimestamp);
        }

        if (props.updateFileId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setUpdateFileId(props.updateFileId);
        }

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.fileHash != null) {
            this.setFileHash(props.fileHash);
        }

        if (props.freezeType != null) {
            this.setFreezeType(props.freezeType);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {FreezeTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const freeze = /** @type {proto.IFreezeTransactionBody} */ (
            body.freeze
        );

        return Transaction._fromProtobufTransactions(
            new FreezeTransaction({
                startTime:
                    freeze.startHour != null && freeze.startMin != null
                        ? {
                              hour: freeze.startHour,
                              minute: freeze.startMin,
                          }
                        : undefined,
                endTime:
                    freeze.endHour != null && freeze.endMin != null
                        ? {
                              hour: freeze.endHour,
                              minute: freeze.endMin,
                          }
                        : undefined,
                startTimestamp:
                    freeze.startTime != null
                        ? Timestamp._fromProtobuf(freeze.startTime)
                        : undefined,
                updateFileId:
                    freeze.updateFile != null
                        ? FileId._fromProtobuf(freeze.updateFile)
                        : undefined,
                fileHash: freeze.fileHash != null ? freeze.fileHash : undefined,
                freezeType:
                    freeze.freezeType != null
                        ? FreezeType._fromCode(freeze.freezeType)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @deprecated - Use `startTimestamp` instead
     * @returns {?HourMinute}
     */
    get startTime() {
        return null;
    }

    /**
     * @deprecated - Use `startTimestamp` instead
     * @param {number | string} startHourOrString
     * @param {?number} startMinute
     * @returns {FreezeTransaction}
     */
    setStartTime(startHourOrString, startMinute) {
        this._requireNotFrozen();
        if (typeof startHourOrString === "string") {
            const split = startHourOrString.split(":");
            this._startTime = {
                hour: Number(split[0]),
                minute: Number(split[1]),
            };
        } else {
            this._startTime = {
                hour: startHourOrString,
                minute: /** @type {number} */ (startMinute),
            };
        }

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get startTimestamp() {
        return this._startTimestamp;
    }

    /**
     * @param {Timestamp} startTimestamp
     * @returns {FreezeTransaction}
     */
    setStartTimestamp(startTimestamp) {
        this._requireNotFrozen();
        this._startTimestamp = startTimestamp;

        return this;
    }

    /**
     * @deprecated
     * @returns {?HourMinute}
     */
    get endTime() {
        console.warn("`FreezeTransaction.endTime` is deprecated");
        return this._endTime;
    }

    /**
     * @deprecated
     * @param {number | string} endHourOrString
     * @param {?number} endMinute
     * @returns {FreezeTransaction}
     */
    setEndTime(endHourOrString, endMinute) {
        console.warn("`FreezeTransaction.endTime` is deprecated");
        this._requireNotFrozen();
        if (typeof endHourOrString === "string") {
            const split = endHourOrString.split(":");
            this._endTime = {
                hour: Number(split[0]),
                minute: Number(split[1]),
            };
        } else {
            this._endTime = {
                hour: endHourOrString,
                minute: /** @type {number} */ (endMinute),
            };
        }

        return this;
    }

    /**
     * @deprecated - Use `fileId` instead
     * @returns {?FileId}
     */
    get updateFileId() {
        return this.fileId;
    }

    /**
     * @deprecated - Use `setFileId()` instead
     * @param {FileId} updateFileId
     * @returns {FreezeTransaction}
     */
    setUpdateFileId(updateFileId) {
        return this.setFileId(updateFileId);
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * @param {FileId} fileId
     * @returns {FreezeTransaction}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId = fileId;

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get fileHash() {
        return this._fileHash;
    }

    /**
     * @param {Uint8Array | string} fileHash
     * @returns {FreezeTransaction}
     */
    setFileHash(fileHash) {
        this._requireNotFrozen();
        this._fileHash =
            typeof fileHash === "string" ? decode$1(fileHash) : fileHash;

        return this;
    }

    /**
     * @returns {?FreezeType}
     */
    get freezeType() {
        return this._freezeType;
    }

    /**
     * @param {FreezeType} freezeType
     * @returns {FreezeTransaction}
     */
    setFreezeType(freezeType) {
        this._requireNotFrozen();
        this._freezeType = freezeType;
        return this;
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "freeze";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IFreezeTransactionBody}
     */
    _makeTransactionData() {
        return {
            startTime:
                this._startTimestamp != null
                    ? this._startTimestamp._toProtobuf()
                    : null,
            updateFile:
                this._fileId != null ? this._fileId._toProtobuf() : null,
            fileHash: this._fileHash,
            freezeType:
                this._freezeType != null ? this._freezeType.valueOf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FreezeTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("freeze", FreezeTransaction._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoAddLiveHashTransactionBody} proto.ICryptoAddLiveHashTransactionBody
 * @typedef {import("@hashgraph/proto").ILiveHash} proto.ILiveHash
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

class LiveHashAddTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Uint8Array} [props.hash]
     * @param {Key[]} [props.keys]
     * @param {Duration | Long | number} [props.duration]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._hash = null;

        /**
         * @private
         * @type {?Key[]}
         */
        this._keys = null;

        /**
         * @private
         * @type {?Duration}
         */
        this._duration = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.hash != null) {
            this.setHash(props.hash);
        }

        if (props.keys != null) {
            this.setKeys(props.keys);
        }

        if (props.duration != null) {
            this.setDuration(props.duration);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {LiveHashAddTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const hashes = /** @type {proto.ICryptoAddLiveHashTransactionBody} */ (
            body.cryptoAddLiveHash
        );
        const liveHash_ = /** @type {proto.ILiveHash} */ (hashes.liveHash);

        return Transaction._fromProtobufTransactions(
            new LiveHashAddTransaction({
                hash: liveHash_.hash != null ? liveHash_.hash : undefined,
                keys:
                    liveHash_.keys != null
                        ? liveHash_.keys.keys != null
                            ? liveHash_.keys.keys.map((key) =>
                                  Key._fromProtobufKey(key)
                              )
                            : undefined
                        : undefined,
                duration:
                    liveHash_.duration != null
                        ? liveHash_.duration.seconds != null
                            ? liveHash_.duration.seconds
                            : undefined
                        : undefined,
                accountId:
                    liveHash_.accountId != null
                        ? AccountId._fromProtobuf(liveHash_.accountId)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?Uint8Array}
     */
    get hash() {
        return this._hash;
    }

    /**
     * @param {Uint8Array} hash
     * @returns {LiveHashAddTransaction}
     */
    setHash(hash) {
        this._requireNotFrozen();
        this._hash = hash;

        return this;
    }

    /**
     * @returns {?Key[]}
     */
    get keys() {
        return this._keys;
    }

    /**
     * @param {Key[] | KeyList} keys
     * @returns {LiveHashAddTransaction}
     */
    setKeys(keys) {
        this._requireNotFrozen();
        this._keys = keys instanceof KeyList ? keys.toArray() : keys;

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get duration() {
        return this._duration;
    }

    /**
     * @param {Duration | Long | number} duration
     * @returns {LiveHashAddTransaction}
     */
    setDuration(duration) {
        this._requireNotFrozen();
        this._duration =
            duration instanceof Duration ? duration : new Duration(duration);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {LiveHashAddTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.addLiveHash(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoAddLiveHash";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ICryptoAddLiveHashTransactionBody}
     */
    _makeTransactionData() {
        return {
            liveHash: {
                hash: this._hash,
                keys:
                    this._keys != null
                        ? {
                              keys: this._keys.map((key) =>
                                  key._toProtobufKey()
                              ),
                          }
                        : undefined,
                duration:
                    this._duration != null
                        ? this._duration._toProtobuf()
                        : null,
                accountId:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `LiveHashAddTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoAddLiveHash",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    LiveHashAddTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoDeleteLiveHashTransactionBody} proto.ICryptoDeleteLiveHashTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

class LiveHashDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Uint8Array} [props.hash]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._hash = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.hash != null) {
            this.setHash(props.hash);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {LiveHashDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const hashes =
            /** @type {proto.ICryptoDeleteLiveHashTransactionBody} */ (
                body.cryptoDeleteLiveHash
            );

        return Transaction._fromProtobufTransactions(
            new LiveHashDeleteTransaction({
                hash:
                    hashes.liveHashToDelete != null
                        ? hashes.liveHashToDelete
                        : undefined,
                accountId:
                    hashes.accountOfLiveHash != null
                        ? AccountId._fromProtobuf(hashes.accountOfLiveHash)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?Uint8Array}
     */
    get hash() {
        return this._hash;
    }

    /**
     * @param {Uint8Array} hash
     * @returns {LiveHashDeleteTransaction}
     */
    setHash(hash) {
        this._requireNotFrozen();
        this._hash = hash;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {LiveHashDeleteTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.deleteLiveHash(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoDeleteLiveHash";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ICryptoDeleteLiveHashTransactionBody}
     */
    _makeTransactionData() {
        return {
            liveHashToDelete: this._hash,
            accountOfLiveHash:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `LiveHashDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoDeleteLiveHash",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    LiveHashDeleteTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ICryptoGetLiveHashQuery} proto.ICryptoGetLiveHashQuery
 * @typedef {import("@hashgraph/proto").ICryptoGetLiveHashResponse} proto.ICryptoGetLiveHashResponse
 * @typedef {import("@hashgraph/proto").ILiveHash} proto.ILiveHash
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @augments {Query<LiveHash>}
 */
class LiveHashQuery extends Query {
    /**
     * @param {object} [props]
     * @param {AccountId | string} [props.accountId]
     * @param {Uint8Array} [props.hash]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?AccountId}
         * @private
         */
        this._accountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        /**
         * @type {?Uint8Array}
         * @private
         */
        this._hash = null;

        if (props.hash != null) {
            this.setHash(props.hash);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {LiveHashQuery}
     */
    static _fromProtobuf(query) {
        const hash = /** @type {proto.ICryptoGetLiveHashQuery} */ (
            query.cryptoGetLiveHash
        );

        return new LiveHashQuery({
            accountId:
                hash.accountID != null
                    ? AccountId._fromProtobuf(hash.accountID)
                    : undefined,
            hash: hash.hash != null ? hash.hash : undefined,
        });
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account to which the livehash is associated.
     *
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get liveHash() {
        return this._hash;
    }

    /**
     * Set the SHA-384 data in the livehash.
     *
     * @param {Uint8Array} hash
     * @returns {this}
     */
    setHash(hash) {
        this._hash = hash;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getLiveHash(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const cryptoGetLiveHash =
            /** @type {proto.ICryptoGetLiveHashResponse} */ (
                response.cryptoGetLiveHash
            );
        return /** @type {proto.IResponseHeader} */ (cryptoGetLiveHash.header);
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @returns {Promise<LiveHash>}
     */
    _mapResponse(response) {
        const hashes = /** @type {proto.ICryptoGetLiveHashResponse} */ (
            response.cryptoGetLiveHash
        );

        return Promise.resolve(
            LiveHash._fromProtobuf(
                /** @type {proto.ILiveHash} */ (hashes.liveHash)
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            cryptoGetLiveHash: {
                header,
                accountID:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
                hash: this._hash,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `LiveHashQuery:${timestamp.toString()}`;
    }
}

// @ts-ignore
// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("cryptoGetLiveHash", LiveHashQuery._fromProtobuf);

class SemanticVersion {
    /**
     * @private
     * @param {object} props
     * @param {number} props.major
     * @param {number} props.minor
     * @param {number} props.patch
     */
    constructor(props) {
        /** @readonly */
        this.major = props.major;
        /** @readonly */
        this.minor = props.minor;
        /** @readonly */
        this.patch = props.patch;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.ISemanticVersion} version
     * @returns {SemanticVersion}
     */
    static _fromProtobuf(version) {
        return new SemanticVersion({
            major: /** @type {number} */ (version.major),
            minor: /** @type {number} */ (version.minor),
            patch: /** @type {number} */ (version.patch),
        });
    }

    /**
     * @internal
     * @returns {proto.ISemanticVersion}
     */
    _toProtobuf() {
        return {
            major: this.major,
            minor: this.minor,
            patch: this.patch,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {SemanticVersion}
     */
    static fromBytes(bytes) {
        return SemanticVersion._fromProtobuf(
            lib.SemanticVersion.decode(bytes)
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.SemanticVersion.encode(this._toProtobuf()).finish();
    }
}

/**
 * Response when the client sends the node CryptoGetVersionInfoQuery.
 */
class NetworkVersionInfo {
    /**
     * @private
     * @param {object} props
     * @param {SemanticVersion} props.protobufVersion
     * @param {SemanticVersion} props.servicesVesion
     */
    constructor(props) {
        /**
         * The account ID for which this information applies.
         *
         * @readonly
         */
        this.protobufVersion = props.protobufVersion;

        /**
         * The account ID for which this information applies.
         *
         * @readonly
         */
        this.servicesVesion = props.servicesVesion;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.INetworkGetVersionInfoResponse} info
     * @returns {NetworkVersionInfo}
     */
    static _fromProtobuf(info) {
        return new NetworkVersionInfo({
            protobufVersion: SemanticVersion._fromProtobuf(
                /** @type {proto.ISemanticVersion} */
                (info.hapiProtoVersion)
            ),
            servicesVesion: SemanticVersion._fromProtobuf(
                /** @type {proto.ISemanticVersion} */
                (info.hederaServicesVersion)
            ),
        });
    }

    /**
     * @internal
     * @returns {proto.INetworkGetVersionInfoResponse}
     */
    _toProtobuf() {
        return {
            hapiProtoVersion: this.protobufVersion._toProtobuf(),
            hederaServicesVersion: this.servicesVesion._toProtobuf(),
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {NetworkVersionInfo}
     */
    static fromBytes(bytes) {
        return NetworkVersionInfo._fromProtobuf(
            lib.NetworkGetVersionInfoResponse.decode(bytes)
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.NetworkGetVersionInfoResponse.encode(
            this._toProtobuf()
        ).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").INetworkGetVersionInfoQuery} proto.INetworkGetVersionInfoQuery
 * @typedef {import("@hashgraph/proto").INetworkGetVersionInfoResponse} proto.INetworkGetVersionInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 */

/**
 * @augments {Query<NetworkVersionInfo>}
 */
class NetworkVersionInfoQuery extends Query {
    constructor() {
        super();
    }

    /**
     * @param {proto.IQuery} query
     * @returns {NetworkVersionInfoQuery}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(query) {
        return new NetworkVersionInfoQuery();
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.network.getVersionInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const networkGetVersionInfo =
            /** @type {proto.INetworkGetVersionInfoResponse} */ (
                response.networkGetVersionInfo
            );
        return /** @type {proto.IResponseHeader} */ (
            networkGetVersionInfo.header
        );
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @returns {Promise<NetworkVersionInfo>}
     */
    _mapResponse(response) {
        const info = /** @type {proto.INetworkGetVersionInfoResponse} */ (
            response.networkGetVersionInfo
        );
        return Promise.resolve(NetworkVersionInfo._fromProtobuf(info));
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            networkGetVersionInfo: {
                header,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `NetworkVersionInfoQuery:${timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "networkGetVersionInfo",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    NetworkVersionInfoQuery._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IScheduleCreateTransactionBody} proto.IScheduleCreateTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ISignatureMap} proto.ISignatureMap
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../PublicKey.js").default} PublicKey
 * @typedef {import("../PrivateKey.js").default} PrivateKey
 */

/**
 * Create a new Hedera crypto-currency account.
 */
class ScheduleCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Key} [props.adminKey]
     * @param {AccountId} [props.payerAccountID]
     * @param {string} [props.scheduleMemo]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Transaction}
         */
        this._scheduledTransaction = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._payerAccountId = null;

        /**
         * @private
         * @type {?string}
         */
        this._scheduleMemo = null;

        /**
         * @private
         * @type {Set<string>}
         */
        this._scheduledSignerPublicKeys = new Set();

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.payerAccountID != null) {
            this.setPayerAccountId(props.payerAccountID);
        }

        if (props.scheduleMemo != null) {
            this.setScheduleMemo(props.scheduleMemo);
        }

        this._defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {ScheduleCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const create = /** @type {proto.IScheduleCreateTransactionBody} */ (
            body.scheduleCreate
        );

        return Transaction._fromProtobufTransactions(
            new ScheduleCreateTransaction({
                adminKey:
                    create.adminKey != null
                        ? Key._fromProtobufKey(create.adminKey)
                        : undefined,
                payerAccountID:
                    create.payerAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {proto.IAccountID} */ (
                                  create.payerAccountID
                              )
                          )
                        : undefined,
                scheduleMemo: create.memo != null ? create.memo : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @internal
     * @param {Transaction} tx
     * @returns {this}
     */
    _setScheduledTransaction(tx) {
        this._scheduledTransaction = tx;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * Set the key for this account.
     *
     * This is the key that must sign each transfer out of the account.
     *
     * If `receiverSignatureRequired` is true, then the key must also sign
     * any transfer into the account.
     *
     * @param {Key} key
     * @returns {this}
     */
    setAdminKey(key) {
        this._requireNotFrozen();
        this._adminKey = key;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get payerAccountId() {
        return this._payerAccountId;
    }

    /**
     * @param {AccountId} account
     * @returns {this}
     */
    setPayerAccountId(account) {
        this._requireNotFrozen();
        this._payerAccountId = account;

        return this;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setScheduleMemo(memo) {
        this._requireNotFrozen();
        this._scheduleMemo = memo;

        return this;
    }

    /**
     * @returns {?string}
     */
    get getScheduleMemo() {
        this._requireNotFrozen();
        return this._scheduleMemo;
    }

    /**
     * @param {Transaction} transaction
     * @returns {this}
     */
    setScheduledTransaction(transaction) {
        this._requireNotFrozen();
        transaction._requireNotFrozen();

        this._scheduledTransaction =
            transaction.schedule()._scheduledTransaction;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._payerAccountId != null) {
            this._payerAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.schedule.createSchedule(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "scheduleCreate";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IScheduleCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            payerAccountID:
                this._payerAccountId != null
                    ? this._payerAccountId._toProtobuf()
                    : null,
            scheduledTransactionBody:
                this._scheduledTransaction != null
                    ? this._scheduledTransaction._getScheduledTransactionBody()
                    : null,
            memo: this._scheduleMemo,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ScheduleCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "scheduleCreate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ScheduleCreateTransaction._fromProtobuf
);

SCHEDULE_CREATE_TRANSACTION.push(() => new ScheduleCreateTransaction());

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IScheduleDeleteTransactionBody} proto.IScheduleDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IScheduleID} proto.IScheduleID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Create a new Hedera crypto-currency account.
 */
class ScheduleDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {ScheduleId | string} [props.scheduleId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ScheduleId}
         */
        this._scheduleId = null;

        if (props.scheduleId != null) {
            this.setScheduleId(props.scheduleId);
        }

        this._defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {ScheduleDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const scheduleDelete =
            /** @type {proto.IScheduleDeleteTransactionBody} */ (
                body.scheduleDelete
            );

        return Transaction._fromProtobufTransactions(
            new ScheduleDeleteTransaction({
                scheduleId:
                    scheduleDelete.scheduleID != null
                        ? ScheduleId._fromProtobuf(
                              /** @type {proto.IScheduleID} */ (
                                  scheduleDelete.scheduleID
                              )
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?ScheduleId}
     */
    get scheduleId() {
        return this._scheduleId;
    }

    /**
     * @param {ScheduleId | string} scheduleId
     * @returns {this}
     */
    setScheduleId(scheduleId) {
        this._requireNotFrozen();
        this._scheduleId =
            typeof scheduleId === "string"
                ? ScheduleId.fromString(scheduleId)
                : scheduleId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._scheduleId != null) {
            this._scheduleId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.schedule.deleteSchedule(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "scheduleDelete";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IScheduleDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            scheduleID:
                this._scheduleId != null
                    ? this._scheduleId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ScheduleDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "scheduleDelete",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ScheduleDeleteTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IScheduleInfo} proto.IScheduleInfo
 * @typedef {import("@hashgraph/proto").IScheduleID} proto.IScheduleID
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IScheduleID} proto.IScheduledID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").IDuration} proto.IDuration
 * @typedef {import("@hashgraph/proto").ISchedulableTransactionBody} proto.ISchedulableTransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 */

/**
 * Response when the client sends the node ScheduleGetInfoQuery.
 */
class ScheduleInfo {
    /**
     * @private
     * @param {object} props
     * @param {ScheduleId} props.scheduleId;
     * @param {?AccountId} props.creatorAccountID;
     * @param {?AccountId} props.payerAccountID;
     * @param {?proto.ISchedulableTransactionBody} props.schedulableTransactionBody;
     * @param {?Key} props.adminKey
     * @param {?KeyList} props.signers;
     * @param {?string} props.scheduleMemo;
     * @param {?Timestamp} props.expirationTime;
     * @param {?Timestamp} props.executed;
     * @param {?Timestamp} props.deleted;
     * @param {?TransactionId} props.scheduledTransactionId;
     */
    constructor(props) {
        /**
         *
         * @readonly
         */
        this.scheduleId = props.scheduleId;

        /**
         *
         * @readonly
         */
        this.creatorAccountId = props.creatorAccountID;

        /**
         *
         * @readonly
         */
        this.payerAccountId = props.payerAccountID;

        /**
         *
         * @readonly
         */
        this.schedulableTransactionBody = props.schedulableTransactionBody;

        /**
         *
         * @readonly
         */
        this.signers = props.signers;

        /**
         *
         * @readonly
         */
        this.scheduleMemo = props.scheduleMemo;

        /**
         *
         * @readonly
         */
        this.adminKey = props.adminKey != null ? props.adminKey : null;

        /**
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         *
         * @readonly
         */
        this.executed = props.executed;

        /**
         *
         * @readonly
         */
        this.deleted = props.deleted;

        this.scheduledTransactionId = props.scheduledTransactionId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.IScheduleInfo} info
     * @returns {ScheduleInfo}
     */
    static _fromProtobuf(info) {
        return new ScheduleInfo({
            scheduleId: ScheduleId._fromProtobuf(
                /** @type {proto.IScheduleID} */ (info.scheduleID)
            ),
            creatorAccountID:
                info.creatorAccountID != null
                    ? AccountId._fromProtobuf(
                          /** @type {proto.IAccountID} */ (
                              info.creatorAccountID
                          )
                      )
                    : null,
            payerAccountID:
                info.payerAccountID != null
                    ? AccountId._fromProtobuf(
                          /** @type {proto.IAccountID} */ (info.payerAccountID)
                      )
                    : null,
            schedulableTransactionBody:
                info.scheduledTransactionBody != null
                    ? info.scheduledTransactionBody
                    : null,
            adminKey:
                info.adminKey != null
                    ? Key._fromProtobufKey(info.adminKey)
                    : null,
            signers:
                info.signers != null
                    ? KeyList.__fromProtobufKeyList(info.signers)
                    : null,
            scheduleMemo: info.memo != null ? info.memo : null,
            expirationTime:
                info.expirationTime != null
                    ? Timestamp._fromProtobuf(
                          /** @type {proto.ITimestamp} */ (info.expirationTime)
                      )
                    : null,
            executed:
                info.executionTime != null
                    ? Timestamp._fromProtobuf(
                          /** @type {proto.ITimestamp} */ (info.executionTime)
                      )
                    : null,
            deleted:
                info.deletionTime != null
                    ? Timestamp._fromProtobuf(
                          /** @type {proto.ITimestamp} */ (info.deletionTime)
                      )
                    : null,
            scheduledTransactionId:
                info.scheduledTransactionID != null
                    ? TransactionId._fromProtobuf(info.scheduledTransactionID)
                    : null,
        });
    }

    /**
     * @returns {proto.IScheduleInfo}
     */
    _toProtobuf() {
        return {
            scheduleID:
                this.scheduleId != null ? this.scheduleId._toProtobuf() : null,
            creatorAccountID:
                this.creatorAccountId != null
                    ? this.creatorAccountId._toProtobuf()
                    : null,
            payerAccountID:
                this.payerAccountId != null
                    ? this.payerAccountId._toProtobuf()
                    : null,
            scheduledTransactionBody:
                this.schedulableTransactionBody != null
                    ? this.schedulableTransactionBody
                    : null,
            adminKey:
                this.adminKey != null ? this.adminKey._toProtobufKey() : null,
            signers:
                this.signers != null
                    ? this.signers._toProtobufKey().keyList
                    : null,
            memo: this.scheduleMemo != null ? this.scheduleMemo : "",
            expirationTime:
                this.expirationTime != null
                    ? this.expirationTime._toProtobuf()
                    : null,
            scheduledTransactionID:
                this.scheduledTransactionId != null
                    ? this.scheduledTransactionId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {Transaction}
     */
    get scheduledTransaction() {
        if (this.schedulableTransactionBody == null) {
            throw new Error("Scheduled transaction body is empty");
        }

        const scheduled = new lib.SchedulableTransactionBody(
            this.schedulableTransactionBody
        );
        const data =
            /** @type {NonNullable<ProtoSchedulableTransactionBody["data"]>} */ (
                scheduled.data
            );

        return Transaction.fromBytes(
            lib.TransactionList.encode({
                transactionList: [
                    {
                        signedTransactionBytes: lib.SignedTransaction.encode({
                            bodyBytes: lib.TransactionBody.encode({
                                transactionFee:
                                    this.schedulableTransactionBody
                                        .transactionFee,
                                memo: this.schedulableTransactionBody.memo,
                                [data]: scheduled[data],
                            }).finish(),
                        }).finish(),
                    },
                ],
            }).finish()
        );
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IScheduleInfo} proto.IScheduleInfo
 * @typedef {import("@hashgraph/proto").IScheduleGetInfoQuery} proto.IScheduleGetInfoQuery
 * @typedef {import("@hashgraph/proto").IScheduleGetInfoResponse} proto.IScheduleGetInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<ScheduleInfo>}
 */
class ScheduleInfoQuery extends Query {
    /**
     * @param {object} properties
     * @param {ScheduleId | string} [properties.scheduleId]
     */
    constructor(properties = {}) {
        super();

        /**
         * @private
         * @type {?ScheduleId}
         */
        this._scheduleId = null;

        if (properties.scheduleId != null) {
            this.setScheduleId(properties.scheduleId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {ScheduleInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {proto.IScheduleGetInfoQuery} */ (
            query.scheduleGetInfo
        );

        return new ScheduleInfoQuery({
            scheduleId:
                info.scheduleID != null
                    ? ScheduleId._fromProtobuf(info.scheduleID)
                    : undefined,
        });
    }

    /**
     * @returns {?ScheduleId}
     */
    get scheduleId() {
        return this._scheduleId;
    }

    /**
     *
     * @param {ScheduleId | string} scheduleId
     * @returns {ScheduleInfoQuery}
     */
    setScheduleId(scheduleId) {
        this._scheduleId =
            typeof scheduleId === "string"
                ? ScheduleId.fromString(scheduleId)
                : scheduleId.clone();

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        let cost = await super.getCost(client);

        if (cost.toTinybars().greaterThan(25)) {
            return cost;
        } else {
            return Hbar.fromTinybars(25);
        }
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._scheduleId != null) {
            this._scheduleId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.schedule.getScheduleInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const scheduleGetInfo = /** @type {proto.IScheduleGetInfoResponse} */ (
            response.scheduleGetInfo
        );
        return /** @type {proto.IResponseHeader} */ (scheduleGetInfo.header);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<ScheduleInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {proto.IScheduleGetInfoResponse} */ (
            response.scheduleGetInfo
        );

        return Promise.resolve(
            ScheduleInfo._fromProtobuf(
                /** @type {proto.IScheduleInfo} */ (info.scheduleInfo)
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            scheduleGetInfo: {
                header,
                scheduleID:
                    this._scheduleId != null
                        ? this._scheduleId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `ScheduleInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("scheduleGetInfo", ScheduleInfoQuery._fromProtobuf);

/**
 * @typedef {object} ProtoSignaturePair
 * @property {(Uint8Array | null)=} pubKeyPrefix
 * @property {(Uint8Array | null)=} ed25519
 */

/**
 * @typedef {object} ProtoSigMap
 * @property {(ProtoSignaturePair[] | null)=} sigPair
 */

/**
 * @typedef {object} ProtoSignedTransaction
 * @property {(Uint8Array | null)=} bodyBytes
 * @property {(ProtoSigMap | null)=} sigMap
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IScheduleSignTransactionBody} proto.IScheduleSignTransactionBody
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ISignatureMap} proto.ISignatureMap
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("@hashgraph/cryptography").PublicKey} PublicKey
 */

/**
 * Create a new Hedera crypto-currency account.
 */
class ScheduleSignTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {ScheduleId | string} [props.scheduleId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ScheduleId}
         */
        this._scheduleId = null;

        if (props.scheduleId != null) {
            this.setScheduleId(props.scheduleId);
        }

        this._defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {ScheduleSignTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const sign = /** @type {proto.IScheduleSignTransactionBody} */ (
            body.scheduleSign
        );

        return Transaction._fromProtobufTransactions(
            new ScheduleSignTransaction({
                scheduleId:
                    sign.scheduleID != null
                        ? ScheduleId._fromProtobuf(sign.scheduleID)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?ScheduleId}
     */
    get scheduleId() {
        return this._scheduleId;
    }

    /**
     * @param {ScheduleId | string} scheduleId
     * @returns {this}
     */
    setScheduleId(scheduleId) {
        this._requireNotFrozen();
        this._scheduleId =
            typeof scheduleId === "string"
                ? ScheduleId.fromString(scheduleId)
                : scheduleId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._scheduleId != null) {
            this._scheduleId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.schedule.signSchedule(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "scheduleSign";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IScheduleSignTransactionBody}
     */
    _makeTransactionData() {
        return {
            scheduleID:
                this._scheduleId != null
                    ? this._scheduleId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ScheduleSignTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "scheduleSign",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ScheduleSignTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ISystemDeleteTransactionBody} proto.ISystemDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

class SystemDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     * @param {ContractId | string} [props.contractId]
     * @param {Timestamp} [props.expirationTime]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {SystemDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const systemDelete = /** @type {proto.ISystemDeleteTransactionBody} */ (
            body.systemDelete
        );

        return Transaction._fromProtobufTransactions(
            new SystemDeleteTransaction({
                fileId:
                    systemDelete.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {proto.IFileID} */ (systemDelete.fileID)
                          )
                        : undefined,
                contractId:
                    systemDelete.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {proto.IContractID} */ (
                                  systemDelete.contractID
                              )
                          )
                        : undefined,
                expirationTime:
                    systemDelete.expirationTime != null
                        ? Timestamp._fromProtobuf(systemDelete.expirationTime)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * @param {FileId | string} fileId
     * @returns {this}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            fileId instanceof FileId ? fileId : FileId.fromString(fileId);

        return this;
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * @param {ContractId | string} contractId
     * @returns {this}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            contractId instanceof ContractId
                ? contractId
                : ContractId.fromString(contractId);

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * @param {Timestamp} expirationTime
     * @returns {SystemDeleteTransaction}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime = expirationTime;
        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        if (this._fileId != null) {
            return channel.file.systemDelete(request);
        } else {
            return channel.smartContract.systemDelete(request);
        }
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "systemDelete";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ISystemDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `SystemDeleteTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("systemDelete", SystemDeleteTransaction._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ISystemUndeleteTransactionBody} proto.ISystemUndeleteTransactionBody
 * @typedef {import("@hashgraph/proto").IContractID} proto.IContractID
 * @typedef {import("@hashgraph/proto").IFileID} proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

class SystemUndeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     * @param {ContractId | string} [props.contractId]
     * @param {Timestamp} [props.expirationTime]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {SystemUndeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const systemUndelete =
            /** @type {proto.ISystemUndeleteTransactionBody} */ (
                body.systemUndelete
            );

        return Transaction._fromProtobufTransactions(
            new SystemUndeleteTransaction({
                fileId:
                    systemUndelete.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {proto.IFileID} */ (
                                  systemUndelete.fileID
                              )
                          )
                        : undefined,
                contractId:
                    systemUndelete.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {proto.IContractID} */ (
                                  systemUndelete.contractID
                              )
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * @param {FileId | string} fileId
     * @returns {this}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            fileId instanceof FileId ? fileId : FileId.fromString(fileId);

        return this;
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * @param {ContractId | string} contractId
     * @returns {this}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            contractId instanceof ContractId
                ? contractId
                : ContractId.fromString(contractId);

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        if (this._fileId != null) {
            return channel.file.systemUndelete(request);
        } else {
            return channel.smartContract.systemUndelete(request);
        }
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "systemUndelete";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ISystemUndeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `SystemUndeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "systemUndelete",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    SystemUndeleteTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenAssociateTransactionBody} proto.ITokenAssociateTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Associate a new Hedera crypto-currency token.
 */
class TokenAssociateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {(TokenId | string)[]} [props.tokenIds]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId[]}
         */
        this._tokenIds = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        this._defaultMaxTransactionFee = new Hbar(5);

        if (props.tokenIds != null) {
            this.setTokenIds(props.tokenIds);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenAssociateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const associateToken =
            /** @type {proto.ITokenAssociateTransactionBody} */ (
                body.tokenAssociate
            );

        return Transaction._fromProtobufTransactions(
            new TokenAssociateTransaction({
                tokenIds:
                    associateToken.tokens != null
                        ? associateToken.tokens.map((token) =>
                              TokenId._fromProtobuf(token)
                          )
                        : undefined,
                accountId:
                    associateToken.account != null
                        ? AccountId._fromProtobuf(associateToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId[]}
     */
    get tokenIds() {
        return this._tokenIds;
    }

    /**
     * @param {(TokenId | string)[]} tokenIds
     * @returns {this}
     */
    setTokenIds(tokenIds) {
        this._requireNotFrozen();
        this._tokenIds = tokenIds.map((tokenId) =>
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone()
        );

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
            if (tokenId != null) {
                tokenId.validateChecksum(client);
            }
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.associateTokens(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenAssociate";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenAssociateTransactionBody}
     */
    _makeTransactionData() {
        return {
            tokens:
                this._tokenIds != null
                    ? this._tokenIds.map((tokenId) => tokenId._toProtobuf())
                    : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenAssociateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenAssociate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenAssociateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenBurnTransactionBody} proto.ITokenBurnTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Burn a new Hedera crypto-currency token.
 */
class TokenBurnTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {Long | number} [props.amount]
     * @param {(Long | number)[]} [props.serials]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._amount = null;

        /**
         * @private
         * @type {Long[]}
         */
        this._serials = [];

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.amount != null) {
            this.setAmount(props.amount);
        }

        if (props.serials != null) {
            this.setSerials(props.serials);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenBurnTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const burnToken = /** @type {proto.ITokenBurnTransactionBody} */ (
            body.tokenBurn
        );

        return Transaction._fromProtobufTransactions(
            new TokenBurnTransaction({
                tokenId:
                    burnToken.token != null
                        ? TokenId._fromProtobuf(burnToken.token)
                        : undefined,
                amount: burnToken.amount != null ? burnToken.amount : undefined,
                serials:
                    burnToken.serialNumbers != null
                        ? burnToken.serialNumbers
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {this}
     */
    setAmount(amount) {
        this._requireNotFrozen();
        this._amount = amount instanceof long ? amount : long.fromValue(amount);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @returns {Long[]}
     */
    get serials() {
        return this._serials;
    }

    /**
     * @param {(Long | number)[]} serials
     * @returns {this}
     */
    setSerials(serials) {
        this._requireNotFrozen();
        this._serials = serials.map((serial) =>
            serial instanceof long ? serial : long.fromValue(serial)
        );

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.burnToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenBurn";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenBurnTransactionBody}
     */
    _makeTransactionData() {
        return {
            amount: this._amount,
            serialNumbers: this._serials,
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenBurnTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenBurn",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenBurnTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").TokenType} proto.TokenType
 */

class TokenType$1 {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case TokenType$1.FungibleCommon:
                return "FUNGIBLE_COMMON";
            case TokenType$1.NonFungibleUnique:
                return "NON_FUNGIBLE_UNIQUE";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {TokenType}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return TokenType$1.FungibleCommon;
            case 1:
                return TokenType$1.NonFungibleUnique;
        }

        throw new Error(
            `(BUG) TokenType.fromCode() does not handle code: ${code}`
        );
    }

    /**
     * @returns {proto.TokenType}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * Interchangeable value with one another, where any quantity of them has the
 * same value as another equal quantity if they are in the same class. Share
 * a single set of properties, not distinct from one another. Simply represented
 * as a balance or quantity to a given Hedera account.
 */
TokenType$1.FungibleCommon = new TokenType$1(0);

/**
 * Unique, not interchangeable with other tokens of the same type as they
 * typically have different values. Individually traced and can carry unique
 * properties (e.g. serial number).
 */
TokenType$1.NonFungibleUnique = new TokenType$1(1);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").TokenSupplyType} proto.TokenSupplyType
 */

class TokenSupplyType {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case TokenSupplyType.Infinite:
                return "INFINITE";
            case TokenSupplyType.Finite:
                return "FINITE";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {TokenSupplyType}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return TokenSupplyType.Infinite;
            case 1:
                return TokenSupplyType.Finite;
        }

        throw new Error(
            `(BUG) TokenSupplyType.fromCode() does not handle code: ${code}`
        );
    }

    /**
     * @returns {proto.TokenSupplyType}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * Interchangeable value with one another, where any quantity of them has the
 * same value as another equal quantity if they are in the same class. Share
 * a single set of properties, not distinct from one another. Simply represented
 * as a balance or quantity to a given Hedera account.
 */
TokenSupplyType.Infinite = new TokenSupplyType(0);

/**
 * Unique, not interchangeable with other tokens of the same type as they
 * typically have different values. Individually traced and can carry unique
 * properties (e.g. serial number).
 */
TokenSupplyType.Finite = new TokenSupplyType(1);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenCreateTransactionBody} proto.ITokenCreateTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./CustomFee.js").default} CustomFee
 */

/**
 * Create a new Hedera crypto-currency token.
 */
class TokenCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {string} [props.tokenName]
     * @param {string} [props.tokenSymbol]
     * @param {Long | number} [props.decimals]
     * @param {Long | number} [props.initialSupply]
     * @param {AccountId | string} [props.treasuryAccountId]
     * @param {Key} [props.adminKey]
     * @param {Key} [props.kycKey]
     * @param {Key} [props.freezeKey]
     * @param {Key} [props.pauseKey]
     * @param {Key} [props.wipeKey]
     * @param {Key} [props.supplyKey]
     * @param {Key} [props.feeScheduleKey]
     * @param {boolean} [props.freezeDefault]
     * @param {AccountId | string} [props.autoRenewAccountId]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {string} [props.tokenMemo]
     * @param {CustomFee[]} [props.customFees]
     * @param {TokenType} [props.tokenType]
     * @param {TokenSupplyType} [props.supplyType]
     * @param {Long | number} [props.maxSupply]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?string}
         */
        this._tokenName = null;

        /**
         * @private
         * @type {?string}
         */
        this._tokenSymbol = null;

        /**
         * @private
         * @type {?Long}
         */
        this._decimals = null;

        /**
         * @private
         * @type {?Long}
         */
        this._initialSupply = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._treasuryAccountId = null;

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._kycKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._freezeKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._pauseKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._wipeKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._supplyKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._feeScheduleKey = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._freezeDefault = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

        /**
         * @private
         * @type {?string}
         */
        this._tokenMemo = null;

        /**
         * @private
         * @type {CustomFee[]}
         */
        this._customFees = [];

        /**
         * @private
         * @type {?TokenType}
         */
        this._tokenType = null;

        /**
         * @private
         * @type {?TokenSupplyType}
         */
        this._supplyType = null;

        /**
         * @private
         * @type {?Long}
         */
        this._maxSupply = null;

        this._defaultMaxTransactionFee = new Hbar(30);

        if (props.tokenName != null) {
            this.setTokenName(props.tokenName);
        }

        if (props.tokenSymbol != null) {
            this.setTokenSymbol(props.tokenSymbol);
        }

        if (props.decimals != null) {
            this.setDecimals(props.decimals);
        }

        if (props.initialSupply != null) {
            this.setInitialSupply(props.initialSupply);
        }

        if (props.treasuryAccountId != null) {
            this.setTreasuryAccountId(props.treasuryAccountId);
        }

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.kycKey != null) {
            this.setKycKey(props.kycKey);
        }

        if (props.freezeKey != null) {
            this.setFreezeKey(props.freezeKey);
        }

        if (props.pauseKey != null) {
            this.setPauseKey(props.pauseKey);
        }

        if (props.wipeKey != null) {
            this.setWipeKey(props.wipeKey);
        }

        if (props.supplyKey != null) {
            this.setSupplyKey(props.supplyKey);
        }

        if (props.feeScheduleKey != null) {
            this.setFeeScheduleKey(props.feeScheduleKey);
        }

        if (props.freezeDefault != null) {
            this.setFreezeDefault(props.freezeDefault);
        }

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.tokenMemo != null) {
            this.setTokenMemo(props.tokenMemo);
        }

        if (props.customFees != null) {
            this.setCustomFees(props.customFees);
        }

        if (props.tokenType != null) {
            this.setTokenType(props.tokenType);
        }

        if (props.supplyType != null) {
            this.setSupplyType(props.supplyType);
        }

        if (props.maxSupply != null) {
            this.setMaxSupply(props.maxSupply);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const create = /** @type {proto.ITokenCreateTransactionBody} */ (
            body.tokenCreation
        );

        return Transaction._fromProtobufTransactions(
            new TokenCreateTransaction({
                tokenName: create.name != null ? create.name : undefined,
                tokenSymbol: create.symbol != null ? create.symbol : undefined,
                decimals: create.decimals != null ? create.decimals : undefined,
                initialSupply:
                    create.initialSupply != null
                        ? create.initialSupply
                        : undefined,
                treasuryAccountId:
                    create.treasury != null
                        ? AccountId._fromProtobuf(create.treasury)
                        : undefined,
                adminKey:
                    create.adminKey != null
                        ? Key._fromProtobufKey(create.adminKey)
                        : undefined,
                kycKey:
                    create.kycKey != null
                        ? Key._fromProtobufKey(create.kycKey)
                        : undefined,
                freezeKey:
                    create.freezeKey != null
                        ? Key._fromProtobufKey(create.freezeKey)
                        : undefined,
                pauseKey:
                    create.pauseKey != null
                        ? Key._fromProtobufKey(create.pauseKey)
                        : undefined,
                wipeKey:
                    create.wipeKey != null
                        ? Key._fromProtobufKey(create.wipeKey)
                        : undefined,
                supplyKey:
                    create.supplyKey != null
                        ? Key._fromProtobufKey(create.supplyKey)
                        : undefined,
                feeScheduleKey:
                    create.feeScheduleKey != null
                        ? Key._fromProtobufKey(create.feeScheduleKey)
                        : undefined,
                freezeDefault:
                    create.freezeDefault != null
                        ? create.freezeDefault
                        : undefined,
                autoRenewAccountId:
                    create.autoRenewAccount != null
                        ? AccountId._fromProtobuf(create.autoRenewAccount)
                        : undefined,
                expirationTime:
                    create.expiry != null
                        ? Timestamp._fromProtobuf(create.expiry)
                        : undefined,
                autoRenewPeriod:
                    create.autoRenewPeriod != null
                        ? Duration._fromProtobuf(create.autoRenewPeriod)
                        : undefined,
                tokenMemo: create.memo != null ? create.memo : undefined,
                customFees:
                    create.customFees != null
                        ? create.customFees.map((fee) => {
                              if (fee.fixedFee != null) {
                                  return CustomFixedFee._fromProtobuf(fee);
                              } else if (fee.fractionalFee != null) {
                                  return CustomFractionalFee._fromProtobuf(fee);
                              } else {
                                  return CustomRoyalyFee._fromProtobuf(fee);
                              }
                          })
                        : undefined,
                tokenType:
                    create.tokenType != null
                        ? TokenType$1._fromCode(create.tokenType)
                        : undefined,
                supplyType:
                    create.supplyType != null
                        ? TokenSupplyType._fromCode(create.supplyType)
                        : undefined,
                maxSupply:
                    create.maxSupply != null ? create.maxSupply : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?string}
     */
    get tokenName() {
        return this._tokenName;
    }

    /**
     * @param {string} name
     * @returns {this}
     */
    setTokenName(name) {
        this._requireNotFrozen();
        this._tokenName = name;

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenSymbol() {
        return this._tokenSymbol;
    }

    /**
     * @param {string} symbol
     * @returns {this}
     */
    setTokenSymbol(symbol) {
        this._requireNotFrozen();
        this._tokenSymbol = symbol;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get decimals() {
        return this._decimals;
    }

    /**
     * @param {Long | number} decimals
     * @returns {this}
     */
    setDecimals(decimals) {
        this._requireNotFrozen();
        this._decimals =
            decimals instanceof long ? decimals : long.fromValue(decimals);

        return this;
    }

    /**
     * @returns {?Long}
     */
    get initialSupply() {
        return this._initialSupply;
    }

    /**
     * @param {Long | number} initialSupply
     * @returns {this}
     */
    setInitialSupply(initialSupply) {
        this._requireNotFrozen();
        this._initialSupply = long.fromValue(initialSupply);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get treasuryAccountId() {
        return this._treasuryAccountId;
    }

    /**
     * @param {AccountId | string} id
     * @returns {this}
     */
    setTreasuryAccountId(id) {
        this._requireNotFrozen();
        this._treasuryAccountId =
            typeof id === "string" ? AccountId.fromString(id) : id.clone();

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setAdminKey(key) {
        this._requireNotFrozen();
        this._adminKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get kycKey() {
        return this._kycKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setKycKey(key) {
        this._requireNotFrozen();
        this._kycKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get freezeKey() {
        return this._freezeKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setFreezeKey(key) {
        this._requireNotFrozen();
        this._freezeKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get pauseKey() {
        return this._pauseKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setPauseKey(key) {
        this._requireNotFrozen();
        this._pauseKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get wipeKey() {
        return this._wipeKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setWipeKey(key) {
        this._requireNotFrozen();
        this._wipeKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get supplyKey() {
        return this._supplyKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setSupplyKey(key) {
        this._requireNotFrozen();
        this._supplyKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get feeScheduleKey() {
        return this._feeScheduleKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setFeeScheduleKey(key) {
        this._requireNotFrozen();
        this._feeScheduleKey = key;

        return this;
    }

    /**
     * @returns {?boolean}
     */
    get freezeDefault() {
        return this._freezeDefault;
    }

    /**
     * @param {boolean} freeze
     * @returns {this}
     */
    setFreezeDefault(freeze) {
        this._requireNotFrozen();
        this._freezeDefault = freeze;

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * @param {Timestamp | Date} time
     * @returns {this}
     */
    setExpirationTime(time) {
        this._requireNotFrozen();
        this._autoRenewPeriod = null;
        this._expirationTime =
            time instanceof Timestamp ? time : Timestamp.fromDate(time);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @param {AccountId | string} id
     * @returns {this}
     */
    setAutoRenewAccountId(id) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            id instanceof AccountId ? id : AccountId.fromString(id);

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this token.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenMemo() {
        return this._tokenMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setTokenMemo(memo) {
        this._requireNotFrozen();
        this._tokenMemo = memo;

        return this;
    }

    /**
     * @returns {CustomFee[]}
     */
    get customFees() {
        return this._customFees;
    }

    /**
     * @param {CustomFee[]} customFees
     * @returns {this}
     */
    setCustomFees(customFees) {
        this._customFees = customFees;
        return this;
    }

    /**
     * @returns {?TokenType}
     */
    get tokenType() {
        return this._tokenType;
    }

    /**
     * @param {TokenType} tokenType
     * @returns {this}
     */
    setTokenType(tokenType) {
        this._tokenType = tokenType;
        return this;
    }

    /**
     * @returns {?TokenSupplyType}
     */
    get supplyType() {
        return this._supplyType;
    }

    /**
     * @param {TokenSupplyType} supplyType
     * @returns {this}
     */
    setSupplyType(supplyType) {
        this._supplyType = supplyType;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get maxSupply() {
        return this._maxSupply;
    }

    /**
     * @param {Long | number} maxSupply
     * @returns {this}
     */
    setMaxSupply(maxSupply) {
        this._maxSupply =
            typeof maxSupply === "number"
                ? long.fromNumber(maxSupply)
                : maxSupply;
        return this;
    }

    /**
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client) {
        if (
            this._autoRenewPeriod != null &&
            client != null &&
            client.operatorAccountId
        ) {
            this._autoRenewAccountId = client.operatorAccountId;
        }

        return super.freezeWith(client);
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._treasuryAccountId != null) {
            this._treasuryAccountId.validateChecksum(client);
        }

        if (this._autoRenewAccountId != null) {
            this._autoRenewAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.createToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenCreation";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            name: this._tokenName,
            symbol: this._tokenSymbol,
            decimals: this._decimals != null ? this._decimals.toInt() : null,
            initialSupply: this._initialSupply,
            treasury:
                this._treasuryAccountId != null
                    ? this._treasuryAccountId._toProtobuf()
                    : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
            freezeKey:
                this._freezeKey != null
                    ? this._freezeKey._toProtobufKey()
                    : null,
            pauseKey:
                this._pauseKey != null ? this._pauseKey._toProtobufKey() : null,
            wipeKey:
                this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
            supplyKey:
                this._supplyKey != null
                    ? this._supplyKey._toProtobufKey()
                    : null,
            feeScheduleKey:
                this._feeScheduleKey != null
                    ? this._feeScheduleKey._toProtobufKey()
                    : null,
            freezeDefault: this._freezeDefault,
            autoRenewAccount:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
            expiry:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
            memo: this._tokenMemo,
            customFees: this.customFees.map((fee) => fee._toProtobuf()),
            tokenType: this._tokenType != null ? this._tokenType._code : null,
            supplyType:
                this._supplyType != null ? this._supplyType._code : null,
            maxSupply: this.maxSupply,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenCreation",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenCreateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenDeleteTransactionBody} proto.ITokenDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Delete a new Hedera crypto-currency token.
 */
class TokenDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const deleteToken = /** @type {proto.ITokenDeleteTransactionBody} */ (
            body.tokenDeletion
        );

        return Transaction._fromProtobufTransactions(
            new TokenDeleteTransaction({
                tokenId:
                    deleteToken.token != null
                        ? TokenId._fromProtobuf(deleteToken.token)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.deleteToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenDeletion";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenDeletion",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenDeleteTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenDissociateTransactionBody} proto.ITokenDissociateTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Dissociate a new Hedera crypto-currency token.
 */
class TokenDissociateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {(TokenId | string)[]} [props.tokenIds]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId[]}
         */
        this._tokenIds = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        this._defaultMaxTransactionFee = new Hbar(5);

        if (props.tokenIds != null) {
            this.setTokenIds(props.tokenIds);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenDissociateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const dissociateToken =
            /** @type {proto.ITokenDissociateTransactionBody} */ (
                body.tokenDissociate
            );

        return Transaction._fromProtobufTransactions(
            new TokenDissociateTransaction({
                tokenIds:
                    dissociateToken.tokens != null
                        ? dissociateToken.tokens.map((token) =>
                              TokenId._fromProtobuf(token)
                          )
                        : undefined,
                accountId:
                    dissociateToken.account != null
                        ? AccountId._fromProtobuf(dissociateToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId[]}
     */
    get tokenIds() {
        return this._tokenIds;
    }

    /**
     * @param {(TokenId | string)[]} tokenIds
     * @returns {this}
     */
    setTokenIds(tokenIds) {
        this._requireNotFrozen();
        this._tokenIds = tokenIds.map((tokenId) =>
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone()
        );

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
            if (tokenId != null) {
                tokenId.validateChecksum(client);
            }
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.dissociateTokens(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenDissociate";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenDissociateTransactionBody}
     */
    _makeTransactionData() {
        return {
            tokens:
                this._tokenIds != null
                    ? this._tokenIds.map((tokenId) => tokenId._toProtobuf())
                    : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenDissociateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenDissociate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenDissociateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenFeeScheduleUpdateTransactionBody} proto.ITokenFeeScheduleUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./CustomFee.js").default} CustomFee
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * FeeScheduleUpdate a new Hedera crypto-currency token.
 */
class TokenFeeScheduleUpdateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {CustomFee[]} [props.customFees]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {CustomFee[]}
         */
        this._customFees = [];

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.customFees != null) {
            this.setCustomFees(props.customFees);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenFeeScheduleUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const feeScheduleUpdate =
            /** @type {proto.ITokenFeeScheduleUpdateTransactionBody} */ (
                body.tokenFeeScheduleUpdate
            );

        return Transaction._fromProtobufTransactions(
            new TokenFeeScheduleUpdateTransaction({
                tokenId:
                    feeScheduleUpdate.tokenId != null
                        ? TokenId._fromProtobuf(feeScheduleUpdate.tokenId)
                        : undefined,
                customFees:
                    feeScheduleUpdate.customFees != null
                        ? feeScheduleUpdate.customFees.map((fee) => {
                              if (fee.fixedFee != null) {
                                  return CustomFixedFee._fromProtobuf(fee);
                              } else if (fee.fractionalFee != null) {
                                  return CustomFractionalFee._fromProtobuf(fee);
                              } else {
                                  return CustomRoyalyFee._fromProtobuf(fee);
                              }
                          })
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : TokenId._fromProtobuf(tokenId._toProtobuf());

        return this;
    }

    /**
     * @returns {CustomFee[]}
     */
    get customFees() {
        return this._customFees;
    }

    /**
     * @param {CustomFee[]} fees
     * @returns {this}
     */
    setCustomFees(fees) {
        this._requireNotFrozen();
        this._customFees = fees;

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.updateTokenFeeSchedule(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenFeeScheduleUpdate";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenFeeScheduleUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            customFees: this._customFees.map((fee) => fee._toProtobuf()),
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenFeeScheduleUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenFeeScheduleUpdate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenFeeScheduleUpdateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenFreezeAccountTransactionBody} proto.ITokenFreezeAccountTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Freeze a new Hedera crypto-currency token.
 */
class TokenFreezeTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenFreezeTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const freezeToken =
            /** @type {proto.ITokenFreezeAccountTransactionBody} */ (
                body.tokenFreeze
            );

        return Transaction._fromProtobufTransactions(
            new TokenFreezeTransaction({
                tokenId:
                    freezeToken.token != null
                        ? TokenId._fromProtobuf(freezeToken.token)
                        : undefined,
                accountId:
                    freezeToken.account != null
                        ? AccountId._fromProtobuf(freezeToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.freezeTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenFreeze";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenFreezeAccountTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenFreezeTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenFreeze",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenFreezeTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenGrantKycTransactionBody} proto.ITokenGrantKycTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * GrantKyc a new Hedera crypto-currency token.
 */
class TokenGrantKycTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenGrantKycTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const grantKycToken =
            /** @type {proto.ITokenGrantKycTransactionBody} */ (
                body.tokenGrantKyc
            );

        return Transaction._fromProtobufTransactions(
            new TokenGrantKycTransaction({
                tokenId:
                    grantKycToken.token != null
                        ? TokenId._fromProtobuf(grantKycToken.token)
                        : undefined,
                accountId:
                    grantKycToken.account != null
                        ? AccountId._fromProtobuf(grantKycToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.grantKycToTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenGrantKyc";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenGrantKycTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenGrantKycTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenGrantKyc",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenGrantKycTransaction._fromProtobuf
);

/**
 * @typedef {import("./CustomFee.js").default} CustomFee
 */

/**
 * Response when the client sends the node TokenGetInfoQuery.
 */
class TokenInfo {
    /**
     * @private
     * @param {object} props
     * @param {TokenId} props.tokenId;
     * @param {string} props.name;
     * @param {string} props.symbol;
     * @param {number} props.decimals;
     * @param {Long} props.totalSupply;
     * @param {AccountId | null} props.treasuryAccountId;
     * @param {Key | null} props.adminKey;
     * @param {Key | null} props.kycKey;
     * @param {Key | null} props.freezeKey;
     * @param {Key | null} props.pauseKey;
     * @param {Key | null} props.wipeKey;
     * @param {Key | null} props.supplyKey;
     * @param {Key | null} props.feeScheduleKey;
     * @param {boolean | null} props.defaultFreezeStatus;
     * @param {boolean | null} props.defaultKycStatus;
     * @param {boolean | null} props.pauseStatus;
     * @param {boolean} props.isDeleted;
     * @param {AccountId | null} props.autoRenewAccountId;
     * @param {Duration | null} props.autoRenewPeriod;
     * @param {Timestamp | null} props.expirationTime;
     * @param {string} props.tokenMemo;
     * @param {CustomFee[]} props.customFees;
     * @param {TokenType | null} props.tokenType;
     * @param {TokenSupplyType | null} props.supplyType;
     * @param {Long | null} props.maxSupply;
     * @param {LedgerId|null} props.ledgerId
     */
    constructor(props) {
        /**
         * ID of the token instance
         *
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The name of the token. It is a string of ASCII only characters
         *
         * @readonly
         */
        this.name = props.name;

        /**
         * The symbol of the token. It is a UTF-8 capitalized alphabetical string
         *
         * @readonly
         */
        this.symbol = props.symbol;

        /**
         * The number of decimal places a token is divisible by
         *
         * @readonly
         */
        this.decimals = props.decimals;

        /**
         * The total supply of tokens that are currently in circulation
         *
         * @readonly
         */
        this.totalSupply = props.totalSupply;

        /**
         * The ID of the account which is set as treasuryAccountId
         *
         * @readonly
         */
        this.treasuryAccountId = props.treasuryAccountId;

        /**
         * The key which can perform update/delete operations on the token. If empty, the token can be perceived as
         * immutable (not being able to be updated/deleted)
         *
         * @readonly
         */
        this.adminKey = props.adminKey;

        /**
         * The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required,
         * and KYC grant or revoke operations are not possible.
         *
         * @readonly
         */
        this.kycKey = props.kycKey;

        /**
         * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is not possible
         *
         * @readonly
         */
        this.freezeKey = props.freezeKey;

        /**
         * The Key which can pause and unpause the Token.
         *
         * @readonly
         */
        this.pauseKey = props.pauseKey;

        /**
         * The key which can wipe token balance of an account. If empty, wipe is not possible
         *
         * @readonly
         */
        this.wipeKey = props.wipeKey;

        /**
         * The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
         *
         * @readonly
         */
        this.supplyKey = props.supplyKey;

        this.feeScheduleKey = props.feeScheduleKey;

        /**
         * The default Freeze status (not applicable = null, frozen = false, or unfrozen = true) of Hedera accounts relative to this token.
         * FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned if Token Freeze Key is set and
         * defaultFreeze is set to true. Unfrozen is returned if Token Freeze Key is set and defaultFreeze is set to false
         *      FreezeNotApplicable = null;
         *      Frozen = true;
         *      Unfrozen = false;
         *
         * @readonly
         */
        this.defaultFreezeStatus = props.defaultFreezeStatus;

        /**
         * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this token. KycNotApplicable
         * is returned if KYC key is not set, otherwise Revoked
         *      KycNotApplicable = null;
         *      Granted = true;
         *      Revoked = false;
         *
         * @readonly
         */
        this.defaultKycStatus = props.defaultKycStatus;

        /**
         * The default pause status of Hedera accounts relative to this token.
         * PauseNotApplicable is returned if pauseKey is not set
         *      PauseNotApplicable = null;
         *      Paused = true;
         *      Unpaused = false;
         *
         * @readonly
         */
        this.pauseStatus = props.pauseStatus;

        /**
         * Specifies whether the token was deleted or not
         *
         * @readonly
         */
        this.isDeleted = props.isDeleted;

        /**
         * An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
         *
         * @readonly
         */
        this.autoRenewAccountId = props.autoRenewAccountId;

        /**
         * The interval at which the auto-renew account will be charged to extend the token's expiry
         *
         * @readonly
         */
        this.autoRenewPeriod = props.autoRenewPeriod;

        /**
         * The epoch second at which the token expire: will; if an auto-renew account and period are specified,
         * this is coerced to the current epoch second plus the autoRenewPeriod
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * The memo associated with the token.
         *
         * @readonly
         */
        this.tokenMemo = props.tokenMemo;

        this.customFees = props.customFees;

        this.tokenType = props.tokenType;

        this.supplyType = props.supplyType;

        this.maxSupply = props.maxSupply;

        this.ledgerId = props.ledgerId;
    }

    /**
     * @internal
     * @param {proto.ITokenInfo} info
     * @returns {TokenInfo}
     */
    static _fromProtobuf(info) {
        const defaultFreezeStatus = /** @type {proto.TokenFreezeStatus} */ (
            info.defaultFreezeStatus
        );
        const defaultKycStatus = /** @type {proto.TokenKycStatus} */ (
            info.defaultKycStatus
        );
        const pauseStatus = /**@type {proto.TokenPauseStatus} */ (
            info.pauseStatus
        );

        const autoRenewAccountId =
            info.autoRenewAccount != null
                ? AccountId._fromProtobuf(info.autoRenewAccount)
                : new AccountId(0);

        return new TokenInfo({
            tokenId: TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (info.tokenId)
            ),
            name: /** @type {string} */ (info.name),
            symbol: /** @type {string} */ (info.symbol),
            decimals: /** @type {number} */ (info.decimals),
            totalSupply: long.fromValue(/** @type {Long} */ (info.totalSupply)),
            treasuryAccountId:
                info.treasury != null
                    ? AccountId._fromProtobuf(
                          /** @type {proto.IAccountID} */ (info.treasury)
                      )
                    : null,
            adminKey:
                info.adminKey != null
                    ? Key._fromProtobufKey(info.adminKey)
                    : null,
            kycKey:
                info.kycKey != null ? Key._fromProtobufKey(info.kycKey) : null,
            freezeKey:
                info.freezeKey != null
                    ? Key._fromProtobufKey(info.freezeKey)
                    : null,
            pauseKey:
                info.pauseKey != null
                    ? Key._fromProtobufKey(info.pauseKey)
                    : null,
            wipeKey:
                info.wipeKey != null
                    ? Key._fromProtobufKey(info.wipeKey)
                    : null,
            supplyKey:
                info.supplyKey != null
                    ? Key._fromProtobufKey(info.supplyKey)
                    : null,
            feeScheduleKey:
                info.feeScheduleKey != null
                    ? Key._fromProtobufKey(info.feeScheduleKey)
                    : null,
            defaultFreezeStatus:
                defaultFreezeStatus === 0 ? null : defaultFreezeStatus == 1,
            defaultKycStatus:
                defaultKycStatus === 0 ? null : defaultKycStatus == 1,
            pauseStatus: pauseStatus === 0 ? null : pauseStatus == 1,
            isDeleted: /** @type {boolean} */ (info.deleted),
            autoRenewAccountId: !(
                autoRenewAccountId.shard.toInt() == 0 &&
                autoRenewAccountId.realm.toInt() == 0 &&
                autoRenewAccountId.num.toInt() == 0
            )
                ? autoRenewAccountId
                : null,
            autoRenewPeriod:
                info.autoRenewPeriod != null
                    ? Duration._fromProtobuf(
                          /** @type {proto.IDuration} */ (info.autoRenewPeriod)
                      )
                    : null,
            expirationTime:
                info.expiry != null
                    ? Timestamp._fromProtobuf(
                          /** @type {proto.ITimestamp} */ (info.expiry)
                      )
                    : null,
            tokenMemo: info.memo != null ? info.memo : "",
            customFees:
                info.customFees != null
                    ? info.customFees.map((fee) => {
                          if (fee.fixedFee != null) {
                              return CustomFixedFee._fromProtobuf(fee);
                          } else if (fee.fractionalFee != null) {
                              return CustomFractionalFee._fromProtobuf(fee);
                          } else {
                              return CustomRoyalyFee._fromProtobuf(fee);
                          }
                      })
                    : [],
            tokenType:
                info.tokenType != null
                    ? TokenType$1._fromCode(info.tokenType)
                    : null,
            supplyType:
                info.supplyType != null
                    ? TokenSupplyType._fromCode(info.supplyType)
                    : null,
            maxSupply: info.maxSupply != null ? info.maxSupply : null,
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
        });
    }

    /**
     * @returns {proto.ITokenInfo}
     */
    _toProtobuf() {
        return {
            tokenId: this.tokenId._toProtobuf(),
            name: this.name,
            symbol: this.symbol,
            decimals: this.decimals,
            totalSupply: this.totalSupply,
            treasury:
                this.treasuryAccountId != null
                    ? this.treasuryAccountId._toProtobuf()
                    : null,
            adminKey:
                this.adminKey != null ? this.adminKey._toProtobufKey() : null,
            kycKey: this.kycKey != null ? this.kycKey._toProtobufKey() : null,
            freezeKey:
                this.freezeKey != null ? this.freezeKey._toProtobufKey() : null,
            pauseKey:
                this.pauseKey != null ? this.pauseKey._toProtobufKey() : null,
            wipeKey:
                this.wipeKey != null ? this.wipeKey._toProtobufKey() : null,
            supplyKey:
                this.supplyKey != null ? this.supplyKey._toProtobufKey() : null,
            feeScheduleKey:
                this.feeScheduleKey != null
                    ? this.feeScheduleKey._toProtobufKey()
                    : null,
            defaultFreezeStatus:
                this.defaultFreezeStatus == null
                    ? 0
                    : this.defaultFreezeStatus
                    ? 1
                    : 2,
            defaultKycStatus:
                this.defaultKycStatus == null
                    ? 0
                    : this.defaultKycStatus
                    ? 1
                    : 2,
            pauseStatus:
                this.pauseStatus == null ? 0 : this.pauseStatus ? 1 : 2,
            deleted: this.isDeleted,
            autoRenewAccount:
                this.autoRenewAccountId != null
                    ? this.autoRenewAccountId._toProtobuf()
                    : undefined,
            autoRenewPeriod:
                this.autoRenewPeriod != null
                    ? this.autoRenewPeriod._toProtobuf()
                    : null,
            expiry:
                this.expirationTime != null
                    ? this.expirationTime._toProtobuf()
                    : null,
            memo: this.tokenMemo,
            customFees: this.customFees.map((fee) => fee._toProtobuf()),
            tokenType: this.tokenType != null ? this.tokenType._code : null,
            supplyType: this.supplyType != null ? this.supplyType._code : null,
            maxSupply: this.maxSupply,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TokenInfo}
     */
    static fromBytes(bytes) {
        return TokenInfo._fromProtobuf(lib.TokenInfo.decode(bytes));
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.TokenInfo.encode(this._toProtobuf()).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ITokenInfo} proto.ITokenInfo
 * @typedef {import("@hashgraph/proto").ITokenGetInfoQuery} proto.ITokenGetInfoQuery
 * @typedef {import("@hashgraph/proto").ITokenGetInfoResponse} proto.ITokenGetInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<TokenInfo>}
 */
class TokenInfoQuery extends Query {
    /**
     * @param {object} properties
     * @param {TokenId | string} [properties.tokenId]
     */
    constructor(properties = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;
        if (properties.tokenId != null) {
            this.setTokenId(properties.tokenId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {TokenInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {proto.ITokenGetInfoQuery} */ (
            query.tokenGetInfo
        );

        return new TokenInfoQuery({
            tokenId:
                info.token != null
                    ? TokenId._fromProtobuf(info.token)
                    : undefined,
        });
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * Set the token ID for which the info is being requested.
     *
     * @param {TokenId | string} tokenId
     * @returns {TokenInfoQuery}
     */
    setTokenId(tokenId) {
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        let cost = await super.getCost(client);

        if (cost.toTinybars().greaterThan(25)) {
            return cost;
        } else {
            return Hbar.fromTinybars(25);
        }
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.token.getTokenInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const tokenGetInfo = /** @type {proto.ITokenGetInfoResponse} */ (
            response.tokenGetInfo
        );
        return /** @type {proto.IResponseHeader} */ (tokenGetInfo.header);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<TokenInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {proto.ITokenGetInfoResponse} */ (
            response.tokenGetInfo
        );

        return Promise.resolve(
            TokenInfo._fromProtobuf(
                /** @type {proto.ITokenInfo} */ (info.tokenInfo)
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            tokenGetInfo: {
                header,
                token:
                    this._tokenId != null ? this._tokenId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `TokenInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("tokenGetInfo", TokenInfoQuery._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenMintTransactionBody} proto.ITokenMintTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Mint a new Hedera crypto-currency token.
 */
class TokenMintTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {Long | number} [props.amount]
     * @param {Uint8Array[]} [props.metadata]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._amount = null;

        /**
         * @private
         * @type {Uint8Array[]}
         */
        this._metadata = [];

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.amount != null) {
            this.setAmount(props.amount);
        }

        if (props.metadata != null) {
            this.setMetadata(props.metadata);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenMintTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const mintToken = /** @type {proto.ITokenMintTransactionBody} */ (
            body.tokenMint
        );

        return Transaction._fromProtobufTransactions(
            new TokenMintTransaction({
                tokenId:
                    mintToken.token != null
                        ? TokenId._fromProtobuf(mintToken.token)
                        : undefined,
                amount: mintToken.amount != null ? mintToken.amount : undefined,
                metadata:
                    mintToken.metadata != null ? mintToken.metadata : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {this}
     */
    setAmount(amount) {
        this._requireNotFrozen();
        this._amount = amount instanceof long ? amount : long.fromValue(amount);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @returns {Uint8Array[]}
     */
    get metadata() {
        return this._metadata;
    }

    /**
     * @param {Uint8Array | string} metadata
     * @returns {this}
     */
    addMetadata(metadata) {
        this._requireNotFrozen();

        if (typeof metadata === "string") {
            console.warn(
                "Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead."
            );
        }

        this._metadata.push(
            typeof metadata === "string" ? decode$1(metadata) : metadata
        );

        return this;
    }

    /**
     * @param {Uint8Array[]} metadata
     * @returns {this}
     */
    setMetadata(metadata) {
        this._requireNotFrozen();

        for (const data of metadata) {
            if (typeof data === "string") {
                console.warn(
                    "Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead."
                );
                break;
            }
        }

        this._metadata = metadata.map((data) =>
            typeof data === "string" ? decode$1(data) : data
        );

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.mintToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenMint";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenMintTransactionBody}
     */
    _makeTransactionData() {
        return {
            amount: this._amount,
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            metadata: this._metadata,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenMintTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenMint",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenMintTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").TokenFreezeStatus} proto.TokenFreezeStatus
 * @typedef {import("@hashgraph/proto").TokenKycStatus} proto.TokenKycStatus
 * @typedef {import("@hashgraph/proto").TokenPauseStatus} proto.TokenPauseStatus
 * @typedef {import("@hashgraph/proto").ITokenNftInfo} proto.ITokenNftInfo
 * @typedef {import("@hashgraph/proto").INftID} proto.INftID
 * @typedef {import("@hashgraph/proto").ITimestamp} proto.ITimestamp
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IKey} proto.IKey
 * @typedef {import("@hashgraph/proto").IDuration} proto.IDuration
 */

class TokenNftInfo {
    /**
     * @private
     * @param {object} props
     * @param {NftId} props.nftId
     * @param {AccountId} props.accountId
     * @param {Timestamp} props.creationTime
     * @param {Uint8Array | null} props.metadata
     * @param {LedgerId|null} props.ledgerId
     */
    constructor(props) {
        /**
         * ID of the nft instance
         *
         * @readonly
         */
        this.nftId = props.nftId;

        /**
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * @readonly
         */
        this.creationTime = props.creationTime;

        /**
         * @readonly
         */
        this.metadata = props.metadata;

        this.ledgerId = props.ledgerId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.ITokenNftInfo} info
     * @returns {TokenNftInfo}
     */
    static _fromProtobuf(info) {
        return new TokenNftInfo({
            nftId: NftId._fromProtobuf(
                /** @type {proto.INftID} */ (info.nftID)
            ),
            accountId: AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (info.accountID)
            ),
            creationTime: Timestamp._fromProtobuf(
                /** @type {proto.ITimestamp} */ (info.creationTime)
            ),
            metadata: info.metadata !== undefined ? info.metadata : null,
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
        });
    }

    /**
     * @returns {proto.ITokenNftInfo}
     */
    _toProtobuf() {
        return {
            nftID: this.nftId._toProtobuf(),
            accountID: this.accountId._toProtobuf(),
            creationTime: this.creationTime._toProtobuf(),
            metadata: this.metadata,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
        };
    }

    /**
     * @typedef {object} TokenNftInfoJson
     * @property {string} nftId
     * @property {string} accountId
     * @property {string} creationTime
     * @property {string | null} metadata
     * @property {string | null} ledgerId
     * @returns {TokenNftInfoJson}
     */
    toJson() {
        return {
            nftId: this.nftId.toString(),
            accountId: this.accountId.toString(),
            creationTime: this.creationTime.toString(),
            metadata: this.metadata != null ? encode$1(this.metadata) : null,
            ledgerId: this.ledgerId != null ? this.ledgerId.toString() : null,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJson());
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").ITokenNftInfo} proto.ITokenNftInfo
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").ITokenGetNftInfoQuery} proto.ITokenGetNftInfoQuery
 * @typedef {import("@hashgraph/proto").ITokenGetNftInfosQuery} proto.ITokenGetNftInfosQuery
 * @typedef {import("@hashgraph/proto").ITokenGetAccountNftInfosQuery} proto.ITokenGetAccountNftInfosQuery
 * @typedef {import("@hashgraph/proto").ITokenGetNftInfoResponse} proto.ITokenGetNftInfoResponse
 * @typedef {import("@hashgraph/proto").ITokenGetNftInfosResponse} proto.ITokenGetNftInfosResponse
 * @typedef {import("@hashgraph/proto").ITokenGetAccountNftInfosResponse} proto.ITokenGetAccountNftInfosResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 */

/**
 * @augments {Query<TokenNftInfo[]>}
 */
class TokenNftInfoQuery extends Query {
    /**
     * @param {object} properties
     * @param {NftId | string} [properties.nftId]
     * @param {AccountId | string} [properties.accountId]
     * @param {TokenId | string} [properties.tokenId]
     * @param {Long | number} [properties.start]
     * @param {Long | number} [properties.end]
     */
    constructor(properties = {}) {
        super();

        /**
         * @private
         * @type {?NftId}
         */
        this._nftId = null;
        if (properties.nftId != null) {
            this.setNftId(properties.nftId);
        }

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;
        if (properties.accountId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setAccountId(properties.accountId);
        }

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;
        if (properties.tokenId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setTokenId(properties.tokenId);
        }

        /**
         * @private
         * @type {?Long}
         */
        this._start = null;
        if (properties.start != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setStart(properties.start);
        }

        /**
         * @private
         * @type {?Long}
         */
        this._end = null;
        if (properties.end != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setEnd(properties.end);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {TokenNftInfoQuery}
     */
    static _fromProtobuf(query) {
        if (query.tokenGetNftInfo != null) {
            const info = /** @type {proto.ITokenGetNftInfoQuery} */ (
                query.tokenGetNftInfo
            );

            return new TokenNftInfoQuery({
                nftId:
                    info.nftID != null
                        ? NftId._fromProtobuf(info.nftID)
                        : undefined,
            });
        } else if (query.tokenGetAccountNftInfos != null) {
            const info = /** @type {proto.ITokenGetAccountNftInfosQuery} */ (
                query.tokenGetAccountNftInfos
            );

            return new TokenNftInfoQuery({
                accountId:
                    info.accountID != null
                        ? AccountId._fromProtobuf(info.accountID)
                        : undefined,
                start: info.start != null ? info.start : undefined,
                end: info.end != null ? info.end : undefined,
            });
        } else {
            const info = /** @type {proto.ITokenGetNftInfosQuery} */ (
                query.tokenGetNftInfos
            );

            return new TokenNftInfoQuery({
                tokenId:
                    info.tokenID != null
                        ? TokenId._fromProtobuf(info.tokenID)
                        : undefined,
                start: info.start != null ? info.start : undefined,
                end: info.end != null ? info.end : undefined,
            });
        }
    }

    /**
     * @returns {?NftId}
     */
    get nftId() {
        return this._nftId;
    }

    /**
     * Set the token ID for which the info is being requested.
     *
     * @param {NftId | string} nftId
     * @returns {TokenNftInfoQuery}
     */
    setNftId(nftId) {
        this._nftId =
            typeof nftId === "string"
                ? NftId.fromString(nftId)
                : NftId._fromProtobuf(nftId._toProtobuf());

        return this;
    }

    /**
     * @deprecated with no replacement
     * @returns {?AccountId}
     */
    get accountId() {
        console.warn(
            "`TokenNftInfoQuery.accountId` is deprecated with no replacement"
        );
        return this._accountId;
    }

    /**
     * @deprecated with no replacement
     * Set the token ID for which the info is being requested.
     * @param {AccountId | string} accountId
     * @returns {TokenNftInfoQuery}
     */
    setAccountId(accountId) {
        console.warn(
            "`TokenNftInfoQuery.setAccountId()` is deprecated with no replacement"
        );
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : AccountId._fromProtobuf(accountId._toProtobuf());

        return this;
    }

    /**
     * @deprecated with no replacement
     * @returns {?TokenId}
     */
    get tokenId() {
        console.warn(
            "`TokenNftInfoQuery.tokenId` is deprecated with no replacement"
        );
        return this._tokenId;
    }

    /**
     * @deprecated with no replacement
     * Set the token ID for which the info is being requested.
     * @param {TokenId | string} tokenId
     * @returns {TokenNftInfoQuery}
     */
    setTokenId(tokenId) {
        console.warn(
            "`TokenNftInfoQuery.setTokenId()` is deprecated with no replacement"
        );
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : TokenId._fromProtobuf(tokenId._toProtobuf());

        return this;
    }

    /**
     * @deprecated with no replacement
     * @returns {?Long}
     */
    get start() {
        console.warn(
            "`TokenNftInfoQuery.start` is deprecated with no replacement"
        );
        return this._start;
    }

    /**
     * @deprecated with no replacement
     * Set the token ID for which the info is being requested.
     * @param {Long | number} start
     * @returns {TokenNftInfoQuery}
     */
    setStart(start) {
        console.warn(
            "`TokenNftInfoQuery.setStart()` is deprecated with no replacement"
        );
        this._start =
            typeof start === "number" ? long.fromNumber(start) : start;

        return this;
    }

    /**
     * @deprecated with no replacement
     * @returns {?Long}
     */
    get end() {
        console.warn(
            "`TokenNftInfoQuery.end` is deprecated with no replacement"
        );
        return this._end;
    }

    /**
     * @deprecated with no replacement
     * Set the token ID for which the info is being requested.
     * @param {Long | number} end
     * @returns {TokenNftInfoQuery}
     */
    setEnd(end) {
        console.warn(
            "`TokenNftInfoQuery.setEnd()` is deprecated with no replacement"
        );
        this._end = typeof end === "number" ? long.fromNumber(end) : end;

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        let cost = await super.getCost(client);

        if (cost.toTinybars().greaterThan(25)) {
            return cost;
        } else {
            return Hbar.fromTinybars(25);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.token.getTokenNftInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const infos = /** @type {proto.ITokenGetNftInfoResponse} */ (
            response.tokenGetNftInfo
        );

        return /** @type {proto.IResponseHeader} */ (infos.header);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<TokenNftInfo[]>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const nfts = [
            /** @type {proto.ITokenNftInfo} */
            (
                /** @type {proto.ITokenGetNftInfoResponse} */ (
                    response.tokenGetNftInfo
                ).nft
            ),
        ];

        return Promise.resolve(
            nfts.map((nft) =>
                TokenNftInfo._fromProtobuf(
                    /** @type {proto.ITokenNftInfo} */ (nft)
                )
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            tokenGetNftInfo: {
                header,
                nftID: this._nftId != null ? this._nftId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `TokenNftInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("tokenGetNftInfo", TokenNftInfoQuery._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenPauseTransactionBody} proto.ITokenPauseTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Pause a new Hedera crypto-currency token.
 */
class TokenPauseTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenPauseTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const pauseToken = /** @type {proto.ITokenPauseTransactionBody} */ (
            body.tokenPause
        );

        return Transaction._fromProtobufTransactions(
            new TokenPauseTransaction({
                tokenId:
                    pauseToken.token != null
                        ? TokenId._fromProtobuf(pauseToken.token)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.pauseToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenPause";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenPauseTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenPauseTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenPause",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenPauseTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenRevokeKycTransactionBody} proto.ITokenRevokeKycTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * RevokeKyc a new Hedera crypto-currency token.
 */
class TokenRevokeKycTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenRevokeKycTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const revokeKycToken =
            /** @type {proto.ITokenRevokeKycTransactionBody} */ (
                body.tokenRevokeKyc
            );

        return Transaction._fromProtobufTransactions(
            new TokenRevokeKycTransaction({
                tokenId:
                    revokeKycToken.token != null
                        ? TokenId._fromProtobuf(revokeKycToken.token)
                        : undefined,
                accountId:
                    revokeKycToken.account != null
                        ? AccountId._fromProtobuf(revokeKycToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.revokeKycFromTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenRevokeKyc";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenRevokeKycTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenRevokeKycTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenRevokeKyc",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenRevokeKycTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenUnfreezeAccountTransactionBody} proto.ITokenUnfreezeAccountTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Unfreeze a new Hedera crypto-currency token.
 */
class TokenUnfreezeTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenUnfreezeTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const unfreezeToken =
            /** @type {proto.ITokenUnfreezeAccountTransactionBody} */ (
                body.tokenUnfreeze
            );

        return Transaction._fromProtobufTransactions(
            new TokenUnfreezeTransaction({
                tokenId:
                    unfreezeToken.token != null
                        ? TokenId._fromProtobuf(unfreezeToken.token)
                        : undefined,
                accountId:
                    unfreezeToken.account != null
                        ? AccountId._fromProtobuf(unfreezeToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.unfreezeTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenUnfreeze";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenUnfreezeAccountTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenUnfreezeTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenUnfreeze",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenUnfreezeTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenUnpauseTransactionBody} proto.ITokenUnpauseTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Unpause a new Hedera crypto-currency token.
 */
class TokenUnpauseTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenUnpauseTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const unpauseToken = /** @type {proto.ITokenUnpauseTransactionBody} */ (
            body.tokenUnpause
        );

        return Transaction._fromProtobufTransactions(
            new TokenUnpauseTransaction({
                tokenId:
                    unpauseToken.token != null
                        ? TokenId._fromProtobuf(unpauseToken.token)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.unpauseToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenUnpause";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenUnpauseTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenUnpauseTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenUnpause",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenUnpauseTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenUpdateTransactionBody} proto.ITokenUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Update a new Hedera crypto-currency token.
 */
class TokenUpdateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {string} [props.tokenName]
     * @param {string} [props.tokenSymbol]
     * @param {AccountId | string} [props.treasuryAccountId]
     * @param {Key} [props.adminKey]
     * @param {Key} [props.kycKey]
     * @param {Key} [props.freezeKey]
     * @param {Key} [props.wipeKey]
     * @param {Key} [props.supplyKey]
     * @param {AccountId | string} [props.autoRenewAccountId]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {string} [props.tokenMemo]
     * @param {Key} [props.feeScheduleKey]
     * @param {Key} [props.pauseKey]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?string}
         */
        this._tokenName = null;

        /**
         * @private
         * @type {?string}
         */
        this._tokenSymbol = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._treasuryAccountId = null;

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._kycKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._freezeKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._wipeKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._supplyKey = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = null;

        /**
         * @private
         * @type {?string}
         */
        this._tokenMemo = null;

        /**
         * @private
         * @type {?Key}
         */
        this._feeScheduleKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._pauseKey = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.tokenName != null) {
            this.setTokenName(props.tokenName);
        }

        if (props.tokenSymbol != null) {
            this.setTokenSymbol(props.tokenSymbol);
        }

        if (props.treasuryAccountId != null) {
            this.setTreasuryAccountId(props.treasuryAccountId);
        }

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.kycKey != null) {
            this.setKycKey(props.kycKey);
        }

        if (props.freezeKey != null) {
            this.setFreezeKey(props.freezeKey);
        }

        if (props.wipeKey != null) {
            this.setWipeKey(props.wipeKey);
        }

        if (props.supplyKey != null) {
            this.setSupplyKey(props.supplyKey);
        }

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.tokenMemo != null) {
            this.setTokenMemo(props.tokenMemo);
        }

        if (props.feeScheduleKey != null) {
            this.setFeeScheduleKey(props.feeScheduleKey);
        }

        if (props.pauseKey != null) {
            this.setPauseKey(props.pauseKey);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const update = /** @type {proto.ITokenUpdateTransactionBody} */ (
            body.tokenUpdate
        );

        return Transaction._fromProtobufTransactions(
            new TokenUpdateTransaction({
                tokenId:
                    update.token != null
                        ? TokenId._fromProtobuf(update.token)
                        : undefined,
                tokenName: update.name != null ? update.name : undefined,
                tokenSymbol: update.symbol != null ? update.symbol : undefined,
                treasuryAccountId:
                    update.treasury != null
                        ? AccountId._fromProtobuf(update.treasury)
                        : undefined,
                adminKey:
                    update.adminKey != null
                        ? Key._fromProtobufKey(update.adminKey)
                        : undefined,
                kycKey:
                    update.kycKey != null
                        ? Key._fromProtobufKey(update.kycKey)
                        : undefined,
                freezeKey:
                    update.freezeKey != null
                        ? Key._fromProtobufKey(update.freezeKey)
                        : undefined,
                wipeKey:
                    update.wipeKey != null
                        ? Key._fromProtobufKey(update.wipeKey)
                        : undefined,
                supplyKey:
                    update.supplyKey != null
                        ? Key._fromProtobufKey(update.supplyKey)
                        : undefined,
                autoRenewAccountId:
                    update.autoRenewAccount != null
                        ? AccountId._fromProtobuf(update.autoRenewAccount)
                        : undefined,
                expirationTime:
                    update.expiry != null
                        ? Timestamp._fromProtobuf(update.expiry)
                        : undefined,
                autoRenewPeriod:
                    update.autoRenewPeriod != null
                        ? Duration._fromProtobuf(update.autoRenewPeriod)
                        : undefined,
                tokenMemo:
                    update.memo != null
                        ? update.memo.value != null
                            ? update.memo.value
                            : undefined
                        : undefined,
                feeScheduleKey:
                    update.feeScheduleKey != null
                        ? Key._fromProtobufKey(update.feeScheduleKey)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenName() {
        return this._tokenName;
    }

    /**
     * @param {string} name
     * @returns {this}
     */
    setTokenName(name) {
        this._requireNotFrozen();
        this._tokenName = name;

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenSymbol() {
        return this._tokenSymbol;
    }

    /**
     * @param {string} symbol
     * @returns {this}
     */
    setTokenSymbol(symbol) {
        this._requireNotFrozen();
        this._tokenSymbol = symbol;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get treasuryAccountId() {
        return this._treasuryAccountId;
    }

    /**
     * @param {AccountId | string} id
     * @returns {this}
     */
    setTreasuryAccountId(id) {
        this._requireNotFrozen();
        this._treasuryAccountId =
            typeof id === "string" ? AccountId.fromString(id) : id.clone();

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setAdminKey(key) {
        this._requireNotFrozen();
        this._adminKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get kycKey() {
        return this._kycKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setKycKey(key) {
        this._requireNotFrozen();
        this._kycKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get freezeKey() {
        return this._freezeKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setFreezeKey(key) {
        this._requireNotFrozen();
        this._freezeKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get wipeKey() {
        return this._wipeKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setWipeKey(key) {
        this._requireNotFrozen();
        this._wipeKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get supplyKey() {
        return this._supplyKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setSupplyKey(key) {
        this._requireNotFrozen();
        this._supplyKey = key;

        return this;
    }

    /**
     * @deprecated
     * @param {Key} key
     * @returns {this}
     */
    setsupplyKey(key) {
        this._requireNotFrozen();
        this._supplyKey = key;

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * @param {Timestamp | Date} time
     * @returns {this}
     */
    setExpirationTime(time) {
        this._requireNotFrozen();
        this._expirationTime =
            time instanceof Timestamp ? time : Timestamp.fromDate(time);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @param {AccountId | string} id
     * @returns {this}
     */
    setAutoRenewAccountId(id) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            id instanceof AccountId ? id : AccountId.fromString(id);

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this token.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenMemo() {
        return this._tokenMemo;
    }

    /**
     * @param {string} tokenMemo
     * @returns {this}
     */
    setTokenMemo(tokenMemo) {
        this._requireNotFrozen();
        this._tokenMemo = tokenMemo;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get feeScheduleKey() {
        return this._feeScheduleKey;
    }

    /**
     * @param {Key} feeScheduleKey
     * @returns {this}
     */
    setFeeScheduleKey(feeScheduleKey) {
        this._requireNotFrozen();
        this._feeScheduleKey = feeScheduleKey;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get pauseKey() {
        return this._pauseKey;
    }

    /**
     * @param {Key} pauseKey
     * @returns {this}
     */
    setPauseKey(pauseKey) {
        this._requireNotFrozen();
        this._pauseKey = pauseKey;
        return this;
    }

    /**
     * @returns {this}
     */
    clearTokenMemo() {
        this._requireNotFrozen();
        this._tokenMemo = null;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._treasuryAccountId != null) {
            this._treasuryAccountId.validateChecksum(client);
        }

        if (this._autoRenewAccountId != null) {
            this._autoRenewAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.updateToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenUpdate";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            name: this.tokenName,
            symbol: this.tokenSymbol,
            treasury:
                this._treasuryAccountId != null
                    ? this._treasuryAccountId._toProtobuf()
                    : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
            freezeKey:
                this._freezeKey != null
                    ? this._freezeKey._toProtobufKey()
                    : null,
            wipeKey:
                this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
            supplyKey:
                this._supplyKey != null
                    ? this._supplyKey._toProtobufKey()
                    : null,
            autoRenewAccount:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
            expiry:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
            memo:
                this._tokenMemo != null
                    ? {
                          value: this._tokenMemo,
                      }
                    : null,
            feeScheduleKey:
                this._feeScheduleKey != null
                    ? this._feeScheduleKey._toProtobufKey()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenUpdate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenUpdateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ITokenWipeAccountTransactionBody} proto.ITokenWipeAccountTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Wipe a new Hedera crypto-currency token.
 */
class TokenWipeTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     * @param {Long | number} [props.amount]
     * @param {(Long | number)[]} [props.serials]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        /**
         * @private
         * @type {Long[]}
         */
        this._serials = [];

        /**
         * @private
         * @type {?Long}
         */
        this._amount = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        if (props.amount != null) {
            this.setAmount(props.amount);
        }

        if (props.serials != null) {
            this.setSerials(props.serials);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TokenWipeTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const wipeToken =
            /** @type {proto.ITokenWipeAccountTransactionBody} */ (
                body.tokenWipe
            );

        return Transaction._fromProtobufTransactions(
            new TokenWipeTransaction({
                tokenId:
                    wipeToken.token != null
                        ? TokenId._fromProtobuf(wipeToken.token)
                        : undefined,
                accountId:
                    wipeToken.account != null
                        ? AccountId._fromProtobuf(wipeToken.account)
                        : undefined,
                amount: wipeToken.amount != null ? wipeToken.amount : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {this}
     */
    setAmount(amount) {
        this._requireNotFrozen();
        this._amount = amount instanceof long ? amount : long.fromValue(amount);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @returns {Long[]}
     */
    get serials() {
        return this._serials;
    }

    /**
     * @param {(Long | number)[]} serials
     * @returns {this}
     */
    setSerials(serials) {
        this._requireNotFrozen();
        this._serials = serials.map((serial) =>
            typeof serial === "number" ? long.fromNumber(serial) : serial
        );

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.wipeTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenWipe";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ITokenWipeAccountTransactionBody}
     */
    _makeTransactionData() {
        return {
            amount: this._amount,
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            serialNumbers: this.serials,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenWipeTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenWipe",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenWipeTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusCreateTopicTransactionBody} proto.IConsensusCreateTopicTransactionBody
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a topic to be used for consensus.
 */
class TopicCreateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {Key} [props.adminKey]
     * @param {Key} [props.submitKey]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {AccountId | string} [props.autoRenewAccountId]
     * @param {string} [props.topicMemo]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._submitKey = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        /**
         * @private
         * @type {Duration}
         */
        this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

        /**
         * @private
         * @type {?string}
         */
        this._topicMemo = null;

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.submitKey != null) {
            this.setSubmitKey(props.submitKey);
        }

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.topicMemo != null) {
            this.setTopicMemo(props.topicMemo);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TopicCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const create =
            /** @type {proto.IConsensusCreateTopicTransactionBody} */ (
                body.consensusCreateTopic
            );

        return Transaction._fromProtobufTransactions(
            new TopicCreateTransaction({
                adminKey:
                    create.adminKey != null
                        ? Key._fromProtobufKey(create.adminKey)
                        : undefined,
                submitKey:
                    create.submitKey != null
                        ? Key._fromProtobufKey(create.submitKey)
                        : undefined,
                autoRenewAccountId:
                    create.autoRenewAccount != null
                        ? AccountId._fromProtobuf(create.autoRenewAccount)
                        : undefined,
                autoRenewPeriod:
                    create.autoRenewPeriod != null
                        ? create.autoRenewPeriod.seconds != null
                            ? create.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                topicMemo: create.memo != null ? create.memo : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?string}
     */
    get topicMemo() {
        return this._topicMemo;
    }

    /**
     * @param {string} topicMemo
     * @returns {this}
     */
    setTopicMemo(topicMemo) {
        this._requireNotFrozen();
        this._topicMemo = topicMemo;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} adminKey
     * @returns {this}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get submitKey() {
        return this._submitKey;
    }

    /**
     * @param {Key} submitKey
     * @returns {this}
     */
    setSubmitKey(submitKey) {
        this._requireNotFrozen();
        this._submitKey = submitKey;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @param {AccountId | string} autoRenewAccountId
     * @returns {this}
     */
    setAutoRenewAccountId(autoRenewAccountId) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            autoRenewAccountId instanceof AccountId
                ? autoRenewAccountId
                : AccountId.fromString(autoRenewAccountId);

        return this;
    }

    /**
     * @returns {Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this account.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._autoRenewAccountId != null) {
            this._autoRenewAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.createTopic(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "consensusCreateTopic";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IConsensusCreateTopicTransactionBody}
     */
    _makeTransactionData() {
        return {
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            submitKey:
                this._submitKey != null
                    ? this._submitKey._toProtobufKey()
                    : null,
            autoRenewAccount:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
            autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
            memo: this._topicMemo,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TopicCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "consensusCreateTopic",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TopicCreateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusDeleteTopicTransactionBody} proto.IConsensusDeleteTopicTransactionBody
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Delete a topic.
 *
 * No more transactions or queries on the topic will succeed.
 *
 * If an adminKey is set, this transaction must be signed by that key.
 * If there is no adminKey, this transaction will fail with Status#Unautorized.
 */
class TopicDeleteTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {TopicId | string} [props.topicId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TopicId}
         */
        this._topicId = null;

        if (props.topicId != null) {
            this.setTopicId(props.topicId);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TopicDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const topicDelete =
            /** @type {proto.IConsensusDeleteTopicTransactionBody} */ (
                body.consensusDeleteTopic
            );

        return Transaction._fromProtobufTransactions(
            new TopicDeleteTransaction({
                topicId:
                    topicDelete.topicID != null
                        ? TopicId._fromProtobuf(topicDelete.topicID)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TopicId}
     */
    get topicId() {
        return this._topicId;
    }

    /**
     * Set the topic ID which is being deleted in this transaction.
     *
     * @param {TopicId | string} topicId
     * @returns {TopicDeleteTransaction}
     */
    setTopicId(topicId) {
        this._requireNotFrozen();
        this._topicId =
            typeof topicId === "string"
                ? TopicId.fromString(topicId)
                : topicId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._topicId != null) {
            this._topicId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.deleteTopic(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "consensusDeleteTopic";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IConsensusDeleteTopicTransactionBody}
     */
    _makeTransactionData() {
        return {
            topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TopicDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "consensusDeleteTopic",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TopicDeleteTransaction._fromProtobuf
);

/**
 * Current state of a topic.
 */
class TopicInfo {
    /**
     * @private
     * @param {object} props
     * @param {TopicId} props.topicId
     * @param {string} props.topicMemo
     * @param {Uint8Array} props.runningHash
     * @param {Long} props.sequenceNumber
     * @param {?Timestamp} props.expirationTime
     * @param {?Key} props.adminKey
     * @param {?Key} props.submitKey
     * @param {?Duration} props.autoRenewPeriod
     * @param {?AccountId} props.autoRenewAccountId
     * @param {LedgerId|null} props.ledgerId
     */
    constructor(props) {
        /**
         * The ID of the topic for which information is requested.
         *
         * @readonly
         */
        this.topicId = props.topicId;

        /**
         * Short publicly visible memo about the topic. No guarantee of uniqueness.
         *
         * @readonly
         */
        this.topicMemo = props.topicMemo;

        /**
         * SHA-384 running hash of (previousRunningHash, topicId, consensusTimestamp, sequenceNumber, message).
         *
         * @readonly
         */
        this.runningHash = props.runningHash;

        /**
         * Sequence number (starting at 1 for the first submitMessage) of messages on the topic.
         *
         * @readonly
         */
        this.sequenceNumber = props.sequenceNumber;

        /**
         * Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic.
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * Access control for update/delete of the topic. Null if there is no key.
         *
         * @readonly
         */
        this.adminKey = props.adminKey;

        /**
         * Access control for ConsensusService.submitMessage. Null if there is no key.
         *
         * @readonly
         */
        this.submitKey = props.submitKey;

        /**
         * @readonly
         */
        this.autoRenewPeriod = props.autoRenewPeriod;

        /**
         * @readonly
         */
        this.autoRenewAccountId = props.autoRenewAccountId;

        this.ledgerId = props.ledgerId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {proto.IConsensusGetTopicInfoResponse} infoResponse
     * @returns {TopicInfo}
     */
    static _fromProtobuf(infoResponse) {
        const info = /** @type {proto.IConsensusTopicInfo} */ (
            infoResponse.topicInfo
        );

        return new TopicInfo({
            topicId: TopicId._fromProtobuf(
                /** @type {proto.ITopicID} */ (infoResponse.topicID)
            ),
            topicMemo: info.memo != null ? info.memo : "",
            runningHash:
                info.runningHash != null ? info.runningHash : new Uint8Array(),
            sequenceNumber:
                info.sequenceNumber != null
                    ? info.sequenceNumber instanceof long
                        ? info.sequenceNumber
                        : long.fromValue(info.sequenceNumber)
                    : long.ZERO,
            expirationTime:
                info.expirationTime != null
                    ? Timestamp._fromProtobuf(info.expirationTime)
                    : null,
            adminKey:
                info.adminKey != null
                    ? Key._fromProtobufKey(info.adminKey)
                    : null,
            submitKey:
                info.submitKey != null
                    ? Key._fromProtobufKey(info.submitKey)
                    : null,
            autoRenewPeriod:
                info.autoRenewPeriod != null
                    ? new Duration(
                          /** @type {Long} */ (info.autoRenewPeriod.seconds)
                      )
                    : null,
            autoRenewAccountId:
                info.autoRenewAccount != null
                    ? AccountId._fromProtobuf(info.autoRenewAccount)
                    : null,
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
        });
    }

    /**
     * @internal
     * @returns {proto.IConsensusGetTopicInfoResponse}
     */
    _toProtobuf() {
        return {
            topicID: this.topicId._toProtobuf(),
            topicInfo: {
                memo: this.topicMemo,
                runningHash: this.runningHash,
                sequenceNumber: this.sequenceNumber,
                expirationTime:
                    this.expirationTime != null
                        ? this.expirationTime._toProtobuf()
                        : null,
                adminKey:
                    this.adminKey != null
                        ? this.adminKey._toProtobufKey()
                        : null,
                submitKey:
                    this.submitKey != null
                        ? this.submitKey._toProtobufKey()
                        : null,
                autoRenewPeriod:
                    this.autoRenewPeriod != null
                        ? this.autoRenewPeriod._toProtobuf()
                        : null,
                autoRenewAccount:
                    this.autoRenewAccountId != null
                        ? this.autoRenewAccountId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TopicInfo}
     */
    static fromBytes(bytes) {
        return TopicInfo._fromProtobuf({
            topicInfo: lib.ConsensusTopicInfo.decode(bytes),
        });
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return lib.ConsensusTopicInfo.encode(
            /** @type {proto.IConsensusTopicInfo} */ (
                this._toProtobuf().topicInfo
            )
        ).finish();
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IResponseHeader} proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").IConsensusTopicQuery} proto.IConsensusTopicQuery
 * @typedef {import("@hashgraph/proto").IConsensusGetTopicInfoResponse} proto.IConsensusGetTopicInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Retrieve the latest state of a topic.
 *
 * @augments {Query<TopicInfo>}
 */
class TopicInfoQuery extends Query {
    /**
     * @param {object} [props]
     * @param {TopicId | string} [props.topicId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TopicId}
         */
        this._topicId = null;

        if (props.topicId != null) {
            this.setTopicId(props.topicId);
        }
    }

    /**
     * @internal
     * @param {proto.IQuery} query
     * @returns {TopicInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {proto.IConsensusTopicQuery} */ (
            query.consensusGetTopicInfo
        );

        return new TopicInfoQuery({
            topicId:
                info.topicID != null
                    ? TopicId._fromProtobuf(info.topicID)
                    : undefined,
        });
    }

    /**
     * @returns {?TopicId}
     */
    get topicId() {
        return this._topicId;
    }

    /**
     * Set the topic ID for which the info is being requested.
     *
     * @param {TopicId | string} topicId
     * @returns {TopicInfoQuery}
     */
    setTopicId(topicId) {
        this._topicId =
            typeof topicId === "string"
                ? TopicId.fromString(topicId)
                : topicId.clone();

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        let cost = await super.getCost(client);

        if (cost.toTinybars().greaterThan(25)) {
            return cost;
        } else {
            return Hbar.fromTinybars(25);
        }
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._topicId != null) {
            this._topicId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.getTopicInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @returns {proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const consensusGetTopicInfo =
            /** @type {proto.IConsensusGetTopicInfoResponse} */ (
                response.consensusGetTopicInfo
            );
        return /** @type {proto.IResponseHeader} */ (
            consensusGetTopicInfo.header
        );
    }

    /**
     * @protected
     * @override
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<TopicInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        return Promise.resolve(
            TopicInfo._fromProtobuf(
                /** @type {proto.IConsensusGetTopicInfoResponse} */ (
                    response.consensusGetTopicInfo
                )
            )
        );
    }

    /**
     * @override
     * @internal
     * @param {proto.IQueryHeader} header
     * @returns {proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            consensusGetTopicInfo: {
                header,
                topicID:
                    this._topicId != null ? this._topicId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `TopicInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("consensusGetTopicInfo", TopicInfoQuery._fromProtobuf);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusSubmitMessageTransactionBody} proto.IConsensusSubmitMessageTransactionBody
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").IConsensusMessageChunkInfo} proto.IConsensusMessageChunkInfo
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 */

class TopicMessageSubmitTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {TopicId | string} [props.topicId]
     * @param {Uint8Array | string} [props.message]
     * @param {number} [props.maxChunks]
     * @param {number} [props.chunkSize]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TopicId}
         */
        this._topicId = null;

        if (props.topicId != null) {
            this.setTopicId(props.topicId);
        }

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._message = null;

        if (props.message != null) {
            this.setMessage(props.message);
        }

        /**
         * @private
         * @type {number}
         */
        this._maxChunks = 20;

        /**
         * @private
         * @type {number}
         */
        this._chunkSize = CHUNK_SIZE;

        if (props.maxChunks != null) {
            this.setMaxChunks(props.maxChunks);
        }

        if (props.chunkSize != null) {
            this.setChunkSize(props.chunkSize);
        }

        /** @type {proto.IConsensusMessageChunkInfo | null} */
        this._chunkInfo = null;
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TopicMessageSubmitTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const message =
            /** @type {proto.IConsensusSubmitMessageTransactionBody} */ (
                body.consensusSubmitMessage
            );

        return Transaction._fromProtobufTransactions(
            new TopicMessageSubmitTransaction({
                topicId:
                    message.topicID != null
                        ? TopicId._fromProtobuf(message.topicID)
                        : undefined,
                message: message.message != null ? message.message : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @param {TransactionId} transactionId
     * @returns {this}
     */
    setTransactionId(transactionId) {
        this._requireNotFrozen();

        if (
            transactionId.accountId == null ||
            transactionId.validStart == null
        ) {
            throw new Error(
                "`TopicMessageSubmitTransaction` does not support `TransactionId` built from `nonce`"
            );
        }

        this._transactionIds.setList([transactionId]);

        return this;
    }

    /**
     * @returns {?TopicId}
     */
    get topicId() {
        return this._topicId;
    }

    /**
     * @param {TopicId | string} topicId
     * @returns {this}
     */
    setTopicId(topicId) {
        this._requireNotFrozen();

        this._topicId =
            typeof topicId === "string"
                ? TopicId.fromString(topicId)
                : topicId.clone();

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get message() {
        return this._message;
    }

    /**
     * @param {string | Uint8Array} message
     * @returns {this}
     */
    setMessage(message) {
        this._requireNotFrozen();
        message = requireStringOrUint8Array(message);
        this._message =
            message instanceof Uint8Array ? message : encode(message);
        return this;
    }

    /**
     * @returns {?number}
     */
    get maxChunks() {
        return this._maxChunks;
    }

    /**
     * @param {number} maxChunks
     * @returns {this}
     */
    setMaxChunks(maxChunks) {
        this._requireNotFrozen();
        this._maxChunks = maxChunks;
        return this;
    }

    /**
     * @returns {?number}
     */
    get chunkSize() {
        return this._chunkSize;
    }

    /**
     * @param {number} chunkSize
     * @returns {this}
     */
    setChunkSize(chunkSize) {
        this._chunkSize = chunkSize;
        return this;
    }

    /**
     * Freeze this transaction from further modification to prepare for
     * signing or serialization.
     *
     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
     * nodes to prepare this transaction for.
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client) {
        super.freezeWith(client);

        if (this._message == null) {
            return this;
        }

        const chunks = Math.floor(
            (this._message.length + (this._chunkSize - 1)) / this._chunkSize
        );

        if (chunks > this._maxChunks) {
            throw new Error(
                `Message with size ${this._message.length} too long for ${this._maxChunks} chunks`
            );
        }

        const initialTransactionId = this.transactionId._toProtobuf();
        let nextTransactionId = this.transactionId;

        // Hack around the locked list. Should refactor a bit to remove such code
        this._transactionIds.locked = false;

        this._transactions.clear();
        this._transactionIds.clear();
        this._signedTransactions.clear();

        for (let chunk = 0; chunk < chunks; chunk++) {
            this._chunkInfo = {
                initialTransactionID: initialTransactionId,
                total: chunks,
                number: chunk + 1,
            };

            this._transactionIds.push(nextTransactionId);
            this._transactionIds.advance();

            for (const nodeAccountId of this._nodeAccountIds.list) {
                this._signedTransactions.push(
                    this._makeSignedTransaction(nodeAccountId)
                );
            }

            nextTransactionId = new TransactionId(
                /** @type {AccountId} */ (nextTransactionId.accountId),
                new Timestamp(
                    /** @type {Timestamp} */ (
                        nextTransactionId.validStart
                    ).seconds,
                    /** @type {Timestamp} */ (
                        nextTransactionId.validStart
                    ).nanos.add(1)
                )
            );
        }

        this._transactionIds.advance();
        this._chunkInfo = null;

        return this;
    }

    /**
     * @returns {ScheduleCreateTransaction}
     */
    schedule() {
        this._requireNotFrozen();

        if (this._message != null && this._message.length > this._chunkSize) {
            throw new Error(
                `cannot schedule \`TopicMessageSubmitTransaction\` with message over ${this._chunkSize} bytes`
            );
        }

        return super.schedule();
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @param {number=} requestTimeout
     * @returns {Promise<TransactionResponse>}
     */
    async execute(client, requestTimeout) {
        return (await this.executeAll(client, requestTimeout))[0];
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @param {number=} requestTimeout
     * @returns {Promise<TransactionResponse[]>}
     */
    async executeAll(client, requestTimeout) {
        if (!super._isFrozen()) {
            this.freezeWith(client);
        }

        // on execute, sign each transaction with the operator, if present
        // and we are signing a transaction that used the default transaction ID

        const transactionId = this.transactionId;
        const operatorAccountId = client.operatorAccountId;

        if (
            operatorAccountId != null &&
            operatorAccountId.equals(
                /** @type {AccountId} */ (transactionId.accountId)
            )
        ) {
            await super.signWithOperator(client);
        }

        const responses = [];
        let remainingTimeout = requestTimeout;
        for (let i = 0; i < this._transactionIds.length; i++) {
            const startTimestamp = Date.now();
            responses.push(await super.execute(client, remainingTimeout));

            if (remainingTimeout != null) {
                remainingTimeout = Date.now() - startTimestamp;
            }
        }

        return responses;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.submitMessage(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "consensusSubmitMessage";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IConsensusSubmitMessageTransactionBody}
     */
    _makeTransactionData() {
        if (this._chunkInfo != null && this._message != null) {
            const num = /** @type {number} */ (this._chunkInfo.number);
            const startIndex = (num - 1) * this._chunkSize;
            let endIndex = startIndex + this._chunkSize;

            if (endIndex > this._message.length) {
                endIndex = this._message.length;
            }

            return {
                topicID:
                    this._topicId != null ? this._topicId._toProtobuf() : null,
                message: this._message.slice(startIndex, endIndex),
                chunkInfo: this._chunkInfo,
            };
        } else {
            return {
                topicID:
                    this._topicId != null ? this._topicId._toProtobuf() : null,
                message: this._message,
            };
        }
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TopicMessageSubmitTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "consensusSubmitMessage",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TopicMessageSubmitTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IConsensusUpdateTopicTransactionBody} proto.IConsensusUpdateTopicTransactionBody
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Update a topic.
 *
 * If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
 * Otherwise transaction must be signed by the adminKey.
 *
 * If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
 *
 * If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
 */
class TopicUpdateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {TopicId | string} [props.topicId]
     * @param {Key} [props.adminKey]
     * @param {Key} [props.submitKey]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {AccountId | string} [props.autoRenewAccountId]
     * @param {string} [props.topicMemo]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TopicId}
         */
        this._topicId = null;

        if (props.topicId != null) {
            this.setTopicId(props.topicId);
        }

        /**
         * @private
         * @type {?string}
         */
        this._topicMemo = null;

        if (props.topicMemo != null) {
            this.setTopicMemo(props.topicMemo);
        }

        /**
         * @private
         * @type {?Key}
         */
        this._submitKey = null;

        if (props.submitKey != null) {
            this.setSubmitKey(props.submitKey);
        }

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        /**
         * @private
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = null;

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TopicUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const update =
            /** @type {proto.IConsensusUpdateTopicTransactionBody} */ (
                body.consensusUpdateTopic
            );

        return Transaction._fromProtobufTransactions(
            new TopicUpdateTransaction({
                topicId:
                    update.topicID != null
                        ? TopicId._fromProtobuf(update.topicID)
                        : undefined,
                adminKey:
                    update.adminKey != null
                        ? Key._fromProtobufKey(update.adminKey)
                        : undefined,
                submitKey:
                    update.submitKey != null
                        ? Key._fromProtobufKey(update.submitKey)
                        : undefined,
                autoRenewAccountId:
                    update.autoRenewAccount != null
                        ? AccountId._fromProtobuf(update.autoRenewAccount)
                        : undefined,
                autoRenewPeriod:
                    update.autoRenewPeriod != null
                        ? update.autoRenewPeriod.seconds != null
                            ? update.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                topicMemo:
                    update.memo != null
                        ? update.memo.value != null
                            ? update.memo.value
                            : undefined
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {?TopicId}
     */
    get topicId() {
        return this._topicId;
    }

    /**
     * @param {TopicId | string} topicId
     * @returns {TopicUpdateTransaction}
     */
    setTopicId(topicId) {
        this._requireNotFrozen();
        this._topicId =
            typeof topicId === "string"
                ? TopicId.fromString(topicId)
                : topicId.clone();

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearTopicId() {
        this._requireNotFrozen();
        this._topicId = null;

        return this;
    }

    /**
     * @returns {?string}
     */
    get topicMemo() {
        return this._topicMemo;
    }

    /**
     * @param {string} topicMemo
     * @returns {TopicUpdateTransaction}
     */
    setTopicMemo(topicMemo) {
        this._requireNotFrozen();
        this._topicMemo = topicMemo;

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearTopicMemo() {
        this._requireNotFrozen();
        this._topicMemo = null;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} adminKey
     * @returns {TopicUpdateTransaction}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearAdminKey() {
        this._requireNotFrozen();
        this._adminKey = null;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get submitKey() {
        return this._submitKey;
    }

    /**
     * @param {Key} submitKey
     * @returns {TopicUpdateTransaction}
     */
    setSubmitKey(submitKey) {
        this._requireNotFrozen();
        this._submitKey = submitKey;

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearSubmitKey() {
        this._requireNotFrozen();
        this._submitKey = null;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @param {AccountId | string} autoRenewAccountId
     * @returns {TopicUpdateTransaction}
     */
    setAutoRenewAccountId(autoRenewAccountId) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            autoRenewAccountId instanceof AccountId
                ? autoRenewAccountId
                : AccountId.fromString(autoRenewAccountId);

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearAutoRenewAccountId() {
        this._requireNotFrozen();
        this._autoRenewAccountId = null;

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this account.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {TopicUpdateTransaction}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._topicId != null) {
            this._topicId.validateChecksum(client);
        }

        if (this._autoRenewAccountId != null) {
            this._autoRenewAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.updateTopic(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "consensusUpdateTopic";
    }

    /**
     * @override
     * @protected
     * @returns {proto.IConsensusUpdateTopicTransactionBody}
     */
    _makeTransactionData() {
        return {
            topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            submitKey:
                this._submitKey != null
                    ? this._submitKey._toProtobufKey()
                    : null,
            memo:
                this._topicMemo != null
                    ? {
                          value: this._topicMemo,
                      }
                    : null,
            autoRenewAccount:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TopicUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "consensusUpdateTopic",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TopicUpdateTransaction._fromProtobuf
);

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenBalance} proto.ITokenBalance
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @augments {ObjectMap<TokenId, number | null>}
 */
class NullableTokenDecimalMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransferList} proto.ITransferList
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 */

/**
 * @typedef {import("../long.js").LongObject} LongObject
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @augments {ObjectMap<AccountId, Hbar>}
 */
class HbarTransferMap extends ObjectMap {
    constructor() {
        super((s) => AccountId.fromString(s));
    }

    /**
     * @param {proto.ITransferList} transfers
     * @returns {HbarTransferMap}
     */
    static _fromProtobuf(transfers) {
        const accountTransfers = new HbarTransferMap();

        for (const transfer of transfers.accountAmounts != null
            ? transfers.accountAmounts
            : []) {
            const account = AccountId._fromProtobuf(
                /** @type {proto.IAccountID} */ (transfer.accountID)
            );

            accountTransfers._set(
                account,
                Hbar.fromTinybars(/** @type {Long} */ (transfer.amount))
            );
        }

        return accountTransfers;
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITokenTransferList} proto.ITokenTransferList
 * @typedef {import("@hashgraph/proto").IAccountAmount} proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").INftTransfer} proto.INftTransfer
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency tokentransfer.
 */
class TokenNftTransfer {
    /**
     * @internal
     * @param {object} props
     * @param {TokenId | string} props.tokenId
     * @param {AccountId | string} props.senderAccountId
     * @param {AccountId | string} props.receiverAccountId
     * @param {Long | number} props.serialNumber
     * @param {boolean} props.isApproved
     */
    constructor(props) {
        /**
         * The Token ID that sends or receives cryptocurrency.
         */
        this.tokenId =
            props.tokenId instanceof TokenId
                ? props.tokenId
                : TokenId.fromString(props.tokenId);

        /**
         * The Account ID that sends or receives cryptocurrency.
         */
        this.senderAccountId =
            props.senderAccountId instanceof AccountId
                ? props.senderAccountId
                : AccountId.fromString(props.senderAccountId);

        /**
         * The Account ID that sends or receives cryptocurrency.
         */
        this.receiverAccountId =
            props.receiverAccountId instanceof AccountId
                ? props.receiverAccountId
                : AccountId.fromString(props.receiverAccountId);

        this.serialNumber = long.fromValue(props.serialNumber);
        this.isApproved = props.isApproved;
    }

    /**
     * @internal
     * @param {proto.ITokenTransferList[]} tokenTransfers
     * @returns {TokenNftTransfer[]}
     */
    static _fromProtobuf(tokenTransfers) {
        const transfers = [];

        for (const tokenTransfer of tokenTransfers) {
            const tokenId = TokenId._fromProtobuf(
                /** @type {proto.ITokenID} */ (tokenTransfer.token)
            );

            for (const transfer of tokenTransfer.nftTransfers != null
                ? tokenTransfer.nftTransfers
                : []) {
                transfers.push(
                    new TokenNftTransfer({
                        tokenId,
                        senderAccountId: AccountId._fromProtobuf(
                            /** @type {proto.IAccountID} */ (
                                transfer.senderAccountID
                            )
                        ),
                        receiverAccountId: AccountId._fromProtobuf(
                            /** @type {proto.IAccountID} */ (
                                transfer.receiverAccountID
                            )
                        ),
                        serialNumber:
                            transfer.serialNumber != null
                                ? transfer.serialNumber
                                : long.ZERO,
                        isApproved: transfer.isApproval == true,
                    })
                );
            }
        }

        return transfers;
    }

    /**
     * @internal
     * @returns {proto.INftTransfer}
     */
    _toProtobuf() {
        return {
            senderAccountID: this.senderAccountId._toProtobuf(),
            receiverAccountID: this.receiverAccountId._toProtobuf(),
            serialNumber: this.serialNumber,
            isApproval: this.isApproved,
        };
    }
}

/**
 * @typedef {import("../long.js").LongObject} LongObject
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").ITransaction} proto.ITransaction
 * @typedef {import("@hashgraph/proto").ISignedTransaction} proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").TransactionBody} proto.TransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionBody} proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").ITransactionResponse} proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").ICryptoTransferTransactionBody} proto.ICryptoTransferTransactionBody
 * @typedef {import("@hashgraph/proto").ITokenID} proto.ITokenID
 * @typedef {import("@hashgraph/proto").IAccountID} proto.IAccountID
 * @typedef {import("@hashgraph/proto").IAccountAmount} proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").ITokenTransferList} proto.ITokenTransferList
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} TransferTokensInput
 * @property {TokenId | string} tokenId
 * @property {AccountId | string} accountId
 * @property {Long | number} amount
 */

/**
 * @typedef {object} TransferTokenObject
 * @property {TokenId} tokenId
 * @property {AccountId} accountId
 * @property {Long} amount
 */

/**
 * @typedef {object} TransferHbarInput
 * @property {AccountId | string} accountId
 * @property {number | string | Long | BigNumber | Hbar} amount
 */

/**
 * @typedef {object} TransferNftInput
 * @property {TokenId | string} tokenId
 * @property {AccountId | string} sender
 * @property {AccountId | string} recipient
 * @property {Long | number} serial
 */

/**
 * Transfers a new Hedera crypto-currency token.
 */
class TransferTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {(TransferTokensInput)[]} [props.tokenTransfers]
     * @param {(TransferHbarInput)[]} [props.hbarTransfers]
     * @param {(TransferNftInput)[]} [props.nftTransfers]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {TokenTransfer[]}
         */
        this._tokenTransfers = [];

        /**
         * @private
         * @type {Transfer[]}
         */
        this._hbarTransfers = [];

        /**
         * @private
         * @type {TokenNftTransfer[]}
         */
        this._nftTransfers = [];

        this._defaultMaxTransactionFee = new Hbar(1);

        for (const transfer of props.tokenTransfers != null
            ? props.tokenTransfers
            : []) {
            this.addTokenTransfer(
                transfer.tokenId,
                transfer.accountId,
                transfer.amount
            );
        }

        for (const transfer of props.hbarTransfers != null
            ? props.hbarTransfers
            : []) {
            this.addHbarTransfer(transfer.accountId, transfer.amount);
        }

        for (const transfer of props.nftTransfers != null
            ? props.nftTransfers
            : []) {
            this.addNftTransfer(
                transfer.tokenId,
                transfer.serial,
                transfer.sender,
                transfer.recipient
            );
        }
    }

    /**
     * @internal
     * @param {proto.ITransaction[]} transactions
     * @param {proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {proto.ITransactionBody[]} bodies
     * @returns {TransferTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies
    ) {
        const body = bodies[0];
        const cryptoTransfer =
            /** @type {proto.ICryptoTransferTransactionBody} */ (
                body.cryptoTransfer
            );

        const transfers = new TransferTransaction();

        transfers._tokenTransfers = TokenTransfer._fromProtobuf(
            cryptoTransfer.tokenTransfers != null
                ? cryptoTransfer.tokenTransfers
                : []
        );

        transfers._hbarTransfers = Transfer._fromProtobuf(
            cryptoTransfer.transfers != null
                ? cryptoTransfer.transfers.accountAmounts != null
                    ? cryptoTransfer.transfers.accountAmounts
                    : []
                : []
        );

        transfers._nftTransfers = TokenNftTransfer._fromProtobuf(
            cryptoTransfer.tokenTransfers != null
                ? cryptoTransfer.tokenTransfers
                : []
        );

        return Transaction._fromProtobufTransactions(
            transfers,
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies
        );
    }

    /**
     * @returns {TokenTransferMap}
     */
    get tokenTransfers() {
        const map = new TokenTransferMap();

        for (const transfer of this._tokenTransfers) {
            let transferMap = map.get(transfer.tokenId);

            if (transferMap != null) {
                transferMap._set(transfer.accountId, transfer.amount);
            } else {
                transferMap = new TokenTransferAccountMap();
                transferMap._set(transfer.accountId, transfer.amount);
                map._set(transfer.tokenId, transferMap);
            }
        }

        return map;
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {number | Long} amount
     * @param {boolean} isApproved
     * @returns {this}
     */
    _addTokenTransfer(tokenId, accountId, amount, isApproved) {
        this._requireNotFrozen();

        const token =
            tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);
        const account =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);
        const value = amount instanceof long ? amount : long.fromNumber(amount);

        for (const tokenTransfer of this._tokenTransfers) {
            if (
                tokenTransfer.tokenId.compare(token) === 0 &&
                tokenTransfer.accountId.compare(account) === 0
            ) {
                tokenTransfer.amount = tokenTransfer.amount.add(value);
                tokenTransfer.expectedDecimals = null;
                return this;
            }
        }

        this._tokenTransfers.push(
            new TokenTransfer({
                tokenId,
                accountId,
                expectedDecimals: null,
                amount,
                isApproved,
            })
        );

        return this;
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {number | Long} amount
     * @returns {this}
     */
    addTokenTransfer(tokenId, accountId, amount) {
        return this._addTokenTransfer(tokenId, accountId, amount, false);
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {number | Long} amount
     * @returns {this}
     */
    addApprovedTokenTransfer(tokenId, accountId, amount) {
        return this._addTokenTransfer(tokenId, accountId, amount, true);
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {number | Long} amount
     * @param {number} decimals
     * @returns {this}
     */
    addTokenTransferWithDecimals(tokenId, accountId, amount, decimals) {
        this._requireNotFrozen();

        const token =
            tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);
        const account =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);
        const value = amount instanceof long ? amount : long.fromNumber(amount);

        let found = false;

        for (const tokenTransfer of this._tokenTransfers) {
            if (tokenTransfer.tokenId.compare(token) === 0) {
                if (
                    tokenTransfer.expectedDecimals != null &&
                    tokenTransfer.expectedDecimals !== decimals
                ) {
                    throw new Error("expected decimals mis-match");
                } else {
                    tokenTransfer.expectedDecimals = decimals;
                }

                if (tokenTransfer.accountId.compare(account) === 0) {
                    tokenTransfer.amount = tokenTransfer.amount.add(value);
                    tokenTransfer.expectedDecimals = decimals;
                    found = true;
                }
            }
        }

        if (found) {
            return this;
        }

        this._tokenTransfers.push(
            new TokenTransfer({
                tokenId,
                accountId,
                expectedDecimals: decimals,
                amount,
                isApproved: false,
            })
        );

        return this;
    }

    /**
     * @returns {NullableTokenDecimalMap}
     */
    get tokenIdDecimals() {
        const map = new NullableTokenDecimalMap();

        for (const transfer of this._tokenTransfers) {
            map._set(transfer.tokenId, transfer.expectedDecimals);
        }

        return map;
    }

    /**
     * @returns {HbarTransferMap}
     */
    get hbarTransfers() {
        const map = new HbarTransferMap();

        for (const transfer of this._hbarTransfers) {
            map._set(transfer.accountId, transfer.amount);
        }

        return map;
    }

    /**
     * @internal
     * @param {AccountId | string} accountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @param {boolean} isApproved
     * @returns {TransferTransaction}
     */
    _addHbarTransfer(accountId, amount, isApproved) {
        this._requireNotFrozen();

        const account =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);
        const hbars = amount instanceof Hbar ? amount : new Hbar(amount);

        for (const transfer of this._hbarTransfers) {
            if (transfer.accountId.compare(account) === 0) {
                transfer.amount = Hbar.fromTinybars(
                    transfer.amount.toTinybars().add(hbars.toTinybars())
                );
                return this;
            }
        }

        this._hbarTransfers.push(
            new Transfer({
                accountId: account,
                amount: hbars,
                isApproved,
            })
        );

        return this;
    }

    /**
     * @internal
     * @param {AccountId | string} accountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {TransferTransaction}
     */
    addHbarTransfer(accountId, amount) {
        return this._addHbarTransfer(accountId, amount, false);
    }

    /**
     * @internal
     * @param {AccountId | string} accountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {TransferTransaction}
     */
    addApprovedHbarTransfer(accountId, amount) {
        return this._addHbarTransfer(accountId, amount, true);
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const transfer of this._hbarTransfers) {
            transfer.accountId.validateChecksum(client);
        }

        for (const transfer of this._tokenTransfers) {
            transfer.tokenId.validateChecksum(client);
            transfer.accountId.validateChecksum(client);
        }

        for (const transfer of this._nftTransfers) {
            transfer.tokenId.validateChecksum(client);
            transfer.senderAccountId.validateChecksum(client);
            transfer.receiverAccountId.validateChecksum(client);
        }
    }

    /**
     * @returns {TokenNftTransferMap}
     */
    get nftTransfers() {
        const map = new TokenNftTransferMap();

        for (const transfer of this._nftTransfers) {
            const transferList = map.get(transfer.tokenId);

            const nftTransfer = {
                sender: transfer.senderAccountId,
                recipient: transfer.receiverAccountId,
                serial: transfer.serialNumber,
                isApproved: transfer.isApproved,
            };

            if (transferList != null) {
                transferList.push(nftTransfer);
            } else {
                map._set(transfer.tokenId, [nftTransfer]);
            }
        }

        return map;
    }

    /**
     * @param {boolean} isApproved
     * @param {NftId | TokenId | string} tokenIdOrNftId
     * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
     * @param {AccountId | string} receiverAccountIdOrSenderAccountId
     * @param {(AccountId | string)=} receiver
     * @returns {TransferTransaction}
     */
    _addNftTransfer(
        isApproved,
        tokenIdOrNftId,
        senderAccountIdOrSerialNumber,
        receiverAccountIdOrSenderAccountId,
        receiver
    ) {
        this._requireNotFrozen();

        let nftId;
        let senderAccountId;
        let receiverAccountId;

        if (tokenIdOrNftId instanceof NftId) {
            nftId = tokenIdOrNftId;
            senderAccountId =
                typeof senderAccountIdOrSerialNumber === "string"
                    ? AccountId.fromString(senderAccountIdOrSerialNumber)
                    : /** @type {AccountId} */ (senderAccountIdOrSerialNumber);
            receiverAccountId =
                typeof receiverAccountIdOrSenderAccountId === "string"
                    ? AccountId.fromString(receiverAccountIdOrSenderAccountId)
                    : /** @type {AccountId} */ (
                          receiverAccountIdOrSenderAccountId
                      );
        } else if (tokenIdOrNftId instanceof TokenId) {
            nftId = new NftId(
                tokenIdOrNftId,
                /** @type {Long} */ (senderAccountIdOrSerialNumber)
            );
            senderAccountId =
                typeof receiverAccountIdOrSenderAccountId === "string"
                    ? AccountId.fromString(receiverAccountIdOrSenderAccountId)
                    : /** @type {AccountId} */ (
                          receiverAccountIdOrSenderAccountId
                      );
            receiverAccountId =
                typeof receiver === "string"
                    ? AccountId.fromString(receiver)
                    : /** @type {AccountId} */ (receiver);
        } else {
            try {
                nftId = NftId.fromString(tokenIdOrNftId);
                senderAccountId =
                    typeof senderAccountIdOrSerialNumber === "string"
                        ? AccountId.fromString(senderAccountIdOrSerialNumber)
                        : /** @type {AccountId} */ (
                              senderAccountIdOrSerialNumber
                          );
                receiverAccountId =
                    typeof receiverAccountIdOrSenderAccountId === "string"
                        ? AccountId.fromString(
                              receiverAccountIdOrSenderAccountId
                          )
                        : /** @type {AccountId} */ (
                              receiverAccountIdOrSenderAccountId
                          );
            } catch (_) {
                const tokenId = TokenId.fromString(tokenIdOrNftId);
                nftId = new NftId(
                    tokenId,
                    /** @type {Long} */ (senderAccountIdOrSerialNumber)
                );
                senderAccountId =
                    typeof receiverAccountIdOrSenderAccountId === "string"
                        ? AccountId.fromString(
                              receiverAccountIdOrSenderAccountId
                          )
                        : /** @type {AccountId} */ (
                              receiverAccountIdOrSenderAccountId
                          );
                receiverAccountId =
                    typeof receiver === "string"
                        ? AccountId.fromString(receiver)
                        : /** @type {AccountId} */ (receiver);
            }
        }

        for (const nftTransfer of this._nftTransfers) {
            if (
                nftTransfer.tokenId.compare(nftId.tokenId) === 0 &&
                nftTransfer.serialNumber.compare(nftId.serial) === 0
            ) {
                nftTransfer.senderAccountId = senderAccountId;
                nftTransfer.receiverAccountId = receiverAccountId;
                return this;
            }
        }

        this._nftTransfers.push(
            new TokenNftTransfer({
                tokenId: nftId.tokenId,
                serialNumber: nftId.serial,
                senderAccountId,
                receiverAccountId,
                isApproved,
            })
        );

        return this;
    }

    /**
     * @param {NftId | TokenId | string} tokenIdOrNftId
     * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
     * @param {AccountId | string} receiverAccountIdOrSenderAccountId
     * @param {(AccountId | string)=} receiver
     * @returns {TransferTransaction}
     */
    addNftTransfer(
        tokenIdOrNftId,
        senderAccountIdOrSerialNumber,
        receiverAccountIdOrSenderAccountId,
        receiver
    ) {
        return this._addNftTransfer(
            false,
            tokenIdOrNftId,
            senderAccountIdOrSerialNumber,
            receiverAccountIdOrSenderAccountId,
            receiver
        );
    }

    /**
     * @param {NftId | TokenId | string} tokenIdOrNftId
     * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
     * @param {AccountId | string} receiverAccountIdOrSenderAccountId
     * @param {(AccountId | string)=} receiver
     * @returns {TransferTransaction}
     */
    addApprovedNftTransfer(
        tokenIdOrNftId,
        senderAccountIdOrSerialNumber,
        receiverAccountIdOrSenderAccountId,
        receiver
    ) {
        return this._addNftTransfer(
            true,
            tokenIdOrNftId,
            senderAccountIdOrSerialNumber,
            receiverAccountIdOrSenderAccountId,
            receiver
        );
    }

    /**
     * @deprecated - Use `addApprovedHbarTransfer()` instead
     * @param {AccountId | string} accountId
     * @param {boolean} isApproved
     * @returns {TransferTransaction}
     */
    setHbarTransferApproval(accountId, isApproved) {
        const account =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId;

        for (const transfer of this._hbarTransfers) {
            if (transfer.accountId.compare(account) === 0) {
                transfer.isApproved = isApproved;
            }
        }

        return this;
    }

    /**
     * @deprecated - Use `addApprovedTokenTransfer()` instead
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {boolean} isApproved
     * @returns {TransferTransaction}
     */
    setTokenTransferApproval(tokenId, accountId, isApproved) {
        const token =
            typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
        const account =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId;

        for (const tokenTransfer of this._tokenTransfers) {
            if (
                tokenTransfer.tokenId.compare(token) === 0 &&
                tokenTransfer.accountId.compare(account) === 0
            ) {
                tokenTransfer.isApproved = isApproved;
            }
        }

        return this;
    }

    /**
     * @deprecated - Use `addApprovedNftTransfer()` instead
     * @param {NftId | string} nftId
     * @param {boolean} isApproved
     * @returns {TransferTransaction}
     */
    setNftTransferApproval(nftId, isApproved) {
        const nft = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

        for (const transfer of this._nftTransfers) {
            if (
                transfer.tokenId.compare(nft.tokenId) === 0 &&
                transfer.serialNumber.compare(nft.serial) === 0
            ) {
                transfer.isApproved = isApproved;
            }
        }

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.ITransaction} request
     * @returns {Promise<proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.cryptoTransfer(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoTransfer";
    }

    /**
     * @override
     * @protected
     * @returns {proto.ICryptoTransferTransactionBody}
     */
    _makeTransactionData() {
        /** @type {{tokenId: TokenId; expectedDecimals: number | null; transfers: TokenTransfer[]; nftTransfers: TokenNftTransfer[];}[]} */
        const tokenTransferList = [];

        this._tokenTransfers.sort((a, b) => {
            const compare = a.tokenId.compare(b.tokenId);

            if (compare !== 0) {
                return compare;
            }

            return a.accountId.compare(b.accountId);
        });

        this._nftTransfers.sort((a, b) => {
            const senderComparision = a.senderAccountId.compare(
                b.senderAccountId
            );
            if (senderComparision != 0) {
                return senderComparision;
            }

            const recipientComparision = a.receiverAccountId.compare(
                b.receiverAccountId
            );
            if (recipientComparision != 0) {
                return recipientComparision;
            }

            return a.serialNumber.compare(b.serialNumber);
        });

        let i = 0;
        let j = 0;
        while (
            i < this._tokenTransfers.length ||
            j < this._nftTransfers.length
        ) {
            if (
                i < this._tokenTransfers.length &&
                j < this._nftTransfers.length
            ) {
                const iTokenId = this._tokenTransfers[i].tokenId;
                const jTokenId = this._nftTransfers[j].tokenId;

                const last =
                    tokenTransferList.length > 0
                        ? tokenTransferList[tokenTransferList.length - 1]
                        : null;
                const lastTokenId = last != null ? last.tokenId : null;

                if (
                    last != null &&
                    lastTokenId != null &&
                    lastTokenId.compare(iTokenId) === 0
                ) {
                    last.transfers.push(this._tokenTransfers[i++]);
                    continue;
                }

                if (
                    last != null &&
                    lastTokenId != null &&
                    lastTokenId.compare(jTokenId) === 0
                ) {
                    last.nftTransfers.push(this._nftTransfers[j++]);
                    continue;
                }

                const result = iTokenId.compare(jTokenId);

                if (result === 0) {
                    tokenTransferList.push({
                        tokenId: iTokenId,
                        expectedDecimals:
                            this._tokenTransfers[i].expectedDecimals,
                        transfers: [this._tokenTransfers[i++]],
                        nftTransfers: [this._nftTransfers[j++]],
                    });
                } else if (result <= 0) {
                    tokenTransferList.push({
                        tokenId: iTokenId,
                        expectedDecimals:
                            this._tokenTransfers[i].expectedDecimals,
                        transfers: [this._tokenTransfers[i++]],
                        nftTransfers: [],
                    });
                } else {
                    tokenTransferList.push({
                        tokenId: iTokenId,
                        expectedDecimals: null,
                        transfers: [],
                        nftTransfers: [this._nftTransfers[j++]],
                    });
                }
            } else if (i < this._tokenTransfers.length) {
                const iTokenId = this._tokenTransfers[i].tokenId;

                const last =
                    tokenTransferList.length > 0
                        ? tokenTransferList[tokenTransferList.length - 1]
                        : null;
                const lastTokenId = last != null ? last.tokenId : null;

                if (
                    last != null &&
                    lastTokenId != null &&
                    lastTokenId.compare(iTokenId) === 0
                ) {
                    last.transfers.push(this._tokenTransfers[i++]);
                    continue;
                }

                tokenTransferList.push({
                    tokenId: iTokenId,
                    expectedDecimals: this._tokenTransfers[i].expectedDecimals,
                    transfers: [this._tokenTransfers[i++]],
                    nftTransfers: [],
                });
            } else if (j < this._nftTransfers.length) {
                const jTokenId = this._nftTransfers[j].tokenId;

                const last =
                    tokenTransferList.length > 0
                        ? tokenTransferList[tokenTransferList.length - 1]
                        : null;
                const lastTokenId = last != null ? last.tokenId : null;

                if (
                    last != null &&
                    lastTokenId != null &&
                    lastTokenId.compare(jTokenId) === 0
                ) {
                    last.nftTransfers.push(this._nftTransfers[j++]);
                    continue;
                }

                tokenTransferList.push({
                    tokenId: jTokenId,
                    expectedDecimals: null,
                    transfers: [],
                    nftTransfers: [this._nftTransfers[j++]],
                });
            }
        }

        this._hbarTransfers.sort((a, b) => a.accountId.compare(b.accountId));

        return {
            transfers: {
                accountAmounts: this._hbarTransfers.map((transfer) => {
                    return {
                        accountID: transfer.accountId._toProtobuf(),
                        amount: transfer.amount.toTinybars(),
                        isApproval: transfer.isApproved,
                    };
                }),
            },
            tokenTransfers: tokenTransferList.map((tokenTransfer) => {
                return {
                    token: tokenTransfer.tokenId._toProtobuf(),
                    expectedDecimals:
                        tokenTransfer.expectedDecimals != null
                            ? { value: tokenTransfer.expectedDecimals }
                            : null,
                    transfers: tokenTransfer.transfers.map((transfer) =>
                        transfer._toProtobuf()
                    ),
                    nftTransfers: tokenTransfer.nftTransfers.map((transfer) =>
                        transfer._toProtobuf()
                    ),
                };
            }),
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TransferTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoTransfer",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TransferTransaction._fromProtobuf
);

/**
 * @typedef {import("./LedgerId.js").default} LedgerId
 * @typedef {import("./SignerSignature.js").default} SignerSignature
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./transaction/TransactionRecord.js").default} TransactionRecord
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./account/AccountBalance.js").default} AccountBalance
 * @typedef {import("./account/AccountInfo.js").default} AccountInfo
 */

/**
 * @template {any} O
 * @typedef {import("./query/Query.js").default<O>} Query<O>
 */

/**
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 * @typedef {import("./Executable.js").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
 */

/**
 * @abstract
 */
class Signer {
    /**
     * @protected
     */
    constructor() {}

    /**
     * @abstract
     * @returns {LedgerId?}
     */
    getLedgerId() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {AccountId}
     */
    getAccountId() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {{[key: string]: (string | AccountId)}}
     */
    getNetwork() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {string[]}
     */
    getMirrorNetwork() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @param {Uint8Array[]} messages
     * @returns {Promise<SignerSignature[]>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sign(messages) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {Promise<AccountBalance>}
     */
    getAccountBalance() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {Promise<AccountInfo>}
     */
    getAccountInfo() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {Promise<TransactionRecord[]>}
     */
    getAccountRecords() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @param {Transaction} transaction
     * @returns {Promise<Transaction>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    signTransaction(transaction) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @param {Transaction} transaction
     * @returns {Promise<Transaction>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    checkTransaction(transaction) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @param {Transaction} transaction
     * @returns {Promise<Transaction>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    populateTransaction(transaction) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @template RequestT
     * @template ResponseT
     * @template OutputT
     * @param {Executable<RequestT, ResponseT, OutputT>} request
     * @returns {Promise<OutputT>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendRequest(request) {
        throw new Error("not implemented");
    }
}

/**
 * @typedef {import("./LedgerId.js").default} LedgerId
 * @typedef {import("./SignerSignature.js").default} SignerSignature
 * @typedef {import("./Provider.js").default} Provider
 * @typedef {import("./Key.js").default} Key
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./account/AccountBalance.js").default} AccountBalance
 * @typedef {import("./account/AccountInfo.js").default} AccountInfo
 */

/**
 * @template {any} O
 * @typedef {import("./query/Query.js").default<O>} Query<O>
 */

/**
 * @abstract
 */
class Wallet extends Signer {
    /**
     * @protected
     */
    constructor() {
        super();
    }

    /**
     * @abstract
     * @returns {Provider}
     */
    getProvider() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {Key}
     */
    getAccountKey() {
        throw new Error("not implemented");
    }
}

/**
 * @typedef {import("./PublicKey.js").default} PublicKey
 * @typedef {import("./account/AccountId.js").default} AccountId
 */

class SignerSignature {
    /**
     * @param {object} props
     * @param {PublicKey} props.publicKey
     * @param {Uint8Array} props.signature
     * @param {AccountId} props.accountId
     */
    constructor(props) {
        this.publicKey = props.publicKey;
        this.signature = props.signature;
        this.accountId = props.accountId;
    }
}

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").IQuery} proto.IQuery
 * @typedef {import("@hashgraph/proto").IResponse} proto.IResponse
 * @typedef {import("@hashgraph/proto").IQueryHeader} proto.IQueryHeader
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../Status.js").default} Status
 * @typedef {import("../Executable.js").ExecutionState} ExecutionState
 */

/**
 * @template OutputT
 * @augments {Executable<proto.IQuery, proto.IResponse, Hbar>}
 */
class CostQuery extends Executable {
    /**
     * @param {import("./Query.js").default<OutputT>} query
     */
    constructor(query) {
        super();

        this._query = query;
        this._grpcDeadline = query._grpcDeadline;
        this._requestTimeout = query._requestTimeout;
        this._nodeAccountIds.setList(query._nodeAccountIds.list);
        this._operator = query._operator;

        /**
         * @type {proto.IQueryHeader | null}
         */
        this._header = null;
    }

    /**
     * @returns {TransactionId}
     */
    _getTransactionId() {
        return this._query._getTransactionId();
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        return `CostQuery:${this._query._getLogId()}`;
    }

    /**
     * @abstract
     * @protected
     * @param {import("../client/Client.js").default<*, *>} client
     * @returns {Promise<void>}
     */
    async _beforeExecute(client) {
        if (client == null) {
            throw new Error("Cannot do CostQuery without Client");
        }

        const operator =
            this._operator != null ? this._operator : client._operator;

        if (operator == null) {
            throw new Error(
                "`client` must have an `operator` or an explicit payment transaction must be provided"
            );
        }

        if (this._query._nodeAccountIds.isEmpty) {
            this._query._nodeAccountIds.setList(
                client._network.getNodeAccountIdsForExecute()
            );
        }

        this._header = {
            payment: await _makePaymentTransaction(
                /** @type {import("../transaction/TransactionId.js").default} */
                (TransactionId.generate(new AccountId(0))),
                new AccountId(0),
                operator,
                new Hbar(0)
            ),
            responseType: lib.ResponseType.COST_ANSWER,
        };
    }

    /**
     * @abstract
     * @internal
     * @returns {Promise<proto.IQuery>}
     */
    _makeRequestAsync() {
        return Promise.resolve(
            this._query._onMakeRequest(
                /** @type {proto.IQueryHeader} */ (this._header)
            )
        );
    }

    /**
     * @abstract
     * @internal
     * @param {proto.IQuery} request
     * @param {proto.IResponse} response
     * @returns {ExecutionState}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        return this._query._shouldRetry(request, response);
    }

    /**
     * @abstract
     * @internal
     * @param {proto.IQuery} request
     * @param {proto.IResponse} response
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response) {
        return this._query._mapStatusError(request, response);
    }

    /**
     * @override
     * @internal
     * @param {proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {proto.IQuery} request
     * @returns {Promise<Hbar>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const cost = this._query._mapResponseHeader(response).cost;
        return Promise.resolve(
            Hbar.fromTinybars(/** @type {Long | number} */ (cost))
        );
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {proto.IQuery} request
     * @returns {Promise<proto.IResponse>}
     */
    _execute(channel, request) {
        return this._query._execute(channel, request);
    }

    /**
     * @override
     * @returns {AccountId}
     */
    _getNodeAccountId() {
        if (!this._nodeAccountIds.isEmpty) {
            // if there are payment transactions,
            // we need to use the node of the current payment transaction
            return this._nodeAccountIds.list[this._nextNodeAccountIdIndex];
        } else {
            throw new Error(
                "(BUG) nodeAccountIds were not set for query before executing"
            );
        }
    }
}

COST_QUERY.push((query) => new CostQuery(query));

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("./address_book/NodeAddress.js").default} NodeAddress
 */

const HOST_AND_PORT = /^(\S+):(\d+)$/;

class ManagedNodeAddress {
    /**
     * @param {object} props
     * @param {string} [props.address]
     * @param {string} [props.host]
     * @param {number | null} [props.port]
     */
    constructor(props = {}) {
        if (props.address != null) {
            const hostAndPortResult = HOST_AND_PORT.exec(props.address);

            if (hostAndPortResult == null) {
                throw new Error(`failed to parse address: ${props.address}`);
            }

            /** @type {string} */
            this._address = /** @type {string} */ (hostAndPortResult[1]);

            /** @type {number | null} */
            this._port =
                hostAndPortResult[2] != null
                    ? parseInt(/** @type {string }*/ (hostAndPortResult[2]))
                    : null;
        } else if (props.host != null && props.port != null) {
            /** @type {string} */
            this._address = props.host;

            /** @type {number | null} */
            this._port = props.port;
        } else {
            throw new Error(
                `failed to create a managed node address: ${JSON.stringify(
                    props
                )}`
            );
        }

        Object.freeze(this);
    }

    /**
     * @param {string} address
     * @returns {ManagedNodeAddress};
     */
    static fromString(address) {
        return new ManagedNodeAddress({ address });
    }

    toInsecure() {
        let port = this.port;

        switch (this.port) {
            case 50212:
                port = 50211;
                break;
            case 443:
                port = 5600;
        }

        return new ManagedNodeAddress({ host: this.address, port });
    }

    toSecure() {
        let port = this.port;

        switch (this.port) {
            case 50211:
                port = 50212;
                break;
            case 5600:
                port = 443;
        }

        return new ManagedNodeAddress({ host: this.address, port });
    }

    /**
     * @returns {string}
     */
    get address() {
        return this._address;
    }

    /**
     * @returns {number | null}
     */
    get port() {
        return this._port;
    }

    /**
     * @returns {boolean}
     */
    isTransportSecurity() {
        return this._port == 50212 || this._port == 443;
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this.port == null) {
            return this.address;
        } else {
            return `${this.address}:${this.port}`;
        }
    }
}

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("./address_book/NodeAddress.js").default} NodeAddress
 */

/**
 * @template {Channel | MirrorChannel} ChannelT
 * @typedef {object} NewNode
 * @property {string | ManagedNodeAddress} address
 * @property {(address: string, cert?: string) => ChannelT} channelInitFunction
 */

/**
 * @template {Channel | MirrorChannel} ChannelT
 * @typedef {object} CloneNode
 * @property {ManagedNode<ChannelT>} node
 * @property {ManagedNodeAddress} address
 */

/**
 * @abstract
 * @template {Channel | MirrorChannel} ChannelT
 */
class ManagedNode {
    /**
     * @param {object} props
     * @param {NewNode<ChannelT>=} [props.newNode]
     * @param {CloneNode<ChannelT>=} [props.cloneNode]
     */
    constructor(props = {}) {
        if (props.newNode != null) {
            this._address =
                typeof props.newNode.address === "string"
                    ? ManagedNodeAddress.fromString(props.newNode.address)
                    : props.newNode.address;

            /** @type {string=} */
            this._cert = undefined;

            /** @type {ChannelT | null} */
            this._channel = null;

            /** @type {(address: string, cert?: string) => ChannelT} */
            this._channelInitFunction = props.newNode.channelInitFunction;

            this._lastUsed = Date.now();
            this._backoffUntil = Date.now();
            this._useCount = 0;
            this._badGrpcStatusCount = 0;
            this._minBackoff = 8000;
            this._maxBackoff = 1000 * 60 * 60;
            this._currentBackoff = this._minBackoff;
        } else if (props.cloneNode != null) {
            /** @type {ManagedNodeAddress} */
            this._address = props.cloneNode.address;

            /** @type {string=} */
            this._cert = props.cloneNode.node._cert;

            /** @type {ChannelT | null} */
            this._channel = props.cloneNode.node._channel;

            /** @type {(address: string, cert?: string) => ChannelT} */
            this._channelInitFunction =
                props.cloneNode.node._channelInitFunction;

            /** @type {number} */
            this._currentBackoff = props.cloneNode.node._currentBackoff;

            /** @type {number} */
            this._lastUsed = props.cloneNode.node._lastUsed;

            /** @type {number} */
            this._backoffUntil = props.cloneNode.node._backoffUntil;

            /** @type {number} */
            this._useCount = props.cloneNode.node._useCount;

            /** @type {number} */
            this._badGrpcStatusCount = props.cloneNode.node._badGrpcStatusCount;

            /** @type {number} */
            this._minBackoff = props.cloneNode.node._minBackoff;

            /** @type {number} */
            this._maxBackoff = props.cloneNode.node._minBackoff;
        } else {
            throw new Error(
                `failed to create ManagedNode: ${JSON.stringify(props)}`
            );
        }
    }

    /**
     * @abstract
     * @returns {string}
     */
    // eslint-disable-next-line jsdoc/require-returns-check
    getKey() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {ManagedNode<ChannelT>}
     */
    // eslint-disable-next-line jsdoc/require-returns-check
    toInsecure() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {ManagedNode<ChannelT>}
     */
    // eslint-disable-next-line jsdoc/require-returns-check
    toSecure() {
        throw new Error("not implemented");
    }

    /**
     * @param {string} ledgerId
     * @returns {this}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCert(ledgerId) {
        return this;
    }

    /**
     * @returns {ManagedNodeAddress}
     */
    get address() {
        return this._address;
    }

    /**
     * @returns {number}
     */
    get attempts() {
        return this._badGrpcStatusCount;
    }

    /**
     * @returns {number}
     */
    get minBackoff() {
        return this._minBackoff;
    }

    /**
     * @param {number} minBackoff
     * @returns {this}
     */
    setMinBackoff(minBackoff) {
        if (this._currentBackoff <= minBackoff) {
            this._currentBackoff = minBackoff;
        }

        this._minBackoff = minBackoff;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxBackoff() {
        return this._maxBackoff;
    }

    /**
     * @param {number} maxBackoff
     * @returns {this}
     */
    setMaxBackoff(maxBackoff) {
        if (this._currentBackoff <= maxBackoff) {
            this._currentBackoff = maxBackoff;
        }

        this._maxBackoff = maxBackoff;
        return this;
    }

    getChannel() {
        this._useCount++;
        this.__lastUsed = Date.now();

        if (this._channel != null) {
            return this._channel;
        }

        this._channel = this._channelInitFunction(
            this.address.toString(),
            this._cert
        );
        return this._channel;
    }

    /**
     * Determines if this node is healthy by checking if this node hasn't been
     * in use for a the required `_currentBackoff` period. Since this looks at `this._lastUsed`
     * and that value is only set in the `wait()` method, any node that has not
     * returned a bad gRPC status will always be considered healthy.
     *
     * @returns {boolean}
     */
    isHealthy() {
        return this._backoffUntil <= Date.now();
    }

    increaseDelay() {
        this._currentBackoff = Math.min(
            this._currentBackoff * 2,
            this._maxBackoff
        );
        this._backoffUntil = Date.now() + this._currentBackoff;
    }

    decreaseDelay() {
        this._currentBackoff = Math.max(
            this._currentBackoff / 2,
            this._minBackoff
        );
    }

    /**
     * @returns {number}
     */
    getRemainingTime() {
        return this._backoffUntil - this._lastUsed;
    }

    /**
     * This is only ever called if the node itself is down.
     * A node returning a transaction with a bad status code does not indicate
     * the node is down, and hence this method will not be called.
     *
     * @returns {Promise<void>}
     */
    wait() {
        return new Promise((resolve) =>
            setTimeout(resolve, this.getRemainingTime())
        );
    }

    /**
     * @param {ManagedNode<*>} node
     * @returns {number}
     */
    compare(node) {
        let comparison = this.getRemainingTime() - node.getRemainingTime();
        if (comparison != 0) {
            return comparison;
        }

        comparison = this._currentBackoff - node._currentBackoff;
        if (comparison != 0) {
            return comparison;
        }

        comparison = this._badGrpcStatusCount - node._badGrpcStatusCount;
        if (comparison != 0) {
            return comparison;
        }

        comparison = this._useCount - node._useCount;
        if (comparison != 0) {
            return comparison;
        }

        return this._lastUsed - node._lastUsed;
    }

    close() {
        if (this._channel != null) {
            this._channel.close();
        }

        this._channel = null;
    }
}

/** @type {{[key: string]: string}} */
const PREVIEWNET_CERTS = {
    "0.0.3": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUenyqJ4UaFBbwokatcUqAwW3o3rswCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU4WhgPMjI5NTA2MDcyMjIxNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEm5b1+oG9R0qt
zM7UZnS5l/xxUNHIHq5+NAvtlviCpJL19jrW9+/UOy00Qqc6vS6tS1hS+dNJmpiZ
FN0EHew4VDR7ACnL4LDJKmIHWjQ0iwvZo5kCpO0r9BtPN5FvaSxyo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUeciBviJtjeuue0GPf1xllNw7qvYwCgYIKoZIzj0EAwMDaAAwZQIw
JeG0H2HdsI1VhOYmJmYlNeKCNgAk+LMorzPmsIInVBO2HK2IrKfpReWDS/m5j51V
AjEAxKBxDezJDqAZHTkTXCg+X9Q9V6J6M5yDy5IS90aCWEo+W8C1Hc6hkn2/NrvT
PhwK
-----END CERTIFICATE-----
`,
    "0.0.4": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUUfjO8LyXBdzrzbAe1Yl+d34IDsIwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDExHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU5WhgPMjI5NTA2MDcyMjIxNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAxMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAERwfj4ZtD/wRb
f8h9NEMu2sQoLFK9Gc4SQ8o6j4ccLYGdgOoVoq4zzy4Jr7ZtCTuACfCfhp7wy8ra
+6cugccaSd6AzOKRSVZvQvkUTFKIoAOKwp6IhlU48rmi80MT07eyo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUCGhfVMP72Y0G5XUksE3dPgFHrzkwCgYIKoZIzj0EAwMDZwAwZAIw
cpX7irZWyuujWRYUs9kLNgB2YLQK+n8r1fH+tJg3+zkcZ2pzhGWmpUUZWOzsDqGC
AjBUbhlmrTc4LrEBN0EMiRYzfPD2kBZxusLBDIg/aDYERCMcsFvF1T9SsuasF/B+
cI8=
-----END CERTIFICATE-----
`,
    "0.0.5": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUIo4L+7xe/mUmpKy4qOAQEIxz8UMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDIxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU5WhgPMjI5NTA2MDcyMjIxNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAyMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEoFgCjb1/7BUJ
EXKIPJLlsOSp/39G8l92wOSr7h+Py7iwVwu68H2ykftMOq3tRwDRXZHz7ViqcIZ9
lfMcS8sbRtVm9tBbNciVUqTLWX9nHr/c4PhKEi+LdgtSUr2+hHiWo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUMR89BHC3yKC4YwUgyBVQUGBCprQwCgYIKoZIzj0EAwMDZwAwZAIw
Us2BdslcScIwcmxoB60K7/1BPfQI8ccDZIMosas6U2zhinTnRKik1T0i+uHhLl8e
AjA5apAwSPTnP7j3Bo/FOCkfjTqOjwp2lUqzDJYKolKsHX2sy8hX9MkYiY46SaJ1
P+0=
-----END CERTIFICATE-----
`,
    "0.0.6": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUWpji03mJsR/16MP8BrOfpNz7aQMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDMxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMTU5WhgPMjI5NTA2MDcyMjIxNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAzMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE+KDMC99Q1rWi
+FwlytGMS5qzTDytCvk+PzdONnDZ/weNSv4j3BXSo588IwhIxLtfcBlyo/+PmE1c
5qGFXuMoZjGr22VpvogkRgPejD+Gawb4A2XHkMCD8NmO66uPw97po1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUN1qEI4eQ+WHavb9ypGV417NvhGowCgYIKoZIzj0EAwMDaAAwZQIw
L0khkiDOiFRa3wx9l5JNjaSRePPc3ZaTaJQkPYeauMaLWEvmC/0e2/e9gPm5qJ8E
AjEAgXQMko3vNB8VRN4XjyFJa8p/muZ/tLA15wPnb/boUmiZ+njDDSaiu8tIQrTB
gHW6
-----END CERTIFICATE-----
`,
    "0.0.7": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUEJ7AJvrqDUBNKbssGoJtww3v+WowCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDQxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjAwWhgPMjI5NTA2MDcyMjIyMDBaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA0MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEfgJ8w9GUWM3y
yusedZOFQrgXFVsdtRsMSHbqyVCN6+Wow6SIjy29GRMSP5R2aswupFgh6lXJRqnr
tY+hpRumFKsmSo+5+l8DBcql4rzs4utESTehM+Cq9LYc4A1z0UIRo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUMCm3UqSbT01Zr23hLzCGnXbDa+MwCgYIKoZIzj0EAwMDZwAwZAIw
FNcN7mKJo/bwpRT+y/KbYkCJsvljdbXzJOXXQ3e6J6R+0vLqcT25J/ry6pBZMUwR
AjAswu29z8KJCSxnWwnPpHDmkRT15zG/xS+pAmx3oeQSqp6ZD7qpdJE8zzhbfe5x
wAc=
-----END CERTIFICATE-----
`,
};

/** @type {{[key: string]: string}} */
const TESTNET_CERTS = {
    "0.0.3": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUMkNeM6Sbk9ZFYmRWZmSgTQHHWyUwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU4WhgPMjI5NTA2MDcyMjIyNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAETLLoIMZjEhDP
KLHS7bJT4OTYGgR/8mB65yfx3KqMLYFF+q2SpWkIrYgUQLVEUEibVSnLlxRUzH7R
szcKynpTwh0W0yfWanZKQg+RWoKkEYlu2GvkUtJb8cRVM9NLmJUeo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUSrIepwFx8gZ8/G+WGaxs6GgkMtQwCgYIKoZIzj0EAwMDaQAwZgIx
AJxC0fjB1OrF9vkCKsfnPS3Z+1hscrZhEDG38NxdLEAfPQ5VmyrSBgJy11FBp8yB
0QIxAKzbge3Lf7iBMwYwm+2M/GiVgmHNMLdtrYuerWpdbYOHgRNAkyt57JoThn0u
Tzkd5Q==
-----END CERTIFICATE-----
`,
    "0.0.4": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUGLriiLPacglp6U+BtJcF9TI7xEUwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDExHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU4WhgPMjI5NTA2MDcyMjIyNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAxMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEXhR9cb6mH9AE
GNSGk3OkxN1C/JW49ddYZ/XWD4InjS8D1kXmB1Y39v1mF0L1loG6lDT8Zp46zrj7
5zMONXZeD2b0mx5hHhtllPTpJ10Tlt9FDoyFbKwPRQ/SAPNADfuzo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUCaKtx8RZ1XJO9rmZMbIcFJZkcv4wCgYIKoZIzj0EAwMDaAAwZQIx
APhDW0VrNSmq8hODdhIVV4GyvpYhp3Fksg+sZr3DmUatwn+ptj+X+9IzgPl9QYE3
kAIwcy2ixgNkjC/DYVmgT4MpUnLneLK0gA23Vj2QwACaTH99H/ybqUH7srj0POB9
5wvV
-----END CERTIFICATE-----
`,
    "0.0.5": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUEMduome38hvAuIKoGjg/tHatQZMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDIxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU4WhgPMjI5NTA2MDcyMjIyNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAyMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEl1olzP1L4WgX
d7aujOXmTQZt3tEOGzkMa3S6qJwISLBI7Tb9KaW8zYIe9xWBVAwphCbD0wn9xpPV
wMr4uTn+JocugYBbe2YoUGzWTkxWnOEKXbh/nQJCe3XE/C0FY8fAo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQULfw7LVtTiUDVIvZwhhWW0soQtSQwCgYIKoZIzj0EAwMDaQAwZgIx
AID5v3Lo2zlnpFzTdJFqBpw6fV+vmpI+JBj61f264J/uHMbELiu2dwxhwWaMElX7
wQIxAJxccFr7Bf1KjaMyT2dq75zQzFuKDMj9x92yAqM2Gas/Yay+Ccpm8FBn7BFl
ke1Qwg==
-----END CERTIFICATE-----
`,
    "0.0.6": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUcCg/gZGxk/UjYkhW1jg4Zki+jfwwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDMxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU5WhgPMjI5NTA2MDcyMjIyNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAzMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEOSsXBZicyrxy
tHJHKh04Mvu6SKM49IC7rAXw5CjlOod5OTeHg0fa5vVoBME4mlWP+LsMMqf8welC
20b4wMwUC1Hnd66v8crX8L1wvZ9EmKLTvhTd65bS5zloMiSbpdF2o1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUgMMwqaGuUT6JCH0gsbqullaW6/QwCgYIKoZIzj0EAwMDaAAwZQIx
AMggJ1eMmT7C14z7wHCsOdDOgmzg733+a5dsuAcxknoz/sQLN8wqy1JxShWgEIA/
xwIweTDAX/4JZnr3mlSC57lYXbHk/c319VfN9Ybxg0FaDXa8tOqg7Ml6Uu3IGujQ
a3eY
-----END CERTIFICATE-----
`,
    "0.0.7": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUXADwhiD5acpA66GPoXuAevBfZBIwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDQxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjIyMjU5WhgPMjI5NTA2MDcyMjIyNTlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA0MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEBgLhLiGz8qWu
50vzxSyQkrmhpxuHBJhpGzA0WaUJdAUlaUOL1753ZxxA08wUmcozILNEnMaQ+ROn
+fuGctv90ZcrSekODjxjbKH2ntVLP8xwkBRCTJ0WRBNenxxBD438o1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUhYOOD/z3ty9O5GuSTXnyujIqBRgwCgYIKoZIzj0EAwMDaQAwZgIx
AMxbZ4gvkXaORauQFUPRYwOJrihWIA+3ttGDua//YfEbshytQ8b4L65W/1Xs8eOd
DwIxAImwTzRam8tScdOzmuGgPcML2lkETMpMA2rZYVyEL/VNktIxvB2oE+4M0v5l
r8IbTA==
-----END CERTIFICATE-----
`,
};

/** @type {{[key: string]: string}} */
const MAINNET_CERTS = {
    "0.0.3": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUZWoT9TlgbZy+syLbqZhO5++1cVgwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ3WhgPMjI5NTA2MDcyMjQyNDdaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8NhDGK/dgWvD
RHEJ8af7CBDdhvujH5XIrLen33GTLY8DbJwJW2jdsLGx3+DRVVmeNQZxCbcGj0e2
IyypkG6s0mtnmeymD8mI3JU8m1aZiuIptZSH3Bw1BNn2hKU4x42co1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUbYGliiNtMkGaroQxXWCl+kYHDBwwCgYIKoZIzj0EAwMDZwAwZAIw
ImTOEYu0y73Ggt4NAjFFsN2sV7CsEL3NoJqJ7MZ6U+b3Ax1hnc1eE0oei6xH4VNF
AjBB4iZNvAn6Esiu4k+JPlYuMesplgMv33fU5GsfvLIovN8pOJDe0c+CUmsnfGbP
OsQ=
-----END CERTIFICATE-----
`,
    "0.0.4": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUEGWU0F4aKffY+le55ahQaScDYDwwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDExHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ3WhgPMjI5NTA2MDcyMjQyNDdaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAxMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEqW6TqxMmjL3h
9AVBgfVaFRZlXUcyWa+QYhzxr8sksgJqfDbmGtdaHIdiL1qCPuC4v4G3qrAbXZRm
TYNo5Lz0X2ic5pES6DbacdjOgHH7TAY4BVKkuVrydln2jjhh7SmBo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUcBlY5a1rV0H1iQuJMwWxrTEWQ6MwCgYIKoZIzj0EAwMDZwAwZAIw
R+mY9B2U26yD44s03hjz4TlpkyXbVfmgL3Elqo3lrWDJtvT4zpjGjxg3Q1P3SpZQ
AjAy9DRVrZPzq8iq5Ir7B8XgLQH5QL7SQ3tUL1HzXJYOukvn9Ofr+QADhpb0oJLB
Kug=
-----END CERTIFICATE-----
`,
    "0.0.5": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUbxzfD3ihIK5snumqqKtqtcBPSSQwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDIxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ3WhgPMjI5NTA2MDcyMjQyNDdaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAyMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEWoAjWmW7vpUr
U69wRbK9Firons4kRoin6N8lMjCD+xzsrsT6/wycpzC0F8fxfIvOYSMWRtinhOKl
ZAxp60OWYP87iH7RqWBAnHIJZj/znKTGd+8Sqp/RVQmButFHg/+Go1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUTMtwuDzI4Hun7SPp2Nb3scjUUXkwCgYIKoZIzj0EAwMDZwAwZAIw
HKAgaX39Lgc+4/xHXzZR9mi2p3pf6CDO85Xm56UR/t48HnBkRorR3TFCBXACeIIs
AjBtXglpDnRf6M+nVBlxLdwCQXiwr6vQJ9+dUo+suNkZ1JBmtHypyIqkG2yT4z9C
Lcs=
-----END CERTIFICATE-----
`,
    "0.0.6": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUPwXdJvpCJYO9lm6uQN3S1aBi3PswCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDMxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ4WhgPMjI5NTA2MDcyMjQyNDhaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAzMR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8PwBQ0ywu+0t
eIYbaiKwzGEScQMOYFYAMw49++6bGRiH/XZjsypqlJWy3F/mB3+HNVZsqgB61Jpj
2p98Afkl57MYWhWM29t/x5qAQ8LhKGu2k+BOnCcvHDU2pR+fmFSOo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUgI4r3/iwzFN2wh76y/4XDBk7wgkwCgYIKoZIzj0EAwMDaQAwZgIx
ANAjwHdTWYMCCjrtb2NWzDpsKjf3m6ZcaxbEcM1ta/Zji/4x0+VRZa917CkfaEsr
LAIxAK/erPvIXRU9eNaK/TAQqppSRaF35G6iNnYjQZzfjTU2DczhT4oCjKzGoCHT
kI1zOg==
-----END CERTIFICATE-----
`,
    "0.0.7": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUXUGzJj13Ck2Cp0BKauLOdzgCPwIwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDQxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ4WhgPMjI5NTA2MDcyMjQyNDhaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA0MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8Ee64Tbu53i/
KsuLOJG3GQ4e9gQ+9BtEy7U8kfFzRHh6Ejn7LOW38ZdKX1HP4zXuUusjNvytqDvr
7eclitqnegcEOkIeFK3wQwBoNILuq+r4LRVi19V+AIcl5w3qkJvIo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQU2tbfu7hd7USgbS2WsG/6BduKEAMwCgYIKoZIzj0EAwMDaAAwZQIw
Rw/BOLoScmU7P/1JnNPsGarmnvcuJrokAv1wk6j8s5LGuQHReX+d+O3RPLggwcAY
AjEAjoZnt9simul4cVcVy4G/0f39atanUva17gyzlYXEYx7B6UloxLeEcZhlbBf8
GjRf
-----END CERTIFICATE-----
`,
    "0.0.8": ``,
    "0.0.9": ``,
    "0.0.10": `-----BEGIN CERTIFICATE-----
MIICnzCCAiWgAwIBAgIUNauEDBCmP9igXLWtRpzkQqIGo/wwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDcxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjQ5WhgPMjI5NTA2MDcyMjQyNDlaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA3MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjbkoJBshQXUy
qm5K8ldpTDR94Wk8iEM7QwHfceIxK5pPgaVGRkoJyVLSK5LMH4jyaIHUrtA0lIBQ
o0MsYkq7TOOm7+vo1Yrd8EMbu5StMb3gsXUrj7E/SBKIxULak6hCo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUyKHMzIBPRV/mrgG7tIjzOiw2xbUwCgYIKoZIzj0EAwMDaAAwZQIx
ANsigVtLgTdKWBPVJPstWA0H8yihf0/dmM3GO4qp5keGTWz/O3tnom4iDB6eSrcA
jwIwU82Dh+Wxl3kAD3YJH5VhlfHTm1rPlJETBHZgvPBOYqippao6+WZFEpn2/IDC
NTjn
-----END CERTIFICATE-----
`,
    "0.0.11": `-----BEGIN CERTIFICATE-----
MIICnjCCAiWgAwIBAgIUWtnJm2kswnXYu7/S5BnnTQiDRcUwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDgxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjUwWhgPMjI5NTA2MDcyMjQyNTBaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA4MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjY9Rl+s00xFV
tdTpAixLR4kJIGLfSLOdm+ofU/KuKMRSz5x1ORhIicppKZK24U5WLGXQU1fKLvxX
OmqwqL+6oAONmiHszqVdhWne4QPUba0yw7rf1/OI+IFF1HRK3shQo1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUb/htoTodbq5hjP5RNlQ0rkKwWB0wCgYIKoZIzj0EAwMDZwAwZAIw
bO+9yArr21XKXjYHPadEAYINDxgXEC3W8e3X6MJsHCIZITddWWOyXRNFhz504vN0
AjB8aBuhrKcg1b4CrQDZQcosyVPUGIZKkXdQFfbVdivKrGZvqLS+GdPLd3v2MmHY
orA=
-----END CERTIFICATE-----
`,
    "0.0.12": `-----BEGIN CERTIFICATE-----
MIICoDCCAiWgAwIBAgIUHBsegV0bKtwpHRoOnnhbK7CTHxMwCgYIKoZIzj0EAwMw
gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw
MDAwMDkxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz
MjI0MjUwWhgPMjI5NTA2MDcyMjQyNTBaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G
A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDA5MR8wHQYJKoZIhvcNAQkBFhBh
ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEK+ZAs/00RXaj
buQJJy4zwr/YTj9h5V+vbY7sq9Z1RByEwTRRQOI3OuzzMq1EWKkVJKF/QF5b4yda
x6W9O/NT4EjBXH5XR5X1V6h7aT01YBqsxgMxuUP7kw9K+fW4k6Zao1QwUjAPBgNV
HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd
BgNVHQ4EFgQUKbecoYirLjf2O2oPkoggEE2P7FcwCgYIKoZIzj0EAwMDaQAwZgIx
AP67wsVOkeFo/9QRo+PnZhzEvjOZ/+IUoUhimdljcVwn79tzNP+obf7VW3Oq1wH7
4wIxAL65+WmMTMoI2cN7TCiL7G/W2ChDsASeHfaP/4e4ZViNONWotlY9i9aS3Kwt
LTea1Q==
-----END CERTIFICATE-----
`,
    "0.0.13": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUBNxMZRKru9jzFA8zsOAI4xkMFCMwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDEwMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MFoYDzIyOTUwNjA3MjI0MjUwWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTAxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAShUi9sglwb
0U8QUrGOXJuHRXA9HP8RypkgNBwNRs1YcmPLcuwK70unWlkB81M44IQ7z/dG/0cW
hfFdRI5x4jAeiUFivmWmMLT6lJMPxJ0BkWTGVFVwI3SKcgSvHP9pNS2jVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBSqIMCDzCKKwJJLCXhu9YJYPw6lsDAKBggqhkjOPQQDAwNnADBk
AjBl0bJG2A3443ybvrkKjWu8do6nDSR08/M49+19QfA1aDw0nb2sdCOE+xNitpQ9
7ngCMGuQHmnKA2EyOIVpNl2EtRoG+vdmLJQaoukhmCWjkGrQHkai473tGa9cRZ/8
+RZFzw==
-----END CERTIFICATE-----
`,
    "0.0.14": `-----BEGIN CERTIFICATE-----
MIICoTCCAiegAwIBAgIUJcQrEmPlIh0KWwiC2X6lZ/OdNs8wCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDExMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MVoYDzIyOTUwNjA3MjI0MjUxWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTExHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASxRizKJSbB
HmG2amvTHLCyExJngCh42agaFkv5Ab9mZYbqZPe0nUn/8RlVAvEiRNggCMYXC6MU
e4J6D1aeLhYaa0UY8Fmxd20NUjAOWhJgUXds4ILMMVG+pevofeC8AsujVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBS2Ic+LU/6Wssns4Yyf3N6E666xDzAKBggqhkjOPQQDAwNoADBl
AjAH0JMX48GD6vThA6FUsVnJmBID376PRZgxhuZvn9C0HawvNjZVQTkpzpYCwmia
dO4CMQCotakNxyiOxu/BbnPx6ld5+dqVCugsfqClhUhy8ROpNHfKxp3rW7HopowT
WiMlIyI=
-----END CERTIFICATE-----
`,
    "0.0.15": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUSFFNFv1iquxd5txlWA3PlkNju2EwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDEyMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MVoYDzIyOTUwNjA3MjI0MjUxWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTIxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQus3nAPZkb
ja4Efo7iD4s8NLsFwEwQXQBgBGIJwtA2JRgLyXeWpuu125ib6qJzT8CHvQZhel3b
cwYWi4f2JpabMDepHELLxwZ9fILnAQ8GiHlzhrVq2NI15DI84dXVe4OjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBSEO/JFC5/fDcT2gtipDMYMMTd96DAKBggqhkjOPQQDAwNnADBk
AjBalAU47XQL4ziHD8lj21pcp3+R5FKzn96HclMT/vraknCT1Sl+vCf6EYsqmi6Z
+RwCMDpxL6P6OMqyE+HzAeYQ4Fa7MYEQfZGMjka4zxetBLvIpwUCT4EAO8gv9GoU
wCBUzQ==
-----END CERTIFICATE-----
`,
    "0.0.16": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUdnkil4P+VthVMnqygVwGKLt7VfAwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDEzMR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MVoYDzIyOTUwNjA3MjI0MjUxWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTMxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAARUdz9ig/iA
hEAth2YinHKY6WM63BAxUVItzgk65l1T4wTzwoK4XEwclY5vIeFmZy2e0s95lWgq
SI68VS9gmJ3xp8Q9wOel/bvuF2tvNZmF393TeoNQQVHrQM1yJAx+nPyjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBTBFdNwHKSRDo6CxfA1aglY0N8joTAKBggqhkjOPQQDAwNnADBk
AjAqPIel58Rcl2kDxZxJPD9mK9xW4TU+d2NuP3n140TQ6nPlw1OwCPI7a4i3wfEe
08ICMBbrpNRdFZcvy76KoLPfTPvqbtWWaR/0tLZg4Rjj3x7SYgUg3vrVDmodHGkb
4T2Raw==
-----END CERTIFICATE-----
`,
    "0.0.17": `-----BEGIN CERTIFICATE-----
MIICoDCCAiegAwIBAgIUDg+G4Ep+KEmIo+nCOY8DjFX60swwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE0MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MloYDzIyOTUwNjA3MjI0MjUyWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTQxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASCQRL5xUUh
1bsTXRPAf/qVFWEOxsJTiMlF3+UJ4MajWE5zmc2QNIzqj7NE24z3fNxgjViNK/8+
oBNQeqXfyJ/4etNMzTyG4JTsvWRAQ3aR1J4WDbfwpcgw6AIOKq9OLP6jVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBQB9V2fygf48zyyVL3bnAxCLDUV9zAKBggqhkjOPQQDAwNnADBk
AjBonlThjjvi3fg7ODQcatPHBkp8Yon/p1ukm3YzYA3kitqroXU7BkmwRae2fbqD
TTICMHI+fAy+xWGwXAFNcvNTop11IIoszcgJJY+1Mc2Q/USk3pP6iezta+rvnaWu
7JySHg==
-----END CERTIFICATE-----
`,
    "0.0.18": `-----BEGIN CERTIFICATE-----
MIICojCCAiegAwIBAgIUBvI2Vq6O8yXNzbQlj6uQOdpd1lIwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE1MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1MloYDzIyOTUwNjA3MjI0MjUyWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTUxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAR+jFDSzCdn
mMQpgz/vrmD/xioMioumUmyLAkB+voTNsMAOtiaDVbvJty3b4SJETv5tuZyaF5Gb
QAYuKsP7X8siCCVLZC9i9nCg46NHtuQkEmw1pzUUDmYFDfSV2tWedNqjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBSqvCmoaVEp2d9WPctby+ooPMGmvTAKBggqhkjOPQQDAwNpADBm
AjEA9fQ2OFZa7fAQGGYydfVaUF0ObxKj3T+hyl0jiCKLe+hyxJSrXCFS2BM71UiG
ZMVxAjEAmCzESBzTVvl4Uv3TyActGTijTCqTNpN3gJmQbZYjKVtqf8Wxj9WeH0pM
E8BlA/qE
-----END CERTIFICATE-----
`,
    "0.0.19": `-----BEGIN CERTIFICATE-----
MIICojCCAiegAwIBAgIUZBwp7UPLJkDgngbUIx5xjbAn+7YwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE2MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1M1oYDzIyOTUwNjA3MjI0MjUzWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTYxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASCVYu2uF3T
kCkyRP0FfXVyyTA1z8DFqCKGrcODgGJuVAk59H6u8FIRsNipkb3BXFI0xGccok5X
T+t5bMaGDHYJ4fjU78UtPNmankQ5HoiMRJpy7Vn8mzizUzUqGpnhu6GjVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBQzE6RGn4YlIbdrl0niKWTtJzfXoTAKBggqhkjOPQQDAwNpADBm
AjEAobnXnwlNGNWoHscbl/ytUBSyjC7V11sLYJqtORSRX3k2+bFGsg4ltmOVjTdd
lXatAjEA/Ja3jufmdruqfLa6qigXuYI00YaI96sOwNhdHlnksYfqF41nDe4BsSW6
eQ6N5M9d
-----END CERTIFICATE-----
`,
    "0.0.20": `-----BEGIN CERTIFICATE-----
MIICoTCCAiegAwIBAgIUE1ZRB5n+Yby+Mwgb2xAcVfTZ53kwCgYIKoZIzj0EAwMw
gYUxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv
bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExETAPBgNVBAMMCDAw
MDAwMDE3MR8wHQYJKoZIhvcNAQkBFhBhZG1pbkBoZWRlcmEuY29tMCAXDTIxMDgy
MzIyNDI1M1oYDzIyOTUwNjA3MjI0MjUzWjCBhTELMAkGA1UEBhMCVVMxCzAJBgNV
BAgMAlRYMRMwEQYDVQQHDApSaWNoYXJkc29uMQ8wDQYDVQQKDAZIZWRlcmExDzAN
BgNVBAsMBkhlZGVyYTERMA8GA1UEAwwIMDAwMDAwMTcxHzAdBgkqhkiG9w0BCQEW
EGFkbWluQGhlZGVyYS5jb20wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAR0OfTmHjxT
kBiU3GMa/bTvlTswCDAuFQGIIpMWHaf6V4ighzmn20jCg0AVFStb2q7YLRr4HUx8
ToMzsd7/yjl74BwJgfZnL75T/JInwyMgOBiCTXEf6qVDvhNzL4QJuVujVDBSMA8G
A1UdEQQIMAaHBH8AAAEwCwYDVR0PBAQDAgSwMBMGA1UdJQQMMAoGCCsGAQUFBwMB
MB0GA1UdDgQWBBQFKRUUmdFcDFQzBN9XqMvLgPd7NzAKBggqhkjOPQQDAwNoADBl
AjEA5MUUXSehY3KVIv/2LMgrqo1kPiV39fwYuLSnsMJ67wK8yN1NAkkycg6q2K6g
rBIvAjB3J3a40TINOZTYG+eQs+MSWyfANJLRuJTEOorXzMWM6+05+JYhPnLA8hke
CRfzmSw=
-----END CERTIFICATE-----
`,
};

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./address_book/NodeAddress.js").default} NodeAddress
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./ManagedNodeAddress.js").default} ManagedNodeAddress
 * @typedef {import("./LedgerId.js").default} LedgerId
 */

/**
 * @typedef {object} NewNode
 * @property {AccountId} accountId
 * @property {string} address
 * @property {(address: string, cert?: string) => Channel} channelInitFunction
 */

/**
 * @typedef {object} CloneNode
 * @property {Node} node
 * @property {ManagedNodeAddress} address
 */

/**
 * @augments {ManagedNode<Channel>}
 */
class Node extends ManagedNode {
    /**
     * @param {object} props
     * @param {NewNode=} [props.newNode]
     * @param {CloneNode=} [props.cloneNode]
     */
    constructor(props = {}) {
        super(props);

        if (props.newNode != null) {
            /** @type {AccountId} */
            this._accountId = props.newNode.accountId;

            /** @type {NodeAddress | null} */
            this._nodeAddress = null;
        } else if (props.cloneNode != null) {
            /** @type {AccountId} */
            this._accountId = props.cloneNode.node._accountId;

            /** @type {NodeAddress | null} */
            this._nodeAddress = props.cloneNode.node._nodeAddress;
        } else {
            throw new Error(`failed to create node: ${JSON.stringify(props)}`);
        }
    }

    /**
     * @returns {string}
     */
    getKey() {
        return this._accountId.toString();
    }

    /**
     * @returns {ManagedNode<Channel>}
     */
    toInsecure() {
        return /** @type {this} */ (
            new Node({
                cloneNode: { node: this, address: this._address.toInsecure() },
            })
        );
    }

    /**
     * @returns {ManagedNode<Channel>}
     */
    toSecure() {
        return /** @type {this} */ (
            new Node({
                cloneNode: { node: this, address: this._address.toSecure() },
            })
        );
    }

    /**
     * @param {LedgerId|string} ledgerId
     * @returns {this}
     */
    setCert(ledgerId) {
        switch (ledgerId.toString()) {
            case "previewnet":
                this._cert = PREVIEWNET_CERTS[this._accountId.toString()];
                break;
            case "testnet":
                this._cert = TESTNET_CERTS[this._accountId.toString()];
                break;
            case "mainnet":
                this._cert = MAINNET_CERTS[this._accountId.toString()];
                break;
        }

        return this;
    }

    /**
     * @returns {AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @returns {NodeAddress | null}
     */
    get nodeAddress() {
        return this._nodeAddress;
    }

    /**
     * @param {NodeAddress} nodeAddress
     * @returns {this}
     */
    setNodeAddress(nodeAddress) {
        this._nodeAddress = nodeAddress;
        return this;
    }
}

const PREVIEWNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
    lib.NodeAddressBook.decode(
        decode$1(
            "0ad0070a0e33352e3233312e3230382e31343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340acf070a0d332e3231312e3234382e31373210a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ace070a0c34302e3132312e36342e343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ad1070a0d33352e3139392e31352e31373710a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad1070a0d332e3133332e3231332e31343610a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad0070a0c34302e37302e31312e32303210a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad2070a0e33352e3232352e3230312e31393510a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d35322e31352e3130352e31333010a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d3130342e34332e3234382e363310a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad2070a0e33352e3234372e3130392e31333510a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b35342e3234312e33382e3110a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b31332e38382e32322e343710a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330ad0070a0c33352e3233352e36352e353110a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d35342e3137372e35312e31323710a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad0070a0c31332e36342e3137302e343010a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d33342e3130362e3234372e363510a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33352e38332e38392e31373110a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad1070a0d31332e37382e3233322e31393210a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33342e3132352e32332e343910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390acf070a0b35302e31382e31372e393310a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390ad1070a0d32302e3135302e3133362e383910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a60363465303938363135626634303566376564356134303133343436623839633438386366636436626232356134613637366463373765656131316433336437303236383266306136396138303330653863353737376430653432323033373939"
        )
    )
);
const TESTNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
    lib.NodeAddressBook.decode(
        decode$1(
            "0a7f0a0c33342e39342e3130362e363110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a80010a0d35302e31382e3133322e32313110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a81010a0e3133382e39312e3134322e32313910a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a82010a0d33352e3233372e3131392e353510a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a7f0a0a332e3231322e362e313310a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d35322e3136382e37362e32343110a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d33352e3234352e32372e31393310a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a80010a0b35322e32302e31382e383610a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a81010a0c34302e37392e38332e31323410a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a82010a0d33342e38332e3131322e31313610a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35342e37302e3139322e333310a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35322e3138332e34352e363510a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a80010a0b33342e39342e3136302e3410a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e35342e3137362e3139392e31303910a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a82010a0d31332e36342e3138312e31333610a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e33342e3130362e3130322e32313810a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a82010a0d33352e3135352e34392e31343710a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a81010a0c31332e37382e3233382e333210a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a83010a0e33342e3133332e3139372e32333010a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e31342e3235322e32303710a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e3136352e31372e32333110a388031a05302e302e392806320218093a60363938333261373361333630326538643166626535616435386431633236333761316236373264373165653837616631306462363438656239316166623232383235336231663437653537643364346134346666353437623333393461613232"
        )
    )
);
const MAINNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
    lib.NodeAddressBook.decode(
        decode$1(
            "0ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633435363165336332373863643635306538306334313363613434343233633163336331336366313437356636663639373664353937616534333262343961623432303836623739623834313332363035346238623364636635376438666364373962666330353831383363613234636434633163626335373465643131313765326635623762336336336365376230366439623465666366373337353633376234316665366635336338313162396465363134336633613532393537636466393536373735313230623333373033666635373632313430376162393537356263326433356330643434663039383366633165663633613466663532303966303730633932616631303632393536303163393662636564303634656331393031393730313963363831316334633864643830636234663461633731663961643736653761633839343536666266346630313166393061626432643930353336653832333436353166366265663932376533643564386237626634353930353039383362656361336162656632613964393761663334353737326137373430653936393932373562303138656130646632383661646436636539323365663930386662653736326137356632313131363836326462343464336463613164343462346432653864633130363663353030366262356137643935346164323535643462363033323733343735653531316165623438356430363961303637633061623563323435333863393333633036623561366165666139343030356332393135323133653463636461653663393432663632373266396464353238326436623839306631663230656664323339396364363734393234666135373034366163366461333265373339353161373331313365393166633262376666323965343835316238336666333966383362613965633666303863656664626236636262626666616266646661613931643933306637323030646134383133376333393463626431336537303165636463323631366664323162616436383161613466303031303230333031303030312804320218073a603665396138616263646364653665313134396133656265313766643538643839303538333961383664623732623036613365613230616131373666383638623235343838353261653432336437613963366237636666396537313436323961320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613163343037373135343330336363373263346662373639326333663934323531626465633132333961316637613839373261626539316133353332336662656361363235613766666165363430366338353564633261663231313039303062306466306536653664623736333634646661316666653835656461353637393336653239383562383536333461333261613532613635393964643663333062653166376136633562386635656563616632363231643861343539363832666364326462616164313536316431316633336663636237663535303061633536386431363564626561616365333238366432383934663634313239643738316436633732666437643539396339653164336166346161343333633233623931306661653463343834313634316636313532366164373837656265613533393837343136376539643361373363633066623135363432396431356563373633613664306630363131356137396239616637383364373762393864383330393661613437343366393734303864396531346263663464646666653435393137363838343762343063623864613763613337353235366432623933356430393566653235326661653831666636653337663834643761393064376535373061346638656633633764373636656564613437326630393230313939303135613839303832353961383733633534353466636262646361643265353238646538353435356234303833633764633461646335613938386530636464666463313539643564373132616264353434616137336563303239303839383134633938613434663236666330363434363539633138336533313834616132373266386431646330626661336530613536303438346362303535626134646262356363333339656338306264313164363432646333613730326538633730336162323139333038346439626436336630646665313261343333633235373665616637383163666164383637656637306264613631373638623262656631346635306336633362386230393666303230333031303030312805320218083a606464336233653763643361323537643832373665343635333533363162303138623730303931663438363635653832303031306538316563303539326236396264346265316662643765636435303964303730313364643034313238343266640ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623263636163363561643066633736343561383137626661626334383761643765343133313165376133313938623337666238343264383463333935623366363764366264383438663130633666303363323930653866376461613864303031613834343164633335326131393136306133313933653638623832656466313961653637363933613961333364346362383765373839613130373037313535313565613737326361613862383661353639623931633534353038333564396333353466306461636563393766653737303931623435623134373639386237663836303134323264636432323631653932386465346461633963343264636261666466393663303732333362613330323730373666333763393639653865643330623662356438663530333462653764393263353936663862653836316535316663633361323432626639643862653965326139653865306631353565626366663233656666613763643537633130353432383131643830373736633935383535323666646230656161333465653139353564353131313933393066653837336534633034646564643239313635383834623938623436333038373838616537666334643461613461386663396263323637346261333231343933623632343435356164343130633164653731626339356431643931666130663230313431386137393565333039656166323937623639396266323763396661323736336364353963656230323165313662383230306331303630663238313766643833636663373637313833343839343631653335393932393162333830643665393339626161346231393233326136613237326464653635316638303436666463333464623237366137373764366662326265633332353562326363323434623461663536366231303566333063363530366464616530656233646564646366393437626362396336306530303039383466336234613863366334656434626639306263313933326237663934646333616536623336303030386562393032303430663962303230333031303030312802320218053a603561383634313561303861306138323566336232656237353031303135353230326533313234336665343161303333333834653738633138633131653565386632303964343933623062326664343565303662333734663262363964663564370ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613365333762373663366364356636363232643639323434343464313263363737633339356632623539303266336262393862386138623530353561373037373036636130323863643735303630613264383730326432643862303439343762646366653061386331343161613238343462316530366536363139303031326538623633323661623066613331373937336263376362346432393439663231303861613034633462306339316261613537323866356235363232656337356162663537386131663762343165646532613637656264363963313865353831666466396336303230616330646539636132633331663063363436393030333331316662623563653764623439633738376531613764323761613432356565376238346461376536363933396639633830643065383266636535356530326466633862356337383431386132366161343336353036393837313962616663656366306264343930303061646463666134303537303862646265666262313937343964323264616230303765343464343565613233623130366638383334633135326532353036326434636632346666323533353663376562333732393130353339336662343962616239303461303266306630626234313763643931396433353238393031323865366262666634666163396639306465313138613937346632613664643031653033326137396231373866363066613166636262643032623537303466623436323935633135313930383136333733656464363633356338353639373866316239353033663166373362346230626538616261326564316665656164353939353362663832656664653933613334373161626435356364613362613861363733666262333739393734396662303036643030336630653633663636356333343631643261376232396463386232303462613539613635363638613436616532383738663030643166393439306466396532383066656266343331356561303465616135363861336139666434386336326336336236656364613639303230333031303030312803320218063a606434363430333938303337393230373965636364356134343331316361306463323262353065633839356235366535336431326232396637326463366462613363616665326535623831303466626461303338616635623434376430666231320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393361323135636334613761373232636165396331336162643633366466393963636565633661663964623436623639666135313637313665663530636532343930613938316530396162303139636132636234363831316235623631396431626431643565653666343661343263373737636264656536343261313438346563646635646464333732393634326333386336643433613838353838373434373566353832343434333636346330346466656439623839303435666230383565323563336566636234383431373333656666376335323963313339653639333530633263643739623263386431393637396137313265346538636166643332363735343162383332623365313061303132353564656636396466316539643362386438656166303331316465363764356531326232366464303164626264396433653432643335643964653237313330326530663166363964383763626337616361396538383637653964343238643363616230363636656234393064356662616233306266663366373835643033663230373261343362623962356535343635366135393263623631656166643561356566323834633763616563363666376634373332356363306434633164323766363631643861373438636135303731633036656631333464666639366634303836363838333636643436386132343738303031376530623536616261376661623433623362376330623737393036666165353438326633323831316332393265366231343435346531346238393438303161383661303363633437373934646430643734353237613732653432346564336166613034383939656362396136336632613961653732626537666139383961646630643635613332633835316439383031666334313034386466333335363466633762333137303765633866623830313430666537623761316661313230626131636236363033323463656666623462636332643962623764653063663534633831396632646433626365616465633963323566356531396463396231303230333031303030312806320218093a603365303261363732306334343636353965383633303564353562666565383230623335653635306665636163633535333039373435356532633465303332636339646564313662316262343464336235393262626163623663326266663165360ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303930323539663465336439663066333934323536353438653963373330386231306237333430336363393039346439376164313531623737303631373062393737326365623634643636326563656639303161386437643135643331396135396338623731303731616363643839356237633933363130646336393736663637633465313732396261383337336162376535326133663363386632363534393164646536396436653039393934373065373434353938313133316264393663333665363836353230336662326562643564353065616461666237323633393664656331643931373438393862346539626530346337346433303466656164643963626433323334633362376633333036633939636230633333396663323539363962343164353861326237636663313833326532323664383163313936333939336532323535613038376431363938633033643432313062643634353830363434643039356361373661613137393465646434306331633837623566383261386533396636303365393731313662613034353738653765383033343634393564373835643465663763663737313462396562366635663965306239613934663462373338383436313962393237346434613935656631353735346138396439376566356331613838623664363933653061383065626435333766633963663063613931643163363264393135646537656438313862393532653634633230303239336565386532383461343136613732613365313266633764343233623135386639623439363630636263323436366662656430666564326532346531303266646539343265623463666439346265633436643364393066633038633339666563626130336530636132343634616536363462393739353135626132396531663730326333666537303262653739333739366438656462313761613438633039323930623032343534396630363131663561653233656437653136343432646637643164616432323836633262623039643535323264643365643639386332663032303330313030303128093202180c3a606339373462623938326338313931336237333236643561336639646363343836313261313566376161643032663230376230663130636432303137613666626666353830336537636139626662343730396162323862366230396435623133660ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303962646438653834666164616133353332666334636530316138613137643463336232333266353061393739306532363236383465646334383233653831356131626435623230656365613762663536653239663662623762383331666233626636656663643134373566306238656435666662306231333835623936643136366236323966303339366138666566356630366534626361323565653461313334306565323633613464396262303230643866343732333036663364383836313338646537613031396530353962643061666339303263636261316132313361653264616136306338613031333735356665306134386530333466356234303233613264616465616138386335343836383335336163376137613364663132623266623634313837373465396231346265366561623863633237623838303132616436313632646137346530656562313631333539303566343337333734646162383538366437353061323662626433616332346165643837386334643533653635313037326338373165393464376163633537356339363733383137333461353366656166346437626136626364643234316363363435386336303837643836333032616132353163303466366435366239633332643764393636323437353065643035353738356430373733663433646330393962323863393232383131343865366338316632393766663964313636653030306163303462333132343138363737356663656637356635656261306331303332626631333064663663643761343632313164306466336530353834643932656136373334396438343930353038656234656638386635346338633364343836646538373139663130666139366665623835636337393630373663613738313331386565326439656439303363613133333630343063353961643931613464326636393865393130386165306564623962316362393561643333623139376666623138626431626138623536636265653261616539353835656365323038613165313462343835363436333032303330313030303128083202180b3a603937303834333033333130373866353638326337663332343464383263336233653238316139313837393537386465656163646363326132656265353431616631383831313561643265383338363565356635643234376234613138633165650ab50722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303938383635646566326632616233373663376630663733386331643837613237616330316166643030383632306333356362366562666362623063333330303331393361333838633334366433303233313732373031323139336262373666643330303462383634333132633638396566353231336362623930313130313530396465616239346632366137333265363337393239646134633463623332353137653361646262333831316435306163346337376331666365386236353136303632313566333437303766336537323635353435653538633839343630396532383337366264623737373566653330343339653065313539326664636230633365653163333035373733643037326136623839353765616663653161313162653936356564616666333834333336366362366134346563323561383930313036653632343735363766373662353530666461343832626165633633303764363938656338383834316664363666323366323130653437623861396463626136626134653166613731366462333363383065333038313934393664636235653536303966623665376336313533373962646465643432376539323331623932353463326261663934333630386138366436393861653961336338363339646638383764366636623561373133383564323433333864393131613231326266373166316532616363386231383662393665633865363963383662366430353832313737373661303963396336383935336564623539313635373862356132363362326634363965336230633037656164613731613434376565613766386663316262383037343235353536376237663062643165366166623033353837313863393862343239653234623232393835393666633736636636616633393663613934333464373932366563376433376434623932616635366434356665666638313936303935323234613931366331666665366236363765323535666333616338636363656639323064633034346232353030333133326238373830363734326630323033303130303031320218033a603333373339306438666561313434616663313265383132353461323864616336656138323839333833366163303732656666643835653061373734383538306566323830393636343863356137663864626234636538313437363831353133370ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130306335376564623966663237366530323362323830323163623164383763646631393636623639386366343865346561616137633639323037376365656538636362323339613463393231353937653865383966376363303564336633313331353738393736633465333134343035643461346530336137323431306335633039636135323761643561383562393938363337653732613332653166626330643535343662323436356539653830366332646435303965623035306162356662323730363366643932383135623164643236383965323131316361656236663534396539346139663030663038323164346361366336613631313766356135333363393236336266303734613330643563626566353064316338633233383762636139373265646564613039383362356430613662353764636230303230303036383238623430653430373662343837306232346261643834303536656535326235663432326538383430303238633235303036333832643865396336363132323566346637366561373265333430363037653966633666336332303433333037366131636138636231356564303361633839363664303530376263646536383165346530323331656539663837643131316537623438616338663934643264383432623532646637336635373363633534313439363437393763363236393638666661653734313866336236313039623561306630396533323233663461346435653335303964643235303133386636626331376266366365636531373539343433306466313830613338653930616466326166666266616430633662386331623837663137386130363164636662666638623932633931363664383734633166663561663466626364626665386539643039393337306464663630626537343736333364333665653465623563643531663665336333333965313531653431626462356135636532633863393761306134336233636434636330383138383463383739663964326633373438343238633835373366313763393066336362643032303330313030303128073202180a3a603734306166366266373339653838336338386633333434633961306638623330316533396463393831633531363365306465326133666634326239396534323665643765353662363766343231383530333834356466363266343963396662300ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393133316161333638663933343532323966393762363235396363636166666561323365303063643565616430326533663639366331653731346565333933396461643836306533386266393561323937346639656234386539333433663861616334303565613935356430353332336531313762336231633934383133613361663432666538303832633364343362616631626434643833363765393364623030616436393665363237613130333661653533346630313165616435653536663337613666666534346236623965303939343031313932616435363061303334366234316138313030393566356632643766643332643665656236353562613735386336623532366331323933383661663731393763376135336165363033643632323833323235343936316631366430656661383037396137363835363138383862653733333439323231373935366262636166616562623631333563356662623234383464356234613566646630333336616330326532366331363532633162643865616633306461653164366433656230306637623466616238643634373866653864393565623931316466393636613064656134653532326462373662383936363537306563633561663039353136343234663061663566386565363665333836643536353037313339393731363961633337353733626635326664303538646539356162326666363865363831313161623233343035656139363462326262383864303263306631636165643731656364643465346534303835393438373666646238353030626335356337626130323036366530356162393864396637653034363664393730326562353765653337323266386663633835613735353035666633323632313730323838623738383732336164623937653464653536323063633930656164313338326663643735373138383966656662313165363737316263336636663366656231396337616335343238373864303361393032373035323663336565643234393465666635346531353363613966363839303230333031303030312801320218043a603765616236393661623935343336363538626331346666366234626534643932356364353162323230646632613164356336656531363061646166323961353165363934646533656531383463653232656164386437646239333231383266330ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038326465373330363566333466666332393334306435393439643232323062316534333636656435636637633665626436313663663934313661353365613030313766366262313136626664336633646566636331356237613464646630653434643032666536393536383830353365373961373730653230316263663731393333393030333965653866303836643466613734366337653035363931383330316639623565383465333932363238323830383561373962333232626361306235643835666539373232316132366262646532353863363230663064636561303261623165646431366363343961336632616239323838653364643166333764633462366136663731333366663932653534316337316237306432613266363664353537323561623138626638366430303965633364323466356431326530623565363830326431313531333732643462373634656265636234616638326636343934383565633537623561303164633637393538663561303363636161623763626139333534613137333732633133313662613437633935336161663934393031623366386332346536613361666436373538653766336231343363653264643363623037316232613734633932316365653934396134623561366265383739663163373930613662386436336231393264376565323961393439316664643638396139386330613763336436303332306631623461633264363232396466643934653432663361363034386137366265316562393538633861313837336265386433333861656339666335396162376633373632363738393430326331666435393566313930383735373565306265383237666334633061346662336433393361643734613934396363393836626662363463616264646165353339333566366463353630373464623933643737656133623831366264643662653533343439373237323238393835396666333463653531383630616666623632316431303438376463333834336631663836643534303334613633653438613161306430323033303130303031280a3202180d3a606132656363316232616539386264323862633161303864386633373161306434663734356337363864306337373339363235363265333433623235643833343235656565613765663865613134323935333432623865623738643332656333660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039383735356134303862353332316532363330353230303064366437643461326333613535346435653133383461396362356562663437346165383832633633623438366264303864313434646466316139346365396137643632353139363330303661666461616334353838343666313736343031393566653235333961363536393330656661383534663231343865363865633161303863316334396432303063336633303435666537313437663036643533346334626432363231303063623164643339373339643736306438316130626432306638336632353564323530376434636362313130366235333631386336613934343039633838376361653236326434636565396338363233323134376365633134303465306335376262613733313731333065653339363433383838616633643539386564643832623863363165363561653831613465316135366263303664333937313433613938643431636138376433656634333365663061656162363830313139316233653338343830393638663636623665383836363261663435613965323132393934663638623238386562393637626562393834373863323433653231333663316131353931663036316635626330346232316666326261343862323966313834333130383838373362646665393966386135326539343038393731383536653830346465613630326133313137383663393835363532393633633361333737303332396234303966373466646663373436623232613566383431383931323037316334636538343663396234623332306665646636653962363465326362653338346639613832623661616164346232303930373433316466316133336636393230376135363536303062653831303730643038333239303039393538353961343439386435623539333135626365626566656538303765623061336139343266316364663333363764643434343466646232393838366566636464306265346162653961313838383033393533383735656461333364623732393839663736336230323033303130303031280b3202180e3a603139366237623132303739376364623361396430303362393833643537646131303331303662313733306531376636376532633762616161646234333738396166313639366461313031316232353362636263383630333333383566303332380ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061396462376638626161313236383938666162373839313135613362356438393734346631393765323830343161653039386633653838366336393837313732316531316262306164313166336365393132346161393631643661306463383435663439373635633366616231393935383430323637366635363434363262663238316462613535383837383066303365393035373938653138343236396161613630663761313437323333316532666231646561646438373763383463626362363431636139653563386164366534356263313539636230373966636230643434396364636438643932333963316130343765376234343864613063646361323636313061323566323936643936653734363962363736643461343434353136653761353965383532393361383038366638343063303532383534653032613863623230303264616433353832356265346438336235326661393165386337336666303439373436313438383632373837633131313866393234643331636261633162343466656666323264343336623339373965616466396234336134626661373265313562343735356663616232363065303661323739633362623733626337663136613036306434643532326664343930353830333838616135393564383034343733366535323266363432343931356637383033623735383365303935636466373863333235313936393764653831623839666235303035343735336231613137663961616662303634643834633939326639616231316363626338636231303831346463616635323634616134356632316264656661633832636361636161663335386533313337336565316261346537343032666438613730656130633238636135636337346463343235313063393639636432633435396231656333363838613031656133396139393237313063643232393763393861383462363334386135373738303466646332333464336665313930336532633231653137326461323862353961653665346337653865646438623731633439643730323033303130303031280c3202180f3a603538343661353366343437353239666439636462373830346364333136383865643665656265336236336461326635663231316666626337333731393763663366316366626664613631626537643135313066306539323339383131376637340ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061386365616333363765623166316465356630643965663365616630646639623938343438666532303830383437363536326130363063353163323839373730623463616366653932636236353536393832336539363263326132633966656435336264333663613361313232646531633532356135383266323561346437643632386331613364356264623839333661656365373531306537353534656537303333303235633039326338323865656235373338626530326564393633646138316135393230353633346365393435343537376162383266343066313366316565353565306165373237653233633330323834623166343462393961636534646463356639616337616438386439666132323535393335623234646362613834303036343265313663663235333263306230643638393239303436303837313563343037366634366438346130653066656433366537366363646339363335356537613236313630393435633262353461653236636330306664303832333236333436656565656137646437356639313931316539396462636239396561346163366261303536633333323238643838316438353833316439636338373935393364613137343664643065653935646332623936666539336261666366663263643764393239353864373864663333663230356437313135656439666163346462366634636336306535366135343431646135623562353566613539393939303265393538613662366334346438313064646335363138313234316238376632326630353961363838306538303231373336643031383937646236353434396365383137613233373564303335353163623064653530376336303961306338303330656366346266646562323133633033646161373634613138323162373234333334663731663736386437616563623237373035326137303333373635663037323138303536633738663261383761663138333836643866363161356366636233663262613464643539393135663133643338363334643136393537353730323033303130303031280d320218103a603030306162636435396133306135333838633530306265363832663663613239343034363239356339323735383831633230643334626230643639306564613762333862366262643037613364643166646662366137303434626230396366660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061663062393134323537626637613436353563346135306430636164356530613165343538316564363632336630653837333066373936623866323963353831373862636363363933326331666333316633396566343462383264336334336233393837333733373366656362313239353232386130346664353061313466333634366438346665316634363763616562393864343633653239373565393935623864326531653339663362663661646463323561653335643635643032363038653033343535333739363665326162636534396238313462656164336331623735373137346165333063303062306334336539396238303439366237326433633133316631633665346663646130356632383131376566396532386334333033626534643863376530343264353862383363633132313934356132633635653739363263616139313835393338663337353764663763636139356366303262356533313934346133613631396130616333663165333462396230313364346332323463346631653730666439666433363938336566383661646535313833363263633833323263306637623631613961633735666238326537623836643638626330663039396130396131346361633561316438643338663961386137306363333766663563633362626432373432666664313436323535633137316536613137383038333237316463653066646536383165643439326362353962303739366432373031373538333864633539303831303765336136656133663961343036623364313133306363656333623437393165343962626332333136303362343661623264306639336434336265373561623961346437313065613934306532383561376231353362306361376364646565366439646365306164383335306334316439306332313562393538383531356166613061633333363561653037653831663362626233366264626561633462333162636231616134653832353635623937376639646164383564363236656566396161613965663864376533666230323033303130303031280e320218113a603933653238313031303462326231376230303935326235613431303264333365646230343363623136646533616433643364363832363066353562623065353837333765613539343463333338663763386362383863373833336663383630630ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038633037626533303561643630623930626132646162333962306565373736306531613232663835373532323534306437306230336233663965343837356133613239616230383038386631343466353765623235326534366261353933383564306536643432373031313764613061626331623362383036393463396135303538623836643631646661303665373136373039633838653866656163376333613065316432356663306165626636613866373666636239396638343566653138313436316361623638353862393763336134303237666233373132623134653663303738396465313764343137363435373765353131343137656231363236393265623037616531653733353532333565396262343339303437623663303136313337383265376464366636303464616134363734363631643533393631663436633366616136623765373637363264333733623562353432623739656139363365666266333361633638313938626232623636316366663637363931366566333732616434633236633231366334626334373837633834656333326431383464373763373531383663303963663364396639313433336361393835333131396261623331666136616432366634353365353936643962646563613638613537363962633866656537613533356438306338633666336566623164666232383861623661393739383534623763653833313234656330643130326166663934633362373466396333373839353863323565623933336464353363316538303561313836353464366439313836393930663635373034323966393630663334653862346637666439393732646362666539323430653037346461326433353561356637656639633161663632656635393832613831373435373862396331356334396563353636626461636233306363666365663039636466653730386164343837343234653963316265363533663965653736363065376439343263316566613564613238366531616464616230366139613333663964653934363739356230323033303130303031280f320218123a603934383235313739643163333934303137306233356432363665346366613830643737386335653966356261653764653833666638636334373431663362653336616336336431653761653439373261656466366263316533636632303638390ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030626531376339393634376365633635613434343037623533353835366233633362616566356235346635363561663538623834353662613863376365353335643561633732633631633434633736623363353763386538363438343136333762653130613833636665333963303932343736643064626534643663646364636437323061333062356266656235316130316131386635383263343566366338363939336663663764663138323933356465316438363930363034346463663335313836393335643962643765656137393532333532626562623465663961653066373636316537306134323337616661393839393636383763613438666366633562303064333830376630353462653066613863336266613432353033386265366566323935313634663232663733623765383863393465613962653861613466336132343563383962396431666435313932663761353062393538623265663831303462333666316266386664326366623238633134323138303063316334376534656639386166313530303730636336643639643137653865623932663138613661613161363532363661343935323338643130336638663639356235376563663337333635306130353230303837343537323162656138313536323739363763383037363336356466386334633761376434646438663263333835306331386662613731656236306536653864666264313936653035333766643730623334346563626363353330646663383364613666656466343964353161393034313935303262613964373063643335663163663363303639346532333534663930363466646266353335656232336332376330613433643062373863316638363763363164393836393564386465663762633261313062623636373463323266363661616230613931383133646466323763646238353263353965663739653162396531613037356661366565323761376533373734646266346232363436353432376536643561623931666537663066336137313738346563613138326235303230333031303030312810320218133a603038393039376465663031623037633764393734613537353532353161366161613061666236623332613534353334336432393138653732626164303433323163313131633234643432373538306633626131653236616139643735653632360ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613561643262373634336130346330353564326638636432353131623135313339666334353537353632313338386534396331313962326633393861636131313066363133393662306338363664653530363335323262623835343032373365313366366439346365316536303433386636616662303061616136343631326637313435653962636538626331613533623934313931336161373663396633613238333366616437636632383563376163326433376639396633633263646234396465346431353165363136373835363466323831663534313432346234316661376335316232613936303232383363376433326565303065623833386461313563333861666339366530363164393763656465323231363566663161613935396631633432373562326430393863343035383661353537396662623363623930303732373034313230613861363661353237306634666366643130383663393233363930613335653766643434356533336163303366313339633638363835353635373063646334616166323231303761366331613434323435366137633663373965653034303930653765356434663636626361363063613166343762366466623534336461633363626631396137373139613866353562366638336234613362386136366436303235366430613436353531666137303234626430353633316238613535383038373732353463326632663236386364633333643264626263666237333365396662653233336262396362353961623331613031343862323365386334323638306666313061663463373961346430383334366662373961393364393632393534386561663162623132343639386661656661346364643732343432633033613034623733333433326637343839303361333235633238336434353661623961653932316165376564333339316535643137383765666463323335343061376238356336393161653837306130376639306231316331336233326365343365616564313562333639363835636534393137376363393835303230333031303030312811320218143a603939666162633461646534653636326336653238323366346139366562323134343034383465356136643064333132623730633036386432326236323936333830376332333361343964626239383361376562623330653737303637373261340ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030386434356332316330633935656636356130323964353263393537666430663835663230313233646130333465363136373164646565353437356630373338326136366336366362346463353035303464646664333735383130383364663864313735373733306564386436663336346466346333366132363531353931393535646132303161323430376661386162396232333133383131323235613064613233306662653338306530393061613536656661346632303265633962343832336636353031643936616336393865626632366161636633656532643166333261373231633934376531303736636633356233373364613164383761333661313532653030653731303131373932323832653832356666313731633538333362383835373062666336646138343439653666393566386231323635616235353531393430333135353364316435373666393363343263306361363061616261633463386464313632643831313466326232313531313538336337323533396665353663343939613932396465336134306130643435633137633538396332643739383863653236656166633932613364333762376561303034326434336530336166613632373162323632353561366363636661653533373138323164383165306230356332353062353966306139303734316130653065383861303965643536633562393738306430393566303930366630623831643531323633393832616165303131333663303732643834346131316436646134623261363163363434653161623137663136666634386565323366656465383435326631653432653264333061303739306332356434323036306531643434613637316132656232336431313466363863373165333366313736646235386136386234333030353462633164323938336132336133326561366666393566613763346438653338306562323936653938623739363865636638343534643831376337333765656135646439323165623836633136633762323933303461346137656362653561336131303230333031303030312812320218153a606537396165396337313933643164326263393433383436346338616135663632323461653835323936366134336239383235383833663766373432633533393562643330393935383761393638363662393233396431656666336165353037610ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623035616265326162303066646430366339353565383637313062306530366631613932363234613438616431636263386466633666323231323936326230633330666462643238346133376335613337363538623633633336656138313632353631613865346639343663626535373232633032383830316630663238316337306638643838633763303061326632653239663539376237393938363965643833353664663537633437626539393434613261616666363530663962346262613064626335336463383830666462623639656134353139303564323830323230326638653239633034613736643237616632656237633534383438356266336634363934633930633431383130383838383433373932383438383335663738313637303764336538643736663465363766353738306263663038383133633535656336333961396264363234313738663565623134376435303061663335316539656631623165333432343834636132363064623763636261653438366631336366323635623562316162363838303636303038303533623230633364656463653737316339613038613033323061613963653435316562396439383361376234396361613130393666386164633039383331386463333865306537636566306438653564353537613036373536383561316339653235366132626339646261333232623362623331373263663731343037376263333830663861306134333361386266613766626663353966366230393365633862663665393339376330396231386531383034306331623536363836343733376338666137653239373935663361343538386464613763326261623439353636356363346139623833366532656239306336326133666361663539316662356638313830346337363138306536323666613236343461376465333435313164366334363637643938393337653237373333663464316539313338383333353465353466643733353137323165373666376235366333343833333838663461366238376232386165626562303230333031303030312813320218163a603962343038383566313362366163316337353336393262613366313739303061333838333165363934613061663937343934623834333838323039636235656662646339386136646162623265316337313833393166633133356264616163330ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396463643863306135336539306333353539353734663636323034313137643362353033653530613336643330393766616338343239653663656364333762623534303731383038663265653938323033356638353161306339626532313736333833613232653338633161626131363866333266393035373063623332333363666536323539383736363661663637623531346361656632316662386466366430666364333363663236303662393264646561353533366236303638643836373832653339626435633338343435393931643431396237643165633038353939343132633039343964316332343062333563313464633535323734646261373166666165393336313235613566383139663534313332653234333964346163353539373939366563653835653133646666333336316639313331663536636561633562396635353262343963663666396139616336653564636532646233363934363266393361663830653562353662366538626566613136326130363162346137363839326264633834363437333036633630303835386664643237303332373663326337303434303139386566643766653335343563663261623538306337346366643634343561616637626437663734356363323532656162643236356561626565383632343137313034653639343861353537353666646332323264663061313031353234646531633363303863636630343330313165633766653936346564643834353161313330313437633037333633613335663131666465656638663261326237363137353762343335386666383962373561343864363762646336303930363933653062623836373965636262393366666462336633656439366265633933656634363536653337313661623837636534366361386531323539633866656464653866326631656130663365623263343865393635353164653132333330333435373235663435656436396338353735623531363833616661343732363231383236646232326262326431633466316533363436346139303230333031303030312814320218173a60346630613033333466393737363738313632663830643936376637323139313431333630633062376637663033316233376336396536323137333933336564616434366263626139373636376565373262666435613933346261313532326330"
        )
    )
);

// import {
//     PREVIEWNET_ADDRESS_BOOK,
//     TESTNET_ADDRESS_BOOK,
//     MAINNET_ADDRESS_BOOK,
// } from "../address_book/AddressBooks.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../Node.js").default} Node
 * @typedef {import("../MirrorNode.js").default} MirrorNode
 * @typedef {import("../address_book/NodeAddressBook.js").default} NodeAddressBook
 */

/**
 * @template {Channel | MirrorChannel} ChannelT
 * @typedef {import("../ManagedNode.js").default<ChannelT>} ManagedNode
 */

/**
 * @template {Channel | MirrorChannel} ChannelT
 * @template {ManagedNode<ChannelT>} NetworkNodeT
 * @template {{ toString: () => string }} KeyT
 */
class MangedNetwork {
    /**
     * @param {(address: string) => ChannelT} createNetworkChannel
     */
    constructor(createNetworkChannel) {
        /**
         * Map of node account ID (as a string)
         * to the node URL.
         *
         * @internal
         * @type {Map<string, NetworkNodeT[]>}
         */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this._network = new Map();

        /**
         * List of node account IDs.
         *
         * @protected
         * @type {NetworkNodeT[]}
         */
        this._nodes = [];

        /** @type {(address: string, cert?: string) => ChannelT} */
        this._createNetworkChannel = createNetworkChannel;

        /** @type {LedgerId | null} */
        this._ledgerId = null;

        this._minBackoff = 8000;
        this._maxBackoff = 1000 * 60 * 60;

        /** @type {number} */
        this._maxNodeAttempts = -1;

        this._transportSecurity = false;
    }

    /**
     * @returns {boolean}
     */
    isTransportSecurity() {
        return this._transportSecurity;
    }

    /**
     * @param {boolean} transportSecurity
     * @returns {this}
     */
    setTransportSecurity(transportSecurity) {
        if (this._transportSecurity != transportSecurity) {
            this._network.clear();

            for (let i = 0; i < this._nodes.length; i++) {
                let node = this._nodes[i];
                node.close();

                node = /** @type {NetworkNodeT} */ (
                    transportSecurity
                        ? node
                              .toSecure()
                              .setCert(
                                  this._ledgerId != null
                                      ? this._ledgerId._toStringForChecksum()
                                      : ""
                              )
                        : node.toInsecure()
                );
                this._nodes[i] = node;

                const nodes =
                    this._network.get(node.getKey()) != null
                        ? /** @type {NetworkNodeT[]} */ (
                              this._network.get(node.getKey())
                          )
                        : [];
                nodes.push(node);
                this._network.set(node.getKey(), nodes);
            }
        }

        this._transportSecurity = transportSecurity;
        return this;
    }

    /**
     * @deprecated
     * @param {string} networkName
     * @returns {this}
     */
    setNetworkName(networkName) {
        console.warn("Deprecated: Use `setLedgerId` instead");
        return this.setLedgerId(networkName);
    }

    /**
     * @deprecated
     * @returns {string | null}
     */
    get networkName() {
        console.warn("Deprecated: Use `ledgerId` instead");
        return this.ledgerId != null ? this.ledgerId.toString() : null;
    }

    /**
     * @param {string|LedgerId} ledgerId
     * @returns {this}
     */
    setLedgerId(ledgerId) {
        this._ledgerId =
            typeof ledgerId === "string"
                ? LedgerId.fromString(ledgerId)
                : ledgerId;
        return this;
    }

    /**
     * @returns {LedgerId | null}
     */
    get ledgerId() {
        return this._ledgerId != null ? this._ledgerId : null;
    }

    /**
     * @abstract
     * @param {[string, KeyT]} entry
     * @returns {NetworkNodeT}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _createNodeFromNetworkEntry(entry) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @param {Map<string, KeyT>} network
     * @returns {number[]}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _getNodesToRemove(network) {
        throw new Error("not implemented");
    }

    _removeDeadNodes() {
        if (this._maxNodeAttempts > 0) {
            for (let i = this._nodes.length - 1; i >= 0; i--) {
                const node = this._nodes[i];

                if (node._badGrpcStatusCount < this._maxNodeAttempts) {
                    continue;
                }

                this._closeNode(i);
            }
        }
    }

    /**
     * @param {number} count
     * @returns {NetworkNodeT[]}
     */
    _getNumberOfMostHealthyNodes(count) {
        this._removeDeadNodes();
        this._nodes.sort((a, b) => a.compare(b));

        for (const [, value] of this._network) {
            // eslint-disable-next-line ie11/no-loop-func
            value.sort((a, b) => a.compare(b));
        }

        /** @type {NetworkNodeT[]} */
        const nodes = [];
        const keys = new Set();

        for (const node of this._nodes) {
            if (keys.size >= count) {
                break;
            }

            if (!keys.has(node.getKey())) {
                keys.add(node.getKey());
                nodes.push(node);
            }
        }

        return nodes;
    }

    /**
     * @param {number} i
     */
    _closeNode(i) {
        const node = this._nodes[i];

        node.close();
        this._removeNodeFromNetwork(node);
        this._nodes.splice(i, 1);
    }

    /**
     * @param {NetworkNodeT} node
     */
    _removeNodeFromNetwork(node) {
        const network = /** @type {NetworkNodeT[]} */ (
            this._network.get(node.getKey())
        );

        for (let j = 0; j < network.length; j++) {
            if (network[j] === node) {
                network.splice(j, 1);
                break;
            }
        }

        if (network.length === 0) {
            this._network.delete(node.getKey());
        }
    }

    /**
     * @param {Map<string, KeyT>} network
     * @returns {this}
     */
    _setNetwork(network) {
        // Remove nodes that are not in the new network
        for (const i of this._getNodesToRemove(network)) {
            this._closeNode(i);
        }

        // Add new nodes
        for (const [key, value] of network) {
            const node = this._createNodeFromNetworkEntry([key, value]);

            this._nodes.push(node);

            const network = this._network.has(node.getKey())
                ? /** @type {NetworkNodeT[]} */ (
                      this._network.get(node.getKey())
                  )
                : [];
            network.push(node);
            this._network.set(node.getKey(), network);
        }

        shuffle(this._nodes);
        for (const [, value] of this._network) {
            shuffle(value);
        }

        this._ledgerId = null;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxNodeAttempts() {
        return this._maxNodeAttempts;
    }

    /**
     * @param {number} maxNodeAttempts
     * @returns {this}
     */
    setMaxNodeAttempts(maxNodeAttempts) {
        this._maxNodeAttempts = maxNodeAttempts;
        return this;
    }

    /**
     * @returns {number}
     */
    get minBackoff() {
        return this._minBackoff;
    }

    /**
     * @param {number} minBackoff
     * @returns {this}
     */
    setMinBackoff(minBackoff) {
        this._minBackoff = minBackoff;
        for (const node of this._nodes) {
            node.setMinBackoff(minBackoff);
        }
        return this;
    }

    /**
     * @returns {number}
     */
    get maxBackoff() {
        return this._maxBackoff;
    }

    /**
     * @param {number} maxBackoff
     * @returns {this}
     */
    setMaxBackoff(maxBackoff) {
        this._maxBackoff = maxBackoff;
        for (const node of this._nodes) {
            node.setMaxBackoff(maxBackoff);
        }
        return this;
    }

    /**
     * @param {KeyT} key
     * @returns {NetworkNodeT}
     */
    getNode(key) {
        return /** @type {NetworkNodeT[]} */ (
            this._network.get(key.toString())
        )[0];
    }

    close() {
        for (const node of this._nodes) {
            node.close();
        }

        this._network.clear();
        this._nodes = [];
    }
}

/**
 * https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
 *
 * @template T
 * @param {Array<T>} array
 */
function shuffle(array) {
    var currentIndex = array.length,
        temporaryValue,
        randomIndex;

    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
}

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../address_book/NodeAddressBook.js").default} NodeAddressBook
 */

/**
 * @augments {ManagedNetwork<Channel, Node, AccountId>}
 */
class Network$1 extends MangedNetwork {
    /**
     * @param {(address: string) => Channel} createNetworkChannel
     */
    constructor(createNetworkChannel) {
        super(createNetworkChannel);

        this._maxNodesPerTransaction = -1;

        /** @type {NodeAddressBook | null} */
        this._addressBook = null;
    }

    /**
     * @param {{[key: string]: (string | AccountId)}} network
     */
    setNetwork(network) {
        this._setNetwork(
            // eslint-disable-next-line ie11/no-collection-args
            new Map(
                // eslint-disable-next-line ie11/no-collection-args
                Object.entries(network).map(([key, value]) => {
                    return [
                        key,
                        typeof value === "string"
                            ? AccountId.fromString(value)
                            : value,
                    ];
                })
            )
        );
    }

    /**
     * @returns {{[key: string]: (string | AccountId)}}
     */
    get network() {
        /**
         * @type {{[key: string]: (string | AccountId)}}
         */
        var n = {};

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const node of this._nodes) {
            n[node.address.toString()] = node.accountId;
        }

        return n;
    }

    /**
     * @param {string} networkName
     * @returns {this}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setNetworkName(networkName) {
        super.setLedgerId(networkName);

        switch (networkName) {
            case "mainnet":
                this._addressBook = MAINNET_ADDRESS_BOOK;
                break;
            case "testnet":
                this._addressBook = TESTNET_ADDRESS_BOOK;
                break;
            case "previewnet":
                this._addressBook = PREVIEWNET_ADDRESS_BOOK;
                break;
        }

        if (this._addressBook != null) {
            for (const node of this._nodes) {
                for (const address of this._addressBook.nodeAddresses) {
                    if (
                        address.accountId != null &&
                        address.accountId.toString() ===
                            node.accountId.toString()
                    ) {
                        node.setNodeAddress(address);
                    }
                }
            }
        }

        return this;
    }

    /**
     * @returns {string | null}
     */
    get networkName() {
        return this._ledgerId != null ? this._ledgerId.toString() : null;
    }

    /**
     * @abstract
     * @param {[string, (string | AccountId)]} entry
     * @returns {Node}
     */
    _createNodeFromNetworkEntry(entry) {
        const accountId =
            typeof entry[1] === "string"
                ? AccountId.fromString(entry[1])
                : entry[1];

        return new Node({
            newNode: {
                address: entry[0],
                accountId,
                channelInitFunction: this._createNetworkChannel,
            },
        }).setMinBackoff(this._minBackoff);
    }

    /**
     * @abstract
     * @param {Map<string, AccountId>} network
     * @returns {number[]}
     */
    _getNodesToRemove(network) {
        const indexes = [];

        for (let i = this._nodes.length - 1; i >= 0; i--) {
            const node = this._nodes[i];
            const accountId = network.get(node.address.toString());

            if (
                accountId == null ||
                accountId.toString() !== node.accountId.toString()
            ) {
                indexes.push(i);
            }
        }

        return indexes;
    }

    /**
     * @abstract
     * @param {[string, (string | AccountId)]} entry
     * @returns {boolean}
     */
    _checkNetworkContainsEntry(entry) {
        for (const node of this._nodes) {
            if (node.address.toString() === entry[0]) {
                return true;
            }
        }

        return false;
    }

    /**
     * @returns {number}
     */
    get maxNodesPerTransaction() {
        return this._maxNodesPerTransaction;
    }

    /**
     * @param {number} maxNodesPerTransaction
     * @returns {this}
     */
    setMaxNodesPerTransaction(maxNodesPerTransaction) {
        this._maxNodesPerTransaction = maxNodesPerTransaction;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxNodeAttempts() {
        return this._maxNodeAttempts;
    }

    /**
     * @param {number} maxNodeAttempts
     * @returns {this}
     */
    setMaxNodeAttempts(maxNodeAttempts) {
        this._maxNodeAttempts = maxNodeAttempts;
        return this;
    }

    /**
     * @internal
     * @returns {number}
     */
    getNumberOfNodesForTransaction() {
        if (this._maxNodesPerTransaction > 0) {
            return this._maxNodesPerTransaction;
        }

        return (this._nodes.length + 3 - 1) / 3;
    }

    /**
     * @internal
     * @returns {AccountId[]}
     */
    getNodeAccountIdsForExecute() {
        return this._getNumberOfMostHealthyNodes(
            this.getNumberOfNodesForTransaction()
        ).map((node) => node.accountId);
    }
}

/**
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("./ManagedNodeAddress.js").default} ManagedNodeAddress
 */

/**
 * @typedef {object} NewNode
 * @property {string} address
 * @property {(address: string, cert?: string) => MirrorChannel} channelInitFunction
 */

/**
 * @typedef {object} CloneNode
 * @property {MirrorNode} node
 * @property {ManagedNodeAddress} address
 */

/**
 * @augments {ManagedNode<MirrorChannel>}
 */
class MirrorNode extends ManagedNode {
    /**
     * @param {object} props
     * @param {NewNode=} [props.newNode]
     * @param {CloneNode=} [props.cloneNode]
     */
    constructor(props = {}) {
        super(props);
    }

    /**
     * @returns {string}
     */
    getKey() {
        return this._address.toString();
    }

    /**
     * @returns {MirrorNode}
     */
    toInsecure() {
        return new MirrorNode({
            cloneNode: { node: this, address: this._address.toInsecure() },
        });
    }

    /**
     * @returns {MirrorNode}
     */
    toSecure() {
        return new MirrorNode({
            cloneNode: { node: this, address: this._address.toSecure() },
        });
    }
}

/**
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 */

/**
 * @augments {ManagedNetwork<MirrorChannel, MirrorNode, string>}
 */
class MirrorNetwork extends MangedNetwork {
    /**
     * @param {(address: string) => MirrorChannel} channelInitFunction
     */
    constructor(channelInitFunction) {
        super(channelInitFunction);
    }

    /**
     * @param {string[]} network
     */
    setNetwork(network) {
        // eslint-disable-next-line ie11/no-collection-args
        this._setNetwork(new Map(network.map((address) => [address, address])));
    }

    /**
     * @returns {string[]}
     */
    get network() {
        /**
         * @type {string[]}
         */
        var n = [];

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const node of this._nodes) {
            n.push(node.address.toString());
        }

        return n;
    }

    /**
     * @abstract
     * @param {[string, string]} entry
     * @returns {MirrorNode}
     */
    _createNodeFromNetworkEntry(entry) {
        return new MirrorNode({
            newNode: {
                address: entry[1],
                channelInitFunction: this._createNetworkChannel,
            },
        }).setMinBackoff(this._minBackoff);
    }

    /**
     * @abstract
     * @param {Map<string, string>} network
     * @returns {number[]}
     */
    _getNodesToRemove(network) {
        const indexes = [];

        const values = Object.values(network);

        for (let i = this._nodes.length - 1; i >= 0; i--) {
            const node = this._nodes[i];

            if (!values.includes(node.address.toString())) {
                indexes.push(i);
            }
        }

        return indexes;
    }

    /**
     * @returns {MirrorNode}
     */
    getNextMirrorNode() {
        if (this._createNetworkChannel == null) {
            throw new Error("mirror network not supported on browser");
        }

        return this._getNumberOfMostHealthyNodes(1)[0];
    }
}

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 */

/**
 * @typedef {object} Operator
 * @property {string | PrivateKey} privateKey
 * @property {string | AccountId} accountId
 */

/**
 * @typedef {object} ClientOperator
 * @property {PublicKey} publicKey
 * @property {AccountId} accountId
 * @property {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
 */

/**
 * @typedef {object} ClientConfiguration
 * @property {{[key: string]: (string | AccountId)} | string} network
 * @property {string[] | string} [mirrorNetwork]
 * @property {Operator} [operator]
 */

/**
 * @typedef {"mainnet" | "testnet" | "previewnet"} NetworkName
 */

/**
 * @abstract
 * @template {Channel} ChannelT
 * @template {MirrorChannel} MirrorChannelT
 */
class Client {
    /**
     * @protected
     * @hideconstructor
     * @param {ClientConfiguration} [props]
     */
    constructor(props) {
        /**
         * List of mirror network URLs.
         *
         * @internal
         * @type {MirrorNetwork}
         */
        this._mirrorNetwork = new MirrorNetwork(
            this._createMirrorNetworkChannel()
        );

        /**
         * Map of node account ID (as a string)
         * to the node URL.
         *
         * @internal
         * @type {Network}
         */
        this._network = new Network$1(this._createNetworkChannel());

        /**
         * @internal
         * @type {?ClientOperator}
         */
        this._operator = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._defaultMaxTransactionFee = null;

        /**
         * @private
         * @type {Hbar}
         */
        this._maxQueryPayment = new Hbar(1);

        if (props != null) {
            if (props.operator != null) {
                this.setOperator(
                    props.operator.accountId,
                    props.operator.privateKey
                );
            }
        }

        this._signOnDemand = false;

        this._autoValidateChecksums = false;

        /** @type {number | null} */
        this._maxAttempts = null;

        /** @type {number} */
        this._minBackoff = 250;

        /** @type {number} */
        this._maxBackoff = 8000;

        this._defaultRegenerateTransactionId = true;

        this._requestTimeout = null;
    }

    /**
     * @deprecated
     * @param {NetworkName} networkName
     * @returns {this}
     */
    setNetworkName(networkName) {
        // uses custom NetworkName type
        // remove if phasing out set|get NetworkName
        console.warn("Deprecated: Use `setLedgerId` instead");
        return this.setLedgerId(networkName);
    }

    /**
     * @deprecated
     * @returns {string | null}
     */
    get networkName() {
        console.warn("Deprecated: Use `ledgerId` instead");
        return this.ledgerId != null ? this.ledgerId.toString() : null;
    }

    /**
     * @param {string|LedgerId} ledgerId
     * @returns {this}
     */
    setLedgerId(ledgerId) {
        this._network.setLedgerId(
            typeof ledgerId === "string"
                ? LedgerId.fromString(ledgerId)
                : ledgerId
        );

        return this;
    }

    /**
     * @returns {LedgerId | null}
     */
    get ledgerId() {
        return this._network._ledgerId != null ? this._network.ledgerId : null;
    }

    /**
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {void}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setNetwork(network) {
        throw new Error("not implemented");
    }

    /**
     * @returns {{[key: string]: (string | AccountId)}}
     */
    get network() {
        return this._network.network;
    }

    /**
     * @param {string[] | string} mirrorNetwork
     * @returns {void}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setMirrorNetwork(mirrorNetwork) {
        throw new Error("not implemented");
    }

    /**
     * @returns {string[]}
     */
    get mirrorNetwork() {
        return this._mirrorNetwork.network;
    }

    /**
     * @returns {boolean}
     */
    get signOnDemand() {
        return this._signOnDemand;
    }

    /**
     * @param {boolean} signOnDemand
     */
    setSignOnDemand(signOnDemand) {
        this._signOnDemand = signOnDemand;
    }

    /**
     * @returns {boolean}
     */
    isTransportSecurity() {
        return this._network.isTransportSecurity();
    }

    /**
     * @param {boolean} transportSecurity
     * @returns {this}
     */
    setTransportSecurity(transportSecurity) {
        this._network.setTransportSecurity(transportSecurity);
        this._mirrorNetwork.setTransportSecurity(transportSecurity);
        return this;
    }

    /**
     * Set the account that will, by default, pay for transactions and queries built with this client.
     *
     * @param {AccountId | string} accountId
     * @param {PrivateKey | string} privateKey
     * @returns {this}
     */
    setOperator(accountId, privateKey) {
        const key =
            typeof privateKey === "string"
                ? PrivateKey.fromString(privateKey)
                : privateKey;

        return this.setOperatorWith(accountId, key.publicKey, (message) =>
            Promise.resolve(key.sign(message))
        );
    }

    /**
     * Sets the account that will, by default, pay for transactions and queries built with
     * this client.
     *
     * @param {AccountId | string} accountId
     * @param {PublicKey | string} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {this}
     */
    setOperatorWith(accountId, publicKey, transactionSigner) {
        const accountId_ =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);

        if (this._network._ledgerId != null) {
            accountId_.validateChecksum(this);
        }

        this._operator = {
            transactionSigner,

            accountId: accountId_,

            publicKey:
                publicKey instanceof PublicKey
                    ? publicKey
                    : PublicKey.fromString(publicKey),
        };

        return this;
    }

    /**
     * @param {boolean} value
     * @returns {this}
     */
    setAutoValidateChecksums(value) {
        this._autoValidateChecksums = value;
        return this;
    }

    /**
     * @returns {boolean}
     */
    isAutoValidateChecksumsEnabled() {
        return this._autoValidateChecksums;
    }

    /**
     * @returns {?AccountId}
     */
    get operatorAccountId() {
        return this._operator != null ? this._operator.accountId : null;
    }

    /**
     * @returns {?PublicKey}
     */
    get operatorPublicKey() {
        return this._operator != null ? this._operator.publicKey : null;
    }

    /**
     * @deprecated - Use `defaultMaxTransactionFee` instead
     * @returns {?Hbar}
     */
    get maxTransactionFee() {
        return this._defaultMaxTransactionFee;
    }

    /**
     * @deprecated - Use `setDefaultMaxTransactionFee()` instead
     * Set the maximum fee to be paid for transactions
     * executed by this client.
     * @param {Hbar} maxTransactionFee
     * @returns {this}
     */
    setMaxTransactionFee(maxTransactionFee) {
        this._defaultMaxTransactionFee = maxTransactionFee;
        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get defaultMaxTransactionFee() {
        return this._defaultMaxTransactionFee;
    }

    /**
     * Set the defaultimum fee to be paid for transactions
     * executed by this client.
     *
     * @param {Hbar} defaultMaxTransactionFee
     * @returns {this}
     */
    setDefaultMaxTransactionFee(defaultMaxTransactionFee) {
        this._defaultMaxTransactionFee = defaultMaxTransactionFee;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get defaultRegenerateTransactionId() {
        return this._defaultRegenerateTransactionId;
    }

    /**
     * Set if a new transaction ID should be generated when a `TRANSACTION_EXPIRED` status
     * is returned.
     *
     * @param {boolean} defaultRegenerateTransactionId
     * @returns {this}
     */
    setDefaultRegenerateTransactionId(defaultRegenerateTransactionId) {
        this._defaultRegenerateTransactionId = defaultRegenerateTransactionId;
        return this;
    }

    /**
     * @returns {Hbar}
     */
    get maxQueryPayment() {
        return this._maxQueryPayment;
    }

    /**
     * Set the maximum payment allowable for queries.
     *
     * @param {Hbar} maxQueryPayment
     * @returns {Client<ChannelT, MirrorChannelT>}
     */
    setMaxQueryPayment(maxQueryPayment) {
        this._maxQueryPayment = maxQueryPayment;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxAttempts() {
        return this._maxAttempts != null ? this._maxAttempts : 10;
    }

    /**
     * @param {number} maxAttempts
     * @returns {this}
     */
    setMaxAttempts(maxAttempts) {
        this._maxAttempts = maxAttempts;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxNodeAttempts() {
        return this._network.maxNodeAttempts;
    }

    /**
     * @param {number} maxNodeAttempts
     * @returns {this}
     */
    setMaxNodeAttempts(maxNodeAttempts) {
        this._network.setMaxNodeAttempts(maxNodeAttempts);
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeWaitTime() {
        return this._network.minBackoff;
    }

    /**
     * @param {number} nodeWaitTime
     * @returns {this}
     */
    setNodeWaitTime(nodeWaitTime) {
        this._network.setMinBackoff(nodeWaitTime);
        return this;
    }

    /**
     * @returns {number}
     */
    get maxNodesPerTransaction() {
        return this._network.maxNodesPerTransaction;
    }

    /**
     * @param {number} maxNodesPerTransaction
     * @returns {this}
     */
    setMaxNodesPerTransaction(maxNodesPerTransaction) {
        this._network.setMaxNodesPerTransaction(maxNodesPerTransaction);
        return this;
    }

    /**
     * @param {?number} minBackoff
     * @returns {this}
     */
    setMinBackoff(minBackoff) {
        if (minBackoff == null) {
            throw new Error("minBackoff cannot be null.");
        }
        if (minBackoff > this._maxBackoff) {
            throw new Error("minBackoff cannot be larger than maxBackoff.");
        }
        this._minBackoff = minBackoff;
        return this;
    }

    /**
     * @returns {number}
     */
    get minBackoff() {
        return this._minBackoff;
    }

    /**
     * @param {?number} maxBackoff
     * @returns {this}
     */
    setMaxBackoff(maxBackoff) {
        if (maxBackoff == null) {
            throw new Error("maxBackoff cannot be null.");
        } else if (maxBackoff < this._minBackoff) {
            throw new Error("maxBackoff cannot be smaller than minBackoff.");
        }
        this._maxBackoff = maxBackoff;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxBackoff() {
        return this._maxBackoff;
    }

    /**
     * @param {number} nodeMinBackoff
     * @returns {this}
     */
    setNodeMinBackoff(nodeMinBackoff) {
        this._network.setMinBackoff(nodeMinBackoff);
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeMinBackoff() {
        return this._network.minBackoff;
    }

    /**
     * @param {number} nodeMaxBackoff
     * @returns {this}
     */
    setNodeMaxBackoff(nodeMaxBackoff) {
        this._network.setMaxBackoff(nodeMaxBackoff);
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeMaxBackoff() {
        return this._network.maxBackoff;
    }

    /**
     * @param {number} requestTimeout - Number of milliseconds
     * @returns {this}
     */
    setRequestTimeout(requestTimeout) {
        this._requestTimeout = requestTimeout;
        return this;
    }

    /**
     * @returns {?number}
     */
    get requestTimeout() {
        return this._requestTimeout;
    }

    /**
     * @param {AccountId | string} accountId
     */
    async ping(accountId) {
        try {
            await new AccountBalanceQuery({ accountId })
                .setNodeAccountIds([
                    accountId instanceof AccountId
                        ? accountId
                        : AccountId.fromString(accountId),
                ])
                .execute(this);
        } catch (_) {
            // Do nothing
        }
    }

    async pingAll() {
        for (const nodeAccountId of Object.values(this._network.network)) {
            await this.ping(nodeAccountId);
        }
    }

    /**
     * @returns {void}
     */
    close() {
        this._network.close();
        this._mirrorNetwork.close();
    }

    /**
     * @abstract
     * @returns {(address: string) => ChannelT}
     */
    _createNetworkChannel() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {(address: string) => MirrorChannelT}
     */
    _createMirrorNetworkChannel() {
        throw new Error("not implemented");
    }
}

/**
 * @internal
 * @abstract
 */
class Channel {
    /**
     * @protected
     */
    constructor() {
        /**
         * @protected
         * @type {?CryptoService}
         */
        this._crypto = null;

        /**
         * @protected
         * @type {?SmartContractService}
         */
        this._smartContract = null;

        /**
         * @protected
         * @type {?FileService}
         */
        this._file = null;

        /**
         * @protected
         * @type {?ConsensusService}
         */
        this._consensus = null;

        /**
         * @protected
         * @type {?FreezeService}
         */
        this._freeze = null;

        /**
         * @protected
         * @type {?NetworkService}
         */
        this._network = null;

        /**
         * @protected
         * @type {?TokenService}
         */
        this._token = null;

        /**
         * @protected
         * @type {?ScheduleService}
         */
        this._schedule = null;
    }

    /**
     * @abstract
     * @returns {void}
     */
    close() {
        throw new Error("not implemented");
    }

    /**
     * @returns {CryptoService}
     */
    get crypto() {
        if (this._crypto != null) {
            return this._crypto;
        }

        this._crypto = lib.CryptoService.create(
            this._createUnaryClient("CryptoService")
        );

        return this._crypto;
    }

    /**
     * @returns {SmartContractService}
     */
    get smartContract() {
        if (this._smartContract != null) {
            return this._smartContract;
        }

        this._smartContract = lib.SmartContractService.create(
            this._createUnaryClient("SmartContractService")
        );

        return this._smartContract;
    }

    /**
     * @returns {FileService}
     */
    get file() {
        if (this._file != null) {
            return this._file;
        }

        this._file = lib.FileService.create(this._createUnaryClient("FileService"));

        return this._file;
    }

    /**
     * @returns {ConsensusService}
     */
    get consensus() {
        if (this._consensus != null) {
            return this._consensus;
        }

        this._consensus = lib.ConsensusService.create(
            this._createUnaryClient("ConsensusService")
        );

        return this._consensus;
    }

    /**
     * @returns {FreezeService}
     */
    get freeze() {
        if (this._freeze != null) {
            return this._freeze;
        }

        this._freeze = lib.FreezeService.create(
            this._createUnaryClient("FreezeService")
        );

        return this._freeze;
    }

    /**
     * @returns {NetworkService}
     */
    get network() {
        if (this._network != null) {
            return this._network;
        }

        this._network = lib.NetworkService.create(
            this._createUnaryClient("NetworkService")
        );

        return this._network;
    }

    /**
     * @returns {TokenService}
     */
    get token() {
        if (this._token != null) {
            return this._token;
        }

        this._token = lib.TokenService.create(
            this._createUnaryClient("TokenService")
        );

        return this._token;
    }

    /**
     * @returns {ScheduleService}
     */
    get schedule() {
        if (this._schedule != null) {
            return this._schedule;
        }

        this._schedule = lib.ScheduleService.create(
            this._createUnaryClient("ScheduleService")
        );

        return this._schedule;
    }

    /**
     * @abstract
     * @protected
     * @param {string} serviceName
     * @returns {import("protobufjs").RPCImpl}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _createUnaryClient(serviceName) {
        throw new Error("not implemented");
    }
}

// grpc-web+proto is a series of data or trailer frames

// a frame is identified by a single byte (0 = data or 1 = trailer) followed by 4 bytes for the
// length of the frame, followed by the frame data

/**
 * @param {Uint8Array} data
 * @returns {ArrayBuffer}
 */
function encodeRequest(data) {
    // for our requests, we want to transfer a single data frame

    const frame = new ArrayBuffer(data.byteLength + 5);

    // the frame type (data) is zero and can be left default-initialized

    // the length of the frame data
    new DataView(frame, 1, 4).setUint32(0, data.length);

    // copy in the frame data
    new Uint8Array(frame, 5).set(data);

    return frame;
}

/**
 * @param {ArrayBuffer} data
 * @param {number} byteOffset
 * @param {number} byteLength
 * @returns {Uint8Array}
 */
function decodeUnaryResponse(
    data,
    byteOffset = 0,
    byteLength = data.byteLength
) {
    const dataView = new DataView(data, byteOffset, byteLength);
    let dataOffset = 0;

    /** @type {?Uint8Array} */
    let unaryResponse = null;

    // 0 = successful
    let status = 0;

    while (dataOffset < dataView.byteLength) {
        const frameByte = dataView.getUint8(dataOffset + 0);
        const frameType = frameByte >> 7;
        const frameByteLength = dataView.getUint32(dataOffset + 1);
        const frameOffset = dataOffset + 5; // offset from the start of the dataView
        if (frameOffset + frameByteLength > dataView.byteLength) {
            throw new Error("(BUG) unexpected frame length past the boundary");
        }
        const frameData = new Uint8Array(
            data,
            dataView.byteOffset + frameOffset,
            frameByteLength
        );

        if (frameType === 0) {
            if (unaryResponse != null) {
                throw new Error(
                    "(BUG) unexpectedly received more than one data frame"
                );
            }

            unaryResponse = frameData;
        } else if (frameType === 1) {
            const trailer = decode(frameData);
            const [trailerName, trailerValue] = trailer.split(":");

            if (trailerName === "grpc-status") {
                status = parseInt(trailerValue);
            } else {
                throw new Error(`(BUG) unhandled trailer, ${trailer}`);
            }
        } else {
            throw new Error(`(BUG) unexpected frame type: ${frameType}`);
        }

        dataOffset += frameByteLength + 5;
    }

    if (status !== 0) {
        throw new Error(`(BUG) unhandled grpc-status: ${status}`);
    }

    if (unaryResponse == null) {
        throw new Error("(BUG) unexpectedly received no response");
    }

    return unaryResponse;
}

class WebChannel extends Channel {
    /**
     * @param {string} address
     */
    constructor(address) {
        super();

        /**
         * @type {string}
         * @private
         */
        this._address = address;
    }

    /**
     * @override
     * @returns {void}
     */
    close() {
        // do nothing
    }

    /**
     * @override
     * @protected
     * @param {string} serviceName
     * @returns {import("protobufjs").RPCImpl}
     */
    _createUnaryClient(serviceName) {
        return async (method, requestData, callback) => {
            const response = await fetch(
                `${this._address}/proto.${serviceName}/${method.name}`,
                {
                    method: "POST",
                    headers: {
                        "content-type": "application/grpc-web+proto",
                        "x-user-agent": "hedera-sdk-js/v2",
                        "x-grpc-web": "1",
                    },
                    body: encodeRequest(requestData),
                }
            );

            const responseBuffer = await response.arrayBuffer();
            const unaryResponse = decodeUnaryResponse(responseBuffer);

            callback(null, unaryResponse);
        };
    }
}

/**
 * @typedef {import("./Client.js").ClientConfiguration} ClientConfiguration
 */

const Network = {
    /**
     * @param {string} name
     * @returns {{[key: string]: (string | AccountId)}}
     */
    fromName(name) {
        switch (name) {
            case "mainnet":
                return Network.MAINNET;

            case "testnet":
                return Network.TESTNET;

            case "previewnet":
                return Network.PREVIEWNET;

            default:
                throw new Error(`unknown network name: ${name}`);
        }
    },

    MAINNET: {
        "https://grpc-web.myhbarwallet.com:443": new AccountId(3),
    },

    TESTNET: {
        "https://grpc-web.testnet.myhbarwallet.com:443": new AccountId(3),
    },

    PREVIEWNET: {
        "https://grpc-web.previewnet.myhbarwallet.com:443": new AccountId(3),
    },
};

/**
 * @augments {Client<WebChannel, *>}
 */
class WebClient extends Client {
    /**
     * @param {ClientConfiguration} [props]
     */
    constructor(props) {
        super(props);

        if (props != null) {
            if (typeof props.network === "string") {
                switch (props.network) {
                    case "mainnet":
                        this.setNetwork(Network.MAINNET);
                        this.setLedgerId(LedgerId.MAINNET);
                        break;

                    case "testnet":
                        this.setNetwork(Network.TESTNET);
                        this.setLedgerId(LedgerId.TESTNET);
                        break;

                    case "previewnet":
                        this.setNetwork(Network.PREVIEWNET);
                        this.setLedgerId(LedgerId.PREVIEWNET);
                        break;

                    default:
                        throw new Error(
                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                            `unknown network: ${props.network}`
                        );
                }
            } else if (props.network != null) {
                this.setNetwork(props.network);
            }
        }
    }

    /**
     * @param {string | ClientConfiguration} data
     * @returns {WebClient}
     */
    static fromConfig(data) {
        return new WebClient(
            typeof data === "string"
                ? /** @type {ClientConfiguration | undefined} */ (
                      JSON.parse(data)
                  )
                : data
        );
    }

    /**
     * Construct a client for a specific network.
     *
     * It is the responsibility of the caller to ensure that all nodes in the map are part of the
     * same Hedera network. Failure to do so will result in undefined behavior.
     *
     * The client will load balance all requests to Hedera using a simple round-robin scheme to
     * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be
     * tried.
     *
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {WebClient}
     */
    static forNetwork(network) {
        return new WebClient({ network });
    }

    /**
     * @param {string} network
     * @returns {WebClient}
     */
    static forName(network) {
        return new WebClient({ network });
    }

    /**
     * Construct a Hedera client pre-configured for Mainnet access.
     *
     * @returns {WebClient}
     */
    static forMainnet() {
        return new WebClient({ network: "mainnet" });
    }

    /**
     * Construct a Hedera client pre-configured for Testnet access.
     *
     * @returns {WebClient}
     */
    static forTestnet() {
        return new WebClient({ network: "testnet" });
    }

    /**
     * Construct a Hedera client pre-configured for Previewnet access.
     *
     * @returns {WebClient}
     */
    static forPreviewnet() {
        return new WebClient({ network: "previewnet" });
    }

    /**
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {void}
     */
    setNetwork(network) {
        if (typeof network === "string") {
            switch (network) {
                case "previewnet":
                    this._network.setNetwork(Network.PREVIEWNET);
                    break;
                case "testnet":
                    this._network.setNetwork(Network.TESTNET);
                    break;
                case "mainnet":
                    this._network.setNetwork(Network.MAINNET);
            }
        } else {
            this._network.setNetwork(network);
        }
    }

    /**
     * @param {string[] | string} mirrorNetwork
     * @returns {this}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setMirrorNetwork(mirrorNetwork) {
        if (typeof mirrorNetwork === "string") {
            this._mirrorNetwork.setNetwork([]);
        } else {
            this._mirrorNetwork.setNetwork(mirrorNetwork);
        }

        return this;
    }

    /**
     * @override
     * @returns {(address: string) => WebChannel}
     */
    _createNetworkChannel() {
        return (address) => new WebChannel(address);
    }

    /**
     * @override
     * @returns {(address: string) => *}
     */
    _createMirrorNetworkChannel() {
        return () => {
            throw new Error("mirror support is not supported in browsers");
        };
    }
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

const version$7 = "logger/5.5.0";

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version$7);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

const version$6 = "bytes/5.5.0";

const logger$9 = new Logger(version$6);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$9.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0x0" + hex.substring(2);
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger$9.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        const result = [];
        for (let i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger$9.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map(item => arrayify(item));
    const length = objects.reduce((accum, item) => (accum + item.length), 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$9.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger$9.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger$9.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger$9.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger$9.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger$9.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}

const version$5 = "bignumber/5.5.0";

var BN = _BN.BN;
const logger$8 = new Logger(version$5);
const _constructorGuard$1 = {};
const MAX_SAFE = 0x1fffffffffffff;
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        logger$8.checkNew(new.target, BigNumber);
        if (constructorGuard !== _constructorGuard$1) {
            logger$8.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault("division by zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("cannot modulo negative values", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("cannot raise to negative values", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("cannot 'and' negative values", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("cannot 'or' negative values", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("cannot 'xor' negative values", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault("cannot mask negative values", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault("cannot shift negative values", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault("cannot shift negative values", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger$8.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger$8.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger$8.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger$8.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard$1, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard$1, toHex(new BN(value)));
            }
            return logger$8.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
            return BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if (isHexString(hex) || (hex[0] === "-" && isHexString(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger$8.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger$8.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger$8.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}

const version$4 = "properties/5.5.0";

(window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$7 = new Logger(version$4);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            let value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger$7.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof (object) === "object") {
        const result = {};
        for (const key in object) {
            const value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger$7.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info) {
        for (const key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
}

const version$3 = "abi/5.5.0";

const logger$6 = new Logger(version$3);
const _constructorGuard = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        logger$6.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger$6.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i = 0; i < param.length; i++) {
        let c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        logger$6.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (let key in params) {
        defineReadOnly(object, key, params[key]);
    }
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$6.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            let result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.components) {
                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof (value) === "string") {
            return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(_constructorGuard, {
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$6.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === "string") {
            return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger$6.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(" ")[0] === "function") {
            return FunctionFragment.fromString(value.substring(8).trim());
        }
        else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(" ")[0] === "error") {
            return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger$6.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            logger$6.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
            logger$6.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger$6.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return (value && value._isFragment && value.type === "event");
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) {
            logger$6.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
            logger$6.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = BigNumber.from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                logger$6.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                logger$6.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger$6.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            logger$6.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        logger$6.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        if (format === FormatTypes.sighash) {
            logger$6.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            logger$6.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
            logger$6.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            logger$6.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return (value && value._isFragment && value.type === "constructor");
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
            }
            if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            logger$6.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
            logger$6.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
            logger$6.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                logger$6.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return (value && value._isFragment && value.type === "function");
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger$6.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$6.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            logger$6.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
            logger$6.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return (value && value._isFragment && value.type === "error");
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        logger$6.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    logger$6.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}

const logger$5 = new Logger(version$3);
class Coder {
    constructor(name, type, localName, dynamic) {
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger$5.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return hexConcat(this._data);
    }
    get length() { return this._dataLength; }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData(concat(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = arrayify(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = arrayify(BigNumber.from(value));
        if (bytes.length > this.wordSize) {
            logger$5.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes.length
            });
        }
        if (bytes.length % this.wordSize) {
            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() { return hexlify(this._data); }
    get consumed() { return this._offset; }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
        }
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) {
            return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                logger$5.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + alignedLength
                });
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
    }
}

var global$2 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$2.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$2.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version$2 = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config$1 = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance$1 = global$2.performance || {};
var performanceNow =
  performance$1.now        ||
  performance$1.mozNow     ||
  performance$1.msNow      ||
  performance$1.oNow       ||
  performance$1.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance$1)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version$2,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config$1,
  uptime: uptime
};

var process$1 = browser$1;

var sha3$1 = {exports: {}};

(function (module) {
/*jslint bitwise: true */
(function () {

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process$1 === 'object' && process$1.versions && process$1.versions.node;
  if (NODE_JS) {
    root = commonjsGlobal;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
  }
})();
}(sha3$1));

var sha3 = sha3$1.exports;

function keccak256(data) {
    return '0x' + sha3.keccak_256(arrayify(data));
}

const version$1 = "address/5.5.0";

const logger$4 = new Logger(version$1);
function getChecksumAddress(address) {
    if (!isHexString(address, 20)) {
        logger$4.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = arrayify(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
function getAddress(address) {
    let result = null;
    if (typeof (address) !== "string") {
        logger$4.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger$4.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger$4.throwArgumentError("bad icap checksum", "address", address);
        }
        result = _base36To16(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger$4.throwArgumentError("invalid address", "address", address);
    }
    return result;
}

class AddressCoder extends Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = getAddress(value);
        }
        catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
    }
}

// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends Coder {
    constructor(coder) {
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

const logger$3 = new Logger(version$3);
function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            if (!name) {
                logger$3.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            if (unique[name]) {
                logger$3.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            unique[name] = true;
            return values[name];
        });
    }
    else {
        logger$3.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
        logger$3.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new Writer(writer.wordSize);
    let dynamicWriter = new Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value != undefined) {
            values.push(value);
        }
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
            return;
        }
        if (name === "length") {
            name = "_length";
        }
        if (values[name] != null) {
            return;
        }
        const value = values[index];
        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
        else {
            values[name] = value;
        }
    });
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
    }
    return Object.freeze(values);
}
class ArrayCoder extends Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger$3.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) {
                logger$3.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
                    length: reader._data.length,
                    count: count
                });
            }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
    }
}

class BooleanCoder extends Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}

class DynamicBytesCoder extends Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
    }
}

// @TODO: Merge this with bytes
class FixedBytesCoder extends Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = arrayify(value);
        if (data.length !== this.size) {
            this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
    }
}

class NullCoder extends Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}

const NegativeOne = ( /*#__PURE__*/BigNumber.from(-1));
const Zero = ( /*#__PURE__*/BigNumber.from(0));
const One = ( /*#__PURE__*/BigNumber.from(1));
const MaxUint256 = ( /*#__PURE__*/BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

class NumberCoder extends Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = BigNumber.from(value);
        // Check bounds are safe for encoding
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}

const version = "strings/5.5.0";

const logger$2 = new Logger(version);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger$2.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = arrayify(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger$2.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return arrayify(result);
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}

class StringCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
    }
    decode(reader) {
        return toUtf8String(super.decode(reader));
    }
}

class TupleCoder extends Coder {
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return pack(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
    }
}

const logger$1 = new Logger(version$3);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        logger$1.checkNew(new.target, AbiCoder);
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new AddressCoder(param.name);
            case "bool":
                return new BooleanCoder(param.name);
            case "string":
                return new StringCoder(param.name);
            case "bytes":
                return new BytesCoder(param.name);
            case "array":
                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new TupleCoder((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                logger$1.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                logger$1.throwArgumentError("invalid bytes length", "param", param);
            }
            return new FixedBytesCoder(size, param.name);
        }
        return logger$1.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new Writer(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            logger$1.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = (new TupleCoder(coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();

function id(text) {
    return keccak256(toUtf8Bytes(text));
}

const logger = new Logger(version$3);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
    constructor(fragments) {
        logger.checkNew(new.target, Interface);
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
            return Fragment.from(fragment);
        }).filter((fragment) => (fragment != null)));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment) => {
            let bucket = null;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        logger.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    defineReadOnly(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            defineReadOnly(this, "deploy", ConstructorFragment.from({
                payable: false,
                type: "constructor"
            }));
        }
        defineReadOnly(this, "_isInterface", true);
    }
    format(format) {
        if (!format) {
            format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
            logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === FormatTypes.json) {
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return defaultAbiCoder;
    }
    static getAddress(address) {
        return getAddress(address);
    }
    static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return id(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            for (const name in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name)) {
                    return this.functions[name];
                }
            }
            logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching function", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching functions", "name", name);
            }
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for (const name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            logger.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching event", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching events", "name", name);
            }
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            const getSighash = getStatic(this.constructor, "getSighash");
            for (const name in this.errors) {
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                    return this.errors[name];
                }
            }
            logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching error", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching errors", "name", name);
            }
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof (fragment) === "string") {
            try {
                fragment = this.getFunction(fragment);
            }
            catch (error) {
                try {
                    fragment = this.getError(fragment);
                }
                catch (_) {
                    throw error;
                }
            }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        return hexlify(concat([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                }
                catch (error) { }
                break;
            case 4: {
                const selector = hexlify(bytes.slice(0, 4));
                const builtin = BuiltinErrors[selector];
                if (builtin) {
                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                    errorName = builtin.name;
                    errorSignature = builtin.signature;
                    if (builtin.reason) {
                        reason = errorArgs[0];
                    }
                }
                else {
                    try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    }
                    catch (error) {
                        console.log(error);
                    }
                }
                break;
            }
        }
        return logger.throwError("call revert exception", Logger.errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            errorArgs, errorName, errorSignature, reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
            logger.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
            });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return id(value);
            }
            else if (param.type === "bytes") {
                return keccak256(hexlify(value));
            }
            // Check addresses are valid
            if (param.type === "address") {
                this._abiCoder.encode(["address"], [value]);
            }
            return hexZeroPad(hexlify(value), 32);
        };
        values.forEach((value, index) => {
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) {
                    logger.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                }
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
            logger.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push(id(value));
                }
                else if (param.type === "bytes") {
                    topics.push(keccak256(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                logger.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = new Indexed({ _isIndexed: true, hash: null });
                }
                else if (dynamic[index]) {
                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                }
                else {
                    try {
                        result[index] = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        result[index] = error;
                    }
                }
            }
            else {
                try {
                    result[index] = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    result[index] = error;
                }
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) {
                    Object.defineProperty(result, param.name, {
                        enumerable: true,
                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }
                    });
                }
                else {
                    result[param.name] = value;
                }
            }
        });
        // Make all error indexed values throw on access
        for (let i = 0; i < result.length; i++) {
            const value = result[i];
            if (value instanceof Error) {
                Object.defineProperty(result, i, {
                    enumerable: true,
                    get: () => { throw wrapAccessError(`index ${i}`, value); }
                });
            }
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: BigNumber.from(tx.value || "0"),
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = hexlify(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
        return !!(value && value._isInterface);
    }
}

var traverse$2 = {exports: {}};

var traverse = traverse$2.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f; },
            after : function (f) { modifiers.after = f; },
            pre : function (f) { modifiers.pre = f; },
            post : function (f) { modifiers.post = f; },
            stop : function () { alive = false; },
            block : function () { keepGoing = false; }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node);
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

var traverse$1 = traverse$2.exports;

/**
 * Common functionality exhibited by session-bounded, id-entifiable LiveEntity instances.
 */
class LiveEntity {
  constructor(session, id) {
    this.session = session;
    this.id = id;
  }

  get log() {
    return this.session.log;
  }

  equals(what) {
    if (what instanceof LiveEntity) {
      return what.id.toString() === this.id.toString();
    }

    return this._equals(what);
  }

  deleteEntity(args) {
    const transaction = this._getDeleteTransaction(args);

    return this.executeAndReturnStatus(transaction);
  }

  async updateEntity(args) {
    const transaction = await this._getUpdateTransaction(args);
    return this.executeAndReturnStatus(transaction);
  }

  _equals(what) {
    return false;
  }

  async executeAndReturnStatus(transaction) {
    return this.session.execute(transaction, TypeOfExecutionReturn.Receipt, false).then(receipt => receipt.status);
  }

}

class BaseLiveEntityWithBalance extends LiveEntity {
  getBalanceOfLiveEntity() {
    const queryPayload = this._getBalancePayload();

    const balanceQuery = new AccountBalanceQuery(queryPayload);
    return this.session.execute(balanceQuery, TypeOfExecutionReturn.Result, false);
  }

  transferHbarToLiveEntity(hbarAmount) {
    const amountToTransfer = hbarAmount instanceof Hbar ? hbarAmount : new Hbar(hbarAmount);
    const transferTransaction = new TransferTransaction().addHbarTransfer(this.session.wallet.account.id, amountToTransfer.negated()).addHbarTransfer(this.id.toString(), amountToTransfer);
    return this.executeAndReturnStatus(transferTransaction);
  }

  associateTokensWithLiveEntity(tokens) {
    const tokenAssociateTransaction = new TokenAssociateTransaction().setAccountId(this.id.toString()).setTokenIds(tokens);
    return this.executeAndReturnStatus(tokenAssociateTransaction);
  }

  _getDeleteTransaction(args) {
    return this.newDeleteTransaction(this._getDeleteArguments(args));
  }

  _getDeleteArguments(args) {
    let argsToReturn = args;

    if (!args || !args.has("transferAccountId") || !args.has("transferContractId")) {
      argsToReturn = { ...args,
        "transferAccountId": this.session.wallet.account.id
      };
    }

    return argsToReturn;
  }

}

function upperCaseFirstOf(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

class ParamTypeToFunctionNameMapper {
  constructor(paramType) {
    this.paramType = paramType;
  }

  map({
    prefix = ''
  }) {
    const defTypeToTarget = this._geCanonicalTypeFor(this.paramType);

    return `${prefix}${this._getFunctionParticleFor(defTypeToTarget)}`;
  }
  /**
   * Retrieves the canonical value of the provided param type-definition such as an 'int256' whenever referencing its shorter form, 'int'.
   *   See {@link https://docs.soliditylang.org/en/v0.8.10/abi-spec.html#types} for a list of such mappings.
   */


  _geCanonicalTypeFor(paramType) {
    if ('int' === paramType.type) return 'int256';
    if ('int[]' === paramType.type) return 'int256[]';
    if ('uint' === paramType.type) return 'uint256';
    if ('uint[]' === paramType.type) return 'uint256[]';
    return paramType.type;
  }
  /**
   * Given a type-name, it maps it to the Hedera Equivalent function-name expected value ready to be used in an actual SDK call 
   * such as a 'get'-ing operation or an 'add'-ing one.
   *   Ex. 'uint256[]' would get mapped to 'Uint256Array' which, when 'add'-ing, would end up to be used as 'addUint256Array'.
   */


  _getFunctionParticleFor(typeName) {
    let functionParticle = upperCaseFirstOf(typeName);

    if (functionParticle.endsWith("[]")) {
      functionParticle = functionParticle.replace("[]", "Array");
    }

    return functionParticle;
  }

}

function isSolidityAddressable(arg) {
  return arg && arg.getSolidityAddress && typeof arg.getSolidityAddress === 'function';
}
function extractSolidityAddressFrom(addr) {
  const matchedExp = /^(?:0x)?([0-9a-fA-F]{40})$/g.exec(addr);
  return matchedExp != undefined ? matchedExp[1] : undefined;
}

// This module holds generic functionality that belongs nowhere.
// Always be mindful when adding code here and try to refactor and group the functionality into something more meaningful.
// This project is not fond of utility classes.

/**
 * A generic mapper that transforms something to something else. 
 * If what needs to be transformed is a plain, non-array, value, it just transforms it.
 * If it's an array, the transformation applies to all its elements. 
 * If it's a deep nested array (array within an array), the transformation applies to the leaf elements.
 * 
 * @param what The thing that will get transformed
 * @param into The transformer
 * @returns Transforms what into something else
 */
function transform(what, into) {
  return Array.isArray(what) ? what.map(el => transform(el, into)) : into(what);
}

class ContractFunctionParameters extends ContractFunctionParameters$1 {
  /**
     * Given a set of user-defined arguments and starting from the provided function/constructor interface definition, 
     * facilitates the construction of a {@see ContractFunctionParameters} ready to be embedded in a Contract transaction/query.
     * 
     * @param {ConstructorFragment|FunctionFragment} fDescription - The function/constructor schema
     * @param {Array} args - A list of arguments to be parsed into the underlying AbiDescription 
     */
  static async newFor(fDescription, args) {
    if (!Array.isArray(args)) {
      throw new ContractFunctionParametersParser("I need an array of args in order to construct the ContractFunctionParameters instance for.");
    } else if (fDescription.inputs.length !== args.length) {
      throw new ContractFunctionParametersParser(`The contract expects ${fDescription.inputs.length} arguments yet ${args.length} were provided.`);
    }

    const toReturn = new ContractFunctionParameters();

    for (const id in args) {
      const fInputDescription = fDescription.inputs[id];
      const fctCallName = new ParamTypeToFunctionNameMapper(fInputDescription).map({
        prefix: 'add'
      });
      const shouldUseBigNumbers = fctCallName.indexOf("64") !== -1 || fctCallName.indexOf("256") !== -1;
      let argToAdd = args[id];

      if (fInputDescription.type.startsWith('address')) {
        const considerMappingSolidityAddressableToAddress = arg => isSolidityAddressable(arg) ? arg.getSolidityAddress() : arg;

        argToAdd = transform(argToAdd, considerMappingSolidityAddressableToAddress);
      } else if (fInputDescription.type.startsWith('bytes') && !(argToAdd instanceof Uint8Array)) {
        argToAdd = transform(argToAdd, arrayify);
      } else if (shouldUseBigNumbers) {
        const toBigNumber = arg => {
          if (arg instanceof Hbar) {
            return arg._valueInTinybar;
          }

          return arg instanceof BigNumber$1 ? arg : new BigNumber$1(arg);
        };

        argToAdd = transform(argToAdd, toBigNumber);
      }

      toReturn[fctCallName](argToAdd);
    }

    return toReturn;
  }

  constructor() {
    super();
  }

}
class ContractFunctionParametersParser extends Error {
  constructor(msg) {
    super(msg);
  }

}

class BasicCreatableEntity {
  constructor(name) {
    this.name = name;
  }

}

let KeyType;

(function (KeyType) {
  KeyType[KeyType["ECDSA"] = 0] = "ECDSA";
  KeyType[KeyType["ED25519"] = 1] = "ED25519";
  KeyType[KeyType["Unknown"] = 2] = "Unknown";
})(KeyType || (KeyType = {}));

class Account extends BasicCreatableEntity {
  static async mapAccountFeaturesToAccountArguments(session, features) {
    // we are looking to generate a key if a keyType exists on the AccountFeatures
    if (features.keyType !== null) {
      const key = await Account.considerGenerateKeyFromAccountFeatures(session.log, features);
      return Object.assign({}, features, {
        key
      });
    }

    return features;
  }
  /**
   * @param logger - StratoLogger to log information of the created key
   * @param features - AccountFeatures being used to find out what type of key needs to be generated
   * @returns - the key for the new account
   */


  static async considerGenerateKeyFromAccountFeatures(logger, features) {
    let keyToReturn = features.key;

    if (!features.key) {
      const {
        keyType
      } = features;
      const keyTypeString = keyType === KeyType.ED25519 ? KeyType[KeyType.ED25519] : KeyType[KeyType.ECDSA];
      keyToReturn = keyType === KeyType.ED25519 ? await PrivateKey.generateED25519Async() : await PrivateKey.generateECDSAAsync();
      logger.debug(`A new '${keyTypeString}' key has been created: ${keyToReturn.toStringDer()} . Copy it since this is only time you'll see it.`);
    }

    return keyToReturn;
  }

  constructor(info) {
    super("Account");
    this.accountFeatures = {
      keyType: KeyType.ED25519,
      ...info
    };
  }

  async createVia({
    session
  }) {
    let resolutedInfo;

    if (this.key) {
      resolutedInfo = Object.assign({}, this.accountFeatures, {
        key: this.key
      });
    }

    resolutedInfo = await Account.mapAccountFeaturesToAccountArguments(session, this.accountFeatures);
    const createAccountTransaction = new AccountCreateTransaction(resolutedInfo);
    const {
      accountId
    } = await session.execute(createAccountTransaction, TypeOfExecutionReturn.Receipt, true);
    return new LiveAccountWithPrivateKey({
      id: accountId,
      privateKey: resolutedInfo.key,
      session
    });
  }

}

class LiveAccount extends BaseLiveEntityWithBalance {
  constructor({
    session,
    id
  }) {
    super(session, id);
  }

  getSolidityAddress() {
    return this.id.toSolidityAddress();
  }

  getLiveEntityInfo() {
    const accountInfoQuery = new AccountInfoQuery().setAccountId(this.id);
    return this.session.execute(accountInfoQuery, TypeOfExecutionReturn.Result, false);
  }

  newDeleteTransaction(args) {
    return new AccountDeleteTransaction({
      accountId: this.id,
      ...args
    });
  }

  async _getUpdateTransaction(args) {
    const propsUsedForUpdate = await Account.mapAccountFeaturesToAccountArguments(this.session, args);
    return new AccountUpdateTransaction(propsUsedForUpdate);
  }

  _getBalancePayload() {
    return {
      accountId: this.id
    };
  }

}
/**
 * A wrapper class that contains both a {@link LiveAccount} and its associated private-key generated, most likely, at network-creation time.
 * Consequently, this is meant to be generated when first {@link ApiSession.create}-ing an {@link Account}.
 */

class LiveAccountWithPrivateKey extends LiveAccount {
  constructor({
    session,
    id,
    privateKey
  }) {
    super({
      id,
      session
    });
    this.privateKey = privateKey;
  }

  tryToSign(transaction) {
    const signature = this.privateKey.signTransaction(transaction);
    transaction.addSignature(this.privateKey.publicKey, signature);
  }

  async _getUpdateTransaction(args) {
    const updateTransaction = await super._getUpdateTransaction(args); // TODO: freeze with signer similar to the delete op?

    this.tryToSign(updateTransaction);
    return updateTransaction;
  }

  _getDeleteTransaction(args) {
    const deleteTransaction = super._getDeleteTransaction(args);

    deleteTransaction.freezeWithSigner(this.session.wallet.signer);
    this.tryToSign(deleteTransaction);
    return deleteTransaction;
  }

}

class StratoAddress {
  static getSolidityAddressMatchOrDieTryingFrom(addr) {
    const matchedSolidityAddress = extractSolidityAddressFrom(addr);

    if (!matchedSolidityAddress) {
      throw new Error(`The provided address '${addr}' does not appear to be a valid Solidity address.`);
    } // We're lower-casein this to match Hedera's ".toSolidityAddress" behavior for consistency


    return matchedSolidityAddress.toLowerCase();
  }

  constructor(session, address) {
    this.session = session;
    this.id = StratoAddress.getSolidityAddressMatchOrDieTryingFrom(address);
  }

  getSolidityAddress() {
    return this.id;
  }

  async toLiveAccount() {
    const id = AccountId.fromSolidityAddress(this.getSolidityAddress());
    return new LiveAccount({
      id,
      session: this.session
    });
  }

  async toLiveContract(cInterface) {
    const id = ContractId.fromSolidityAddress(this.getSolidityAddress());
    return new LiveContract({
      cInterface,
      id,
      session: this.session
    });
  }

  equals(what) {
    if (what instanceof LiveEntity) {
      return what.id.toString() === this.id.toString();
    }

    return typeof what === 'string' ? extractSolidityAddressFrom(what).toLocaleLowerCase() === this.id : what instanceof AccountId ? what.toSolidityAddress() === this.id : false;
  }

}

var Hex = {};

var interopRequireDefault$1 = {exports: {}};

(function (module) {
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(interopRequireDefault$1));

var toConsumableArray = {exports: {}};

var arrayWithoutHoles = {exports: {}};

var arrayLikeToArray = {exports: {}};

(function (module) {
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(arrayLikeToArray));

(function (module) {
var arrayLikeToArray$1 = arrayLikeToArray.exports;

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray$1(arr);
}

module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(arrayWithoutHoles));

var iterableToArray = {exports: {}};

(function (module) {
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(iterableToArray));

var unsupportedIterableToArray = {exports: {}};

(function (module) {
var arrayLikeToArray$1 = arrayLikeToArray.exports;

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray$1(o, minLen);
}

module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(unsupportedIterableToArray));

var nonIterableSpread = {exports: {}};

(function (module) {
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(nonIterableSpread));

(function (module) {
var arrayWithoutHoles$1 = arrayWithoutHoles.exports;

var iterableToArray$1 = iterableToArray.exports;

var unsupportedIterableToArray$1 = unsupportedIterableToArray.exports;

var nonIterableSpread$1 = nonIterableSpread.exports;

function _toConsumableArray(arr) {
  return arrayWithoutHoles$1(arr) || iterableToArray$1(arr) || unsupportedIterableToArray$1(arr) || nonIterableSpread$1();
}

module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(toConsumableArray));

var _interopRequireDefault$2 = interopRequireDefault$1.exports;

Object.defineProperty(Hex, "__esModule", {
  value: true
});
var encodeToHex_1 = Hex.encodeToHex = encodeToHex;

var _toConsumableArray2 = _interopRequireDefault$2(toConsumableArray.exports);

function encodeToHex(what) {
  var addPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var unPrefixedHexEncoding = (0, _toConsumableArray2["default"])(what).map(function (x) {
    return x.toString(16).padStart(2, "0");
  }).join("");
  return addPrefix ? "0x".concat(unPrefixedHexEncoding) : unPrefixedHexEncoding;
}

const UNHANDLED_EVENT_NAME = "UnhandledEventName";

function isContractQueryRequest(request) {
  return request instanceof ContractCallQuery;
}

function parseLogs(cInterface, logs) {
  return logs.map(recordLog => {
    const data = encodeToHex_1(recordLog.data);
    const topics = recordLog.topics.map(topic => encodeToHex_1(topic));

    try {
      const logDescription = cInterface.parseLog({
        data,
        topics
      });
      const decodedEventObject = Object.keys(logDescription.args).filter(evDataKey => isNaN(Number(evDataKey))).map(namedEvDataKey => ({
        [namedEvDataKey]: logDescription.args[namedEvDataKey]
      })).reduce((p, c) => ({ ...p,
        ...c
      }), {});
      return {
        name: logDescription.name,
        payload: decodedEventObject
      };
    } catch (e) {
      // No-op, yet we need to filter this element out because something went wrong
      // TODO: log something here
      return null;
    }
  }).filter(parsedLogCandidate => parsedLogCandidate !== null);
}

class LiveContract extends BaseLiveEntityWithBalance {
  /**
     * Constructs a new LiveContract to be interacted with on the Hashgraph.
     */
  static async newFollowingUpload({
    session,
    contract,
    emitConstructorLogs,
    transaction
  }) {
    let id;
    let logs;

    if (emitConstructorLogs) {
      const createdContractRecord = await session.execute(transaction, TypeOfExecutionReturn.Record, true);
      id = createdContractRecord.receipt.contractId;
      logs = parseLogs(contract.interface, createdContractRecord.contractFunctionResult.logs);
    } else {
      const transactionReceipt = await session.execute(transaction, TypeOfExecutionReturn.Receipt, true);
      id = transactionReceipt.contractId;
      logs = [];
    }

    return new LiveContractWithLogs({
      cInterface: contract.interface,
      id,
      logs,
      session
    });
  }

  constructor({
    session,
    id,
    cInterface
  }) {
    super(session, id);
    this.events = new EventEmitter();
    this.interface = cInterface; // Dynamically inject ABI function handling

    Object.values(this.interface.functions).forEach(fDescription => Object.defineProperty(this, fDescription.name, {
      enumerable: true,
      value: async function (fDescription, ...args) {
        const {
          request,
          meta
        } = await this.createContractRequestFor({
          fDescription,
          args
        });
        const isNonQuery = !(request instanceof ContractCallQuery);
        const executionResultType = isNonQuery && meta.onlyReceipt ? TypeOfExecutionReturn.Receipt : TypeOfExecutionReturn.Result;
        const callResponse = await this.session.execute(request, executionResultType, meta.emitReceipt);

        if (executionResultType == TypeOfExecutionReturn.Result) {
          this.tryToProcessForEvents(callResponse);
          return await this.tryExtractingResponse(callResponse, fDescription);
        } // Reaching this point means that only the receipt was requested. We have it so we pass it through


        return callResponse;
      }.bind(this, fDescription),
      writable: false
    }));
  }
  /**
   * Retrieves the Solidity address representation of the underlying, deployed, contract.
   */


  getSolidityAddress() {
    return this.id.toSolidityAddress();
  }
  /**
   * Registers/De-registers code to be executed when a particular contract event gets triggered.
   * 
   * @param name - the name of the event of interest
   * @param clb - if {@link undefined}, it removes all registered callbacks for the provided event-name else, 
   *              if a function callback is provided, registers it to be executed when the event gets fired
   * @throws - if there is no such event-name defined, an error gets thrown
   */


  onEvent(name, clb) {
    const eventExists = Object.values(this.interface.events).find(ev => ev.name === name) !== undefined;

    if (!eventExists && UNHANDLED_EVENT_NAME !== name) {
      throw new Error(`There is no such event named '${name}' defined in this contract.`);
    }

    if (!clb) {
      // remove all handlers for this event
      this.events.removeAllListeners(name);
    } else {
      // register the event handler
      this.events.on(name, clb);
    }
  }
  /**
   * Registers/De-registers code to be executed when a particular contract event gets triggered yet there are no event-handlers registered to handle it.
   * 
   * @param clb - the callback to get executed, if defined, otherwise remove all callbacks for this special event
   */


  onUnhandledEvents(clb) {
    this.onEvent(UNHANDLED_EVENT_NAME, clb);
  }
  /**
   * Creates a contract query/call request based for the given function-description and the desired arguments (args).
   * The first argument is checked to see if it matches the constructor arguments schema and, if it does, it's used to construct the
   * actual request instance, discarding it in the process so that the remaining arguments can all be used as the actual values sent to 
   * the targeted function.
   */


  async createContractRequestFor({
    fDescription,
    args
  }) {
    let requestOptionsPresentInArgs = false;
    const constructorArgs = {
      contractId: this.id,
      gas: this.session.defaults.contractTransactionGas
    };
    const meta = {
      emitReceipt: this.session.defaults.emitLiveContractReceipts,
      onlyReceipt: this.session.defaults.onlyReceiptsFromContractRequests
    }; // Try to unpack common meta-args that can be passed in at query/transaction construction time

    if (args && args.length > 0) {
      if (args[0].gas instanceof Hbar) {
        args[0].gas = args[0].gas.toTinybars();
      }

      if (Number.isInteger(args[0].gas) || args[0].gas instanceof long) {
        constructorArgs.gas = args[0].gas;
        requestOptionsPresentInArgs = true;
      }
    } // Initialize the Hedera request-object itself passing in any additional constructor args (if provided)


    const request = fDescription.constant ? new ContractCallQuery(constructorArgs) : new ContractExecuteTransaction(constructorArgs); // Inject session-configurable defaults

    if (isContractQueryRequest(request) && this.session.defaults.paymentForContractQuery > 0) {
      const queryPaymentInHbar = Hbar.fromTinybars(this.session.defaults.paymentForContractQuery);
      request.setQueryPayment(queryPaymentInHbar);
    } // Try to inject setter-only options


    if (args && args.length > 0) {
      if (isContractQueryRequest(request)) {
        // Try setting additional Query properties
        if (args[0].maxQueryPayment instanceof Hbar) {
          request.setMaxQueryPayment(args[0].maxQueryPayment);
          requestOptionsPresentInArgs = true;
        }

        if (args[0].paymentTransactionId instanceof TransactionId) {
          request.setPaymentTransactionId(args[0].paymentTransactionId);
          requestOptionsPresentInArgs = true;
        }

        if (args[0].queryPayment instanceof Hbar) {
          request.setQueryPayment(args[0].queryPayment);
          requestOptionsPresentInArgs = true;
        }
      } else {
        // This is a state-changing Transaction. Try setting additional properties as well
        if (args[0].amount) {
          // number | string | Long | BigNumber | Hbar
          request.setPayableAmount(args[0].amount);
          requestOptionsPresentInArgs = true;
        }

        if (args[0].maxTransactionFee) {
          // number | string | Long | BigNumber | Hbar
          request.setMaxTransactionFee(args[0].maxTransactionFee);
          requestOptionsPresentInArgs = true;
        }

        if (Array.isArray(args[0].nodeAccountIds)) {
          request.setNodeAccountIds(args[0].nodeAccountIds);
          requestOptionsPresentInArgs = true;
        }

        if (args[0].transactionId instanceof TransactionId) {
          request.setTransactionId(args[0].transactionId);
          requestOptionsPresentInArgs = true;
        }

        if (args[0].transactionMemo) {
          // string
          request.setTransactionMemo(args[0].transactionMemo);
          requestOptionsPresentInArgs = true;
        }

        if (Number.isInteger(args[0].transactionValidDuration)) {
          request.setTransactionValidDuration(args[0].transactionValidDuration);
          requestOptionsPresentInArgs = true;
        }
      }
    } // Try extracting meta-arguments (if any)


    if (args && args.length > 0) {
      if (args[0].emitReceipt === false || args[0].emitReceipt === true) {
        meta.emitReceipt = args[0].emitReceipt;
        requestOptionsPresentInArgs = true;
      }

      if (args[0].onlyReceipt === false || args[0].onlyReceipt === true) {
        meta.onlyReceipt = args[0].onlyReceipt;
        requestOptionsPresentInArgs = true;
      }
    } // Try cleaning up arguments list if config object was provide


    if (requestOptionsPresentInArgs) {
      args = args.slice(1);
    } // Prepare the targeted function


    request.setFunction(fDescription.name, await ContractFunctionParameters.newFor(fDescription, args));
    return {
      meta,
      request
    };
  }
  /**
   * Given a contract-request response (txResponse) and a targeted function-description, it tries to extract and prepare the caller response based on
   * the contract's output function ABI specs.
   */


  tryExtractingResponse(txResponse, fDescription) {
    let fResponse;
    const fResult = this.interface.decodeFunctionResult(fDescription, txResponse.asBytes());
    const fResultKeys = Object.keys(fResult).filter(evDataKey => isNaN(Number(evDataKey)));

    if (fDescription.outputs && fDescription.outputs.length !== 0) {
      if (fResultKeys.length === fDescription.outputs.length) {
        // A named object can be returned since all the outputs are named
        const isBytesTypeExpectedFor = propKey => fDescription.outputs.find(o => o.name === propKey).type.startsWith('bytes');

        const tryMappingToHederaBytes = propKey => isBytesTypeExpectedFor(propKey) ? arrayify(fResult[propKey]) : fResult[propKey];

        fResponse = fResultKeys.map(namedfDataKey => ({
          [namedfDataKey]: tryMappingToHederaBytes(namedfDataKey)
        })).reduce((p, c) => ({ ...p,
          ...c
        }), {});
      } else if (fDescription.outputs.length > 1) {
        fResponse = [...fResult]; // Map all Ethers HexString representations of bytes-type responses to their UInt8Array forms (same used by Hedera)

        fResponse = fDescription.outputs.map((dType, id) => dType.type.startsWith('bytes') ? arrayify(fResponse[id]) : fResponse[id]);
      } else {
        fResponse = fResult[0];
      } // Do various type re-mappings such as:
      //    - Ethers' BigNumber to the Hedera-used, bignumber.js equivalent
      //    - solidity-address compatible values to LiveAddress-es


      const tryRemapingValue = (what, f) => {
        let wasMapped = false;

        if (typeof what === 'string' && extractSolidityAddressFrom(what) !== undefined) {
          // most likely, this is a solidity-address
          f(new StratoAddress(this.session, what), true);
          wasMapped = true;
        } else if (BigNumber.isBigNumber(what)) {
          f(new BigNumber$1(what.toString()), false);
          wasMapped = true;
        }

        return wasMapped;
      };

      if (!tryRemapingValue(fResponse, newVal => {
        fResponse = newVal;
      })) {
        traverse$1(fResponse).forEach(function (x) {
          tryRemapingValue(x, this.update);
        });
      }
    }

    return fResponse;
  }
  /**
   * Given the call-response of a contract-method call/query, we try to see if there have been any events emitted and, if so, we re-emit them on the live-contract events pub-sub channel.
   * 
   * Note: even if there is an event triggered, if there are no handlers registered, the first thing we do is try to dump it on the {@link UNHANDLED_EVENT_NAME} channel. 
   *       if there are no handlers registered there either, we skip the event all-together.
   */


  tryToProcessForEvents(callResponse) {
    const loggedEvents = parseLogs(this.interface, callResponse.logs);
    loggedEvents.forEach(({
      name,
      payload
    }) => {
      let evNameToSendTo;

      if (this.events.listenerCount(name) === 0) {
        // No one is interested in this event
        // Try to dump it to the "catch-all-if-none-defined" event handler
        if (this.events.listenerCount(UNHANDLED_EVENT_NAME) === 0) {
          // No default, catch-all event handler defined. Skip event entirely
          return;
        }

        evNameToSendTo = UNHANDLED_EVENT_NAME;
      } else {
        // We have listeners for this event. Business as usual
        evNameToSendTo = name;
      }

      try {
        this.events.emit(evNameToSendTo, payload);
      } catch (e) {
        {
          // We re-interpret and throw it so that any tests running will be aware of it
          throw new Error(`The event-emitter handle '${name}' failed to execute with the following reason: ${e.message}`);
        } // otherwise, it's a No-op

      }
    });
  }

  getLiveEntityInfo() {
    const contractInfoQuery = new ContractInfoQuery().setContractId(this.id);
    return this.session.execute(contractInfoQuery, TypeOfExecutionReturn.Result, false);
  }

  newDeleteTransaction(args) {
    return new ContractDeleteTransaction({
      contractId: this.id,
      ...args
    });
  }

  _getUpdateTransaction(args) {
    throw new Error("Method not implemented.");
  }

  _getBalancePayload() {
    return {
      contractId: this.id
    };
  }

}
/**
 * A wrapper class that contains both a {@link LiveContract} and its associated logs generated at construction time.
 * Consequently, this is meant to be generated when first {@link ApiSession.upload}-ing a {@link Contract}.
 */

class LiveContractWithLogs extends LiveContract {
  constructor({
    session,
    id,
    cInterface,
    logs
  }) {
    super({
      cInterface,
      id,
      session
    });
    this.liveContract = this;
    this.logs = logs;
  }

}

var dotenv = {};

Object.defineProperty(dotenv, "__esModule", {
  value: true
});
var config_1 = dotenv.config = config;

function config() {
  return {
    parsed: undefined
  };
}

class EnvironmentInvalidError extends Error {
  constructor(message) {
    super(message);
  }

}

/**
 * The Hedera Network label value used in library configurations (such as the {@link ApiSession.default} method) to signify 
 * that the library is targeting a custom network implementation with its own nodes apart from [the official ones](https://docs.hedera.com/guides/mirrornet/hedera-mirror-node#mainnet). 
 * 
 * `Note:` When this type of network is selected, its node address book must also be provided and that is usually done through something like the
 *         `HEDERAS_NODES` env-parameter (when using {@link ApiSession.default})
 * 
 * Example of a `.env` file that targets a `customnet`, [local hedera-services](https://github.com/buidler-labs/dockerized-hedera-services) deployment:
 * ```
 * HEDERAS_NETWORK=customnet
 * HEDERAS_NODES=127.0.0.1:50211#3
 * ```
 * 
 * `Note #2:` If you're planning to target a local `customnet` deployment, you might as well add the operator credentials to the mix:
 * ```
 * HEDERAS_OPERATOR_ID=0.0.2
 * HEDERAS_OPERATOR_KEY=91132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137
 * ```
 * Please see our [dockerized-hedera-services](https://github.com/buidler-labs/dockerized-hedera-services) for more info as to how to run a local, [dockerized](https://hub.docker.com/r/buidlerlabs/hedera-services), 
 * [hedera-services](https://github.com/hashgraph/hedera-services) network.
 */
const HEDERA_CUSTOM_NET_NAME = "customnet";
const AVAILABLE_NETWORK_NAMES = {
  CustomNet: HEDERA_CUSTOM_NET_NAME,
  MainNet: "mainnet",
  PreviewNet: "previewnet",
  TestNet: "testnet"
};

/**
 * The main entry-class for the Hedera Strato library.
 * 
 * It starts out by referencing a Hedera Network (being it [official](https://docs.hedera.com/guides/mirrornet/hedera-mirror-node#mainnet) or {@link HEDERA_CUSTOM_NET_NAME | custom}) 
 * client before allowing to generate an {@link ApiSession} through the {@link HederaNetwork.login} method call.
 */
class HederaNetwork {
  static newFrom(params) {
    return new HederaNetwork(params.defaults, params.name, params.nodes);
  }

  constructor(defaults, name, nodesInfo) {
    this.defaults = defaults;
    this.name = name;
    this.nodesInfo = nodesInfo;

    if (typeof nodesInfo === 'string') {
      this.nodes = this.parseNetworkAddressBookFrom(nodesInfo);
    } else {
      this.nodes = nodesInfo;
    }

    const acceptedNetworkNames = Object.values(AVAILABLE_NETWORK_NAMES);

    if (!acceptedNetworkNames.includes(this.name)) {
      throw new EnvironmentInvalidError(`There is no such '${this.name}' network available. In order to continue, please choose a valid name from: ${acceptedNetworkNames.join(', ')}`);
    }

    try {
      WebClient.forName(this.name);
    } catch (e) {
      // This is a non-standard client. Maybe it's a local-net one?
      if (HEDERA_CUSTOM_NET_NAME === this.name) {
        if (!this.nodes || Object.keys(this.nodes).length === 0) {
          throw new EnvironmentInvalidError(`Please provide a list of network nodes in order to use a ${this.name} network.`);
        }
      } else {
        // Note: this should never happen, but still ... better play it safe
        throw new EnvironmentInvalidError(`There is no such ${this.name} network available in this library. Available network names to choose from are: ${acceptedNetworkNames.join(', ')}`);
      }
    }
  }

  getClient() {
    if (HEDERA_CUSTOM_NET_NAME === this.name) {
      return WebClient.forNetwork(this.nodes);
    } // TODO: remove 'setMaxNodesPerTransaction' once upgrading away from 2.7.0 and tests are passing


    return WebClient.forName(this.name).setMaxNodesPerTransaction(1);
  }
  /**
   * Parses the provided string and constructs the hedera-network nodes object required to initialize a custom Hedera Client.
   * The expected {@param string} format is in the following form: <ip>:<port>#<account-id>[,<ip2>:<port2>#<account-id2>...]
   * Example: 127.0.0.1:50211#2,127.0.0.1:50212:#5 would get mapped to the following object: 
   * {
   *   "127.0.0.1:50211": new AccountId(2),
   *   "127.0.0.1:50212": new AccountId(5)
   * }
   */


  parseNetworkAddressBookFrom(val) {
    const networkInfo = {};

    if (val) {
      const nodeEntries = val.split(/\s*,\s*/);
      const nodeDefinitions = nodeEntries.map(entry => {
        if (entry.indexOf("#") === -1) {
          throw new EnvironmentInvalidError(`Node definition entry '${entry}' is missing the account-id separator (#)`);
        }

        const [address, rawAccountNr] = entry.split("#");
        const accountNr = parseInt(rawAccountNr);
        return {
          [address]: new AccountId(accountNr)
        };
      });

      for (const rnEntry of nodeDefinitions) {
        const nodeAddress = Object.keys(rnEntry)[0];
        networkInfo[nodeAddress] = rnEntry[nodeAddress];
      }
    }

    return networkInfo;
  }

}

/* eslint-disable @typescript-eslint/no-unused-vars */
class WalletProvider {
  constructor(ctx) {
    this.ctx = ctx;
    this.setNetwork(ctx.network);
  }

  setNetwork(network) {
    this.network = network;
    return this;
  }

  buildFor(data) {
    this.sanityCheck();
    return this._buildCold(data);
  }

  sanityCheck() {
    if (!this.network) {
      throw new Error("Please first provide a HederaNetwork to the WalletProvider in order to build a new Wallet.");
    }
  }

}
class NotSupportedWalletProvider extends WalletProvider {
  constructor(ctx, controller) {
    super(ctx);
    throw new Error("You're trying to create a wallet-provider for a not-supported wallet-type. Something went wrong since you most likely would not want to ever do that.");
  }

  _buildCold(data) {
    // No-op
    return Promise.resolve();
  }

}

class BasicStratoWallet {
  constructor(wallet) {
    this.wallet = wallet;
    this.signer = wallet;
  }
  /**
   * @override
   */


  get account() {
    return {
      id: this.wallet.getAccountId(),
      publicKey: this.wallet.getAccountKey()
    };
  }

  async execute(transaction) {
    const transactionResponse = await transaction.executeWithSigner(this.wallet);
    return transactionResponse;
  }

  getReceipt(response) {
    return this.wallet.getProvider().getTransactionReceipt(response.transactionId);
  }

}

class BrowserWalletProvider extends WalletProvider {
  constructor(ctx, controller) {
    super(ctx);
    this.controller = controller;
  }

  async _buildCold(data) {
    return new BrowserWallet(this.controller, data.propName);
  }

}

class BrowserWallet extends BasicStratoWallet {
  constructor(controller, windowPropName) {
    super(window[windowPropName]); // TODO: bind to controller events somehow?
  }

}

class CredentialsInvalidError extends Error {
  constructor(message) {
    super(message);
  }

}

// TODO: once hashgraph/hedera-sdk-js#991 gets resolved, remove this class and replace all references to it
class LegacyLocalWallet extends Wallet {
  constructor(network, accountId, operatorKey) {
    super();
    this.accountId = accountId;
    this.client = network.getClient();
    this.publicKey = operatorKey.publicKey;
    this.client.setOperator(accountId, operatorKey);

    this.signer = message => Promise.resolve(operatorKey.sign(message));
  }

  getProvider() {
    return {
      getTransactionReceipt: async transactionId => new TransactionReceiptQuery().setTransactionId(transactionId).execute(this.client)
    };
  }

  getAccountKey() {
    return this.publicKey;
  }

  getLedgerId() {
    return this.client.ledgerId;
  }

  getAccountId() {
    return this.accountId;
  }

  getNetwork() {
    return this.client.network;
  }

  getMirrorNetwork() {
    return this.client.mirrorNetwork;
  }

  async sign(messages) {
    const signatures = [];

    for (const message of messages) {
      signatures.push(new SignerSignature({
        accountId: this.accountId,
        publicKey: this.publicKey,
        signature: await this.signer(message)
      }));
    }

    return signatures;
  }

  getAccountBalance() {
    return new AccountBalanceQuery().setAccountId(this.accountId).execute(this.client);
  }

  getAccountInfo() {
    return new AccountInfoQuery().setAccountId(this.accountId).execute(this.client);
  }

  getAccountRecords() {
    return new AccountRecordsQuery().setAccountId(this.accountId).execute(this.client);
  }

  signTransaction(transaction) {
    return transaction.signWith(this.publicKey, this.signer);
  }

  checkTransaction(transaction) {
    const transactionId = transaction.transactionId;

    if (transactionId.accountId != null && transactionId.accountId.compare(this.accountId) != 0) {
      throw new Error("transaction's ID constructed with a different account ID");
    }

    const nodeAccountIds = (transaction.nodeAccountIds != null ? transaction.nodeAccountIds : []).map(nodeAccountId => nodeAccountId.toString());
    const network = Object.values(this.getNetwork()).map(nodeAccountId => nodeAccountId.toString());

    if (!nodeAccountIds.reduce((previous, current) => previous && network.includes(current), true)) {
      throw new Error("Transaction already set node account IDs to values not within the current network");
    }

    return Promise.resolve(transaction);
  }

  populateTransaction(transaction) {
    transaction.setTransactionId(TransactionId.generate(this.accountId));
    transaction.setNodeAccountIds(this.client._network.getNodeAccountIdsForExecute());
    return Promise.resolve(transaction.freeze());
  }

  sendRequest(request) {
    return request.execute(this.client);
  }

}

class HederaLocalWalletProvider extends WalletProvider {
  constructor(ctx, controller) {
    super(ctx);
    this.controller = controller;
  }

  async buildOperatedBy(operatorId, operatorKey) {
    this.sanityCheck();
    return new SdkWallet(this.controller, this.ctx.network, typeof operatorId === 'string' ? AccountId.fromString(operatorId) : operatorId, typeof operatorKey === 'string' ? PrivateKey.fromString(operatorKey) : operatorKey);
  }

  async _buildCold(data) {
    return this.buildOperatedBy(data.accountId, data.privateKey);
  }

}

class SdkWallet extends BasicStratoWallet {
  constructor(controller, network, operatorId, operatorKey) {
    // Start out with what's provided
    // TODO: once hashgraph/hedera-sdk-js#991 gets resolved, remove and replace LegacyLocalWallet with LocalWallet
    super(new LegacyLocalWallet(network, operatorId, operatorKey)); // Bind to controller events

    this.network = network;
    this.operatorId = operatorId;
    this.operatorKey = operatorKey;
    controller.onAccountChanged(account => {
      this.operatorKey = PrivateKey.fromString(account.operatorKey);
      this.wallet = new LegacyLocalWallet(network, AccountId.fromString(account.operatorId), PrivateKey.fromString(account.operatorKey));
      this.operatorId = this.wallet.getAccountId();
    });
    controller.onNetworkChanged(network => {
      this.network = network;
      this.wallet = new LegacyLocalWallet(network, this.wallet.getAccountId(), operatorKey);
    });
  }

}

class Subscription {
  constructor(events, eventName, clb) {
    this.events = events;
    this.eventName = eventName;
    this.clb = clb;
    events.on(eventName, clb);
  }

  unsubscribe() {
    this.events.off(this.eventName, this.clb);
  }

}

class _NeverFiringSubscription extends Subscription {
  constructor() {
    super(new EventEmitter(), "NeverFiringSubscription", _data => {
      /* No-op */
    });
  }

}

const NeverFiringSubscription = new _NeverFiringSubscription();

class BasicWalletController {
  static NETWORK_CHANGE_REQUESTED = "NETWORK_CHANGE_REQUESTED";
  static ACCOUNT_CHANGE_REQUESTED = "ACCOUNT_CHANGE_REQUESTED";

  constructor(ctx) {
    this.ctx = ctx;
    this.pubSub = new EventEmitter();
  }

  changeAccount(account, ...args) {
    const accountPayload = this.getAccountPayload(account, ...args);
    this.pubSub.emit(BasicWalletController.ACCOUNT_CHANGE_REQUESTED, accountPayload);
  }

  changeNetwork(network) {
    this.pubSub.emit(BasicWalletController.NETWORK_CHANGE_REQUESTED, network);
  }

  onAccountChanged(clb) {
    return new Subscription(this.pubSub, BasicWalletController.ACCOUNT_CHANGE_REQUESTED, clb);
  }

  onNetworkChanged(clb) {
    return new Subscription(this.pubSub, BasicWalletController.NETWORK_CHANGE_REQUESTED, clb);
  }

}

class HederaWalletController extends BasicWalletController {
  constructor(ctx) {
    super(ctx);
  }

  getAccountPayload(account, ...args) {
    if (args.length === 0) {
      throw new Error("The private-key must also be provided in order to switch the account.");
    }

    try {
      const privateKey = args[0] instanceof PrivateKey ? args[0] : PrivateKey.fromString(args[0]);
      return {
        operatorId: account instanceof AccountId ? account.toString() : account,
        operatorKey: privateKey.toStringDer()
      };
    } catch (e) {
      throw new Error(`The provided key is not in a valid format. Cannot change account.`);
    }
  }

}

/* eslint-disable @typescript-eslint/no-unused-vars */
class ImpotentWalletController {
  changeAccount(_account, ..._args) {
    throw new Error("This WalletController cannot change the account of the underlying wallet.");
  }

  changeNetwork(_network) {
    throw new Error("This WalletController cannot change the network of the underlying wallet.");
  }

  onAccountChanged(clb) {
    return NeverFiringSubscription;
  }

  onNetworkChanged(clb) {
    return NeverFiringSubscription;
  }

}

const WALLET_TYPE_CONSTRUCTOR_GUARD = {};
class WalletType {
  constructor(constructorGuard, name, defaultController = ImpotentWalletController, providerHaving = NotSupportedWalletProvider, computeColdStartOptionsFrom) {
    this.name = name;
    this.defaultController = defaultController;
    this.providerHaving = providerHaving;
    this.computeColdStartOptionsFrom = computeColdStartOptionsFrom;

    if (constructorGuard !== WALLET_TYPE_CONSTRUCTOR_GUARD) {
      throw new Error("Wallet types cannot be defined from outside this module!");
    }
  }

  equals(other) {
    return other instanceof WalletType && this.name === other.name;
  }

}
class WalletTypes {
  unknownWalletType = new WalletType(WALLET_TYPE_CONSTRUCTOR_GUARD, "Unknown");

  constructor() {
    this.knownWalletTypes = [new WalletType(WALLET_TYPE_CONSTRUCTOR_GUARD, "Sdk", HederaWalletController, // Default WalletController
    HederaLocalWalletProvider, // Associated WalletProvider
    params => {
      // ColdStart options parser for pre-configured runtime parameters
      try {
        return {
          accountId: AccountId.fromString(params.wallet.sdk.operatorId),
          privateKey: PrivateKey.fromString(params.wallet.sdk.operatorKey)
        };
      } catch (e) {
        throw new CredentialsInvalidError(e.message);
      }
    }), new WalletType(WALLET_TYPE_CONSTRUCTOR_GUARD, "Browser", ImpotentWalletController, // No WalletController
    BrowserWalletProvider, // Associated WalletProvider
    params => {
      // ColdStart options parser for pre-configured runtime parameters
      return {
        propName: params.wallet.window.propName
      };
    })];
  }

  isKnown(walletType) {
    return !this.Unknown.equals(walletType);
  }

  get Unknown() {
    return this.unknownWalletType;
  }

  getBy({
    name
  }) {
    const candidateWalletTypes = this.knownWalletTypes.filter(type => type.name === name);
    return candidateWalletTypes.length === 0 ? this.Unknown : candidateWalletTypes[0];
  }

}

var StratoLogger$1 = {};

var classCallCheck$1 = {exports: {}};

(function (module) {
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(classCallCheck$1));

var createClass$1 = {exports: {}};

(function (module) {
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(createClass$1));

var inherits = {exports: {}};

var setPrototypeOf = {exports: {}};

(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(setPrototypeOf));

(function (module) {
var setPrototypeOf$1 = setPrototypeOf.exports;

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf$1(subClass, superClass);
}

module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(inherits));

var possibleConstructorReturn = {exports: {}};

var _typeof = {exports: {}};

(function (module) {
function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}

module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(_typeof));

var assertThisInitialized = {exports: {}};

(function (module) {
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(assertThisInitialized));

(function (module) {
var _typeof$1 = _typeof.exports["default"];

var assertThisInitialized$1 = assertThisInitialized.exports;

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized$1(self);
}

module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(possibleConstructorReturn));

var getPrototypeOf = {exports: {}};

(function (module) {
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(getPrototypeOf));

var _interopRequireDefault$1 = interopRequireDefault$1.exports;

Object.defineProperty(StratoLogger$1, "__esModule", {
  value: true
});
var StratoLogger_2 = StratoLogger$1.StratoLogger = void 0;

var _classCallCheck2$1 = _interopRequireDefault$1(classCallCheck$1.exports);

var _createClass2$1 = _interopRequireDefault$1(createClass$1.exports);

var _inherits2 = _interopRequireDefault$1(inherits.exports);

var _possibleConstructorReturn2 = _interopRequireDefault$1(possibleConstructorReturn.exports);

var _getPrototypeOf2 = _interopRequireDefault$1(getPrototypeOf.exports);

var _events = _interopRequireDefault$1(EventEmitter);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var LEVELS = {
  error: 0,
  warn: 1,
  // eslint-disable-next-line sort-keys
  info: 2,
  // eslint-disable-next-line sort-keys
  http: 3,
  verbose: 4,
  // eslint-disable-next-line sort-keys
  debug: 5,
  silly: 6
};

var StratoLogger = /*#__PURE__*/function (_EventEmitter) {
  (0, _inherits2["default"])(StratoLogger, _EventEmitter);

  var _super = _createSuper(StratoLogger);

  function StratoLogger(params) {
    var _this;

    (0, _classCallCheck2$1["default"])(this, StratoLogger);
    _this = _super.call(this);
    _this.level = LEVELS[params.level];
    _this.isLoggingEnabled = params.enabled;
    return _this;
  }

  (0, _createClass2$1["default"])(StratoLogger, [{
    key: "isSillyLoggingEnabled",
    get: function get() {
      return this._isLevelEnabled(LEVELS.silly);
    }
  }, {
    key: "debug",
    value: function debug(message) {
      for (var _len = arguments.length, meta = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        meta[_key - 1] = arguments[_key];
      }

      if (this._isLevelEnabled(LEVELS.debug)) this.emit.apply(this, ["debug", message].concat(meta));
      return this;
    }
  }, {
    key: "error",
    value: function error(message) {
      for (var _len2 = arguments.length, meta = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        meta[_key2 - 1] = arguments[_key2];
      }

      if (this._isLevelEnabled(LEVELS.error)) this.emit.apply(this, ["error", message].concat(meta));
      return this;
    }
  }, {
    key: "info",
    value: function info(message) {
      for (var _len3 = arguments.length, meta = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        meta[_key3 - 1] = arguments[_key3];
      }

      if (this._isLevelEnabled(LEVELS.info)) this.emit.apply(this, ["info", message].concat(meta));
      return this;
    }
  }, {
    key: "silly",
    value: function silly(message) {
      for (var _len4 = arguments.length, meta = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        meta[_key4 - 1] = arguments[_key4];
      }

      if (this._isLevelEnabled(LEVELS.silly)) this.emit.apply(this, ["debug", message].concat(meta));
      return this;
    }
  }, {
    key: "verbose",
    value: function verbose(message) {
      for (var _len5 = arguments.length, meta = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        meta[_key5 - 1] = arguments[_key5];
      }

      if (this._isLevelEnabled(LEVELS.verbose)) this.emit.apply(this, ["debug", message].concat(meta));
      return this;
    }
  }, {
    key: "warn",
    value: function warn(message) {
      for (var _len6 = arguments.length, meta = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        meta[_key6 - 1] = arguments[_key6];
      }

      if (this._isLevelEnabled(LEVELS.warn)) this.emit.apply(this, ["warn", message].concat(meta));
      return this;
    }
  }, {
    key: "_isLevelEnabled",
    value: function _isLevelEnabled(level) {
      return this.isLoggingEnabled && this.level >= level;
    }
  }]);
  return StratoLogger;
}(_events["default"]);

StratoLogger_2 = StratoLogger$1.StratoLogger = StratoLogger;

class DefaultPrivateKeyWalletController extends HederaWalletController {
  constructor(ctx) {
    super(ctx);
  }

  getAccountPayload(account) {
    return super.getAccountPayload(account, this.ctx.params.wallet.controller.default.operatorKey);
  }

}

class WalletControllers {
  constructor(ctx) {
    this.impotentController = new ImpotentWalletController();
    this.knownControllers = [{
      name: "Hedera",
      value: new HederaWalletController(ctx)
    }, {
      name: "DefaultPrivateKey",
      value: new DefaultPrivateKeyWalletController(ctx)
    }];
  }

  get Unknown() {
    return this.impotentController;
  }

  getBy({
    name
  }) {
    const candidateWalletControllers = this.knownControllers.filter(controller => controller.name === name);
    return candidateWalletControllers.length === 0 ? this.Unknown : candidateWalletControllers[0].value;
  }

}

// Note: This follows the @hashgraph/sdk/lib/transaction/Transaction > CHUNK_SIZE value
const DEFAULT_FILE_CHUNK_SIZE = 1024;
const DefinedNetworkDefaults = {
  [AVAILABLE_NETWORK_NAMES.CustomNet]: {
    fileChunkSize: DEFAULT_FILE_CHUNK_SIZE
  },
  [AVAILABLE_NETWORK_NAMES.MainNet]: {
    fileChunkSize: DEFAULT_FILE_CHUNK_SIZE
  },
  [AVAILABLE_NETWORK_NAMES.TestNet]: {
    fileChunkSize: DEFAULT_FILE_CHUNK_SIZE
  },
  [AVAILABLE_NETWORK_NAMES.PreviewNet]: {
    fileChunkSize: DEFAULT_FILE_CHUNK_SIZE
  }
};
/**
 * Contains any parameters/objects that can be created with those parameters which are unpacked by other components in the library
 */

class StratoContext {
  constructor(source) {
    let dEnv = config_1({
      path: source.path
    }).parsed;
    const eParams = {};
    const rParams = source?.params ?? {}; // Filter and get a hold of the raw parameters of interest

    if (!dEnv) {
      // Default to whatever lies in the {}
      dEnv = {};
    }

    Object.keys(dEnv).filter(rrParamKey => rrParamKey.startsWith('HEDERAS_')).forEach(acceptedParamKey => {
      eParams[acceptedParamKey] = dEnv[acceptedParamKey];
    }); // Parse and extract the managed values

    const networkName = rParams.network?.name ?? eParams.HEDERAS_NETWORK ?? 'unspecified';
    this.walletTypes = new WalletTypes();
    this.params = {
      logger: {
        enabled: (rParams.logger?.enabled ?? eParams.HEDERAS_LOGGER_ENABLED ?? 'false') === 'true',
        level: rParams.logger?.level ?? eParams.HEDERAS_LOGGER_LEVEL ?? 'info'
      },
      network: {
        defaults: DefinedNetworkDefaults[rParams.network?.name ?? eParams.HEDERAS_NETWORK ?? 'unspecified'],
        name: networkName,
        nodes: rParams.network?.nodes ?? eParams.HEDERAS_NODES ?? ""
      },
      session: {
        defaults: this.parseSessionDefaultsFrom(networkName, rParams, eParams)
      },
      wallet: this.computeWalletSpecsFrom(rParams, eParams)
    };
    this.walletControllers = new WalletControllers(this);
    this.log = new StratoLogger_2(this.params.logger);
    this.network = HederaNetwork.newFrom(this.params.network);
  }

  async getWallet(controller) {
    const walletType = typeof this.params.wallet.type === 'string' ? this.walletTypes.getBy({
      name: this.params.wallet.type
    }) : this.params.wallet.type;
    const resolvedController = controller ?? this.walletControllers.getBy({
      name: this.params.wallet.controller.type
    }) ?? new walletType.defaultController(this);
    const provider = new walletType.providerHaving(this, resolvedController);
    const coldStartData = walletType.computeColdStartOptionsFrom(this.params);

    if (coldStartData) {
      return {
        controller: resolvedController,
        wallet: await provider.buildFor(coldStartData)
      };
    } else {
      throw new Error("Please provide either the cold-start data or a saved-state from where to create the bounded underlying Wallet with.");
    }
  }

  computeWalletSpecsFrom(rParams, eParams) {
    const walletControllerDefaultPrivateKey = rParams.wallet?.controller?.default?.operatorKey ?? eParams.HEDERAS_WALLET_CONTROLLER_DEFAULT_PRIVATE_KEY;
    const walletControllerType = rParams.wallet?.controller?.type ?? eParams.HEDERAS_WALLET_CONTROLLER ?? "Hedera";
    const walletType = this.walletTypes.getBy({
      name: typeof rParams.wallet?.type === 'string' ? rParams.wallet?.type : eParams.HEDERAS_WALLET_TYPE ? eParams.HEDERAS_WALLET_TYPE : "Sdk"
    });
    const walletWindowPropName = rParams.wallet?.window?.propName ?? eParams.HEDERAS_WALLET_WINDOW_PROPERTY_NAME ?? "hedera";

    if (!this.walletTypes.isKnown(walletType)) {
      throw new Error("Only 'Sdk' and 'Browser' wallet types are currently supported. If not specified, it defaults to 'Sdk'.");
    }

    return {
      controller: {
        default: {
          operatorKey: walletControllerDefaultPrivateKey
        },
        type: walletControllerType
      },
      sdk: {
        operatorId: rParams.wallet?.sdk?.operatorId ?? eParams.HEDERAS_OPERATOR_ID,
        operatorKey: rParams.wallet?.sdk?.operatorKey ?? eParams.HEDERAS_OPERATOR_KEY
      },
      type: walletType,
      window: {
        propName: walletWindowPropName
      }
    };
  }

  parseSessionDefaultsFrom(networkName, rParams, eParams) {
    const resolveSessionDefaultValueFor = particle => eParams[`HEDERAS_${networkName.toUpperCase()}_DEFAULT_${particle.toUpperCase()}`] || eParams[`HEDERAS_DEFAULT_${particle.toUpperCase()}`];

    return {
      contractCreationGas: rParams.session?.defaults?.contractCreationGas ?? parseInt(resolveSessionDefaultValueFor("contract_creation_gas") ?? "150000"),
      contractTransactionGas: rParams.session?.defaults?.contractCreationGas ?? parseInt(resolveSessionDefaultValueFor("contract_transaction_gas") ?? "169000"),
      emitConstructorLogs: rParams.session?.defaults?.emitConstructorLogs ?? (resolveSessionDefaultValueFor("emit_constructor_logs") ?? "true") === "true",
      emitLiveContractReceipts: rParams.session?.defaults?.emitLiveContractReceipts ?? (resolveSessionDefaultValueFor("emit_live_contracts_receipts") ?? "false") === "true",
      onlyReceiptsFromContractRequests: rParams.session?.defaults?.onlyReceiptsFromContractRequests ?? (resolveSessionDefaultValueFor("contract_requests_return_only_receipts") ?? "true") === "true",
      paymentForContractQuery: rParams.session?.defaults?.paymentForContractQuery ?? parseInt(resolveSessionDefaultValueFor("payment_for_contract_query") ?? "1000000")
    };
  }

}

class BasicUploadableEntity {
  constructor(nameOfUpload) {
    this.nameOfUpload = nameOfUpload;
  }
  /**
   * Uploads this Uploadable to the desired session passing in arguments if provided.
   * 
   * @param {Array} args - A list of arguments to use and/or pass along. If the first object contains a '_file' property, it's assumed that its content contains
   *                       FileCreateTransaction constructor arguments and is embedded in the transaction being created. It then goes on to discard that initial
   *                       value before passing the remaining arguments along to the _onFileUploaded implementation.
   * @public
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  async uploadTo({
    session,
    args = []
  }) {
    const whatToUpload = await this.getContent();
    const {
      appendTxCount,
      areOverridesProvided,
      fileTransactions
    } = await this._getFileTransactionsFor({
      args,
      content: whatToUpload,
      session
    });
    const transactionReceipt = await session.execute(fileTransactions[0], TypeOfExecutionReturn.Receipt, true);

    if (transactionReceipt.status !== Status.Success) {
      throw new Error(`There was an issue while creating the file (status ${transactionReceipt.status}). Aborting file upload.`);
    } else {
      session.log.debug(`Uploaded content to HFS resulting in file id ${transactionReceipt.fileId}`);

      if (fileTransactions.length > 1 && fileTransactions[1] instanceof FileAppendTransaction) {
        session.log.debug(`Appending the remaining content with a total of ${appendTxCount} file-append transactions.`);
        await session.execute(fileTransactions[1].setFileId(transactionReceipt.fileId), TypeOfExecutionReturn.Result, true);
        session.log.verbose(`Done appending. Content has been successfully uploaded and is available at HFS id ${transactionReceipt.fileId}`);
      }
    }

    if (areOverridesProvided) {
      args = args.slice(1);
    }

    return this.onFileUploaded({
      args,
      receipt: transactionReceipt,
      session
    });
  }

  async _getFileTransactionsFor({
    content,
    session,
    args = []
  }) {
    const fileChunkSize = session.network.defaults.fileChunkSize;
    const fileTransactions = [];
    let fileCreationOverrides = {}; // If available, lock onto any file-creation arguments to embedd when constructing the initial transaction

    if (args.length > 0 && Object.keys(args[0]).length !== 0 && Object.keys(args[0])[0] === '_file') {
      fileCreationOverrides = args[0]._file;
    } // Start off with a file-create transaction


    fileTransactions.push(new FileCreateTransaction(Object.assign({}, {
      keys: [session.wallet.account.publicKey],
      ...fileCreationOverrides
    }, {
      contents: content.length > fileChunkSize ? content.slice(0, fileChunkSize) : content
    }))); // Add, if necessary, other file-append transactions to consume the rest of the chunks

    let maxChunks = 0;

    if (content.length > fileChunkSize) {
      const contentToAppend = content.slice(fileChunkSize);
      maxChunks = Math.ceil(contentToAppend.length / fileChunkSize);
      fileTransactions.push(new FileAppendTransaction({
        contents: contentToAppend,
        maxChunks
      }));
    }

    return {
      appendTxCount: maxChunks,
      areOverridesProvided: Object.keys(fileCreationOverrides).length !== 0,
      fileTransactions
    };
  }

}

class LiveFile extends LiveEntity {
  constructor({
    session,
    id,
    data
  }) {
    super(session, id instanceof FileId ? id : FileId.fromString(id));
    this.data = data;
  }

  getLiveEntityInfo() {
    const fileInfoQuery = new FileInfoQuery({
      fileId: this.id
    });
    return this.session.execute(fileInfoQuery, TypeOfExecutionReturn.Result, false);
  }

  getSolidityAddress() {
    return this.id.toSolidityAddress();
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _getDeleteTransaction(args) {
    return new FileDeleteTransaction({
      fileId: this.id
    });
  }

  async _getUpdateTransaction(args) {
    return new FileUpdateTransaction({ ...args,
      fileId: this.id
    });
  }

  async getContents() {
    const fileContentsQuery = new FileContentsQuery({
      fileId: this.id
    });
    const queryResponse = await this.session.execute(fileContentsQuery, TypeOfExecutionReturn.Result, false);
    return queryResponse;
  }

}

class File extends BasicUploadableEntity {
  constructor(info) {
    super('File');
    this.info = info;
  }

  async getContent() {
    return this.info;
  }

  async onFileUploaded({
    session,
    receipt,
    args = []
  }) {
    return new LiveFile({
      data: this.info,
      id: receipt.fileId,
      session
    });
  }

}

/**
 * Represents a Hedera, HFS-managed, Json object
 */

class LiveJson extends LiveFile {
  constructor({
    session,
    id,
    data
  }) {
    super({
      data,
      id,
      session
    });

    if (typeof data === 'string') {
      data = JSON.parse(data);
    } // Dynamically bind 'data' properties to instance


    Object.keys(data).forEach(jDataKey => Object.defineProperty(this, jDataKey, {
      enumerable: true,
      value: data[jDataKey],
      writable: false
    }));
  }

}

/**
 * A data-holder class that can source the creation of a {@link LiveJson} persisted on the [Hedera File Service (HFS)](https://docs.hedera.com/guides/docs/sdks/file-storage)
 */

class Json extends BasicUploadableEntity {
  /**
   * Checks to see if a piece of data can be referenced by a {@link Json} object or not.
   * 
   * @param {object} jInfo - info-param to check 
   * @returns - true if the data is {@link Json} reference-able and false otherwise
   */
  static isInfoAcceptable(jInfo) {
    try {
      Json._guardForInvalid(jInfo);

      return true;
    } catch (e) {// No-op
    }

    return false;
  }

  static _guardForInvalid(jInfo) {
    if (jInfo === null || typeof jInfo !== 'object') {
      throw new Error("Please provide a valid JSON object to instantiate a static Json with.");
    } else {
      const containsInvalidKeys = Object.keys(jInfo).find(jInfoKey => jInfoKey.length > 0 && (jInfoKey[0] === '_' || jInfoKey === 'id')) !== undefined;

      if (containsInvalidKeys) {
        throw new Error("Static Jsons can only be constructed from JSON objects who's properties don't start with '_' or has the 'id' naming.");
      }
    }
  }
  /**
       * Tries to construct the a new {@link Json} instance that hosts the provided info. Throws an error if, for any reason, the provided data cannot be Json-referenced.
       * 
       * @param info - the payload to reference
       */


  constructor(info) {
    super('Json');
    this.info = info;

    Json._guardForInvalid(info);
  }

  async getContent() {
    return JSON.stringify(this.info);
  }

  async onFileUploaded({
    session,
    receipt,
    args = []
  }) {
    return new LiveJson({
      data: JSON.stringify(this.info),
      id: receipt.fileId,
      session
    });
  }

}

let TypeOfExecutionReturn;

(function (TypeOfExecutionReturn) {
  TypeOfExecutionReturn["Receipt"] = "Receipt";
  TypeOfExecutionReturn["Record"] = "Record";
  TypeOfExecutionReturn["Result"] = "Result";
})(TypeOfExecutionReturn || (TypeOfExecutionReturn = {}));

const SESSION_CONSTRUCTOR_GUARD = {}; // The inner-name for the receipt pub-sub event slot

const TRANSACTION_ON_RECEIPT_EVENT_NAME = "__TransactionOnReceiptAvailable_EventName__";
/**
 * The core class used for all business-logic, runtime network-interactions.
 * 
 * Should only be instantiable through direct {@link ApiSession} factory methods such as {@link ApiSession.default} (to load from a .env-like file/runtime {})
 * or {@link ApiSession.buildFrom} to construct an {@link ApiSession} from a manually-built {@link StratoContext} instance.
 */

class ApiSession {
  /**
   * Builds and retrieves the default {@link ApiSession} associated with this runtime. There are currently 2 ways of providing the parameters required for the api-session to be built:
   * - either pass them through the {@param source.env} parameter property (defaults to the `{}` for node environments) or 
   * - give the path to a [dotenv](https://www.npmjs.com/package/dotenv) like file (defaults to `.env`) from which they are loaded by the library (the {@link source.path} parameter)
   *   which can be auto-overwritten via the {@link undefined} value
   * 
   * `Note:` At least one source must be properly wired and if both these parameter sources are set, the environment/runtime values overwrite the file-loaded ones.
   * 
   * In order for the default {@link ApiSession} to be generated, the resulting resolved parameters must have the following values present:
   * - `HEDERAS_NETWORK` : the targeted hedera-network cluster. Can be one of the following: `mainnet`, `testnet`, `previewnet` or {@link HederaNetwork.HEDERA_CUSTOM_NET_NAME | customnet}
   * - `HEDERAS_NODES` : (mandatory if `HEDERAS_NETWORK={@link HederaNetwork.HEDERA_CUSTOM_NET_NAME}`) a comma separated list of {@link HederaNodesAddressBook} nodes encoded in 
   *                     the following format `<node_ip>:<node_port>#<account_number>`. Eg. `127.0.0.1:502111#3` would be parsed in an address book having a node with IP `127.0.0.1`
   *                     and port 502111 associated with {@link AccountId} `3`
   * - `HEDERAS_WALLET_TYPE` : the network {@link StratoWallet} to use. Possible Values are statically defined in the {@link WalletTypes} props. If not provided, it defaults to `Sdk` which
   *                           targets the native {@link LocalWallet} provided by the Hedera SDK.
   * 
   * For other possible config values, please either see the `.env.sample` info file provided with the main repo code or, better yet, the {@link https://hsj-docs.buidlerlabs.com/markdown/configuration online configuration} docs.
   */
  static async default(params = {}, path = '.env') {
    const ctxArgs = typeof params === 'string' ? {
      params: {},
      path: params
    } : {
      params,
      path
    };
    const ctx = new StratoContext(ctxArgs);
    return ApiSession.buildFrom(ctx);
  }
  /**
   * Another, more parametrically, way to build an {@link ApiSession} besides the {@link ApiSession.default} variant.
   */


  static async buildFrom(ctx) {
    const {
      wallet,
      controller
    } = await ctx.getWallet();
    return {
      controller,
      session: new ApiSession(SESSION_CONSTRUCTOR_GUARD, {
        client: wallet,
        ctx
      })
    };
  }

  /**
   * @hidden
   */
  constructor(constructorGuard, {
    ctx,
    client
  }) {
    if (constructorGuard !== SESSION_CONSTRUCTOR_GUARD) {
      throw new Error("API sessions can only be constructed through a SessionBuilder instance!");
    }

    this.log = ctx.log;
    this.network = ctx.network;
    this.client = client;
    this.defaults = ctx.params.session.defaults;
    this.events = new EventEmitter();
  }
  /**
   * Retrieves the wallet-info structure portraying both account and current signer info for this {@link ApiSession}.
   */


  get wallet() {
    return this.client;
  }
  /**
   * Creates a new {@link LiveEntity} such as an {@link LiveAccount} or a {@link LiveToken}.
   * 
   * @param what {@link CreatableEntity} - the prototype of the entity of interest 
   * @returns - an interactive {@link LiveEntity} instance which resides on the chain
   */


  async create(what) {
    this.log.info(`Creating a new Hedera ${what.name}`);
    const createdLiveEntity = await what.createVia({
      session: this
    });
    this.log.info(`Successfully created ${what.name} id ${createdLiveEntity.id}`);
    return createdLiveEntity;
  }
  /**
    * Queries/Executes a contract function, capable of returning the {@link ContractFunctionResult} if successful. This depends on the {@param returnType} of course.
    */


  // Overload implementation
  async execute(transaction, returnType, getReceipt = false) {
    const isContractTransaction = transaction instanceof ContractCallQuery || transaction instanceof ContractExecuteTransaction;
    let executionResult;
    let txReceipt;
    let txRecord;
    const txResponse = await this.client.execute(transaction); // start with the assumption that either the execution is not a contract-transaction or that the transaction-response is not a TransactionResponse

    executionResult = txResponse; // see if the above assumption holds and refine executionResult if case may be

    if (txResponse instanceof TransactionResponse) {
      // start out by generating the receipt for the original transaction
      txReceipt = await this.client.getReceipt(txResponse);

      if (returnType === TypeOfExecutionReturn.Record || isContractTransaction && returnType === TypeOfExecutionReturn.Result) {
        const txRecordQuery = new TransactionRecordQuery().setTransactionId(txResponse.transactionId);
        txRecord = await this.client.execute(txRecordQuery); // lock onto the contract-function-result of the record just in case a Result return-type is expected

        executionResult = txRecord.contractFunctionResult;
      }

      if (this.canReceiptBeEmitted(getReceipt)) {
        this.events.emit(TRANSACTION_ON_RECEIPT_EVENT_NAME, {
          receipt: txReceipt,
          transaction: transaction
        });
      }
    } // Depending on the return-type resolution, fetch the typed-result


    return {
      [TypeOfExecutionReturn.Record]: txRecord,
      [TypeOfExecutionReturn.Receipt]: txReceipt,
      [TypeOfExecutionReturn.Result]: executionResult
    }[returnType];
  }
  /**
   * Retrieves the solidity-address of the underlying {@link AccountId} that's operating this session.
   */


  getSolidityAddress() {
    return this.wallet.account.id.toSolidityAddress();
  }
  /**
   * Loads a pre-deployed {@link LiveContract} ready to be called into at runtime. The contract-interface is passed in raw-ly 
   * through the {@link abi} param.
   * 
   * @param {object} options
   * @param {ContractId|string} options.id - the {@link ContractId} to load being it string-serialized or already parsed
   * @param {Promised<Interface>|Promised<Array>} options.abi - either the [etherjs contract interface](https://docs.ethers.io/v5/api/utils/abi/interface/) or 
   *                                                            the [etherjs Interface compatible ABI definitions](https://docs.ethers.io/v5/api/utils/abi/interface/#Interface--creating) 
   *                                                            to use with the resulting live-contract. Promises that resolve to any of these 2 types are also accepted.
   */


  async getLiveContract({
    id,
    abi = []
  }) {
    let targetedContractId;
    const resolutedAbi = await abi;

    try {
      targetedContractId = id instanceof ContractId ? id : ContractId.fromString(id);
    } catch (e) {
      throw new Error("Please provide a valid Hedera contract id in order try to lock onto an already-deployed contract.");
    }

    return new LiveContract({
      cInterface: resolutedAbi instanceof Interface ? resolutedAbi : new Interface(resolutedAbi),
      id: targetedContractId,
      session: this
    });
  }
  /**
   * Given a {@link FileId} (string-serialized or parsed) of a deployed {@link Json} instance, retrieves a {@link LiveJson} reference.
   * 
   * @param {object} options 
   * @param {FileId | string} options.id - the file-id to load parsed as a {@link FileId} or raw in a string-serialized
   */


  async getLiveJson({
    id
  }) {
    let targetedFileId;

    try {
      targetedFileId = id instanceof FileId ? id : FileId.fromString(id);
    } catch (e) {
      throw new Error("Please provide a valid Hedera file id in order try to lock onto an already-deployed Json object.");
    }

    const fileContentsQuery = new FileContentsQuery().setFileId(targetedFileId);
    const fileContentsBuffer = await this.execute(fileContentsQuery, TypeOfExecutionReturn.Result, false);
    const fileContents = new TextDecoder('utf8').decode(fileContentsBuffer); // TODO: use file Memo to store hash of file-contents and only return LiveJson instance if the 2 values match

    return new LiveJson({
      data: JSON.parse(fileContents),
      id: targetedFileId,
      session: this
    });
  }
  /**
   * Register a callback to be called when a receipt is required and available for a transaction.
   * 
   * @param clb - Callback function to be called when a {@link TransactionedReceipt} is available. The `transactionedReceipt` contains
   *              a reference to both the actual transaction being executed and the resulting receipt.
   * @returns {ReceiptSubscription} - A subscription object that exposes a 'unsubscribe' method to cancel a subscription.
   */


  subscribeToReceiptsWith(clb) {
    return new Subscription(this.events, TRANSACTION_ON_RECEIPT_EVENT_NAME, clb);
  }
  /**
   * Given an {@link UploadableEntity}, it tries ot upload it using the currently configured {@link ApiSession} passing in-it any provided {@link args}.
   * 
   * @param {Uploadable} what - The {@link UploadableEntity} to push through this {@link ApiSession}
   * @param {*} args - A list of arguments to pass through the upload operation itself.
   *                   Note: this list has, by convention, at various unpacking stages in the call hierarchy, the capabilities to specify SDK behavior through
   *                         eg. "_file" ({@link UploadableEntity}) or "_contract" ({@link Contract})
   * @returns - An instance of the {@link UploadableEntity} concrete result-type which is a subtype of {@link LiveEntity}.
   */


  // Overload implementation
  async upload(what, ...args) {
    let uploadableWhat;

    if (what instanceof BasicUploadableEntity === false) {
      if (typeof what === 'string' || what instanceof Uint8Array) {
        uploadableWhat = new File(what);
      } else if (Json.isInfoAcceptable(what)) {
        uploadableWhat = new Json(what);
      } else {
        throw new Error("Can only upload UploadableFile-s or Json-file acceptable content.");
      }
    } else {
      // upload what was given as is since it's an UploadableEntity type already
      uploadableWhat = what;
    }

    this.log.info(`Uploading a new ${uploadableWhat.nameOfUpload} to Hedera File Service (HFS).`);
    const createdLiveEntity = await uploadableWhat.uploadTo({
      args,
      session: this
    });
    this.log.info(`Successfully created a ${uploadableWhat.nameOfUpload} id ${createdLiveEntity.id}.`);
    return createdLiveEntity;
  }

  canReceiptBeEmitted(isEmitReceiptRequested) {
    return isEmitReceiptRequested && this.events.listenerCount(TRANSACTION_ON_RECEIPT_EVENT_NAME) !== 0;
  }

}

const _GUARD_OBJ = {};
class TokenType {
  constructor(gObj, hTokenType) {
    this.hTokenType = hTokenType;

    if (gObj !== _GUARD_OBJ) {
      throw new Error("TokenType-s can only be created from within the static/Token module");
    }
  }

  equals(what) {
    return what instanceof TokenType ? this.hTokenType._code === what.hTokenType._code : what instanceof TokenType$1 ? this.hTokenType._code === what._code : false;
  }

}
const TokenTypes = {
  FungibleCommon: new TokenType(_GUARD_OBJ, TokenType$1.FungibleCommon),
  NonFungibleUnique: new TokenType(_GUARD_OBJ, TokenType$1.NonFungibleUnique)
};
class Token extends BasicCreatableEntity {
  static mapTokenFeaturesToTokenUpgradeArguments(tokenFeatures) {
    const upgradeFeatures = {};
    tokenFeatures.keys?.admin && (upgradeFeatures['adminKey'] = tokenFeatures.keys?.admin);
    tokenFeatures.keys?.feeSchedule && (upgradeFeatures['feeScheduleKey'] = tokenFeatures.keys?.feeSchedule);
    tokenFeatures.keys?.freeze && (upgradeFeatures['freezeKey'] = tokenFeatures.keys?.freeze);
    tokenFeatures.keys?.kyc && (upgradeFeatures['kycKey'] = tokenFeatures.keys?.kyc);
    tokenFeatures.keys?.pause && (upgradeFeatures['pauseKey'] = tokenFeatures.keys?.pause);
    tokenFeatures.keys?.supply && (upgradeFeatures['supplyKey'] = tokenFeatures.keys?.supply);
    tokenFeatures.keys?.wipe && (upgradeFeatures['wipeKey'] = tokenFeatures.keys?.wipe);
    tokenFeatures.name && (upgradeFeatures['tokenName'] = tokenFeatures.name);
    tokenFeatures.symbol && (upgradeFeatures['tokenSymbol'] = tokenFeatures.symbol);
    tokenFeatures.treasuryAccountId && (upgradeFeatures['treasuryAccountId'] = tokenFeatures.treasuryAccountId);
    return { ...upgradeFeatures,
      ...tokenFeatures
    };
  }

  static mapTokenFeaturesToTokenArguments(tokenFeatures, session) {
    const sessionPublicKey = session.wallet.account.publicKey;
    const sessionAccountId = session.wallet.account.id;
    return {
      // First map to expected properties
      adminKey: tokenFeatures.keys?.admin !== null ? tokenFeatures.keys?.admin ?? sessionPublicKey : undefined,
      feeScheduleKey: tokenFeatures.keys?.feeSchedule !== null ? tokenFeatures.keys?.feeSchedule ?? sessionPublicKey : undefined,
      freezeKey: tokenFeatures.keys?.freeze !== null ? tokenFeatures.keys?.freeze ?? sessionPublicKey : undefined,
      kycKey: tokenFeatures.keys?.kyc !== null ? tokenFeatures.keys?.kyc ?? sessionPublicKey : undefined,
      pauseKey: tokenFeatures.keys?.pause !== null ? tokenFeatures.keys?.pause ?? sessionPublicKey : undefined,
      supplyKey: tokenFeatures.keys?.supply !== null ? tokenFeatures.keys?.supply ?? sessionPublicKey : undefined,
      tokenName: tokenFeatures.name,
      tokenSymbol: tokenFeatures.symbol,
      tokenType: tokenFeatures.type.hTokenType ?? TokenType$1.FungibleCommon,
      treasuryAccountId: tokenFeatures.treasuryAccountId ?? sessionAccountId,
      wipeKey: tokenFeatures.keys?.wipe !== null ? tokenFeatures.keys?.wipe ?? sessionPublicKey : undefined,
      // Merge everything with what's provided
      ...tokenFeatures
    };
  }

  constructor(info) {
    super("Token");
    this.info = info;
  }

  async createVia({
    session
  }) {
    const constructorArgs = Token.mapTokenFeaturesToTokenArguments(this.info, session);
    const createTokenTransaction = new TokenCreateTransaction(constructorArgs);
    const creationReceipt = await session.execute(createTokenTransaction, TypeOfExecutionReturn.Receipt, true);
    return new LiveToken({
      id: creationReceipt.tokenId,
      session
    });
  }

}

/**
 * Represents a native Token on the Hedera Token Service
 */
class LiveToken extends LiveEntity {
  constructor({
    session,
    id
  }) {
    super(session, id);
  }

  getSolidityAddress() {
    return this.id.toSolidityAddress();
  }

  async assignSupplyControlTo(key) {
    const tokenUpdateTx = new TokenUpdateTransaction().setTokenId(this.id).setSupplyKey(key instanceof Key ? key : key.id);
    await this.session.execute(tokenUpdateTx, TypeOfExecutionReturn.Receipt, true);
  }

  async getLiveEntityInfo() {
    const tokenInfoQuery = new TokenInfoQuery().setTokenId(this.id);
    return this.session.execute(tokenInfoQuery, TypeOfExecutionReturn.Result, false);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _getDeleteTransaction(args) {
    return new TokenDeleteTransaction({
      tokenId: this.id
    });
  }

  async _getUpdateTransaction(args) {
    const featuresUsedInTransaction = Token.mapTokenFeaturesToTokenUpgradeArguments(args);
    return new TokenUpdateTransaction({ ...featuresUsedInTransaction,
      tokenId: this.id
    });
  }

}

class Topic extends BasicCreatableEntity {
  static mapTopicFeaturesToTopicArguments(topicFeatures) {
    return {
      adminKey: topicFeatures.keys?.admin,
      autoRenewAccountId: topicFeatures.autoRenewAccountId,
      autoRenewPeriod: topicFeatures.autoRenewPeriod,
      submitKey: topicFeatures.keys?.submit,
      topicMemo: topicFeatures.memo
    };
  }

  constructor(topicFeatures = {}) {
    super("Topic");
    this.topicFeatures = topicFeatures;
  }

  async createVia({
    session
  }) {
    const constructorArgs = Topic.mapTopicFeaturesToTopicArguments(this.topicFeatures);
    const createTopicTransaction = new TopicCreateTransaction(constructorArgs);
    const creationReceipt = await session.execute(createTopicTransaction, TypeOfExecutionReturn.Receipt, true);
    return new LiveTopic({
      session,
      topicId: creationReceipt.topicId
    });
  }

}

/**
 * Represents a Topic on the Hedera Consensus Service
 */
class LiveTopic extends LiveEntity {
  constructor({
    session,
    topicId
  }) {
    super(session, topicId instanceof TopicId ? topicId : TopicId.fromString(topicId));
  }

  getLiveEntityInfo() {
    const topicInfoQuery = new TopicInfoQuery({
      topicId: this.id
    });
    return this.session.execute(topicInfoQuery, TypeOfExecutionReturn.Result, false);
  }

  getSolidityAddress() {
    return this.id.toSolidityAddress();
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _getDeleteTransaction(args) {
    return new TopicDeleteTransaction({
      topicId: this.id
    });
  }

  async _getUpdateTransaction(args) {
    const featuresUsedInTransaction = Topic.mapTopicFeaturesToTopicArguments(args);
    return new TopicUpdateTransaction({ ...featuresUsedInTransaction,
      topicId: this.id
    });
  }

  submitMessage(message) {
    const messageSubmitTransaction = new TopicMessageSubmitTransaction({
      message,
      topicId: this.id
    });
    return this.executeAndReturnStatus(messageSubmitTransaction);
  }

}

var _hederaStrato_ContractsInFileStorage = {
    "hello_strato.sol": `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

contract HelloWorld {
  string public greet = "Hello Strato!";
}
`
  };

var ContractsInFileStorage = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _hederaStrato_ContractsInFileStorage
});

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});
if (typeof global$1.setTimeout === 'function') ;
if (typeof global$1.clearTimeout === 'function') ;

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

var SolidityCompiler$1 = {};

var interopRequireDefault = {exports: {}};

(function (module) {
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(interopRequireDefault));

var classCallCheck = {exports: {}};

(function (module) {
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(classCallCheck));

var createClass = {exports: {}};

(function (module) {
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(createClass));

var defineProperty = {exports: {}};

(function (module) {
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
}(defineProperty));

var WorkerClass = null;

try {
    var WorkerThreads =
        typeof module !== 'undefined' && typeof module.require === 'function' && module.require('worker_threads') ||
        typeof __non_webpack_require__ === 'function' && __non_webpack_require__('worker_threads') ||
        typeof require === 'function' && require('worker_threads');
    WorkerClass = WorkerThreads.Worker;
} catch(e) {} // eslint-disable-line

function decodeBase64$1(base64, enableUnicode) {
    return Buffer.from(base64, 'base64').toString(enableUnicode ? 'utf16' : 'utf8');
}

function createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg) {
    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
    var source = decodeBase64$1(base64, enableUnicode);
    var start = source.indexOf('\n', 10) + 1;
    var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
    return function WorkerFactory(options) {
        return new WorkerClass(body, Object.assign({}, options, { eval: true }));
    };
}

function decodeBase64(base64, enableUnicode) {
    var binaryString = atob(base64);
    if (enableUnicode) {
        var binaryView = new Uint8Array(binaryString.length);
        for (var i = 0, n = binaryString.length; i < n; ++i) {
            binaryView[i] = binaryString.charCodeAt(i);
        }
        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
    }
    return binaryString;
}

function createURL(base64, sourcemapArg, enableUnicodeArg) {
    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
    var source = decodeBase64(base64, enableUnicode);
    var start = source.indexOf('\n', 10) + 1;
    var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
    var blob = new Blob([body], { type: 'application/javascript' });
    return URL.createObjectURL(blob);
}

function createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg) {
    var url;
    return function WorkerFactory(options) {
        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
        return new Worker(url, options);
    };
}

var kIsNodeJS = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

function isNodeJS() {
    return kIsNodeJS;
}

function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
    if (isNodeJS()) {
        return createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg);
    }
    return createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg);
}

var WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwp2YXIgd29ya2VyX2NvZGUgPSAoZnVuY3Rpb24gKCkgewoJJ3VzZSBzdHJpY3QnOwoKCXZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9OwoKCXZhciBTb2xpZGl0eUNvbXBpbGVyX3dvcmtlciA9IHt9OwoKCXZhciBpbnRlcm9wUmVxdWlyZURlZmF1bHQgPSB7ZXhwb3J0czoge319OwoKCShmdW5jdGlvbiAobW9kdWxlKSB7CglmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgewoJICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogewoJICAgICJkZWZhdWx0Ijogb2JqCgkgIH07Cgl9CgoJbW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzOwoJfShpbnRlcm9wUmVxdWlyZURlZmF1bHQpKTsKCgl2YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOgoJICB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDoKCSAgdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSk7CgoJdmFyIGxvb2t1cCA9IFtdOwoJdmFyIHJldkxvb2t1cCA9IFtdOwoJdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheTsKCXZhciBpbml0ZWQgPSBmYWxzZTsKCWZ1bmN0aW9uIGluaXQgKCkgewoJICBpbml0ZWQgPSB0cnVlOwoJICB2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJzsKCSAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsKCSAgICBsb29rdXBbaV0gPSBjb2RlW2ldOwoJICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTsKCSAgfQoKCSAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyOwoJICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjM7Cgl9CgoJZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkgewoJICBpZiAoIWluaXRlZCkgewoJICAgIGluaXQoKTsKCSAgfQoJICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjsKCSAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7CgoJICBpZiAobGVuICUgNCA+IDApIHsKCSAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKQoJICB9CgoJICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKQoJICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0CgkgIC8vIHJlcHJlc2VudCBvbmUgYnl0ZQoJICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXMKCSAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZQoJICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwOwoKCSAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhCgkgIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpOwoKCSAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFycwoJICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW47CgoJICB2YXIgTCA9IDA7CgoJICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7CgkgICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldOwoJICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGOwoJICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7CgkgICAgYXJyW0wrK10gPSB0bXAgJiAweEZGOwoJICB9CgoJICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7CgkgICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7CgkgICAgYXJyW0wrK10gPSB0bXAgJiAweEZGOwoJICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkgewoJICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKTsKCSAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGOwoJICAgIGFycltMKytdID0gdG1wICYgMHhGRjsKCSAgfQoKCSAgcmV0dXJuIGFycgoJfQoKCWZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7CgkgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXQoJfQoKCWZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkgewoJICB2YXIgdG1wOwoJICB2YXIgb3V0cHV0ID0gW107CgkgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7CgkgICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTsKCSAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7CgkgIH0KCSAgcmV0dXJuIG91dHB1dC5qb2luKCcnKQoJfQoKCWZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7CgkgIGlmICghaW5pdGVkKSB7CgkgICAgaW5pdCgpOwoJICB9CgkgIHZhciB0bXA7CgkgIHZhciBsZW4gPSB1aW50OC5sZW5ndGg7CgkgIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMzsgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXMKCSAgdmFyIG91dHB1dCA9ICcnOwoJICB2YXIgcGFydHMgPSBbXTsKCSAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7IC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgMwoKCSAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlcgoJICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7CgkgICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSk7CgkgIH0KCgkgIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXMKCSAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHsKCSAgICB0bXAgPSB1aW50OFtsZW4gLSAxXTsKCSAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXTsKCSAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXTsKCSAgICBvdXRwdXQgKz0gJz09JzsKCSAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7CgkgICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKTsKCSAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF07CgkgICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl07CgkgICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl07CgkgICAgb3V0cHV0ICs9ICc9JzsKCSAgfQoKCSAgcGFydHMucHVzaChvdXRwdXQpOwoKCSAgcmV0dXJuIHBhcnRzLmpvaW4oJycpCgl9CgoJZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewoJICB2YXIgZSwgbTsKCSAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7CgkgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwoJICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7CgkgIHZhciBuQml0cyA9IC03OwoJICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwOwoJICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7CgkgIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldOwoKCSAgaSArPSBkOwoKCSAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7CgkgIHMgPj49ICgtbkJpdHMpOwoJICBuQml0cyArPSBlTGVuOwoJICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fQoKCSAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7CgkgIGUgPj49ICgtbkJpdHMpOwoJICBuQml0cyArPSBtTGVuOwoJICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fQoKCSAgaWYgKGUgPT09IDApIHsKCSAgICBlID0gMSAtIGVCaWFzOwoJICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHsKCSAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSkKCSAgfSBlbHNlIHsKCSAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pOwoJICAgIGUgPSBlIC0gZUJpYXM7CgkgIH0KCSAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbikKCX0KCglmdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKCSAgdmFyIGUsIG0sIGM7CgkgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwoJICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTsKCSAgdmFyIGVCaWFzID0gZU1heCA+PiAxOwoJICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApOwoJICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpOwoJICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7CgkgIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwOwoKCSAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7CgoJICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkgewoJICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDsKCSAgICBlID0gZU1heDsKCSAgfSBlbHNlIHsKCSAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7CgkgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkgewoJICAgICAgZS0tOwoJICAgICAgYyAqPSAyOwoJICAgIH0KCSAgICBpZiAoZSArIGVCaWFzID49IDEpIHsKCSAgICAgIHZhbHVlICs9IHJ0IC8gYzsKCSAgICB9IGVsc2UgewoJICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpOwoJICAgIH0KCSAgICBpZiAodmFsdWUgKiBjID49IDIpIHsKCSAgICAgIGUrKzsKCSAgICAgIGMgLz0gMjsKCSAgICB9CgoJICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkgewoJICAgICAgbSA9IDA7CgkgICAgICBlID0gZU1heDsKCSAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CgkgICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CgkgICAgICBlID0gZSArIGVCaWFzOwoJICAgIH0gZWxzZSB7CgkgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CgkgICAgICBlID0gMDsKCSAgICB9CgkgIH0KCgkgIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9CgoJICBlID0gKGUgPDwgbUxlbikgfCBtOwoJICBlTGVuICs9IG1MZW47CgkgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge30KCgkgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODsKCX0KCgl2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZzsKCgl2YXIgaXNBcnJheSQyID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7CgkgIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJzsKCX07CgoJLyohCgkgKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci4KCSAqCgkgKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz4KCSAqIEBsaWNlbnNlICBNSVQKCSAqLwoKCXZhciBJTlNQRUNUX01BWF9CWVRFUyA9IDUwOwoKCS8qKgoJICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDoKCSAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpCgkgKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpCgkgKgoJICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLAoJICogT3BlcmEgMTEuNissIGlPUyA0LjIrLgoJICoKCSAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW4KCSAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLgoJICoKCSAqIE5vdGU6CgkgKgoJICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcywKCSAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC4KCSAqCgkgKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi4KCSAqCgkgKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZgoJICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLgoKCSAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5CgkgKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS4KCSAqLwoJQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbCQxLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZAoJICA/IGdsb2JhbCQxLlRZUEVEX0FSUkFZX1NVUFBPUlQKCSAgOiB0cnVlOwoKCS8qCgkgKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuCgkgKi8KCXZhciBfa01heExlbmd0aCA9IGtNYXhMZW5ndGgoKTsKCglmdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHsKCSAgcmV0dXJuIEJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQKCSAgICA/IDB4N2ZmZmZmZmYKCSAgICA6IDB4M2ZmZmZmZmYKCX0KCglmdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkgewoJICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7CgkgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJykKCSAgfQoJICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgewoJICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZQoJICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpOwoJICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyJDEucHJvdG90eXBlOwoJICB9IGVsc2UgewoJICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3MKCSAgICBpZiAodGhhdCA9PT0gbnVsbCkgewoJICAgICAgdGhhdCA9IG5ldyBCdWZmZXIkMShsZW5ndGgpOwoJICAgIH0KCSAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDsKCSAgfQoKCSAgcmV0dXJuIHRoYXQKCX0KCgkvKioKCSAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpcgoJICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZgoJICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kcwoJICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQKCSAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuCgkgKgoJICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLgoJICovCgoJZnVuY3Rpb24gQnVmZmVyJDEgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CgkgIGlmICghQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIkMSkpIHsKCSAgICByZXR1cm4gbmV3IEJ1ZmZlciQxKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQoJICB9CgoJICAvLyBDb21tb24gY2FzZS4KCSAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7CgkgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykgewoJICAgICAgdGhyb3cgbmV3IEVycm9yKAoJICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnCgkgICAgICApCgkgICAgfQoJICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpCgkgIH0KCSAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCgl9CgoJQnVmZmVyJDEucG9vbFNpemUgPSA4MTkyOyAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uCgoJLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uCglCdWZmZXIkMS5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHsKCSAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlciQxLnByb3RvdHlwZTsKCSAgcmV0dXJuIGFycgoJfTsKCglmdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CgkgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignInZhbHVlIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpCgkgIH0KCgkgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsKCSAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCgkgIH0KCgkgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7CgkgICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpCgkgIH0KCgkgIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKQoJfQoKCS8qKgoJICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3IKCSAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLgoJICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKQoJICogQnVmZmVyLmZyb20oYXJyYXkpCgkgKiBCdWZmZXIuZnJvbShidWZmZXIpCgkgKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSkKCSAqKi8KCUJ1ZmZlciQxLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewoJICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQoJfTsKCglpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgewoJICBCdWZmZXIkMS5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7CgkgIEJ1ZmZlciQxLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXk7Cgl9CgoJZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkgewoJICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQoJICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7CgkgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpCgkgIH0KCX0KCglmdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHsKCSAgYXNzZXJ0U2l6ZShzaXplKTsKCSAgaWYgKHNpemUgPD0gMCkgewoJICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkKCSAgfQoJICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7CgkgICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXMKCSAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkCgkgICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LgoJICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnCgkgICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKQoJICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKQoJICB9CgkgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkKCX0KCgkvKioKCSAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS4KCSAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSkKCSAqKi8KCUJ1ZmZlciQxLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CgkgIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZykKCX07CgoJZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHsKCSAgYXNzZXJ0U2l6ZShzaXplKTsKCSAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7CgkgIGlmICghQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgewoJICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7CgkgICAgICB0aGF0W2ldID0gMDsKCSAgICB9CgkgIH0KCSAgcmV0dXJuIHRoYXQKCX0KCgkvKioKCSAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuCgkgKiAqLwoJQnVmZmVyJDEuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkgewoJICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSkKCX07CgkvKioKCSAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLgoJICovCglCdWZmZXIkMS5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkgewoJICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSkKCX07CgoJZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykgewoJICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHsKCSAgICBlbmNvZGluZyA9ICd1dGY4JzsKCSAgfQoKCSAgaWYgKCFCdWZmZXIkMS5pc0VuY29kaW5nKGVuY29kaW5nKSkgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJlbmNvZGluZyIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpCgkgIH0KCgkgIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDsKCSAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpOwoKCSAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7CgoJICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHsKCSAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGwKCSAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLgoJICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKQoJICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbCk7CgkgIH0KCgkgIHJldHVybiB0aGF0Cgl9CgoJZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHsKCSAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDsKCSAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpOwoJICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7CgkgICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1OwoJICB9CgkgIHJldHVybiB0aGF0Cgl9CgoJZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7CgkgIGFycmF5LmJ5dGVMZW5ndGg7IC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXIKCgkgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkgewoJICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcJ29mZnNldFwnIGlzIG91dCBvZiBib3VuZHMnKQoJICB9CgoJICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7CgkgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wnbGVuZ3RoXCcgaXMgb3V0IG9mIGJvdW5kcycpCgkgIH0KCgkgIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHsKCSAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KTsKCSAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgewoJICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpOwoJICB9IGVsc2UgewoJICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7CgkgIH0KCgkgIGlmIChCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7CgkgICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlCgkgICAgdGhhdCA9IGFycmF5OwoJICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyJDEucHJvdG90eXBlOwoJICB9IGVsc2UgewoJICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3MKCSAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSk7CgkgIH0KCSAgcmV0dXJuIHRoYXQKCX0KCglmdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHsKCSAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkgewoJICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDsKCSAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7CgoJICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkgewoJICAgICAgcmV0dXJuIHRoYXQKCSAgICB9CgoJICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbik7CgkgICAgcmV0dXJuIHRoYXQKCSAgfQoKCSAgaWYgKG9iaikgewoJICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJgoJICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikgewoJICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkgewoJICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApCgkgICAgICB9CgkgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopCgkgICAgfQoKCSAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkkMihvYmouZGF0YSkpIHsKCSAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKQoJICAgIH0KCSAgfQoKCSAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpCgl9CgoJZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7CgkgIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlbgoJICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLikKCSAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHsKCSAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICsKCSAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKQoJICB9CgkgIHJldHVybiBsZW5ndGggfCAwCgl9CgoJZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7CgkgIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcQoJICAgIGxlbmd0aCA9IDA7CgkgIH0KCSAgcmV0dXJuIEJ1ZmZlciQxLmFsbG9jKCtsZW5ndGgpCgl9CglCdWZmZXIkMS5pc0J1ZmZlciA9IGlzQnVmZmVyJDE7CglmdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7CgkgIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpCgl9CgoJQnVmZmVyJDEuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHsKCSAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGEpIHx8ICFpbnRlcm5hbElzQnVmZmVyKGIpKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpCgkgIH0KCgkgIGlmIChhID09PSBiKSByZXR1cm4gMAoKCSAgdmFyIHggPSBhLmxlbmd0aDsKCSAgdmFyIHkgPSBiLmxlbmd0aDsKCgkgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7CgkgICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKCSAgICAgIHggPSBhW2ldOwoJICAgICAgeSA9IGJbaV07CgkgICAgICBicmVhawoJICAgIH0KCSAgfQoKCSAgaWYgKHggPCB5KSByZXR1cm4gLTEKCSAgaWYgKHkgPCB4KSByZXR1cm4gMQoJICByZXR1cm4gMAoJfTsKCglCdWZmZXIkMS5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHsKCSAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHsKCSAgICBjYXNlICdoZXgnOgoJICAgIGNhc2UgJ3V0ZjgnOgoJICAgIGNhc2UgJ3V0Zi04JzoKCSAgICBjYXNlICdhc2NpaSc6CgkgICAgY2FzZSAnbGF0aW4xJzoKCSAgICBjYXNlICdiaW5hcnknOgoJICAgIGNhc2UgJ2Jhc2U2NCc6CgkgICAgY2FzZSAndWNzMic6CgkgICAgY2FzZSAndWNzLTInOgoJICAgIGNhc2UgJ3V0ZjE2bGUnOgoJICAgIGNhc2UgJ3V0Zi0xNmxlJzoKCSAgICAgIHJldHVybiB0cnVlCgkgICAgZGVmYXVsdDoKCSAgICAgIHJldHVybiBmYWxzZQoJICB9Cgl9OwoKCUJ1ZmZlciQxLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7CgkgIGlmICghaXNBcnJheSQyKGxpc3QpKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpCgkgIH0KCgkgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgewoJICAgIHJldHVybiBCdWZmZXIkMS5hbGxvYygwKQoJICB9CgoJICB2YXIgaTsKCSAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7CgkgICAgbGVuZ3RoID0gMDsKCSAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewoJICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoOwoJICAgIH0KCSAgfQoKCSAgdmFyIGJ1ZmZlciA9IEJ1ZmZlciQxLmFsbG9jVW5zYWZlKGxlbmd0aCk7CgkgIHZhciBwb3MgPSAwOwoJICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewoJICAgIHZhciBidWYgPSBsaXN0W2ldOwoJICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7CgkgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJykKCSAgICB9CgkgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpOwoJICAgIHBvcyArPSBidWYubGVuZ3RoOwoJICB9CgkgIHJldHVybiBidWZmZXIKCX07CgoJZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykgewoJICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7CgkgICAgcmV0dXJuIHN0cmluZy5sZW5ndGgKCSAgfQoJICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmCgkgICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7CgkgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoCgkgIH0KCSAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7CgkgICAgc3RyaW5nID0gJycgKyBzdHJpbmc7CgkgIH0KCgkgIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoOwoJICBpZiAobGVuID09PSAwKSByZXR1cm4gMAoKCSAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uCgkgIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlOwoJICBmb3IgKDs7KSB7CgkgICAgc3dpdGNoIChlbmNvZGluZykgewoJICAgICAgY2FzZSAnYXNjaWknOgoJICAgICAgY2FzZSAnbGF0aW4xJzoKCSAgICAgIGNhc2UgJ2JpbmFyeSc6CgkgICAgICAgIHJldHVybiBsZW4KCSAgICAgIGNhc2UgJ3V0ZjgnOgoJICAgICAgY2FzZSAndXRmLTgnOgoJICAgICAgY2FzZSB1bmRlZmluZWQ6CgkgICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aAoJICAgICAgY2FzZSAndWNzMic6CgkgICAgICBjYXNlICd1Y3MtMic6CgkgICAgICBjYXNlICd1dGYxNmxlJzoKCSAgICAgIGNhc2UgJ3V0Zi0xNmxlJzoKCSAgICAgICAgcmV0dXJuIGxlbiAqIDIKCSAgICAgIGNhc2UgJ2hleCc6CgkgICAgICAgIHJldHVybiBsZW4gPj4+IDEKCSAgICAgIGNhc2UgJ2Jhc2U2NCc6CgkgICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoCgkgICAgICBkZWZhdWx0OgoJICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOAoJICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwoJICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CgkgICAgfQoJICB9Cgl9CglCdWZmZXIkMS5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDsKCglmdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7CgkgIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlOwoKCSAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCAidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMiIgc2luY2UgaXQncyBhIHJlYWQtb25seQoJICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LgoKCSAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kCgkgIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS4KCSAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbiwKCSAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uCgkgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkgewoJICAgIHN0YXJ0ID0gMDsKCSAgfQoJICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMgoJICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LgoJICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkgewoJICAgIHJldHVybiAnJwoJICB9CgoJICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHsKCSAgICBlbmQgPSB0aGlzLmxlbmd0aDsKCSAgfQoKCSAgaWYgKGVuZCA8PSAwKSB7CgkgICAgcmV0dXJuICcnCgkgIH0KCgkgIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuCgkgIGVuZCA+Pj49IDA7CgkgIHN0YXJ0ID4+Pj0gMDsKCgkgIGlmIChlbmQgPD0gc3RhcnQpIHsKCSAgICByZXR1cm4gJycKCSAgfQoKCSAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7CgoJICB3aGlsZSAodHJ1ZSkgewoJICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKCSAgICAgIGNhc2UgJ2hleCc6CgkgICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKCSAgICAgIGNhc2UgJ3V0ZjgnOgoJICAgICAgY2FzZSAndXRmLTgnOgoJICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgoJICAgICAgY2FzZSAnYXNjaWknOgoJICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKCSAgICAgIGNhc2UgJ2xhdGluMSc6CgkgICAgICBjYXNlICdiaW5hcnknOgoJICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCgkgICAgICBjYXNlICdiYXNlNjQnOgoJICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCgkgICAgICBjYXNlICd1Y3MyJzoKCSAgICAgIGNhc2UgJ3Vjcy0yJzoKCSAgICAgIGNhc2UgJ3V0ZjE2bGUnOgoJICAgICAgY2FzZSAndXRmLTE2bGUnOgoJICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgoJICAgICAgZGVmYXVsdDoKCSAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpCgkgICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCk7CgkgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKCSAgICB9CgkgIH0KCX0KCgkvLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdAoJLy8gQnVmZmVyIGluc3RhbmNlcy4KCUJ1ZmZlciQxLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlOwoKCWZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHsKCSAgdmFyIGkgPSBiW25dOwoJICBiW25dID0gYlttXTsKCSAgYlttXSA9IGk7Cgl9CgoJQnVmZmVyJDEucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7CgkgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDsKCSAgaWYgKGxlbiAlIDIgIT09IDApIHsKCSAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKQoJICB9CgkgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHsKCSAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTsKCSAgfQoJICByZXR1cm4gdGhpcwoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHsKCSAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoOwoJICBpZiAobGVuICUgNCAhPT0gMCkgewoJICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpCgkgIH0KCSAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkgewoJICAgIHN3YXAodGhpcywgaSwgaSArIDMpOwoJICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTsKCSAgfQoJICByZXR1cm4gdGhpcwoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHsKCSAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoOwoJICBpZiAobGVuICUgOCAhPT0gMCkgewoJICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpCgkgIH0KCSAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkgewoJICAgIHN3YXAodGhpcywgaSwgaSArIDcpOwoJICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTsKCSAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7CgkgICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpOwoJICB9CgkgIHJldHVybiB0aGlzCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHsKCSAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMDsKCSAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnCgkgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aCkKCSAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHsKCSAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJykKCSAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlCgkgIHJldHVybiBCdWZmZXIkMS5jb21wYXJlKHRoaXMsIGIpID09PSAwCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7CgkgIHZhciBzdHIgPSAnJzsKCSAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTOwoJICBpZiAodGhpcy5sZW5ndGggPiAwKSB7CgkgICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7CgkgICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJzsKCSAgfQoJICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+JwoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7CgkgIGlmICghaW50ZXJuYWxJc0J1ZmZlcih0YXJnZXQpKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpCgkgIH0KCgkgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7CgkgICAgc3RhcnQgPSAwOwoJICB9CgkgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgewoJICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwOwoJICB9CgkgIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkgewoJICAgIHRoaXNTdGFydCA9IDA7CgkgIH0KCSAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkgewoJICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDsKCSAgfQoKCSAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7CgkgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpCgkgIH0KCgkgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHsKCSAgICByZXR1cm4gMAoJICB9CgkgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkgewoJICAgIHJldHVybiAtMQoJICB9CgkgIGlmIChzdGFydCA+PSBlbmQpIHsKCSAgICByZXR1cm4gMQoJICB9CgoJICBzdGFydCA+Pj49IDA7CgkgIGVuZCA+Pj49IDA7CgkgIHRoaXNTdGFydCA+Pj49IDA7CgkgIHRoaXNFbmQgPj4+PSAwOwoKCSAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDAKCgkgIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDsKCSAgdmFyIHkgPSBlbmQgLSBzdGFydDsKCSAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpOwoKCSAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpOwoJICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTsKCgkgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHsKCSAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHsKCSAgICAgIHggPSB0aGlzQ29weVtpXTsKCSAgICAgIHkgPSB0YXJnZXRDb3B5W2ldOwoJICAgICAgYnJlYWsKCSAgICB9CgkgIH0KCgkgIGlmICh4IDwgeSkgcmV0dXJuIC0xCgkgIGlmICh5IDwgeCkgcmV0dXJuIDEKCSAgcmV0dXJuIDAKCX07CgoJLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLAoJLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC4KCS8vCgkvLyBBcmd1bWVudHM6CgkvLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaAoJLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXIKCS8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMgoJLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmcKCS8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mCglmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKCSAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoCgkgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTEKCgkgIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0CgkgIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHsKCSAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7CgkgICAgYnl0ZU9mZnNldCA9IDA7CgkgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHsKCSAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZjsKCSAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHsKCSAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDA7CgkgIH0KCSAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OyAgLy8gQ29lcmNlIHRvIE51bWJlci4KCSAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7CgkgICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgImZvbyIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlcgoJICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTsKCSAgfQoKCSAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXIKCSAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7CgkgIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHsKCSAgICBpZiAoZGlyKSByZXR1cm4gLTEKCSAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTsKCSAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkgewoJICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwOwoJICAgIGVsc2UgcmV0dXJuIC0xCgkgIH0KCgkgIC8vIE5vcm1hbGl6ZSB2YWwKCSAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7CgkgICAgdmFsID0gQnVmZmVyJDEuZnJvbSh2YWwsIGVuY29kaW5nKTsKCSAgfQoKCSAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2YKCSAgaWYgKGludGVybmFsSXNCdWZmZXIodmFsKSkgewoJICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHMKCSAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgewoJICAgICAgcmV0dXJuIC0xCgkgICAgfQoJICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpCgkgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHsKCSAgICB2YWwgPSB2YWwgJiAweEZGOyAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdCgkgICAgaWYgKEJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYKCSAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHsKCSAgICAgIGlmIChkaXIpIHsKCSAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCkKCSAgICAgIH0gZWxzZSB7CgkgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KQoJICAgICAgfQoJICAgIH0KCSAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikKCSAgfQoKCSAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJykKCX0KCglmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7CgkgIHZhciBpbmRleFNpemUgPSAxOwoJICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDsKCSAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7CgoJICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgewoJICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwoJICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8CgkgICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHsKCSAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikgewoJICAgICAgICByZXR1cm4gLTEKCSAgICAgIH0KCSAgICAgIGluZGV4U2l6ZSA9IDI7CgkgICAgICBhcnJMZW5ndGggLz0gMjsKCSAgICAgIHZhbExlbmd0aCAvPSAyOwoJICAgICAgYnl0ZU9mZnNldCAvPSAyOwoJICAgIH0KCSAgfQoKCSAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7CgkgICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkgewoJICAgICAgcmV0dXJuIGJ1ZltpXQoJICAgIH0gZWxzZSB7CgkgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKQoJICAgIH0KCSAgfQoKCSAgdmFyIGk7CgkgIGlmIChkaXIpIHsKCSAgICB2YXIgZm91bmRJbmRleCA9IC0xOwoJICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykgewoJICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkgewoJICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpOwoJICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplCgkgICAgICB9IGVsc2UgewoJICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXg7CgkgICAgICAgIGZvdW5kSW5kZXggPSAtMTsKCSAgICAgIH0KCSAgICB9CgkgIH0gZWxzZSB7CgkgICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7CgkgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHsKCSAgICAgIHZhciBmb3VuZCA9IHRydWU7CgkgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7CgkgICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHsKCSAgICAgICAgICBmb3VuZCA9IGZhbHNlOwoJICAgICAgICAgIGJyZWFrCgkgICAgICAgIH0KCSAgICAgIH0KCSAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGkKCSAgICB9CgkgIH0KCgkgIHJldHVybiAtMQoJfQoKCUJ1ZmZlciQxLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CgkgIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewoJICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSkKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKCSAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKQoJfTsKCglmdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CgkgIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7CgkgIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0OwoJICBpZiAoIWxlbmd0aCkgewoJICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKCSAgfSBlbHNlIHsKCSAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTsKCSAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7CgkgICAgICBsZW5ndGggPSByZW1haW5pbmc7CgkgICAgfQoJICB9CgoJICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0cwoJICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDsKCSAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpCgoJICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikgewoJICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7CgkgIH0KCSAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewoJICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpOwoJICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaQoJICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDsKCSAgfQoJICByZXR1cm4gaQoJfQoKCWZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CgkgIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpCgl9CgoJZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CgkgIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQoJfQoKCWZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKCSAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoJfQoKCWZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKCSAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQoJfQoKCWZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CgkgIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpCgl9CgoJQnVmZmVyJDEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7CgkgIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpCgkgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgewoJICAgIGVuY29kaW5nID0gJ3V0ZjgnOwoJICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoOwoJICAgIG9mZnNldCA9IDA7CgkgIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKQoJICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7CgkgICAgZW5jb2RpbmcgPSBvZmZzZXQ7CgkgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CgkgICAgb2Zmc2V0ID0gMDsKCSAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSkKCSAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7CgkgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDsKCSAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkgewoJICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDsKCSAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JzsKCSAgICB9IGVsc2UgewoJICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7CgkgICAgICBsZW5ndGggPSB1bmRlZmluZWQ7CgkgICAgfQoJICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzCgkgIH0gZWxzZSB7CgkgICAgdGhyb3cgbmV3IEVycm9yKAoJICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJwoJICAgICkKCSAgfQoKCSAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0OwoJICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmc7CgoJICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkgewoJICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpCgkgIH0KCgkgIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnOwoKCSAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7CgkgIGZvciAoOzspIHsKCSAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CgkgICAgICBjYXNlICdoZXgnOgoJICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCgkgICAgICBjYXNlICd1dGY4JzoKCSAgICAgIGNhc2UgJ3V0Zi04JzoKCSAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKCSAgICAgIGNhc2UgJ2FzY2lpJzoKCSAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCgkgICAgICBjYXNlICdsYXRpbjEnOgoJICAgICAgY2FzZSAnYmluYXJ5JzoKCSAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgoJICAgICAgY2FzZSAnYmFzZTY0JzoKCSAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGUKCSAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgoJICAgICAgY2FzZSAndWNzMic6CgkgICAgICBjYXNlICd1Y3MtMic6CgkgICAgICBjYXNlICd1dGYxNmxlJzoKCSAgICAgIGNhc2UgJ3V0Zi0xNmxlJzoKCSAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKCSAgICAgIGRlZmF1bHQ6CgkgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKQoJICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwoJICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CgkgICAgfQoJICB9Cgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkgewoJICByZXR1cm4gewoJICAgIHR5cGU6ICdCdWZmZXInLAoJICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKQoJICB9Cgl9OwoKCWZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKCSAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkgewoJICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1ZikKCSAgfSBlbHNlIHsKCSAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpCgkgIH0KCX0KCglmdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewoJICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwoJICB2YXIgcmVzID0gW107CgoJICB2YXIgaSA9IHN0YXJ0OwoJICB3aGlsZSAoaSA8IGVuZCkgewoJICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07CgkgICAgdmFyIGNvZGVQb2ludCA9IG51bGw7CgkgICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0CgkgICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDMKCSAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMgoJICAgICAgOiAxOwoKCSAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7CgkgICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50OwoKCSAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkgewoJICAgICAgICBjYXNlIDE6CgkgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHsKCSAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZTsKCSAgICAgICAgICB9CgkgICAgICAgICAgYnJlYWsKCSAgICAgICAgY2FzZSAyOgoJICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwoJICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CgkgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRik7CgkgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHsKCSAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICB9CgkgICAgICAgICAgYnJlYWsKCSAgICAgICAgY2FzZSAzOgoJICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwoJICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07CgkgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CgkgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRik7CgkgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7CgkgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgfQoJICAgICAgICAgIGJyZWFrCgkgICAgICAgIGNhc2UgNDoKCSAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKCSAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdOwoJICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdOwoJICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CgkgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRik7CgkgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHsKCSAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICB9CgkgICAgICB9CgkgICAgfQoKCSAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7CgkgICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhCgkgICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlCgkgICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7CgkgICAgICBieXRlc1BlclNlcXVlbmNlID0gMTsKCSAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikgewoJICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSkKCSAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwOwoJICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTsKCSAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGOwoJICAgIH0KCgkgICAgcmVzLnB1c2goY29kZVBvaW50KTsKCSAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7CgkgIH0KCgkgIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKQoJfQoKCS8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aAoJLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLgoJLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eQoJdmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwOwoKCWZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykgewoJICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7CgkgIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHsKCSAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKCkKCSAgfQoKCSAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCAiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkIi4KCSAgdmFyIHJlcyA9ICcnOwoJICB2YXIgaSA9IDA7CgkgIHdoaWxlIChpIDwgbGVuKSB7CgkgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoCgkgICAgICBTdHJpbmcsCgkgICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpCgkgICAgKTsKCSAgfQoJICByZXR1cm4gcmVzCgl9CgoJZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CgkgIHZhciByZXQgPSAnJzsKCSAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKCgkgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CgkgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7CgkgIH0KCSAgcmV0dXJuIHJldAoJfQoKCWZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKCSAgdmFyIHJldCA9ICcnOwoJICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwoKCSAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKCSAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pOwoJICB9CgkgIHJldHVybiByZXQKCX0KCglmdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CgkgIHZhciBsZW4gPSBidWYubGVuZ3RoOwoKCSAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDsKCSAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjsKCgkgIHZhciBvdXQgPSAnJzsKCSAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKCSAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKTsKCSAgfQoJICByZXR1cm4gb3V0Cgl9CgoJZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKCSAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpOwoJICB2YXIgcmVzID0gJyc7CgkgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHsKCSAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7CgkgIH0KCSAgcmV0dXJuIHJlcwoJfQoKCUJ1ZmZlciQxLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7CgkgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDsKCSAgc3RhcnQgPSB+fnN0YXJ0OwoJICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kOwoKCSAgaWYgKHN0YXJ0IDwgMCkgewoJICAgIHN0YXJ0ICs9IGxlbjsKCSAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7CgkgIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHsKCSAgICBzdGFydCA9IGxlbjsKCSAgfQoKCSAgaWYgKGVuZCA8IDApIHsKCSAgICBlbmQgKz0gbGVuOwoJICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwOwoJICB9IGVsc2UgaWYgKGVuZCA+IGxlbikgewoJICAgIGVuZCA9IGxlbjsKCSAgfQoKCSAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDsKCgkgIHZhciBuZXdCdWY7CgkgIGlmIChCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7CgkgICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTsKCSAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyJDEucHJvdG90eXBlOwoJICB9IGVsc2UgewoJICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0OwoJICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIkMShzbGljZUxlbiwgdW5kZWZpbmVkKTsKCSAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHsKCSAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTsKCSAgICB9CgkgIH0KCgkgIHJldHVybiBuZXdCdWYKCX07CgoJLyoKCSAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLgoJICovCglmdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkgewoJICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKQoJICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpCgl9CgoJQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CgkgIG9mZnNldCA9IG9mZnNldCB8IDA7CgkgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7CgoJICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdOwoJICB2YXIgbXVsID0gMTsKCSAgdmFyIGkgPSAwOwoJICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewoJICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsOwoJICB9CgoJICByZXR1cm4gdmFsCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewoJICBvZmZzZXQgPSBvZmZzZXQgfCAwOwoJICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7CgkgIGlmICghbm9Bc3NlcnQpIHsKCSAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTsKCSAgfQoKCSAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTsKCSAgdmFyIG11bCA9IDE7CgkgIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkgewoJICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7CgkgIH0KCgkgIHJldHVybiB2YWwKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkgewoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTsKCSAgcmV0dXJuIHRoaXNbb2Zmc2V0XQoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CgkgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwoJICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkgewoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKCSAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CgoJICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHwKCSAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHwKCSAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgKwoJICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CgoJICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgKwoJICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfAoJICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHwKCSAgICB0aGlzW29mZnNldCArIDNdKQoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CgkgIG9mZnNldCA9IG9mZnNldCB8IDA7CgkgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7CgoJICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdOwoJICB2YXIgbXVsID0gMTsKCSAgdmFyIGkgPSAwOwoJICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewoJICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsOwoJICB9CgkgIG11bCAqPSAweDgwOwoKCSAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7CgoJICByZXR1cm4gdmFsCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKCSAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDsKCSAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwOwoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTsKCgkgIHZhciBpID0gYnl0ZUxlbmd0aDsKCSAgdmFyIG11bCA9IDE7CgkgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07CgkgIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkgewoJICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7CgkgIH0KCSAgbXVsICo9IDB4ODA7CgoJICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTsKCgkgIHJldHVybiB2YWwKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7CgkgIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSkKCSAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CgkgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwoJICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7CgkgIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWwKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CgkgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KTsKCSAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbAoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkgewoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKCgkgIHJldHVybiAodGhpc1tvZmZzZXRdKSB8CgkgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfAoJICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8CgkgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CgkgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwoKCSAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHwKCSAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfAoJICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHwKCSAgICAodGhpc1tvZmZzZXQgKyAzXSkKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CgkgIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CgkgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwoJICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNCkKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkgewoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTsKCSAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOCkKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkgewoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTsKCSAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpCgl9OwoKCWZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKCSAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJyJidWZmZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKQoJICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKQoJICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCgl9CgoJQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CgkgIHZhbHVlID0gK3ZhbHVlOwoJICBvZmZzZXQgPSBvZmZzZXQgfCAwOwoJICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7CgkgIGlmICghbm9Bc3NlcnQpIHsKCSAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxOwoJICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTsKCSAgfQoKCSAgdmFyIG11bCA9IDE7CgkgIHZhciBpID0gMDsKCSAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGOwoJICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewoJICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjsKCSAgfQoKCSAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CgkgIHZhbHVlID0gK3ZhbHVlOwoJICBvZmZzZXQgPSBvZmZzZXQgfCAwOwoJICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7CgkgIGlmICghbm9Bc3NlcnQpIHsKCSAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxOwoJICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTsKCSAgfQoKCSAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTsKCSAgdmFyIG11bCA9IDE7CgkgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7CgkgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkgewoJICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjsKCSAgfQoKCSAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewoJICB2YWx1ZSA9ICt2YWx1ZTsKCSAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMCk7CgkgIGlmICghQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTsKCSAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7CgkgIHJldHVybiBvZmZzZXQgKyAxCgl9OwoKCWZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikgewoJICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTsKCSAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkgewoJICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+CgkgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7CgkgIH0KCX0KCglCdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CgkgIHZhbHVlID0gK3ZhbHVlOwoJICBvZmZzZXQgPSBvZmZzZXQgfCAwOwoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApOwoJICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgewoJICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpOwoJICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpOwoJICB9IGVsc2UgewoJICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpOwoJICB9CgkgIHJldHVybiBvZmZzZXQgKyAyCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKCSAgdmFsdWUgPSArdmFsdWU7CgkgIG9mZnNldCA9IG9mZnNldCB8IDA7CgkgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7CgkgIGlmIChCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7CgkgICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTsKCSAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7CgkgIH0gZWxzZSB7CgkgICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpOwoJICB9CgkgIHJldHVybiBvZmZzZXQgKyAyCgl9OwoKCWZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikgewoJICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7CgkgIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHsKCSAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmOwoJICB9Cgl9CgoJQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewoJICB2YWx1ZSA9ICt2YWx1ZTsKCSAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7CgkgIGlmIChCdWZmZXIkMS5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7CgkgICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpOwoJICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTsKCSAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTsKCSAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTsKCSAgfSBlbHNlIHsKCSAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTsKCSAgfQoJICByZXR1cm4gb2Zmc2V0ICsgNAoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CgkgIHZhbHVlID0gK3ZhbHVlOwoJICBvZmZzZXQgPSBvZmZzZXQgfCAwOwoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTsKCSAgaWYgKEJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHsKCSAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTsKCSAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7CgkgICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7CgkgICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpOwoJICB9IGVsc2UgewoJICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTsKCSAgfQoJICByZXR1cm4gb2Zmc2V0ICsgNAoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CgkgIHZhbHVlID0gK3ZhbHVlOwoJICBvZmZzZXQgPSBvZmZzZXQgfCAwOwoJICBpZiAoIW5vQXNzZXJ0KSB7CgkgICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTsKCgkgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpOwoJICB9CgoJICB2YXIgaSA9IDA7CgkgIHZhciBtdWwgPSAxOwoJICB2YXIgc3ViID0gMDsKCSAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGOwoJICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewoJICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7CgkgICAgICBzdWIgPSAxOwoJICAgIH0KCSAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGOwoJICB9CgoJICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aAoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CgkgIHZhbHVlID0gK3ZhbHVlOwoJICBvZmZzZXQgPSBvZmZzZXQgfCAwOwoJICBpZiAoIW5vQXNzZXJ0KSB7CgkgICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTsKCgkgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpOwoJICB9CgoJICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxOwoJICB2YXIgbXVsID0gMTsKCSAgdmFyIHN1YiA9IDA7CgkgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7CgkgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkgewoJICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7CgkgICAgICBzdWIgPSAxOwoJICAgIH0KCSAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGOwoJICB9CgoJICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aAoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewoJICB2YWx1ZSA9ICt2YWx1ZTsKCSAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApOwoJICBpZiAoIUJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7CgkgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMTsKCSAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7CgkgIHJldHVybiBvZmZzZXQgKyAxCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CgkgIHZhbHVlID0gK3ZhbHVlOwoJICBvZmZzZXQgPSBvZmZzZXQgfCAwOwoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApOwoJICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgewoJICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpOwoJICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpOwoJICB9IGVsc2UgewoJICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpOwoJICB9CgkgIHJldHVybiBvZmZzZXQgKyAyCgl9OwoKCUJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CgkgIHZhbHVlID0gK3ZhbHVlOwoJICBvZmZzZXQgPSBvZmZzZXQgfCAwOwoJICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApOwoJICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgewoJICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7CgkgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpOwoJICB9IGVsc2UgewoJICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTsKCSAgfQoJICByZXR1cm4gb2Zmc2V0ICsgMgoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewoJICB2YWx1ZSA9ICt2YWx1ZTsKCSAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDsKCSAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApOwoJICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgewoJICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpOwoJICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpOwoJICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTsKCSAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7CgkgIH0gZWxzZSB7CgkgICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7CgkgIH0KCSAgcmV0dXJuIG9mZnNldCArIDQKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKCSAgdmFsdWUgPSArdmFsdWU7CgkgIG9mZnNldCA9IG9mZnNldCB8IDA7CgkgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTsKCSAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxOwoJICBpZiAoQnVmZmVyJDEuVFlQRURfQVJSQVlfU1VQUE9SVCkgewoJICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpOwoJICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTsKCSAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTsKCSAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7CgkgIH0gZWxzZSB7CgkgICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpOwoJICB9CgkgIHJldHVybiBvZmZzZXQgKyA0Cgl9OwoKCWZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7CgkgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJykKCSAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKQoJfQoKCWZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkgewoJICBpZiAoIW5vQXNzZXJ0KSB7CgkgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCk7CgkgIH0KCSAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTsKCSAgcmV0dXJuIG9mZnNldCArIDQKCX0KCglCdWZmZXIkMS5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewoJICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCkKCX07CgoJQnVmZmVyJDEucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKCSAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KQoJfTsKCglmdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CgkgIGlmICghbm9Bc3NlcnQpIHsKCSAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTsKCSAgfQoJICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpOwoJICByZXR1cm4gb2Zmc2V0ICsgOAoJfQoKCUJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKCSAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KQoJfTsKCglCdWZmZXIkMS5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CgkgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpCgl9OwoKCS8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aCkKCUJ1ZmZlciQxLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkgewoJICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7CgkgIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7CgkgIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7CgkgIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDsKCSAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0OwoKCSAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lCgkgIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMAoJICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDAKCgkgIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnMKCSAgaWYgKHRhcmdldFN0YXJ0IDwgMCkgewoJICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJykKCSAgfQoJICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpCgkgIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKQoKCSAgLy8gQXJlIHdlIG9vYj8KCSAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDsKCSAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7CgkgICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7CgkgIH0KCgkgIHZhciBsZW4gPSBlbmQgLSBzdGFydDsKCSAgdmFyIGk7CgoJICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHsKCSAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmQKCSAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkgewoJICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07CgkgICAgfQoJICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlciQxLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHsKCSAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0CgkgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7CgkgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTsKCSAgICB9CgkgIH0gZWxzZSB7CgkgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoCgkgICAgICB0YXJnZXQsCgkgICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksCgkgICAgICB0YXJnZXRTdGFydAoJICAgICk7CgkgIH0KCgkgIHJldHVybiBsZW4KCX07CgoJLy8gVXNhZ2U6CgkvLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSkKCS8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKQoJLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pCglCdWZmZXIkMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHsKCSAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczoKCSAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7CgkgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHsKCSAgICAgIGVuY29kaW5nID0gc3RhcnQ7CgkgICAgICBzdGFydCA9IDA7CgkgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKCSAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7CgkgICAgICBlbmNvZGluZyA9IGVuZDsKCSAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwoJICAgIH0KCSAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkgewoJICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTsKCSAgICAgIGlmIChjb2RlIDwgMjU2KSB7CgkgICAgICAgIHZhbCA9IGNvZGU7CgkgICAgICB9CgkgICAgfQoJICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHsKCSAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKQoJICAgIH0KCSAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyJDEuaXNFbmNvZGluZyhlbmNvZGluZykpIHsKCSAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZykKCSAgICB9CgkgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHsKCSAgICB2YWwgPSB2YWwgJiAyNTU7CgkgIH0KCgkgIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LgoJICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHsKCSAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JykKCSAgfQoKCSAgaWYgKGVuZCA8PSBzdGFydCkgewoJICAgIHJldHVybiB0aGlzCgkgIH0KCgkgIHN0YXJ0ID0gc3RhcnQgPj4+IDA7CgkgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7CgoJICBpZiAoIXZhbCkgdmFsID0gMDsKCgkgIHZhciBpOwoJICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHsKCSAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CgkgICAgICB0aGlzW2ldID0gdmFsOwoJICAgIH0KCSAgfSBlbHNlIHsKCSAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbCkKCSAgICAgID8gdmFsCgkgICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIkMSh2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKTsKCSAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoOwoJICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7CgkgICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTsKCSAgICB9CgkgIH0KCgkgIHJldHVybiB0aGlzCgl9OwoKCS8vIEhFTFBFUiBGVU5DVElPTlMKCS8vID09PT09PT09PT09PT09PT0KCgl2YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXC8wLTlBLVphLXotX10vZzsKCglmdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7CgkgIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcbiBhbmQgXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3QKCSAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKTsKCSAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJwoJICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJwoJICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3QKCSAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7CgkgICAgc3RyID0gc3RyICsgJz0nOwoJICB9CgkgIHJldHVybiBzdHIKCX0KCglmdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHsKCSAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKQoJICByZXR1cm4gc3RyLnJlcGxhY2UoL15ccyt8XHMrJC9nLCAnJykKCX0KCglmdW5jdGlvbiB0b0hleCAobikgewoJICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNikKCSAgcmV0dXJuIG4udG9TdHJpbmcoMTYpCgl9CgoJZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHsKCSAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTsKCSAgdmFyIGNvZGVQb2ludDsKCSAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7CgkgIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDsKCSAgdmFyIGJ5dGVzID0gW107CgoJICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CgkgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7CgoJICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnQKCSAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkgewoJICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWQKCSAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkgewoJICAgICAgICAvLyBubyBsZWFkIHlldAoJICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7CgkgICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbAoJICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTsKCSAgICAgICAgICBjb250aW51ZQoJICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHsKCSAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkCgkgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpOwoJICAgICAgICAgIGNvbnRpbnVlCgkgICAgICAgIH0KCgkgICAgICAgIC8vIHZhbGlkIGxlYWQKCSAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDsKCgkgICAgICAgIGNvbnRpbnVlCgkgICAgICB9CgoJICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvdwoJICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkgewoJICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7CgkgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7CgkgICAgICAgIGNvbnRpbnVlCgkgICAgICB9CgoJICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXIKCSAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDA7CgkgICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7CgkgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkCgkgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7CgkgICAgfQoKCSAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDsKCgkgICAgLy8gZW5jb2RlIHV0ZjgKCSAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkgewoJICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrCgkgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7CgkgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkgewoJICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrCgkgICAgICBieXRlcy5wdXNoKAoJICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCwKCSAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODAKCSAgICAgICk7CgkgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7CgkgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWsKCSAgICAgIGJ5dGVzLnB1c2goCgkgICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLAoJICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsCgkgICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwCgkgICAgICApOwoJICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHsKCSAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVhawoJICAgICAgYnl0ZXMucHVzaCgKCSAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLAoJICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsCgkgICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCwKCSAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODAKCSAgICAgICk7CgkgICAgfSBlbHNlIHsKCSAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JykKCSAgICB9CgkgIH0KCgkgIHJldHVybiBieXRlcwoJfQoKCWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7CgkgIHZhciBieXRlQXJyYXkgPSBbXTsKCSAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKCSAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi4KCSAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpOwoJICB9CgkgIHJldHVybiBieXRlQXJyYXkKCX0KCglmdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykgewoJICB2YXIgYywgaGksIGxvOwoJICB2YXIgYnl0ZUFycmF5ID0gW107CgkgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CgkgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrCgoJICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTsKCSAgICBoaSA9IGMgPj4gODsKCSAgICBsbyA9IGMgJSAyNTY7CgkgICAgYnl0ZUFycmF5LnB1c2gobG8pOwoJICAgIGJ5dGVBcnJheS5wdXNoKGhpKTsKCSAgfQoKCSAgcmV0dXJuIGJ5dGVBcnJheQoJfQoKCglmdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHsKCSAgcmV0dXJuIHRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpCgl9CgoJZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7CgkgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKCSAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrCgkgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldOwoJICB9CgkgIHJldHVybiBpCgl9CgoJZnVuY3Rpb24gaXNuYW4gKHZhbCkgewoJICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmUKCX0KCgoJLy8gdGhlIGZvbGxvd2luZyBpcyBmcm9tIGlzLWJ1ZmZlciwgYWxzbyBieSBGZXJvc3MgQWJvdWtoYWRpamVoIGFuZCB3aXRoIHNhbWUgbGlzZW5jZQoJLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZwoJLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseQoJZnVuY3Rpb24gaXNCdWZmZXIkMShvYmopIHsKCSAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpCgl9CgoJZnVuY3Rpb24gaXNGYXN0QnVmZmVyIChvYmopIHsKCSAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikKCX0KCgkvLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LgoJZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHsKCSAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Zhc3RCdWZmZXIob2JqLnNsaWNlKDAsIDApKQoJfQoKCXZhciBidWZmZXJFczYgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7CgkJX19wcm90b19fOiBudWxsLAoJCUJ1ZmZlcjogQnVmZmVyJDEsCgkJSU5TUEVDVF9NQVhfQllURVM6IElOU1BFQ1RfTUFYX0JZVEVTLAoJCVNsb3dCdWZmZXI6IFNsb3dCdWZmZXIsCgkJaXNCdWZmZXI6IGlzQnVmZmVyJDEsCgkJa01heExlbmd0aDogX2tNYXhMZW5ndGgKCX0pOwoKCS8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlcgoJLy8gYmFzZWQgb2ZmIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtcHJvY2Vzcy9ibG9iL21hc3Rlci9icm93c2VyLmpzCgoJZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHsKCSAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTsKCX0KCWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkgewoJICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7Cgl9Cgl2YXIgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7Cgl2YXIgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDsKCWlmICh0eXBlb2YgZ2xvYmFsJDEuc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykgewoJICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0OwoJfQoJaWYgKHR5cGVvZiBnbG9iYWwkMS5jbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHsKCSAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7Cgl9CgoJZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHsKCSAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkgewoJICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnMKCSAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTsKCSAgICB9CgkgICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWQKCSAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHsKCSAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7CgkgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7CgkgICAgfQoJICAgIHRyeSB7CgkgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3MKCSAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTsKCSAgICB9IGNhdGNoKGUpewoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5CgkgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7CgkgICAgICAgIH0gY2F0Y2goZSl7CgkgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvcgoJICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApOwoJICAgICAgICB9CgkgICAgfQoKCgl9CglmdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7CgkgICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7CgkgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9ucwoJICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7CgkgICAgfQoJICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWQKCSAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHsKCSAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0OwoJICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7CgkgICAgfQoJICAgIHRyeSB7CgkgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3MKCSAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpOwoJICAgIH0gY2F0Y2ggKGUpewoJICAgICAgICB0cnkgewoJICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseQoJICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7CgkgICAgICAgIH0gY2F0Y2ggKGUpewoJICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuCgkgICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0CgkgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTsKCSAgICAgICAgfQoJICAgIH0KCgoKCX0KCXZhciBxdWV1ZSA9IFtdOwoJdmFyIGRyYWluaW5nID0gZmFsc2U7Cgl2YXIgY3VycmVudFF1ZXVlOwoJdmFyIHF1ZXVlSW5kZXggPSAtMTsKCglmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7CgkgICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7CgkgICAgICAgIHJldHVybjsKCSAgICB9CgkgICAgZHJhaW5pbmcgPSBmYWxzZTsKCSAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkgewoJICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpOwoJICAgIH0gZWxzZSB7CgkgICAgICAgIHF1ZXVlSW5kZXggPSAtMTsKCSAgICB9CgkgICAgaWYgKHF1ZXVlLmxlbmd0aCkgewoJICAgICAgICBkcmFpblF1ZXVlKCk7CgkgICAgfQoJfQoKCWZ1bmN0aW9uIGRyYWluUXVldWUoKSB7CgkgICAgaWYgKGRyYWluaW5nKSB7CgkgICAgICAgIHJldHVybjsKCSAgICB9CgkgICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7CgkgICAgZHJhaW5pbmcgPSB0cnVlOwoKCSAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoOwoJICAgIHdoaWxlKGxlbikgewoJICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTsKCSAgICAgICAgcXVldWUgPSBbXTsKCSAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikgewoJICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkgewoJICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICBxdWV1ZUluZGV4ID0gLTE7CgkgICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDsKCSAgICB9CgkgICAgY3VycmVudFF1ZXVlID0gbnVsbDsKCSAgICBkcmFpbmluZyA9IGZhbHNlOwoJICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTsKCX0KCWZ1bmN0aW9uIG5leHRUaWNrKGZ1bikgewoJICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTsKCSAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsKCSAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsKCSAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldOwoJICAgICAgICB9CgkgICAgfQoJICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7CgkgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHsKCSAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTsKCSAgICB9Cgl9CgkvLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzCglmdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHsKCSAgICB0aGlzLmZ1biA9IGZ1bjsKCSAgICB0aGlzLmFycmF5ID0gYXJyYXk7Cgl9CglJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7CgkgICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7Cgl9OwoJdmFyIHRpdGxlID0gJ2Jyb3dzZXInOwoJdmFyIHBsYXRmb3JtID0gJ2Jyb3dzZXInOwoJdmFyIGJyb3dzZXIgPSB0cnVlOwoJdmFyIGVudiA9IHt9OwoJdmFyIGFyZ3YgPSBbXTsKCXZhciB2ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzCgl2YXIgdmVyc2lvbnMgPSB7fTsKCXZhciByZWxlYXNlID0ge307Cgl2YXIgY29uZmlnID0ge307CgoJZnVuY3Rpb24gbm9vcCQxKCkge30KCgl2YXIgb24gPSBub29wJDE7Cgl2YXIgYWRkTGlzdGVuZXIgPSBub29wJDE7Cgl2YXIgb25jZSA9IG5vb3AkMTsKCXZhciBvZmYgPSBub29wJDE7Cgl2YXIgcmVtb3ZlTGlzdGVuZXIgPSBub29wJDE7Cgl2YXIgcmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcCQxOwoJdmFyIGVtaXQgPSBub29wJDE7CgoJZnVuY3Rpb24gYmluZGluZyhuYW1lKSB7CgkgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpOwoJfQoKCWZ1bmN0aW9uIGN3ZCAoKSB7IHJldHVybiAnLycgfQoJZnVuY3Rpb24gY2hkaXIgKGRpcikgewoJICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7Cgl9ZnVuY3Rpb24gdW1hc2soKSB7IHJldHVybiAwOyB9CgoJLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20va3VtYXZpcy9icm93c2VyLXByb2Nlc3MtaHJ0aW1lL2Jsb2IvbWFzdGVyL2luZGV4LmpzCgl2YXIgcGVyZm9ybWFuY2UgPSBnbG9iYWwkMS5wZXJmb3JtYW5jZSB8fCB7fTsKCXZhciBwZXJmb3JtYW5jZU5vdyA9CgkgIHBlcmZvcm1hbmNlLm5vdyAgICAgICAgfHwKCSAgcGVyZm9ybWFuY2UubW96Tm93ICAgICB8fAoJICBwZXJmb3JtYW5jZS5tc05vdyAgICAgIHx8CgkgIHBlcmZvcm1hbmNlLm9Ob3cgICAgICAgfHwKCSAgcGVyZm9ybWFuY2Uud2Via2l0Tm93ICB8fAoJICBmdW5jdGlvbigpeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSB9OwoKCS8vIGdlbmVyYXRlIHRpbWVzdGFtcCBvciBkZWx0YQoJLy8gc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2hydGltZQoJZnVuY3Rpb24gaHJ0aW1lKHByZXZpb3VzVGltZXN0YW1wKXsKCSAgdmFyIGNsb2NrdGltZSA9IHBlcmZvcm1hbmNlTm93LmNhbGwocGVyZm9ybWFuY2UpKjFlLTM7CgkgIHZhciBzZWNvbmRzID0gTWF0aC5mbG9vcihjbG9ja3RpbWUpOwoJICB2YXIgbmFub3NlY29uZHMgPSBNYXRoLmZsb29yKChjbG9ja3RpbWUlMSkqMWU5KTsKCSAgaWYgKHByZXZpb3VzVGltZXN0YW1wKSB7CgkgICAgc2Vjb25kcyA9IHNlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFswXTsKCSAgICBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMV07CgkgICAgaWYgKG5hbm9zZWNvbmRzPDApIHsKCSAgICAgIHNlY29uZHMtLTsKCSAgICAgIG5hbm9zZWNvbmRzICs9IDFlOTsKCSAgICB9CgkgIH0KCSAgcmV0dXJuIFtzZWNvbmRzLG5hbm9zZWNvbmRzXQoJfQoKCXZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpOwoJZnVuY3Rpb24gdXB0aW1lKCkgewoJICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpOwoJICB2YXIgZGlmID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7CgkgIHJldHVybiBkaWYgLyAxMDAwOwoJfQoKCXZhciBicm93c2VyJDEgPSB7CgkgIG5leHRUaWNrOiBuZXh0VGljaywKCSAgdGl0bGU6IHRpdGxlLAoJICBicm93c2VyOiBicm93c2VyLAoJICBlbnY6IGVudiwKCSAgYXJndjogYXJndiwKCSAgdmVyc2lvbjogdmVyc2lvbiwKCSAgdmVyc2lvbnM6IHZlcnNpb25zLAoJICBvbjogb24sCgkgIGFkZExpc3RlbmVyOiBhZGRMaXN0ZW5lciwKCSAgb25jZTogb25jZSwKCSAgb2ZmOiBvZmYsCgkgIHJlbW92ZUxpc3RlbmVyOiByZW1vdmVMaXN0ZW5lciwKCSAgcmVtb3ZlQWxsTGlzdGVuZXJzOiByZW1vdmVBbGxMaXN0ZW5lcnMsCgkgIGVtaXQ6IGVtaXQsCgkgIGJpbmRpbmc6IGJpbmRpbmcsCgkgIGN3ZDogY3dkLAoJICBjaGRpcjogY2hkaXIsCgkgIHVtYXNrOiB1bWFzaywKCSAgaHJ0aW1lOiBocnRpbWUsCgkgIHBsYXRmb3JtOiBwbGF0Zm9ybSwKCSAgcmVsZWFzZTogcmVsZWFzZSwKCSAgY29uZmlnOiBjb25maWcsCgkgIHVwdGltZTogdXB0aW1lCgl9OwoKCXZhciBwcm9jZXNzID0gYnJvd3NlciQxOwoKCXZhciBpbmhlcml0czsKCWlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJyl7CgkgIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7CgkgICAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGUKCSAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjsKCSAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwgewoJICAgICAgY29uc3RydWN0b3I6IHsKCSAgICAgICAgdmFsdWU6IGN0b3IsCgkgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAoJICAgICAgICB3cml0YWJsZTogdHJ1ZSwKCSAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCgkgICAgICB9CgkgICAgfSk7CgkgIH07Cgl9IGVsc2UgewoJICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3RvcikgewoJICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yOwoJICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9OwoJICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7CgkgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTsKCSAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7CgkgIH07Cgl9Cgl2YXIgaW5oZXJpdHMkMSA9IGluaGVyaXRzOwoKCXZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nOwoJZnVuY3Rpb24gZm9ybWF0JDEoZikgewoJICBpZiAoIWlzU3RyaW5nKGYpKSB7CgkgICAgdmFyIG9iamVjdHMgPSBbXTsKCSAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewoJICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QkMShhcmd1bWVudHNbaV0pKTsKCSAgICB9CgkgICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpOwoJICB9CgoJICB2YXIgaSA9IDE7CgkgIHZhciBhcmdzID0gYXJndW1lbnRzOwoJICB2YXIgbGVuID0gYXJncy5sZW5ndGg7CgkgIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHsKCSAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJzsKCSAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4OwoJICAgIHN3aXRjaCAoeCkgewoJICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7CgkgICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTsKCSAgICAgIGNhc2UgJyVqJzoKCSAgICAgICAgdHJ5IHsKCSAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTsKCSAgICAgICAgfSBjYXRjaCAoXykgewoJICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7CgkgICAgICAgIH0KCSAgICAgIGRlZmF1bHQ6CgkgICAgICAgIHJldHVybiB4OwoJICAgIH0KCSAgfSk7CgkgIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7CgkgICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHsKCSAgICAgIHN0ciArPSAnICcgKyB4OwoJICAgIH0gZWxzZSB7CgkgICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCQxKHgpOwoJICAgIH0KCSAgfQoJICByZXR1cm4gc3RyOwoJfQoKCS8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuCgkvLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LgoJLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC4KCWZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbXNnKSB7CgkgIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuCgkgIGlmIChpc1VuZGVmaW5lZChnbG9iYWwkMS5wcm9jZXNzKSkgewoJICAgIHJldHVybiBmdW5jdGlvbigpIHsKCSAgICAgIHJldHVybiBkZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKCSAgICB9OwoJICB9CgoJICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7CgkgICAgcmV0dXJuIGZuOwoJICB9CgoJICB2YXIgd2FybmVkID0gZmFsc2U7CgkgIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7CgkgICAgaWYgKCF3YXJuZWQpIHsKCSAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHsKCSAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7CgkgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikgewoJICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7CgkgICAgICB9IGVsc2UgewoJICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7CgkgICAgICB9CgkgICAgICB3YXJuZWQgPSB0cnVlOwoJICAgIH0KCSAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsKCSAgfQoKCSAgcmV0dXJuIGRlcHJlY2F0ZWQ7Cgl9CgoJdmFyIGRlYnVncyA9IHt9OwoJdmFyIGRlYnVnRW52aXJvbjsKCWZ1bmN0aW9uIGRlYnVnbG9nKHNldCkgewoJICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSkKCSAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnOwoJICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTsKCSAgaWYgKCFkZWJ1Z3Nbc2V0XSkgewoJICAgIGlmIChuZXcgUmVnRXhwKCdcXGInICsgc2V0ICsgJ1xcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7CgkgICAgICB2YXIgcGlkID0gMDsKCSAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7CgkgICAgICAgIHZhciBtc2cgPSBmb3JtYXQkMS5hcHBseShudWxsLCBhcmd1bWVudHMpOwoJICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTsKCSAgICAgIH07CgkgICAgfSBlbHNlIHsKCSAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTsKCSAgICB9CgkgIH0KCSAgcmV0dXJuIGRlYnVnc1tzZXRdOwoJfQoKCS8qKgoJICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dAoJICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuCgkgKgoJICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC4KCSAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuCgkgKi8KCS8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi8KCWZ1bmN0aW9uIGluc3BlY3QkMShvYmosIG9wdHMpIHsKCSAgLy8gZGVmYXVsdCBvcHRpb25zCgkgIHZhciBjdHggPSB7CgkgICAgc2VlbjogW10sCgkgICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3IKCSAgfTsKCSAgLy8gbGVnYWN5Li4uCgkgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTsKCSAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTsKCSAgaWYgKGlzQm9vbGVhbihvcHRzKSkgewoJICAgIC8vIGxlZ2FjeS4uLgoJICAgIGN0eC5zaG93SGlkZGVuID0gb3B0czsKCSAgfSBlbHNlIGlmIChvcHRzKSB7CgkgICAgLy8gZ290IGFuICJvcHRpb25zIiBvYmplY3QKCSAgICBfZXh0ZW5kKGN0eCwgb3B0cyk7CgkgIH0KCSAgLy8gc2V0IGRlZmF1bHQgb3B0aW9ucwoJICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlOwoJICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjsKCSAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7CgkgIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTsKCSAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjsKCSAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpOwoJfQoKCS8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljcwoJaW5zcGVjdCQxLmNvbG9ycyA9IHsKCSAgJ2JvbGQnIDogWzEsIDIyXSwKCSAgJ2l0YWxpYycgOiBbMywgMjNdLAoJICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sCgkgICdpbnZlcnNlJyA6IFs3LCAyN10sCgkgICd3aGl0ZScgOiBbMzcsIDM5XSwKCSAgJ2dyZXknIDogWzkwLCAzOV0sCgkgICdibGFjaycgOiBbMzAsIDM5XSwKCSAgJ2JsdWUnIDogWzM0LCAzOV0sCgkgICdjeWFuJyA6IFszNiwgMzldLAoJICAnZ3JlZW4nIDogWzMyLCAzOV0sCgkgICdtYWdlbnRhJyA6IFszNSwgMzldLAoJICAncmVkJyA6IFszMSwgMzldLAoJICAneWVsbG93JyA6IFszMywgMzldCgl9OwoKCS8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZQoJaW5zcGVjdCQxLnN0eWxlcyA9IHsKCSAgJ3NwZWNpYWwnOiAnY3lhbicsCgkgICdudW1iZXInOiAneWVsbG93JywKCSAgJ2Jvb2xlYW4nOiAneWVsbG93JywKCSAgJ3VuZGVmaW5lZCc6ICdncmV5JywKCSAgJ251bGwnOiAnYm9sZCcsCgkgICdzdHJpbmcnOiAnZ3JlZW4nLAoJICAnZGF0ZSc6ICdtYWdlbnRhJywKCSAgLy8gIm5hbWUiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nCgkgICdyZWdleHAnOiAncmVkJwoJfTsKCgoJZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkgewoJICB2YXIgc3R5bGUgPSBpbnNwZWN0JDEuc3R5bGVzW3N0eWxlVHlwZV07CgoJICBpZiAoc3R5bGUpIHsKCSAgICByZXR1cm4gJ1x1MDAxYlsnICsgaW5zcGVjdCQxLmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgKwoJICAgICAgICAgICAnXHUwMDFiWycgKyBpbnNwZWN0JDEuY29sb3JzW3N0eWxlXVsxXSArICdtJzsKCSAgfSBlbHNlIHsKCSAgICByZXR1cm4gc3RyOwoJICB9Cgl9CgoKCWZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7CgkgIHJldHVybiBzdHI7Cgl9CgoKCWZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7CgkgIHZhciBoYXNoID0ge307CgoJICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7CgkgICAgaGFzaFt2YWxdID0gdHJ1ZTsKCSAgfSk7CgoJICByZXR1cm4gaGFzaDsKCX0KCgoJZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7CgkgIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy4KCSAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0CgkgIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJgoJICAgICAgdmFsdWUgJiYKCSAgICAgIGlzRnVuY3Rpb24kMSh2YWx1ZS5pbnNwZWN0KSAmJgoJICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsCgkgICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBpbnNwZWN0JDEgJiYKCSAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLgoJICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkgewoJICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTsKCSAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHsKCSAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpOwoJICAgIH0KCSAgICByZXR1cm4gcmV0OwoJICB9CgoJICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllcwoJICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpOwoJICBpZiAocHJpbWl0aXZlKSB7CgkgICAgcmV0dXJuIHByaW1pdGl2ZTsKCSAgfQoKCSAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LgoJICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTsKCSAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7CgoJICBpZiAoY3R4LnNob3dIaWRkZW4pIHsKCSAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpOwoJICB9CgoJICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlCgkgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4CgkgIGlmIChpc0Vycm9yKHZhbHVlKQoJICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7CgkgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTsKCSAgfQoKCSAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLgoJICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHsKCSAgICBpZiAoaXNGdW5jdGlvbiQxKHZhbHVlKSkgewoJICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJzsKCSAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7CgkgICAgfQoJICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHsKCSAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7CgkgICAgfQoJICAgIGlmIChpc0RhdGUodmFsdWUpKSB7CgkgICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7CgkgICAgfQoJICAgIGlmIChpc0Vycm9yKHZhbHVlKSkgewoJICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTsKCSAgICB9CgkgIH0KCgkgIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107CgoJICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5CgkgIGlmIChpc0FycmF5JDEodmFsdWUpKSB7CgkgICAgYXJyYXkgPSB0cnVlOwoJICAgIGJyYWNlcyA9IFsnWycsICddJ107CgkgIH0KCgkgIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9ucwoJICBpZiAoaXNGdW5jdGlvbiQxKHZhbHVlKSkgewoJICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7CgkgICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7CgkgIH0KCgkgIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzCgkgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHsKCSAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTsKCSAgfQoKCSAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlCgkgIGlmIChpc0RhdGUodmFsdWUpKSB7CgkgICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpOwoJICB9CgoJICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yCgkgIGlmIChpc0Vycm9yKHZhbHVlKSkgewoJICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7CgkgIH0KCgkgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkgewoJICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdOwoJICB9CgoJICBpZiAocmVjdXJzZVRpbWVzIDwgMCkgewoJICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHsKCSAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7CgkgICAgfSBlbHNlIHsKCSAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpOwoJICAgIH0KCSAgfQoKCSAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7CgoJICB2YXIgb3V0cHV0OwoJICBpZiAoYXJyYXkpIHsKCSAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTsKCSAgfSBlbHNlIHsKCSAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHsKCSAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTsKCSAgICB9KTsKCSAgfQoKCSAgY3R4LnNlZW4ucG9wKCk7CgoJICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpOwoJfQoKCglmdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkgewoJICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKQoJICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpOwoJICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7CgkgICAgdmFyIHNpbXBsZSA9ICdcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXiJ8IiQvZywgJycpCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAiXFwnIikKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCIvZywgJyInKSArICdcJyc7CgkgICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpOwoJICB9CgkgIGlmIChpc051bWJlcih2YWx1ZSkpCgkgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTsKCSAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpCgkgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7CgkgIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyAib2JqZWN0Iiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuCgkgIGlmIChpc051bGwodmFsdWUpKQoJICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7Cgl9CgoKCWZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7CgkgIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7Cgl9CgoKCWZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHsKCSAgdmFyIG91dHB1dCA9IFtdOwoJICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkgewoJICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxKHZhbHVlLCBTdHJpbmcoaSkpKSB7CgkgICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLAoJICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpOwoJICAgIH0gZWxzZSB7CgkgICAgICBvdXRwdXQucHVzaCgnJyk7CgkgICAgfQoJICB9CgkgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsKCSAgICBpZiAoIWtleS5tYXRjaCgvXlxkKyQvKSkgewoJICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywKCSAgICAgICAgICBrZXksIHRydWUpKTsKCSAgICB9CgkgIH0pOwoJICByZXR1cm4gb3V0cHV0OwoJfQoKCglmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7CgkgIHZhciBuYW1lLCBzdHIsIGRlc2M7CgkgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTsKCSAgaWYgKGRlc2MuZ2V0KSB7CgkgICAgaWYgKGRlc2Muc2V0KSB7CgkgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTsKCSAgICB9IGVsc2UgewoJICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTsKCSAgICB9CgkgIH0gZWxzZSB7CgkgICAgaWYgKGRlc2Muc2V0KSB7CgkgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpOwoJICAgIH0KCSAgfQoJICBpZiAoIWhhc093blByb3BlcnR5JDEodmlzaWJsZUtleXMsIGtleSkpIHsKCSAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nOwoJICB9CgkgIGlmICghc3RyKSB7CgkgICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7CgkgICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHsKCSAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTsKCSAgICAgIH0gZWxzZSB7CgkgICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7CgkgICAgICB9CgkgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xuJykgPiAtMSkgewoJICAgICAgICBpZiAoYXJyYXkpIHsKCSAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHsKCSAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTsKCSAgICAgICAgICB9KS5qb2luKCdcbicpLnN1YnN0cigyKTsKCSAgICAgICAgfSBlbHNlIHsKCSAgICAgICAgICBzdHIgPSAnXG4nICsgc3RyLnNwbGl0KCdcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7CgkgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lOwoJICAgICAgICAgIH0pLmpvaW4oJ1xuJyk7CgkgICAgICAgIH0KCSAgICAgIH0KCSAgICB9IGVsc2UgewoJICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpOwoJICAgIH0KCSAgfQoJICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHsKCSAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXGQrJC8pKSB7CgkgICAgICByZXR1cm4gc3RyOwoJICAgIH0KCSAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpOwoJICAgIGlmIChuYW1lLm1hdGNoKC9eIihbYS16QS1aX11bYS16QS1aXzAtOV0qKSIkLykpIHsKCSAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpOwoJICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7CgkgICAgfSBlbHNlIHsKCSAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgIlxcJyIpCgkgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCIvZywgJyInKQoJICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF4ifCIkKS9nLCAiJyIpOwoJICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTsKCSAgICB9CgkgIH0KCgkgIHJldHVybiBuYW1lICsgJzogJyArIHN0cjsKCX0KCgoJZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHsKCSAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7CgkgICAgaWYgKGN1ci5pbmRleE9mKCdcbicpID49IDApIDsKCSAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cdTAwMWJcW1xkXGQ/bS9nLCAnJykubGVuZ3RoICsgMTsKCSAgfSwgMCk7CgoJICBpZiAobGVuZ3RoID4gNjApIHsKCSAgICByZXR1cm4gYnJhY2VzWzBdICsKCSAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xuICcpICsKCSAgICAgICAgICAgJyAnICsKCSAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcbiAgJykgKwoJICAgICAgICAgICAnICcgKwoJICAgICAgICAgICBicmFjZXNbMV07CgkgIH0KCgkgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07Cgl9CgoKCS8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYAoJLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuCglmdW5jdGlvbiBpc0FycmF5JDEoYXIpIHsKCSAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpOwoJfQoKCWZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHsKCSAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJzsKCX0KCglmdW5jdGlvbiBpc051bGwoYXJnKSB7CgkgIHJldHVybiBhcmcgPT09IG51bGw7Cgl9CgoJZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7CgkgIHJldHVybiBhcmcgPT0gbnVsbDsKCX0KCglmdW5jdGlvbiBpc051bWJlcihhcmcpIHsKCSAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInOwoJfQoKCWZ1bmN0aW9uIGlzU3RyaW5nKGFyZykgewoJICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7Cgl9CgoJZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7CgkgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJzsKCX0KCglmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHsKCSAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwOwoJfQoKCWZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7CgkgIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJzsKCX0KCglmdW5jdGlvbiBpc09iamVjdChhcmcpIHsKCSAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDsKCX0KCglmdW5jdGlvbiBpc0RhdGUoZCkgewoJICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJzsKCX0KCglmdW5jdGlvbiBpc0Vycm9yKGUpIHsKCSAgcmV0dXJuIGlzT2JqZWN0KGUpICYmCgkgICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTsKCX0KCglmdW5jdGlvbiBpc0Z1bmN0aW9uJDEoYXJnKSB7CgkgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nOwoJfQoKCWZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykgewoJICByZXR1cm4gYXJnID09PSBudWxsIHx8CgkgICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHwKCSAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8CgkgICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fAoJICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2wKCSAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnOwoJfQoKCWZ1bmN0aW9uIGlzQnVmZmVyKG1heWJlQnVmKSB7CgkgIHJldHVybiBCdWZmZXIkMS5pc0J1ZmZlcihtYXliZUJ1Zik7Cgl9CgoJZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykgewoJICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pOwoJfQoKCglmdW5jdGlvbiBwYWQobikgewoJICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTsKCX0KCgoJdmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLAoJICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTsKCgkvLyAyNiBGZWIgMTY6MTk6MzQKCWZ1bmN0aW9uIHRpbWVzdGFtcCgpIHsKCSAgdmFyIGQgPSBuZXcgRGF0ZSgpOwoJICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSwKCSAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSwKCSAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpOwoJICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpOwoJfQoKCgkvLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wCglmdW5jdGlvbiBsb2coKSB7CgkgIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGZvcm1hdCQxLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpOwoJfQoKCWZ1bmN0aW9uIF9leHRlbmQob3JpZ2luLCBhZGQpIHsKCSAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdAoJICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjsKCgkgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTsKCSAgdmFyIGkgPSBrZXlzLmxlbmd0aDsKCSAgd2hpbGUgKGktLSkgewoJICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTsKCSAgfQoJICByZXR1cm4gb3JpZ2luOwoJfQoJZnVuY3Rpb24gaGFzT3duUHJvcGVydHkkMShvYmosIHByb3ApIHsKCSAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOwoJfQoKCXZhciByZXF1aXJlJCQxJDEgPSB7CgkgIGluaGVyaXRzOiBpbmhlcml0cyQxLAoJICBfZXh0ZW5kOiBfZXh0ZW5kLAoJICBsb2c6IGxvZywKCSAgaXNCdWZmZXI6IGlzQnVmZmVyLAoJICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsCgkgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24kMSwKCSAgaXNFcnJvcjogaXNFcnJvciwKCSAgaXNEYXRlOiBpc0RhdGUsCgkgIGlzT2JqZWN0OiBpc09iamVjdCwKCSAgaXNSZWdFeHA6IGlzUmVnRXhwLAoJICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsCgkgIGlzU3ltYm9sOiBpc1N5bWJvbCwKCSAgaXNTdHJpbmc6IGlzU3RyaW5nLAoJICBpc051bWJlcjogaXNOdW1iZXIsCgkgIGlzTnVsbE9yVW5kZWZpbmVkOiBpc051bGxPclVuZGVmaW5lZCwKCSAgaXNOdWxsOiBpc051bGwsCgkgIGlzQm9vbGVhbjogaXNCb29sZWFuLAoJICBpc0FycmF5OiBpc0FycmF5JDEsCgkgIGluc3BlY3Q6IGluc3BlY3QkMSwKCSAgZGVwcmVjYXRlOiBkZXByZWNhdGUsCgkgIGZvcm1hdDogZm9ybWF0JDEsCgkgIGRlYnVnbG9nOiBkZWJ1Z2xvZwoJfTsKCglmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHsKCSAgaWYgKGEgPT09IGIpIHsKCSAgICByZXR1cm4gMDsKCSAgfQoKCSAgdmFyIHggPSBhLmxlbmd0aDsKCSAgdmFyIHkgPSBiLmxlbmd0aDsKCgkgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7CgkgICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKCSAgICAgIHggPSBhW2ldOwoJICAgICAgeSA9IGJbaV07CgkgICAgICBicmVhazsKCSAgICB9CgkgIH0KCgkgIGlmICh4IDwgeSkgewoJICAgIHJldHVybiAtMTsKCSAgfQoJICBpZiAoeSA8IHgpIHsKCSAgICByZXR1cm4gMTsKCSAgfQoJICByZXR1cm4gMDsKCX0KCXZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5OwoKCXZhciBvYmplY3RLZXlzJDEgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7CgkgIHZhciBrZXlzID0gW107CgkgIGZvciAodmFyIGtleSBpbiBvYmopIHsKCSAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTsKCSAgfQoJICByZXR1cm4ga2V5czsKCX07Cgl2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlOwoJdmFyIF9mdW5jdGlvbnNIYXZlTmFtZXM7CglmdW5jdGlvbiBmdW5jdGlvbnNIYXZlTmFtZXMoKSB7CgkgIGlmICh0eXBlb2YgX2Z1bmN0aW9uc0hhdmVOYW1lcyAhPT0gJ3VuZGVmaW5lZCcpIHsKCSAgICByZXR1cm4gX2Z1bmN0aW9uc0hhdmVOYW1lczsKCSAgfQoJICByZXR1cm4gX2Z1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7CgkgICAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nOwoJICB9KCkpOwoJfQoJZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHsKCSAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOwoJfQoJZnVuY3Rpb24gaXNWaWV3KGFycmJ1ZikgewoJICBpZiAoaXNCdWZmZXIkMShhcnJidWYpKSB7CgkgICAgcmV0dXJuIGZhbHNlOwoJICB9CgkgIGlmICh0eXBlb2YgZ2xvYmFsJDEuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHsKCSAgICByZXR1cm4gZmFsc2U7CgkgIH0KCSAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHsKCSAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7CgkgIH0KCSAgaWYgKCFhcnJidWYpIHsKCSAgICByZXR1cm4gZmFsc2U7CgkgIH0KCSAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7CgkgICAgcmV0dXJuIHRydWU7CgkgIH0KCSAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7CgkgICAgcmV0dXJuIHRydWU7CgkgIH0KCSAgcmV0dXJuIGZhbHNlOwoJfQoJLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3cKCS8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZQoJLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuCgoJZnVuY3Rpb24gYXNzZXJ0JDModmFsdWUsIG1lc3NhZ2UpIHsKCSAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09Jywgb2spOwoJfQoKCS8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC4KCS8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLAoJLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLAoJLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KQoKCXZhciByZWdleCA9IC9ccypmdW5jdGlvblxzKyhbXlwoXHNdKilccyovOwoJLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanMKCWZ1bmN0aW9uIGdldE5hbWUoZnVuYykgewoJICBpZiAoIWlzRnVuY3Rpb24kMShmdW5jKSkgewoJICAgIHJldHVybjsKCSAgfQoJICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKCkpIHsKCSAgICByZXR1cm4gZnVuYy5uYW1lOwoJICB9CgkgIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7CgkgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7CgkgIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTsKCX0KCWFzc2VydCQzLkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7CglmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7CgkgIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7CgkgIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7CgkgIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkOwoJICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjsKCSAgaWYgKG9wdGlvbnMubWVzc2FnZSkgewoJICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTsKCSAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTsKCSAgfSBlbHNlIHsKCSAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpOwoJICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7CgkgIH0KCSAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7CgkgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgewoJICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7CgkgIH0gZWxzZSB7CgkgICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZQoJICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTsKCSAgICBpZiAoZXJyLnN0YWNrKSB7CgkgICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrOwoKCSAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lcwoJICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7CgkgICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xuJyArIGZuX25hbWUpOwoJICAgICAgaWYgKGlkeCA+PSAwKSB7CgkgICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZQoJICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKQoJICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xuJywgaWR4ICsgMSk7CgkgICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7CgkgICAgICB9CgoJICAgICAgdGhpcy5zdGFjayA9IG91dDsKCSAgICB9CgkgIH0KCX0KCgkvLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvcgoJaW5oZXJpdHMkMShBc3NlcnRpb25FcnJvciwgRXJyb3IpOwoKCWZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHsKCSAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykgewoJICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTsKCSAgfSBlbHNlIHsKCSAgICByZXR1cm4gczsKCSAgfQoJfQoJZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHsKCSAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcygpIHx8ICFpc0Z1bmN0aW9uJDEoc29tZXRoaW5nKSkgewoJICAgIHJldHVybiBpbnNwZWN0JDEoc29tZXRoaW5nKTsKCSAgfQoJICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTsKCSAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJzsKCSAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7Cgl9CglmdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHsKCSAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICsKCSAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgKwoJICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTsKCX0KCgkvLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZAoJLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzCgkvLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlCgkvLyBpZ25vcmVkLgoKCS8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yCgkvLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdAoJLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZQoJLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3IKCS8vIGRpc3BsYXkgcHVycG9zZXMuCgoJZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7CgkgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcih7CgkgICAgbWVzc2FnZTogbWVzc2FnZSwKCSAgICBhY3R1YWw6IGFjdHVhbCwKCSAgICBleHBlY3RlZDogZXhwZWN0ZWQsCgkgICAgb3BlcmF0b3I6IG9wZXJhdG9yLAoJICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uCgkgIH0pOwoJfQoKCS8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLgoJYXNzZXJ0JDMuZmFpbCA9IGZhaWw7CgoJLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZAoJLy8gYnkgISFndWFyZC4KCS8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpOwoJLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCwKCS8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2UKCS8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy4KCglmdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkgewoJICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBvayk7Cgl9Cglhc3NlcnQkMy5vayA9IG9rOwoKCS8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aAoJLy8gPT0uCgkvLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpOwoJYXNzZXJ0JDMuZXF1YWwgPSBlcXVhbDsKCWZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHsKCSAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBlcXVhbCk7Cgl9CgoJLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbAoJLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpOwoJYXNzZXJ0JDMubm90RXF1YWwgPSBub3RFcXVhbDsKCWZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHsKCSAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkgewoJICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9Jywgbm90RXF1YWwpOwoJICB9Cgl9CgoJLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uCgkvLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTsKCWFzc2VydCQzLmRlZXBFcXVhbCA9IGRlZXBFcXVhbDsKCWZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7CgkgIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHsKCSAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBkZWVwRXF1YWwpOwoJICB9Cgl9Cglhc3NlcnQkMy5kZWVwU3RyaWN0RXF1YWwgPSBkZWVwU3RyaWN0RXF1YWw7CglmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgewoJICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHsKCSAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBkZWVwU3RyaWN0RXF1YWwpOwoJICB9Cgl9CgoJZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7CgkgIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LgoJICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkgewoJICAgIHJldHVybiB0cnVlOwoJICB9IGVsc2UgaWYgKGlzQnVmZmVyJDEoYWN0dWFsKSAmJiBpc0J1ZmZlciQxKGV4cGVjdGVkKSkgewoJICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwOwoKCSAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpcwoJICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLgoJICB9IGVsc2UgaWYgKGlzRGF0ZShhY3R1YWwpICYmIGlzRGF0ZShleHBlY3RlZCkpIHsKCSAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpOwoKCSAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXMKCSAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmQKCSAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS4KCSAgfSBlbHNlIGlmIChpc1JlZ0V4cChhY3R1YWwpICYmIGlzUmVnRXhwKGV4cGVjdGVkKSkgewoJICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiYKCSAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmCgkgICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJgoJICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiYKCSAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7CgoJICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsCgkgIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uCgkgIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiYKCSAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHsKCSAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDsKCgkgIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmcKCSAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UKCSAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieQoJICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnkKCSAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXIKCSAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLgoJICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiYKCSAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJgoJICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8CgkgICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7CgkgICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksCgkgICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7CgoJICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpcwoJICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWQKCSAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5cwoJICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5CgkgIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzCgkgIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLgoJICB9IGVsc2UgaWYgKGlzQnVmZmVyJDEoYWN0dWFsKSAhPT0gaXNCdWZmZXIkMShleHBlY3RlZCkpIHsKCSAgICByZXR1cm4gZmFsc2U7CgkgIH0gZWxzZSB7CgkgICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTsKCgkgICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTsKCSAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7CgkgICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7CgkgICAgICAgIHJldHVybiB0cnVlOwoJICAgICAgfQoJICAgIH0KCgkgICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTsKCSAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTsKCgkgICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpOwoJICB9Cgl9CgoJZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7CgkgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJzsKCX0KCglmdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7CgkgIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkKCSAgICByZXR1cm4gZmFsc2U7CgkgIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZQoJICBpZiAoaXNQcmltaXRpdmUoYSkgfHwgaXNQcmltaXRpdmUoYikpCgkgICAgcmV0dXJuIGEgPT09IGI7CgkgIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpCgkgICAgcmV0dXJuIGZhbHNlOwoJICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpOwoJICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpOwoJICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSkKCSAgICByZXR1cm4gZmFsc2U7CgkgIGlmIChhSXNBcmdzKSB7CgkgICAgYSA9IHBTbGljZS5jYWxsKGEpOwoJICAgIGIgPSBwU2xpY2UuY2FsbChiKTsKCSAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpOwoJICB9CgkgIHZhciBrYSA9IG9iamVjdEtleXMkMShhKTsKCSAgdmFyIGtiID0gb2JqZWN0S2V5cyQxKGIpOwoJICB2YXIga2V5LCBpOwoJICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzCgkgIC8vIGhhc093blByb3BlcnR5KQoJICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpCgkgICAgcmV0dXJuIGZhbHNlOwoJICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLAoJICBrYS5zb3J0KCk7CgkgIGtiLnNvcnQoKTsKCSAgLy9+fn5jaGVhcCBrZXkgdGVzdAoJICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewoJICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pCgkgICAgICByZXR1cm4gZmFsc2U7CgkgIH0KCSAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZAoJICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3QKCSAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKCSAgICBrZXkgPSBrYVtpXTsKCSAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKQoJICAgICAgcmV0dXJuIGZhbHNlOwoJICB9CgkgIHJldHVybiB0cnVlOwoJfQoKCS8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LgoJLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7Cglhc3NlcnQkMy5ub3REZWVwRXF1YWwgPSBub3REZWVwRXF1YWw7CglmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgewoJICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHsKCSAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBub3REZWVwRXF1YWwpOwoJICB9Cgl9CgoJYXNzZXJ0JDMubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsOwoJZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHsKCSAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHsKCSAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpOwoJICB9Cgl9CgoKCS8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uCgkvLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpOwoJYXNzZXJ0JDMuc3RyaWN0RXF1YWwgPSBzdHJpY3RFcXVhbDsKCWZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHsKCSAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHsKCSAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBzdHJpY3RFcXVhbCk7CgkgIH0KCX0KCgkvLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXMKCS8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTsKCWFzc2VydCQzLm5vdFN0cmljdEVxdWFsID0gbm90U3RyaWN0RXF1YWw7CglmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7CgkgIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7CgkgICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09Jywgbm90U3RyaWN0RXF1YWwpOwoJICB9Cgl9CgoJZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkgewoJICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHsKCSAgICByZXR1cm4gZmFsc2U7CgkgIH0KCgkgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7CgkgICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsKCSAgfQoKCSAgdHJ5IHsKCSAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHsKCSAgICAgIHJldHVybiB0cnVlOwoJICAgIH0KCSAgfSBjYXRjaCAoZSkgewoJICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLgoJICB9CgoJICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHsKCSAgICByZXR1cm4gZmFsc2U7CgkgIH0KCgkgIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlOwoJfQoKCWZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykgewoJICB2YXIgZXJyb3I7CgkgIHRyeSB7CgkgICAgYmxvY2soKTsKCSAgfSBjYXRjaCAoZSkgewoJICAgIGVycm9yID0gZTsKCSAgfQoJICByZXR1cm4gZXJyb3I7Cgl9CgoJZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7CgkgIHZhciBhY3R1YWw7CgoJICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImJsb2NrIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTsKCSAgfQoKCSAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHsKCSAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7CgkgICAgZXhwZWN0ZWQgPSBudWxsOwoJICB9CgoJICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spOwoKCSAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArCgkgICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpOwoKCSAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHsKCSAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTsKCSAgfQoKCSAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7CgkgIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGlzRXJyb3IoYWN0dWFsKTsKCSAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkOwoKCSAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmCgkgICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmCgkgICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwKCSAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikgewoJICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7CgkgIH0KCgkgIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmCgkgICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkgewoJICAgIHRocm93IGFjdHVhbDsKCSAgfQoJfQoKCS8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjoKCS8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpOwoJYXNzZXJ0JDMudGhyb3dzID0gdGhyb3dzOwoJZnVuY3Rpb24gdGhyb3dzKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkgewoJICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7Cgl9CgoJLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuCglhc3NlcnQkMy5kb2VzTm90VGhyb3cgPSBkb2VzTm90VGhyb3c7CglmdW5jdGlvbiBkb2VzTm90VGhyb3coYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7CgkgIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7Cgl9CgoJYXNzZXJ0JDMuaWZFcnJvciA9IGlmRXJyb3I7CglmdW5jdGlvbiBpZkVycm9yKGVycikgewoJICBpZiAoZXJyKSB0aHJvdyBlcnI7Cgl9CgoJdmFyIHNoYTMgPSB7ZXhwb3J0czoge319OwoKCShmdW5jdGlvbiAobW9kdWxlKSB7CgkvKmpzbGludCBiaXR3aXNlOiB0cnVlICovCgkoZnVuY3Rpb24gKCkgewoKCSAgdmFyIElOUFVUX0VSUk9SID0gJ2lucHV0IGlzIGludmFsaWQgdHlwZSc7CgkgIHZhciBGSU5BTElaRV9FUlJPUiA9ICdmaW5hbGl6ZSBhbHJlYWR5IGNhbGxlZCc7CgkgIHZhciBXSU5ET1cgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JzsKCSAgdmFyIHJvb3QgPSBXSU5ET1cgPyB3aW5kb3cgOiB7fTsKCSAgaWYgKHJvb3QuSlNfU0hBM19OT19XSU5ET1cpIHsKCSAgICBXSU5ET1cgPSBmYWxzZTsKCSAgfQoJICB2YXIgV0VCX1dPUktFUiA9ICFXSU5ET1cgJiYgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnOwoJICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTNfTk9fTk9ERV9KUyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7CgkgIGlmIChOT0RFX0pTKSB7CgkgICAgcm9vdCA9IGNvbW1vbmpzR2xvYmFsOwoJICB9IGVsc2UgaWYgKFdFQl9XT1JLRVIpIHsKCSAgICByb290ID0gc2VsZjsKCSAgfQoJICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBM19OT19DT01NT05fSlMgJiYgJ29iamVjdCcgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzOwoJICB2YXIgQVJSQVlfQlVGRkVSID0gIXJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJzsKCSAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7CgkgIHZhciBTSEFLRV9QQURESU5HID0gWzMxLCA3OTM2LCAyMDMxNjE2LCA1MjAwOTM2OTZdOwoJICB2YXIgQ1NIQUtFX1BBRERJTkcgPSBbNCwgMTAyNCwgMjYyMTQ0LCA2NzEwODg2NF07CgkgIHZhciBLRUNDQUtfUEFERElORyA9IFsxLCAyNTYsIDY1NTM2LCAxNjc3NzIxNl07CgkgIHZhciBQQURESU5HID0gWzYsIDE1MzYsIDM5MzIxNiwgMTAwNjYzMjk2XTsKCSAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07CgkgIHZhciBSQyA9IFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LAoJICAgIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCwKCSAgICAyMTQ3NDgzNjU4LCAwLCAyMTQ3NTE2NTU1LCAwLCAxMzksIDIxNDc0ODM2NDgsIDMyOTA1LCAyMTQ3NDgzNjQ4LCAzMjc3MSwKCSAgICAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCwKCSAgICAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF07CgkgIHZhciBCSVRTID0gWzIyNCwgMjU2LCAzODQsIDUxMl07CgkgIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTsKCSAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2J1ZmZlcicsICdhcnJheUJ1ZmZlcicsICdhcnJheScsICdkaWdlc3QnXTsKCSAgdmFyIENTSEFLRV9CWVRFUEFEID0gewoJICAgICcxMjgnOiAxNjgsCgkgICAgJzI1Nic6IDEzNgoJICB9OwoKCSAgaWYgKHJvb3QuSlNfU0hBM19OT19OT0RFX0pTIHx8ICFBcnJheS5pc0FycmF5KSB7CgkgICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHsKCSAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJzsKCSAgICB9OwoJICB9CgoJICBpZiAoQVJSQVlfQlVGRkVSICYmIChyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSX0lTX1ZJRVcgfHwgIUFycmF5QnVmZmVyLmlzVmlldykpIHsKCSAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7CgkgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmJ1ZmZlciAmJiBvYmouYnVmZmVyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjsKCSAgICB9OwoJICB9CgoJICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHsKCSAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHsKCSAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpOwoJICAgIH07CgkgIH07CgoJICB2YXIgY3JlYXRlU2hha2VPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkgewoJICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykgewoJICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7CgkgICAgfTsKCSAgfTsKCgkgIHZhciBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkgewoJICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykgewoJICAgICAgcmV0dXJuIG1ldGhvZHNbJ2NzaGFrZScgKyBiaXRzXS51cGRhdGUobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcylbb3V0cHV0VHlwZV0oKTsKCSAgICB9OwoJICB9OwoKCSAgdmFyIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkgewoJICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKSB7CgkgICAgICByZXR1cm4gbWV0aG9kc1sna21hYycgKyBiaXRzXS51cGRhdGUoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKVtvdXRwdXRUeXBlXSgpOwoJICAgIH07CgkgIH07CgoJICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kcyA9IGZ1bmN0aW9uIChtZXRob2QsIGNyZWF0ZU1ldGhvZCwgYml0cywgcGFkZGluZykgewoJICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7CgkgICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTsKCSAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU1ldGhvZChiaXRzLCBwYWRkaW5nLCB0eXBlKTsKCSAgICB9CgkgICAgcmV0dXJuIG1ldGhvZDsKCSAgfTsKCgkgIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykgewoJICAgIHZhciBtZXRob2QgPSBjcmVhdGVPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpOwoJICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7CgkgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKTsKCSAgICB9OwoJICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkgewoJICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7CgkgICAgfTsKCSAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7CgkgIH07CgoJICB2YXIgY3JlYXRlU2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykgewoJICAgIHZhciBtZXRob2QgPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7CgkgICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzKSB7CgkgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTsKCSAgICB9OwoJICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykgewoJICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpOwoJICAgIH07CgkgICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7CgkgIH07CgoJICB2YXIgY3JlYXRlQ3NoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHsKCSAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHNdOwoJICAgIHZhciBtZXRob2QgPSBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpOwoJICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAob3V0cHV0Qml0cywgbiwgcykgewoJICAgICAgaWYgKCFuICYmICFzKSB7CgkgICAgICAgIHJldHVybiBtZXRob2RzWydzaGFrZScgKyBiaXRzXS5jcmVhdGUob3V0cHV0Qml0cyk7CgkgICAgICB9IGVsc2UgewoJICAgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS5ieXRlcGFkKFtuLCBzXSwgdyk7CgkgICAgICB9CgkgICAgfTsKCSAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMsIG4sIHMpIHsKCSAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMsIG4sIHMpLnVwZGF0ZShtZXNzYWdlKTsKCSAgICB9OwoJICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlQ3NoYWtlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTsKCSAgfTsKCgkgIHZhciBjcmVhdGVLbWFjTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHsKCSAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHNdOwoJICAgIHZhciBtZXRob2QgPSBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTsKCSAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKGtleSwgb3V0cHV0Qml0cywgcykgewoJICAgICAgcmV0dXJuIG5ldyBLbWFjKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLmJ5dGVwYWQoWydLTUFDJywgc10sIHcpLmJ5dGVwYWQoW2tleV0sIHcpOwoJICAgIH07CgkgICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UsIG91dHB1dEJpdHMsIHMpIHsKCSAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKGtleSwgb3V0cHV0Qml0cywgcykudXBkYXRlKG1lc3NhZ2UpOwoJICAgIH07CgkgICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTsKCSAgfTsKCgkgIHZhciBhbGdvcml0aG1zID0gWwoJICAgIHsgbmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LAoJICAgIHsgbmFtZTogJ3NoYTMnLCBwYWRkaW5nOiBQQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LAoJICAgIHsgbmFtZTogJ3NoYWtlJywgcGFkZGluZzogU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVTaGFrZU1ldGhvZCB9LAoJICAgIHsgbmFtZTogJ2NzaGFrZScsIHBhZGRpbmc6IENTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZUNzaGFrZU1ldGhvZCB9LAoJICAgIHsgbmFtZTogJ2ttYWMnLCBwYWRkaW5nOiBDU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVLbWFjTWV0aG9kIH0KCSAgXTsKCgkgIHZhciBtZXRob2RzID0ge30sIG1ldGhvZE5hbWVzID0gW107CgoJICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZ29yaXRobXMubGVuZ3RoOyArK2kpIHsKCSAgICB2YXIgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tpXTsKCSAgICB2YXIgYml0cyA9IGFsZ29yaXRobS5iaXRzOwoJICAgIGZvciAodmFyIGogPSAwOyBqIDwgYml0cy5sZW5ndGg7ICsraikgewoJICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArICdfJyArIGJpdHNbal07CgkgICAgICBtZXRob2ROYW1lcy5wdXNoKG1ldGhvZE5hbWUpOwoJICAgICAgbWV0aG9kc1ttZXRob2ROYW1lXSA9IGFsZ29yaXRobS5jcmVhdGVNZXRob2QoYml0c1tqXSwgYWxnb3JpdGhtLnBhZGRpbmcpOwoJICAgICAgaWYgKGFsZ29yaXRobS5uYW1lICE9PSAnc2hhMycpIHsKCSAgICAgICAgdmFyIG5ld01ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArIGJpdHNbal07CgkgICAgICAgIG1ldGhvZE5hbWVzLnB1c2gobmV3TWV0aG9kTmFtZSk7CgkgICAgICAgIG1ldGhvZHNbbmV3TWV0aG9kTmFtZV0gPSBtZXRob2RzW21ldGhvZE5hbWVdOwoJICAgICAgfQoJICAgIH0KCSAgfQoKCSAgZnVuY3Rpb24gS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHsKCSAgICB0aGlzLmJsb2NrcyA9IFtdOwoJICAgIHRoaXMucyA9IFtdOwoJICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7CgkgICAgdGhpcy5vdXRwdXRCaXRzID0gb3V0cHV0Qml0czsKCSAgICB0aGlzLnJlc2V0ID0gdHJ1ZTsKCSAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlOwoJICAgIHRoaXMuYmxvY2sgPSAwOwoJICAgIHRoaXMuc3RhcnQgPSAwOwoJICAgIHRoaXMuYmxvY2tDb3VudCA9ICgxNjAwIC0gKGJpdHMgPDwgMSkpID4+IDU7CgkgICAgdGhpcy5ieXRlQ291bnQgPSB0aGlzLmJsb2NrQ291bnQgPDwgMjsKCSAgICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTsKCSAgICB0aGlzLmV4dHJhQnl0ZXMgPSAob3V0cHV0Qml0cyAmIDMxKSA+PiAzOwoKCSAgICBmb3IgKHZhciBpID0gMDsgaSA8IDUwOyArK2kpIHsKCSAgICAgIHRoaXMuc1tpXSA9IDA7CgkgICAgfQoJICB9CgoJICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7CgkgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7CgkgICAgICB0aHJvdyBuZXcgRXJyb3IoRklOQUxJWkVfRVJST1IpOwoJICAgIH0KCSAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7CgkgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7CgkgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHsKCSAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHsKCSAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpOwoJICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikgewoJICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTsKCSAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkgewoJICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHsKCSAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7CgkgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICB9IGVsc2UgewoJICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpOwoJICAgICAgfQoJICAgICAgbm90U3RyaW5nID0gdHJ1ZTsKCSAgICB9CgkgICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBieXRlQ291bnQgPSB0aGlzLmJ5dGVDb3VudCwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsCgkgICAgICBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBpbmRleCA9IDAsIHMgPSB0aGlzLnMsIGksIGNvZGU7CgoJICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgewoJICAgICAgaWYgKHRoaXMucmVzZXQpIHsKCSAgICAgICAgdGhpcy5yZXNldCA9IGZhbHNlOwoJICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrOwoJICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkgewoJICAgICAgICAgIGJsb2Nrc1tpXSA9IDA7CgkgICAgICAgIH0KCSAgICAgIH0KCSAgICAgIGlmIChub3RTdHJpbmcpIHsKCSAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkgewoJICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdOwoJICAgICAgICB9CgkgICAgICB9IGVsc2UgewoJICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7CgkgICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7CgkgICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7CgkgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdOwoJICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7CgkgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTsKCSAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107CgkgICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7CgkgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107CgkgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTsKCSAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107CgkgICAgICAgICAgfSBlbHNlIHsKCSAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTsKCSAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTsKCSAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTsKCSAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdOwoJICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTsKCSAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgIH0KCSAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7CgkgICAgICBpZiAoaSA+PSBieXRlQ291bnQpIHsKCSAgICAgICAgdGhpcy5zdGFydCA9IGkgLSBieXRlQ291bnQ7CgkgICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbYmxvY2tDb3VudF07CgkgICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHsKCSAgICAgICAgICBzW2ldIF49IGJsb2Nrc1tpXTsKCSAgICAgICAgfQoJICAgICAgICBmKHMpOwoJICAgICAgICB0aGlzLnJlc2V0ID0gdHJ1ZTsKCSAgICAgIH0gZWxzZSB7CgkgICAgICAgIHRoaXMuc3RhcnQgPSBpOwoJICAgICAgfQoJICAgIH0KCSAgICByZXR1cm4gdGhpczsKCSAgfTsKCgkgIEtlY2Nhay5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHgsIHJpZ2h0KSB7CgkgICAgdmFyIG8gPSB4ICYgMjU1LCBuID0gMTsKCSAgICB2YXIgYnl0ZXMgPSBbb107CgkgICAgeCA9IHggPj4gODsKCSAgICBvID0geCAmIDI1NTsKCSAgICB3aGlsZSAobyA+IDApIHsKCSAgICAgIGJ5dGVzLnVuc2hpZnQobyk7CgkgICAgICB4ID0geCA+PiA4OwoJICAgICAgbyA9IHggJiAyNTU7CgkgICAgICArK247CgkgICAgfQoJICAgIGlmIChyaWdodCkgewoJICAgICAgYnl0ZXMucHVzaChuKTsKCSAgICB9IGVsc2UgewoJICAgICAgYnl0ZXMudW5zaGlmdChuKTsKCSAgICB9CgkgICAgdGhpcy51cGRhdGUoYnl0ZXMpOwoJICAgIHJldHVybiBieXRlcy5sZW5ndGg7CgkgIH07CgoJICBLZWNjYWsucHJvdG90eXBlLmVuY29kZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHsKCSAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIHN0cjsKCSAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHsKCSAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0JykgewoJICAgICAgICBpZiAoc3RyID09PSBudWxsKSB7CgkgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTsKCSAgICAgICAgfSBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgc3RyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikgewoJICAgICAgICAgIHN0ciA9IG5ldyBVaW50OEFycmF5KHN0cik7CgkgICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc3RyKSkgewoJICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyKSkgewoJICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTsKCSAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgIH0gZWxzZSB7CgkgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7CgkgICAgICB9CgkgICAgICBub3RTdHJpbmcgPSB0cnVlOwoJICAgIH0KCSAgICB2YXIgYnl0ZXMgPSAwLCBsZW5ndGggPSBzdHIubGVuZ3RoOwoJICAgIGlmIChub3RTdHJpbmcpIHsKCSAgICAgIGJ5dGVzID0gbGVuZ3RoOwoJICAgIH0gZWxzZSB7CgkgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewoJICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpOwoJICAgICAgICBpZiAoY29kZSA8IDB4ODApIHsKCSAgICAgICAgICBieXRlcyArPSAxOwoJICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkgewoJICAgICAgICAgIGJ5dGVzICs9IDI7CgkgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkgewoJICAgICAgICAgIGJ5dGVzICs9IDM7CgkgICAgICAgIH0gZWxzZSB7CgkgICAgICAgICAgY29kZSA9IDB4MTAwMDAgKyAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzZmYpKTsKCSAgICAgICAgICBieXRlcyArPSA0OwoJICAgICAgICB9CgkgICAgICB9CgkgICAgfQoJICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlKGJ5dGVzICogOCk7CgkgICAgdGhpcy51cGRhdGUoc3RyKTsKCSAgICByZXR1cm4gYnl0ZXM7CgkgIH07CgoJICBLZWNjYWsucHJvdG90eXBlLmJ5dGVwYWQgPSBmdW5jdGlvbiAoc3RycywgdykgewoJICAgIHZhciBieXRlcyA9IHRoaXMuZW5jb2RlKHcpOwoJICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7ICsraSkgewoJICAgICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGVTdHJpbmcoc3Ryc1tpXSk7CgkgICAgfQoJICAgIHZhciBwYWRkaW5nQnl0ZXMgPSB3IC0gYnl0ZXMgJSB3OwoJICAgIHZhciB6ZXJvcyA9IFtdOwoJICAgIHplcm9zLmxlbmd0aCA9IHBhZGRpbmdCeXRlczsKCSAgICB0aGlzLnVwZGF0ZSh6ZXJvcyk7CgkgICAgcmV0dXJuIHRoaXM7CgkgIH07CgoJICBLZWNjYWsucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkgewoJICAgIGlmICh0aGlzLmZpbmFsaXplZCkgewoJICAgICAgcmV0dXJuOwoJICAgIH0KCSAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7CgkgICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4LCBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zOwoJICAgIGJsb2Nrc1tpID4+IDJdIHw9IHRoaXMucGFkZGluZ1tpICYgM107CgkgICAgaWYgKHRoaXMubGFzdEJ5dGVJbmRleCA9PT0gdGhpcy5ieXRlQ291bnQpIHsKCSAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1tibG9ja0NvdW50XTsKCSAgICAgIGZvciAoaSA9IDE7IGkgPCBibG9ja0NvdW50ICsgMTsgKytpKSB7CgkgICAgICAgIGJsb2Nrc1tpXSA9IDA7CgkgICAgICB9CgkgICAgfQoJICAgIGJsb2Nrc1tibG9ja0NvdW50IC0gMV0gfD0gMHg4MDAwMDAwMDsKCSAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7CgkgICAgICBzW2ldIF49IGJsb2Nrc1tpXTsKCSAgICB9CgkgICAgZihzKTsKCSAgfTsKCgkgIEtlY2Nhay5wcm90b3R5cGUudG9TdHJpbmcgPSBLZWNjYWsucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHsKCSAgICB0aGlzLmZpbmFsaXplKCk7CgoJICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcywKCSAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDsKCSAgICB2YXIgaGV4ID0gJycsIGJsb2NrOwoJICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7CgkgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikgewoJICAgICAgICBibG9jayA9IHNbaV07CgkgICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArCgkgICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXSArCgkgICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl0gKwoJICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdOwoJICAgICAgfQoJICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7CgkgICAgICAgIGYocyk7CgkgICAgICAgIGkgPSAwOwoJICAgICAgfQoJICAgIH0KCSAgICBpZiAoZXh0cmFCeXRlcykgewoJICAgICAgYmxvY2sgPSBzW2ldOwoJICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayAmIDB4MEZdOwoJICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7CgkgICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiA4KSAmIDB4MEZdOwoJICAgICAgfQoJICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7CgkgICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXTsKCSAgICAgIH0KCSAgICB9CgkgICAgcmV0dXJuIGhleDsKCSAgfTsKCgkgIEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7CgkgICAgdGhpcy5maW5hbGl6ZSgpOwoKCSAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsCgkgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7CgkgICAgdmFyIGJ5dGVzID0gdGhpcy5vdXRwdXRCaXRzID4+IDM7CgkgICAgdmFyIGJ1ZmZlcjsKCSAgICBpZiAoZXh0cmFCeXRlcykgewoJICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKChvdXRwdXRCbG9ja3MgKyAxKSA8PCAyKTsKCSAgICB9IGVsc2UgewoJICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTsKCSAgICB9CgkgICAgdmFyIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7CgkgICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHsKCSAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7CgkgICAgICAgIGFycmF5W2pdID0gc1tpXTsKCSAgICAgIH0KCSAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkgewoJICAgICAgICBmKHMpOwoJICAgICAgfQoJICAgIH0KCSAgICBpZiAoZXh0cmFCeXRlcykgewoJICAgICAgYXJyYXlbaV0gPSBzW2ldOwoJICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzKTsKCSAgICB9CgkgICAgcmV0dXJuIGJ1ZmZlcjsKCSAgfTsKCgkgIEtlY2Nhay5wcm90b3R5cGUuYnVmZmVyID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlcjsKCgkgIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHsKCSAgICB0aGlzLmZpbmFsaXplKCk7CgoJICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcywKCSAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDsKCSAgICB2YXIgYXJyYXkgPSBbXSwgb2Zmc2V0LCBibG9jazsKCSAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2NrcykgewoJICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHsKCSAgICAgICAgb2Zmc2V0ID0gaiA8PCAyOwoJICAgICAgICBibG9jayA9IHNbaV07CgkgICAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7CgkgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjsKCSAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjsKCSAgICAgICAgYXJyYXlbb2Zmc2V0ICsgM10gPSAoYmxvY2sgPj4gMjQpICYgMHhGRjsKCSAgICAgIH0KCSAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkgewoJICAgICAgICBmKHMpOwoJICAgICAgfQoJICAgIH0KCSAgICBpZiAoZXh0cmFCeXRlcykgewoJICAgICAgb2Zmc2V0ID0gaiA8PCAyOwoJICAgICAgYmxvY2sgPSBzW2ldOwoJICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjsKCSAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkgewoJICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7CgkgICAgICB9CgkgICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHsKCSAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjsKCSAgICAgIH0KCSAgICB9CgkgICAgcmV0dXJuIGFycmF5OwoJICB9OwoKCSAgZnVuY3Rpb24gS21hYyhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7CgkgICAgS2VjY2FrLmNhbGwodGhpcywgYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7CgkgIH0KCgkgIEttYWMucHJvdG90eXBlID0gbmV3IEtlY2NhaygpOwoKCSAgS21hYy5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7CgkgICAgdGhpcy5lbmNvZGUodGhpcy5vdXRwdXRCaXRzLCB0cnVlKTsKCSAgICByZXR1cm4gS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpOwoJICB9OwoKCSAgdmFyIGYgPSBmdW5jdGlvbiAocykgewoJICAgIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSwKCSAgICAgIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2LCBiNywgYjgsIGI5LCBiMTAsIGIxMSwgYjEyLCBiMTMsIGIxNCwgYjE1LCBiMTYsIGIxNywKCSAgICAgIGIxOCwgYjE5LCBiMjAsIGIyMSwgYjIyLCBiMjMsIGIyNCwgYjI1LCBiMjYsIGIyNywgYjI4LCBiMjksIGIzMCwgYjMxLCBiMzIsIGIzMywKCSAgICAgIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTsKCSAgICBmb3IgKG4gPSAwOyBuIDwgNDg7IG4gKz0gMikgewoJICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07CgkgICAgICBjMSA9IHNbMV0gXiBzWzExXSBeIHNbMjFdIF4gc1szMV0gXiBzWzQxXTsKCSAgICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdOwoJICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107CgkgICAgICBjNCA9IHNbNF0gXiBzWzE0XSBeIHNbMjRdIF4gc1szNF0gXiBzWzQ0XTsKCSAgICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdOwoJICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07CgkgICAgICBjNyA9IHNbN10gXiBzWzE3XSBeIHNbMjddIF4gc1szN10gXiBzWzQ3XTsKCSAgICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdOwoJICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07CgoJICAgICAgaCA9IGM4IF4gKChjMiA8PCAxKSB8IChjMyA+Pj4gMzEpKTsKCSAgICAgIGwgPSBjOSBeICgoYzMgPDwgMSkgfCAoYzIgPj4+IDMxKSk7CgkgICAgICBzWzBdIF49IGg7CgkgICAgICBzWzFdIF49IGw7CgkgICAgICBzWzEwXSBePSBoOwoJICAgICAgc1sxMV0gXj0gbDsKCSAgICAgIHNbMjBdIF49IGg7CgkgICAgICBzWzIxXSBePSBsOwoJICAgICAgc1szMF0gXj0gaDsKCSAgICAgIHNbMzFdIF49IGw7CgkgICAgICBzWzQwXSBePSBoOwoJICAgICAgc1s0MV0gXj0gbDsKCSAgICAgIGggPSBjMCBeICgoYzQgPDwgMSkgfCAoYzUgPj4+IDMxKSk7CgkgICAgICBsID0gYzEgXiAoKGM1IDw8IDEpIHwgKGM0ID4+PiAzMSkpOwoJICAgICAgc1syXSBePSBoOwoJICAgICAgc1szXSBePSBsOwoJICAgICAgc1sxMl0gXj0gaDsKCSAgICAgIHNbMTNdIF49IGw7CgkgICAgICBzWzIyXSBePSBoOwoJICAgICAgc1syM10gXj0gbDsKCSAgICAgIHNbMzJdIF49IGg7CgkgICAgICBzWzMzXSBePSBsOwoJICAgICAgc1s0Ml0gXj0gaDsKCSAgICAgIHNbNDNdIF49IGw7CgkgICAgICBoID0gYzIgXiAoKGM2IDw8IDEpIHwgKGM3ID4+PiAzMSkpOwoJICAgICAgbCA9IGMzIF4gKChjNyA8PCAxKSB8IChjNiA+Pj4gMzEpKTsKCSAgICAgIHNbNF0gXj0gaDsKCSAgICAgIHNbNV0gXj0gbDsKCSAgICAgIHNbMTRdIF49IGg7CgkgICAgICBzWzE1XSBePSBsOwoJICAgICAgc1syNF0gXj0gaDsKCSAgICAgIHNbMjVdIF49IGw7CgkgICAgICBzWzM0XSBePSBoOwoJICAgICAgc1szNV0gXj0gbDsKCSAgICAgIHNbNDRdIF49IGg7CgkgICAgICBzWzQ1XSBePSBsOwoJICAgICAgaCA9IGM0IF4gKChjOCA8PCAxKSB8IChjOSA+Pj4gMzEpKTsKCSAgICAgIGwgPSBjNSBeICgoYzkgPDwgMSkgfCAoYzggPj4+IDMxKSk7CgkgICAgICBzWzZdIF49IGg7CgkgICAgICBzWzddIF49IGw7CgkgICAgICBzWzE2XSBePSBoOwoJICAgICAgc1sxN10gXj0gbDsKCSAgICAgIHNbMjZdIF49IGg7CgkgICAgICBzWzI3XSBePSBsOwoJICAgICAgc1szNl0gXj0gaDsKCSAgICAgIHNbMzddIF49IGw7CgkgICAgICBzWzQ2XSBePSBoOwoJICAgICAgc1s0N10gXj0gbDsKCSAgICAgIGggPSBjNiBeICgoYzAgPDwgMSkgfCAoYzEgPj4+IDMxKSk7CgkgICAgICBsID0gYzcgXiAoKGMxIDw8IDEpIHwgKGMwID4+PiAzMSkpOwoJICAgICAgc1s4XSBePSBoOwoJICAgICAgc1s5XSBePSBsOwoJICAgICAgc1sxOF0gXj0gaDsKCSAgICAgIHNbMTldIF49IGw7CgkgICAgICBzWzI4XSBePSBoOwoJICAgICAgc1syOV0gXj0gbDsKCSAgICAgIHNbMzhdIF49IGg7CgkgICAgICBzWzM5XSBePSBsOwoJICAgICAgc1s0OF0gXj0gaDsKCSAgICAgIHNbNDldIF49IGw7CgoJICAgICAgYjAgPSBzWzBdOwoJICAgICAgYjEgPSBzWzFdOwoJICAgICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7CgkgICAgICBiMzMgPSAoc1sxMF0gPDwgNCkgfCAoc1sxMV0gPj4+IDI4KTsKCSAgICAgIGIxNCA9IChzWzIwXSA8PCAzKSB8IChzWzIxXSA+Pj4gMjkpOwoJICAgICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7CgkgICAgICBiNDYgPSAoc1szMV0gPDwgOSkgfCAoc1szMF0gPj4+IDIzKTsKCSAgICAgIGI0NyA9IChzWzMwXSA8PCA5KSB8IChzWzMxXSA+Pj4gMjMpOwoJICAgICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpOwoJICAgICAgYjI5ID0gKHNbNDFdIDw8IDE4KSB8IChzWzQwXSA+Pj4gMTQpOwoJICAgICAgYjIwID0gKHNbMl0gPDwgMSkgfCAoc1szXSA+Pj4gMzEpOwoJICAgICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpOwoJICAgICAgYjIgPSAoc1sxM10gPDwgMTIpIHwgKHNbMTJdID4+PiAyMCk7CgkgICAgICBiMyA9IChzWzEyXSA8PCAxMikgfCAoc1sxM10gPj4+IDIwKTsKCSAgICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTsKCSAgICAgIGIzNSA9IChzWzIzXSA8PCAxMCkgfCAoc1syMl0gPj4+IDIyKTsKCSAgICAgIGIxNiA9IChzWzMzXSA8PCAxMykgfCAoc1szMl0gPj4+IDE5KTsKCSAgICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTsKCSAgICAgIGI0OCA9IChzWzQyXSA8PCAyKSB8IChzWzQzXSA+Pj4gMzApOwoJICAgICAgYjQ5ID0gKHNbNDNdIDw8IDIpIHwgKHNbNDJdID4+PiAzMCk7CgkgICAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7CgkgICAgICBiNDEgPSAoc1s0XSA8PCAzMCkgfCAoc1s1XSA+Pj4gMik7CgkgICAgICBiMjIgPSAoc1sxNF0gPDwgNikgfCAoc1sxNV0gPj4+IDI2KTsKCSAgICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpOwoJICAgICAgYjQgPSAoc1syNV0gPDwgMTEpIHwgKHNbMjRdID4+PiAyMSk7CgkgICAgICBiNSA9IChzWzI0XSA8PCAxMSkgfCAoc1syNV0gPj4+IDIxKTsKCSAgICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTsKCSAgICAgIGIzNyA9IChzWzM1XSA8PCAxNSkgfCAoc1szNF0gPj4+IDE3KTsKCSAgICAgIGIxOCA9IChzWzQ1XSA8PCAyOSkgfCAoc1s0NF0gPj4+IDMpOwoJICAgICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7CgkgICAgICBiMTAgPSAoc1s2XSA8PCAyOCkgfCAoc1s3XSA+Pj4gNCk7CgkgICAgICBiMTEgPSAoc1s3XSA8PCAyOCkgfCAoc1s2XSA+Pj4gNCk7CgkgICAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTsKCSAgICAgIGI0MyA9IChzWzE2XSA8PCAyMykgfCAoc1sxN10gPj4+IDkpOwoJICAgICAgYjI0ID0gKHNbMjZdIDw8IDI1KSB8IChzWzI3XSA+Pj4gNyk7CgkgICAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTsKCSAgICAgIGI2ID0gKHNbMzZdIDw8IDIxKSB8IChzWzM3XSA+Pj4gMTEpOwoJICAgICAgYjcgPSAoc1szN10gPDwgMjEpIHwgKHNbMzZdID4+PiAxMSk7CgkgICAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTsKCSAgICAgIGIzOSA9IChzWzQ2XSA8PCAyNCkgfCAoc1s0N10gPj4+IDgpOwoJICAgICAgYjMwID0gKHNbOF0gPDwgMjcpIHwgKHNbOV0gPj4+IDUpOwoJICAgICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpOwoJICAgICAgYjEyID0gKHNbMThdIDw8IDIwKSB8IChzWzE5XSA+Pj4gMTIpOwoJICAgICAgYjEzID0gKHNbMTldIDw8IDIwKSB8IChzWzE4XSA+Pj4gMTIpOwoJICAgICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7CgkgICAgICBiNDUgPSAoc1syOF0gPDwgNykgfCAoc1syOV0gPj4+IDI1KTsKCSAgICAgIGIyNiA9IChzWzM4XSA8PCA4KSB8IChzWzM5XSA+Pj4gMjQpOwoJICAgICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7CgkgICAgICBiOCA9IChzWzQ4XSA8PCAxNCkgfCAoc1s0OV0gPj4+IDE4KTsKCSAgICAgIGI5ID0gKHNbNDldIDw8IDE0KSB8IChzWzQ4XSA+Pj4gMTgpOwoKCSAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7CgkgICAgICBzWzFdID0gYjEgXiAofmIzICYgYjUpOwoJICAgICAgc1sxMF0gPSBiMTAgXiAofmIxMiAmIGIxNCk7CgkgICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTsKCSAgICAgIHNbMjBdID0gYjIwIF4gKH5iMjIgJiBiMjQpOwoJICAgICAgc1syMV0gPSBiMjEgXiAofmIyMyAmIGIyNSk7CgkgICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTsKCSAgICAgIHNbMzFdID0gYjMxIF4gKH5iMzMgJiBiMzUpOwoJICAgICAgc1s0MF0gPSBiNDAgXiAofmI0MiAmIGI0NCk7CgkgICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTsKCSAgICAgIHNbMl0gPSBiMiBeICh+YjQgJiBiNik7CgkgICAgICBzWzNdID0gYjMgXiAofmI1ICYgYjcpOwoJICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7CgkgICAgICBzWzEzXSA9IGIxMyBeICh+YjE1ICYgYjE3KTsKCSAgICAgIHNbMjJdID0gYjIyIF4gKH5iMjQgJiBiMjYpOwoJICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7CgkgICAgICBzWzMyXSA9IGIzMiBeICh+YjM0ICYgYjM2KTsKCSAgICAgIHNbMzNdID0gYjMzIF4gKH5iMzUgJiBiMzcpOwoJICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7CgkgICAgICBzWzQzXSA9IGI0MyBeICh+YjQ1ICYgYjQ3KTsKCSAgICAgIHNbNF0gPSBiNCBeICh+YjYgJiBiOCk7CgkgICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpOwoJICAgICAgc1sxNF0gPSBiMTQgXiAofmIxNiAmIGIxOCk7CgkgICAgICBzWzE1XSA9IGIxNSBeICh+YjE3ICYgYjE5KTsKCSAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpOwoJICAgICAgc1syNV0gPSBiMjUgXiAofmIyNyAmIGIyOSk7CgkgICAgICBzWzM0XSA9IGIzNCBeICh+YjM2ICYgYjM4KTsKCSAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpOwoJICAgICAgc1s0NF0gPSBiNDQgXiAofmI0NiAmIGI0OCk7CgkgICAgICBzWzQ1XSA9IGI0NSBeICh+YjQ3ICYgYjQ5KTsKCSAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7CgkgICAgICBzWzddID0gYjcgXiAofmI5ICYgYjEpOwoJICAgICAgc1sxNl0gPSBiMTYgXiAofmIxOCAmIGIxMCk7CgkgICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTsKCSAgICAgIHNbMjZdID0gYjI2IF4gKH5iMjggJiBiMjApOwoJICAgICAgc1syN10gPSBiMjcgXiAofmIyOSAmIGIyMSk7CgkgICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTsKCSAgICAgIHNbMzddID0gYjM3IF4gKH5iMzkgJiBiMzEpOwoJICAgICAgc1s0Nl0gPSBiNDYgXiAofmI0OCAmIGI0MCk7CgkgICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTsKCSAgICAgIHNbOF0gPSBiOCBeICh+YjAgJiBiMik7CgkgICAgICBzWzldID0gYjkgXiAofmIxICYgYjMpOwoJICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7CgkgICAgICBzWzE5XSA9IGIxOSBeICh+YjExICYgYjEzKTsKCSAgICAgIHNbMjhdID0gYjI4IF4gKH5iMjAgJiBiMjIpOwoJICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7CgkgICAgICBzWzM4XSA9IGIzOCBeICh+YjMwICYgYjMyKTsKCSAgICAgIHNbMzldID0gYjM5IF4gKH5iMzEgJiBiMzMpOwoJICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7CgkgICAgICBzWzQ5XSA9IGI0OSBeICh+YjQxICYgYjQzKTsKCgkgICAgICBzWzBdIF49IFJDW25dOwoJICAgICAgc1sxXSBePSBSQ1tuICsgMV07CgkgICAgfQoJICB9OwoKCSAgaWYgKENPTU1PTl9KUykgewoJICAgIG1vZHVsZS5leHBvcnRzID0gbWV0aG9kczsKCSAgfSBlbHNlIHsKCSAgICBmb3IgKGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHsKCSAgICAgIHJvb3RbbWV0aG9kTmFtZXNbaV1dID0gbWV0aG9kc1ttZXRob2ROYW1lc1tpXV07CgkgICAgfQoJICB9Cgl9KSgpOwoJfShzaGEzKSk7CgoJdmFyIGFzc2VydCQyID0gYXNzZXJ0JDM7Cgl2YXIga2VjY2FrMjU2ID0gc2hhMy5leHBvcnRzLmtlY2NhazI1NjsKCglmdW5jdGlvbiBsaWJyYXJ5SGFzaFBsYWNlaG9sZGVyIChpbnB1dCkgewoJICByZXR1cm4gJyQnICsga2VjY2FrMjU2KGlucHV0KS5zbGljZSgwLCAzNCkgKyAnJCc7Cgl9CgoJdmFyIGxpbmtCeXRlY29kZSA9IGZ1bmN0aW9uIChieXRlY29kZSwgbGlicmFyaWVzKSB7CgkgIGFzc2VydCQyKHR5cGVvZiBieXRlY29kZSA9PT0gJ3N0cmluZycpOwoJICBhc3NlcnQkMih0eXBlb2YgbGlicmFyaWVzID09PSAnb2JqZWN0Jyk7CgkgIC8vIE5PVEU6IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBzdXBwb3J0IG9sZCBjb21waWxlciB3aGljaCBkaWRuJ3QgdXNlIGZpbGUgbmFtZXMKCSAgdmFyIGxpYnJhcmllc0NvbXBsZXRlID0ge307CgkgIGZvciAodmFyIGxpYnJhcnlOYW1lIGluIGxpYnJhcmllcykgewoJICAgIGlmICh0eXBlb2YgbGlicmFyaWVzW2xpYnJhcnlOYW1lXSA9PT0gJ29iamVjdCcpIHsKCSAgICAgIC8vIEFQSSBjb21wYXRpYmxlIHdpdGggdGhlIHN0YW5kYXJkIEpTT04gaS9vCgkgICAgICBmb3IgKHZhciBsaWIgaW4gbGlicmFyaWVzW2xpYnJhcnlOYW1lXSkgewoJICAgICAgICBsaWJyYXJpZXNDb21wbGV0ZVtsaWJdID0gbGlicmFyaWVzW2xpYnJhcnlOYW1lXVtsaWJdOwoJICAgICAgICBsaWJyYXJpZXNDb21wbGV0ZVtsaWJyYXJ5TmFtZSArICc6JyArIGxpYl0gPSBsaWJyYXJpZXNbbGlicmFyeU5hbWVdW2xpYl07CgkgICAgICB9CgkgICAgfSBlbHNlIHsKCSAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIEFQSSBmb3IgZWFybHkgc29sYy1qcyB2ZXJzaW9ucwoJICAgICAgdmFyIHBhcnNlZCA9IGxpYnJhcnlOYW1lLm1hdGNoKC9eKFteOl0rKTooLispJC8pOwoJICAgICAgaWYgKHBhcnNlZCkgewoJICAgICAgICBsaWJyYXJpZXNDb21wbGV0ZVtwYXJzZWRbMl1dID0gbGlicmFyaWVzW2xpYnJhcnlOYW1lXTsKCSAgICAgIH0KCSAgICAgIGxpYnJhcmllc0NvbXBsZXRlW2xpYnJhcnlOYW1lXSA9IGxpYnJhcmllc1tsaWJyYXJ5TmFtZV07CgkgICAgfQoJICB9CgoJICBmb3IgKGxpYnJhcnlOYW1lIGluIGxpYnJhcmllc0NvbXBsZXRlKSB7CgkgICAgdmFyIGhleEFkZHJlc3MgPSBsaWJyYXJpZXNDb21wbGV0ZVtsaWJyYXJ5TmFtZV07CgkgICAgaWYgKGhleEFkZHJlc3Muc2xpY2UoMCwgMikgIT09ICcweCcgfHwgaGV4QWRkcmVzcy5sZW5ndGggPiA0MikgewoJICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3Mgc3BlY2lmaWVkIGZvciAnICsgbGlicmFyeU5hbWUpOwoJICAgIH0KCSAgICAvLyByZW1vdmUgMHggcHJlZml4CgkgICAgaGV4QWRkcmVzcyA9IGhleEFkZHJlc3Muc2xpY2UoMik7CgkgICAgaGV4QWRkcmVzcyA9IEFycmF5KDQwIC0gaGV4QWRkcmVzcy5sZW5ndGggKyAxKS5qb2luKCcwJykgKyBoZXhBZGRyZXNzOwoKCSAgICAvLyBTdXBwb3J0IG9sZCAobGlicmFyeSBuYW1lKSBhbmQgbmV3IChoYXNoIG9mIGxpYnJhcnkgbmFtZSkKCSAgICAvLyBwbGFjZWhvbGRlcnMuCgkgICAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiAobmFtZSkgewoJICAgICAgLy8gdHJ1bmNhdGUgdG8gMzcgY2hhcmFjdGVycwoJICAgICAgdmFyIHRydW5jYXRlZE5hbWUgPSBuYW1lLnNsaWNlKDAsIDM2KTsKCSAgICAgIHZhciBsaWJMYWJlbCA9ICdfXycgKyB0cnVuY2F0ZWROYW1lICsgQXJyYXkoMzcgLSB0cnVuY2F0ZWROYW1lLmxlbmd0aCkuam9pbignXycpICsgJ19fJzsKCSAgICAgIHdoaWxlIChieXRlY29kZS5pbmRleE9mKGxpYkxhYmVsKSA+PSAwKSB7CgkgICAgICAgIGJ5dGVjb2RlID0gYnl0ZWNvZGUucmVwbGFjZShsaWJMYWJlbCwgaGV4QWRkcmVzcyk7CgkgICAgICB9CgkgICAgfTsKCgkgICAgcmVwbGFjZShsaWJyYXJ5TmFtZSk7CgkgICAgcmVwbGFjZShsaWJyYXJ5SGFzaFBsYWNlaG9sZGVyKGxpYnJhcnlOYW1lKSk7CgkgIH0KCgkgIHJldHVybiBieXRlY29kZTsKCX07CgoJdmFyIGZpbmRMaW5rUmVmZXJlbmNlcyA9IGZ1bmN0aW9uIChieXRlY29kZSkgewoJICBhc3NlcnQkMih0eXBlb2YgYnl0ZWNvZGUgPT09ICdzdHJpbmcnKTsKCSAgLy8gZmluZCA0MCBieXRlcyBpbiB0aGUgcGF0dGVybiBvZiBfXy4uLjwzNiBkaWdpdHM+Li4uX18KCSAgLy8gZS5nLiBfX0xpYi5zb2w6TF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fCgkgIHZhciBsaW5rUmVmZXJlbmNlcyA9IHt9OwoJICB2YXIgb2Zmc2V0ID0gMDsKCSAgd2hpbGUgKHRydWUpIHsKCSAgICB2YXIgZm91bmQgPSBieXRlY29kZS5tYXRjaCgvX18oLnszNn0pX18vKTsKCSAgICBpZiAoIWZvdW5kKSB7CgkgICAgICBicmVhazsKCSAgICB9CgoJICAgIHZhciBzdGFydCA9IGZvdW5kLmluZGV4OwoJICAgIC8vIHRyaW0gdHJhaWxpbmcgdW5kZXJzY29yZXMKCSAgICAvLyBOT1RFOiB0aGlzIGhhcyBubyB3YXkgb2Yga25vd2luZyBpZiB0aGUgdHJhaWxpbmcgdW5kZXJzY29yZSB3YXMgcGFydCBvZiB0aGUgbmFtZQoJICAgIHZhciBsaWJyYXJ5TmFtZSA9IGZvdW5kWzFdLnJlcGxhY2UoL18rJC9nbSwgJycpOwoKCSAgICBpZiAoIWxpbmtSZWZlcmVuY2VzW2xpYnJhcnlOYW1lXSkgewoJICAgICAgbGlua1JlZmVyZW5jZXNbbGlicmFyeU5hbWVdID0gW107CgkgICAgfQoKCSAgICBsaW5rUmVmZXJlbmNlc1tsaWJyYXJ5TmFtZV0ucHVzaCh7CgkgICAgICAvLyBvZmZzZXRzIGFyZSBpbiBieXRlcyBpbiBiaW5hcnkgcmVwcmVzZW50YXRpb24gKGFuZCBub3QgaGV4KQoJICAgICAgc3RhcnQ6IChvZmZzZXQgKyBzdGFydCkgLyAyLAoJICAgICAgbGVuZ3RoOiAyMAoJICAgIH0pOwoKCSAgICBvZmZzZXQgKz0gc3RhcnQgKyAyMDsKCgkgICAgYnl0ZWNvZGUgPSBieXRlY29kZS5zbGljZShzdGFydCArIDIwKTsKCSAgfQoJICByZXR1cm4gbGlua1JlZmVyZW5jZXM7Cgl9OwoKCXZhciBsaW5rZXIkMSA9IHsKCSAgbGlua0J5dGVjb2RlOiBsaW5rQnl0ZWNvZGUsCgkgIGZpbmRMaW5rUmVmZXJlbmNlczogZmluZExpbmtSZWZlcmVuY2VzCgl9OwoKCXZhciBsaW5rZXIgPSBsaW5rZXIkMTsKCgkvLy8gVHJhbnNsYXRlIG9sZCBzdHlsZSB2ZXJzaW9uIG51bWJlcnMgdG8gc2VtdmVyLgoJLy8vIE9sZCBzdHlsZTogMC4zLjYtM2ZjNjhkYTUvUmVsZWFzZS1FbXNjcmlwdGVuL2NsYW5nCgkvLy8gICAgICAgICAgICAwLjMuNS0zNzE2OTBmMC9SZWxlYXNlLUVtc2NyaXB0ZW4vY2xhbmcvSW50ZXJwcmV0ZXIKCS8vLyAgICAgICAgICAgIDAuMy41LTAvUmVsZWFzZS1FbXNjcmlwdGVuL2NsYW5nL0ludGVycHJldGVyCgkvLy8gICAgICAgICAgICAwLjIuMC1lNzA5ODk1OC8uLUVtc2NyaXB0ZW4vY2xhbmcvaW50IGxpbmtlZCB0byBsaWJldGhlcmV1bS0xLjEuMS1iYmI4MGFiMC8uLUVtc2NyaXB0ZW4vY2xhbmcvaW50CgkvLy8gICAgICAgICAgICAwLjEuMy0wLy4tL2NsYW5nL2ludCBsaW5rZWQgdG8gbGliZXRoZXJldW0tMC45LjkyLTAvLi0vY2xhbmcvaW50CgkvLy8gICAgICAgICAgICAwLjEuMi01YzNiZmQ0YiovLi0vY2xhbmcvaW50CgkvLy8gICAgICAgICAgICAwLjEuMS02ZmY0Y2Q2Yi9SZWxXaXRoRGViSW5mby1FbXNjcmlwdGVuL2NsYW5nL2ludAoJLy8vIE5ldyBzdHlsZTogMC40LjUrY29tbWl0LmIzMTgzNjZlLkVtc2NyaXB0ZW4uY2xhbmcKCWZ1bmN0aW9uIHZlcnNpb25Ub1NlbXZlciAodmVyc2lvbikgewoJICAvLyBGSVhNRTogcGFyc2UgbW9yZSBkZXRhaWwsIGJ1dCB0aGlzIGlzIGEgZ29vZCBzdGFydAoJICB2YXIgcGFyc2VkID0gdmVyc2lvbi5tYXRjaCgvXihbMC05XStcLlswLTldK1wuWzAtOV0rKS0oWzAtOWEtZl17OH0pWy8qXS4qJC8pOwoJICBpZiAocGFyc2VkKSB7CgkgICAgcmV0dXJuIHBhcnNlZFsxXSArICcrY29tbWl0LicgKyBwYXJzZWRbMl07CgkgIH0KCSAgaWYgKHZlcnNpb24uaW5kZXhPZignMC4xLjMtMCcpICE9PSAtMSkgewoJICAgIHJldHVybiAnMC4xLjMnOwoJICB9CgkgIGlmICh2ZXJzaW9uLmluZGV4T2YoJzAuMy41LTAnKSAhPT0gLTEpIHsKCSAgICByZXR1cm4gJzAuMy41JzsKCSAgfQoJICAvLyBhc3N1bWUgaXQgaXMgYWxyZWFkeSBzZW12ZXIgY29tcGF0aWJsZQoJICByZXR1cm4gdmVyc2lvbjsKCX0KCglmdW5jdGlvbiB0cmFuc2xhdGVFcnJvcnMgKHJldCwgZXJyb3JzKSB7CgkgIGZvciAodmFyIGVycm9yIGluIGVycm9ycykgewoJICAgIHZhciB0eXBlID0gJ2Vycm9yJzsKCSAgICB2YXIgZXh0cmFjdFR5cGUgPSAvXiguKik6KFxkKyk6KFxkKyk6KC4qKTovOwoJICAgIGV4dHJhY3RUeXBlID0gZXh0cmFjdFR5cGUuZXhlYyhlcnJvcnNbZXJyb3JdKTsKCSAgICBpZiAoZXh0cmFjdFR5cGUpIHsKCSAgICAgIHR5cGUgPSBleHRyYWN0VHlwZVs0XS50cmltKCk7CgkgICAgfSBlbHNlIGlmIChlcnJvcnNbZXJyb3JdLmluZGV4T2YoJzogV2FybmluZzonKSkgewoJICAgICAgdHlwZSA9ICdXYXJuaW5nJzsKCSAgICB9IGVsc2UgaWYgKGVycm9yc1tlcnJvcl0uaW5kZXhPZignOiBFcnJvcjonKSkgewoJICAgICAgdHlwZSA9ICdFcnJvcic7CgkgICAgfQoJICAgIHJldC5wdXNoKHsKCSAgICAgIHR5cGU6IHR5cGUsCgkgICAgICBjb21wb25lbnQ6ICdnZW5lcmFsJywKCSAgICAgIHNldmVyaXR5OiAodHlwZSA9PT0gJ1dhcm5pbmcnKSA/ICd3YXJuaW5nJyA6ICdlcnJvcicsCgkgICAgICBtZXNzYWdlOiBlcnJvcnNbZXJyb3JdLAoJICAgICAgZm9ybWF0dGVkTWVzc2FnZTogZXJyb3JzW2Vycm9yXQoJICAgIH0pOwoJICB9Cgl9CgoJZnVuY3Rpb24gdHJhbnNsYXRlR2FzRXN0aW1hdGVzIChnYXNFc3RpbWF0ZXMpIHsKCSAgaWYgKGdhc0VzdGltYXRlcyA9PT0gbnVsbCkgewoJICAgIHJldHVybiAnaW5maW5pdGUnOwoJICB9CgoJICBpZiAodHlwZW9mIGdhc0VzdGltYXRlcyA9PT0gJ251bWJlcicpIHsKCSAgICByZXR1cm4gZ2FzRXN0aW1hdGVzLnRvU3RyaW5nKCk7CgkgIH0KCgkgIHZhciBnYXNFc3RpbWF0ZXNUcmFuc2xhdGVkID0ge307CgkgIGZvciAodmFyIGZ1bmMgaW4gZ2FzRXN0aW1hdGVzKSB7CgkgICAgZ2FzRXN0aW1hdGVzVHJhbnNsYXRlZFtmdW5jXSA9IHRyYW5zbGF0ZUdhc0VzdGltYXRlcyhnYXNFc3RpbWF0ZXNbZnVuY10pOwoJICB9CgkgIHJldHVybiBnYXNFc3RpbWF0ZXNUcmFuc2xhdGVkOwoJfQoKCWZ1bmN0aW9uIHRyYW5zbGF0ZUpzb25Db21waWxlck91dHB1dCAob3V0cHV0LCBsaWJyYXJpZXMpIHsKCSAgdmFyIHJldCA9IHt9OwoKCSAgcmV0WydlcnJvcnMnXSA9IFtdOwoJICB2YXIgZXJyb3JzOwoJICBpZiAob3V0cHV0WydlcnJvciddKSB7CgkgICAgZXJyb3JzID0gWyBvdXRwdXRbJ2Vycm9yJ10gXTsKCSAgfSBlbHNlIHsKCSAgICBlcnJvcnMgPSBvdXRwdXRbJ2Vycm9ycyddOwoJICB9CgkgIHRyYW5zbGF0ZUVycm9ycyhyZXRbJ2Vycm9ycyddLCBlcnJvcnMpOwoKCSAgcmV0Wydjb250cmFjdHMnXSA9IHt9OwoJICBmb3IgKHZhciBjb250cmFjdCBpbiBvdXRwdXRbJ2NvbnRyYWN0cyddKSB7CgkgICAgLy8gU3BsaXQgbmFtZSBmaXJzdCwgY2FuIGJlIGBjb250cmFjdGAsIGA6Y29udHJhY3RgIG9yIGBmaWxlbmFtZTpjb250cmFjdGAKCSAgICB2YXIgdG1wID0gY29udHJhY3QubWF0Y2goL14oKFteOl0qKTopPyhbXjpdKykkLyk7CgkgICAgaWYgKHRtcC5sZW5ndGggIT09IDQpIHsKCSAgICAgIC8vIEZvcmNlIGFib3J0CgkgICAgICByZXR1cm4gbnVsbDsKCSAgICB9CgkgICAgdmFyIGZpbGVOYW1lID0gdG1wWzJdOwoJICAgIGlmIChmaWxlTmFtZSA9PT0gdW5kZWZpbmVkKSB7CgkgICAgICAvLyB0aGlzIGlzIHRoZSBjYXNlIG9mIGBjb250cmFjdGAKCSAgICAgIGZpbGVOYW1lID0gJyc7CgkgICAgfQoJICAgIHZhciBjb250cmFjdE5hbWUgPSB0bXBbM107CgoJICAgIHZhciBjb250cmFjdElucHV0ID0gb3V0cHV0Wydjb250cmFjdHMnXVtjb250cmFjdF07CgoJICAgIHZhciBnYXNFc3RpbWF0ZXMgPSBjb250cmFjdElucHV0WydnYXNFc3RpbWF0ZXMnXTsKCSAgICB2YXIgdHJhbnNsYXRlZEdhc0VzdGltYXRlcyA9IHt9OwoKCSAgICBpZiAoZ2FzRXN0aW1hdGVzWydjcmVhdGlvbiddKSB7CgkgICAgICB0cmFuc2xhdGVkR2FzRXN0aW1hdGVzWydjcmVhdGlvbiddID0gewoJICAgICAgICAnY29kZURlcG9zaXRDb3N0JzogdHJhbnNsYXRlR2FzRXN0aW1hdGVzKGdhc0VzdGltYXRlc1snY3JlYXRpb24nXVsxXSksCgkgICAgICAgICdleGVjdXRpb25Db3N0JzogdHJhbnNsYXRlR2FzRXN0aW1hdGVzKGdhc0VzdGltYXRlc1snY3JlYXRpb24nXVswXSkKCSAgICAgIH07CgkgICAgfQoJICAgIGlmIChnYXNFc3RpbWF0ZXNbJ2ludGVybmFsJ10pIHsKCSAgICAgIHRyYW5zbGF0ZWRHYXNFc3RpbWF0ZXNbJ2ludGVybmFsJ10gPSB0cmFuc2xhdGVHYXNFc3RpbWF0ZXMoZ2FzRXN0aW1hdGVzWydpbnRlcm5hbCddKTsKCSAgICB9CgkgICAgaWYgKGdhc0VzdGltYXRlc1snZXh0ZXJuYWwnXSkgewoJICAgICAgdHJhbnNsYXRlZEdhc0VzdGltYXRlc1snZXh0ZXJuYWwnXSA9IHRyYW5zbGF0ZUdhc0VzdGltYXRlcyhnYXNFc3RpbWF0ZXNbJ2V4dGVybmFsJ10pOwoJICAgIH0KCgkgICAgdmFyIGNvbnRyYWN0T3V0cHV0ID0gewoJICAgICAgJ2FiaSc6IEpTT04ucGFyc2UoY29udHJhY3RJbnB1dFsnaW50ZXJmYWNlJ10pLAoJICAgICAgJ21ldGFkYXRhJzogY29udHJhY3RJbnB1dFsnbWV0YWRhdGEnXSwKCSAgICAgICdldm0nOiB7CgkgICAgICAgICdsZWdhY3lBc3NlbWJseSc6IGNvbnRyYWN0SW5wdXRbJ2Fzc2VtYmx5J10sCgkgICAgICAgICdieXRlY29kZSc6IHsKCSAgICAgICAgICAnb2JqZWN0JzogY29udHJhY3RJbnB1dFsnYnl0ZWNvZGUnXSAmJiBsaW5rZXIubGlua0J5dGVjb2RlKGNvbnRyYWN0SW5wdXRbJ2J5dGVjb2RlJ10sIGxpYnJhcmllcyB8fCB7fSksCgkgICAgICAgICAgJ29wY29kZXMnOiBjb250cmFjdElucHV0WydvcGNvZGVzJ10sCgkgICAgICAgICAgJ3NvdXJjZU1hcCc6IGNvbnRyYWN0SW5wdXRbJ3NyY21hcCddLAoJICAgICAgICAgICdsaW5rUmVmZXJlbmNlcyc6IGNvbnRyYWN0SW5wdXRbJ2J5dGVjb2RlJ10gJiYgbGlua2VyLmZpbmRMaW5rUmVmZXJlbmNlcyhjb250cmFjdElucHV0WydieXRlY29kZSddKQoJICAgICAgICB9LAoJICAgICAgICAnZGVwbG95ZWRCeXRlY29kZSc6IHsKCSAgICAgICAgICAnb2JqZWN0JzogY29udHJhY3RJbnB1dFsncnVudGltZUJ5dGVjb2RlJ10gJiYgbGlua2VyLmxpbmtCeXRlY29kZShjb250cmFjdElucHV0WydydW50aW1lQnl0ZWNvZGUnXSwgbGlicmFyaWVzIHx8IHt9KSwKCSAgICAgICAgICAnc291cmNlTWFwJzogY29udHJhY3RJbnB1dFsnc3JjbWFwUnVudGltZSddLAoJICAgICAgICAgICdsaW5rUmVmZXJlbmNlcyc6IGNvbnRyYWN0SW5wdXRbJ3J1bnRpbWVCeXRlY29kZSddICYmIGxpbmtlci5maW5kTGlua1JlZmVyZW5jZXMoY29udHJhY3RJbnB1dFsncnVudGltZUJ5dGVjb2RlJ10pCgkgICAgICAgIH0sCgkgICAgICAgICdtZXRob2RJZGVudGlmaWVycyc6IGNvbnRyYWN0SW5wdXRbJ2Z1bmN0aW9uSGFzaGVzJ10sCgkgICAgICAgICdnYXNFc3RpbWF0ZXMnOiB0cmFuc2xhdGVkR2FzRXN0aW1hdGVzCgkgICAgICB9CgkgICAgfTsKCgkgICAgaWYgKCFyZXRbJ2NvbnRyYWN0cyddW2ZpbGVOYW1lXSkgewoJICAgICAgcmV0Wydjb250cmFjdHMnXVtmaWxlTmFtZV0gPSB7fTsKCSAgICB9CgoJICAgIHJldFsnY29udHJhY3RzJ11bZmlsZU5hbWVdW2NvbnRyYWN0TmFtZV0gPSBjb250cmFjdE91dHB1dDsKCSAgfQoKCSAgdmFyIHNvdXJjZU1hcCA9IHt9OwoJICBmb3IgKHZhciBzb3VyY2VJZCBpbiBvdXRwdXRbJ3NvdXJjZUxpc3QnXSkgewoJICAgIHNvdXJjZU1hcFtvdXRwdXRbJ3NvdXJjZUxpc3QnXVtzb3VyY2VJZF1dID0gc291cmNlSWQ7CgkgIH0KCgkgIHJldFsnc291cmNlcyddID0ge307CgkgIGZvciAodmFyIHNvdXJjZSBpbiBvdXRwdXRbJ3NvdXJjZXMnXSkgewoJICAgIHJldFsnc291cmNlcyddW3NvdXJjZV0gPSB7CgkgICAgICBpZDogc291cmNlTWFwW3NvdXJjZV0sCgkgICAgICBsZWdhY3lBU1Q6IG91dHB1dFsnc291cmNlcyddW3NvdXJjZV0uQVNUCgkgICAgfTsKCSAgfQoKCSAgcmV0dXJuIHJldDsKCX0KCglmdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHRleHQpIHsKCSAgcmV0dXJuIHRleHQKCSAgICAucmVwbGFjZSgvXG4vZywgJ1xcbicpCgkgICAgLnJlcGxhY2UoL1xyL2csICdcXHInKQoJICAgIC5yZXBsYWNlKC9cdC9nLCAnXFx0Jyk7Cgl9CgoJLy8gJ2FzbScgY2FuIGJlIGFuIG9iamVjdCBvciBhIHN0cmluZwoJZnVuY3Rpb24gZm9ybWF0QXNzZW1ibHlUZXh0IChhc20sIHByZWZpeCwgc291cmNlKSB7CgkgIGlmICh0eXBlb2YgYXNtID09PSAnc3RyaW5nJyB8fCBhc20gPT09IG51bGwgfHwgYXNtID09PSB1bmRlZmluZWQpIHsKCSAgICByZXR1cm4gcHJlZml4ICsgKGFzbSB8fCAnJykgKyAnXG4nOwoJICB9CgkgIHZhciB0ZXh0ID0gcHJlZml4ICsgJy5jb2RlXG4nOwoJICBhc21bJy5jb2RlJ10uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkgewoJICAgIHZhciB2ID0gaXRlbS52YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiBpdGVtLnZhbHVlOwoJICAgIHZhciBzcmMgPSAnJzsKCSAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgaXRlbS5iZWdpbiAhPT0gdW5kZWZpbmVkICYmIGl0ZW0uZW5kICE9PSB1bmRlZmluZWQpIHsKCSAgICAgIHNyYyA9IGVzY2FwZVN0cmluZyhzb3VyY2Uuc2xpY2UoaXRlbS5iZWdpbiwgaXRlbS5lbmQpKTsKCSAgICB9CgkgICAgaWYgKHNyYy5sZW5ndGggPiAzMCkgewoJICAgICAgc3JjID0gc3JjLnNsaWNlKDAsIDMwKSArICcuLi4nOwoJICAgIH0KCSAgICBpZiAoaXRlbS5uYW1lICE9PSAndGFnJykgewoJICAgICAgdGV4dCArPSAnICAnOwoJICAgIH0KCSAgICB0ZXh0ICs9IHByZWZpeCArIGl0ZW0ubmFtZSArICcgJyArIHYgKyAnXHRcdFx0JyArIHNyYyArICdcbic7CgkgIH0pOwoJICB0ZXh0ICs9IHByZWZpeCArICcuZGF0YVxuJzsKCSAgdmFyIGFzbURhdGEgPSBhc21bJy5kYXRhJ10gfHwgW107CgkgIGZvciAodmFyIGkgaW4gYXNtRGF0YSkgewoJICAgIHZhciBpdGVtID0gYXNtRGF0YVtpXTsKCSAgICB0ZXh0ICs9ICcgICcgKyBwcmVmaXggKyAnJyArIGkgKyAnOlxuJzsKCSAgICB0ZXh0ICs9IGZvcm1hdEFzc2VtYmx5VGV4dChpdGVtLCBwcmVmaXggKyAnICAgICcsIHNvdXJjZSk7CgkgIH0KCSAgcmV0dXJuIHRleHQ7Cgl9CgoJZnVuY3Rpb24gcHJldHR5UHJpbnRMZWdhY3lBc3NlbWJseUpTT04gKGFzc2VtYmx5LCBzb3VyY2UpIHsKCSAgcmV0dXJuIGZvcm1hdEFzc2VtYmx5VGV4dChhc3NlbWJseSwgJycsIHNvdXJjZSk7Cgl9CgoJdmFyIHRyYW5zbGF0ZSQxID0gewoJICB2ZXJzaW9uVG9TZW12ZXI6IHZlcnNpb25Ub1NlbXZlciwKCSAgdHJhbnNsYXRlSnNvbkNvbXBpbGVyT3V0cHV0OiB0cmFuc2xhdGVKc29uQ29tcGlsZXJPdXRwdXQsCgkgIHByZXR0eVByaW50TGVnYWN5QXNzZW1ibHlKU09OOiBwcmV0dHlQcmludExlZ2FjeUFzc2VtYmx5SlNPTgoJfTsKCgl2YXIgcmVxdWlyZUZyb21TdHJpbmckMSA9IHtleHBvcnRzOiB7fX07CgoJdmFyIHJlcXVpcmUkJDAkMSA9IHt9OwoKCS8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgoJLy8KCS8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCgkvLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCgkvLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCgkvLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCgkvLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0CgkvLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKCS8vIGZvbGxvd2luZyBjb25kaXRpb25zOgoJLy8KCS8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCgkvLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KCS8vCgkvLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwoJLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgoJLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgoJLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCgkvLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKCS8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKCS8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgoJLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlCgkvLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XCkgaW4gdGhlIGFycmF5CgkvLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2gKCS8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocykKCWZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkgewoJICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMAoJICB2YXIgdXAgPSAwOwoJICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKCSAgICB2YXIgbGFzdCA9IHBhcnRzW2ldOwoJICAgIGlmIChsYXN0ID09PSAnLicpIHsKCSAgICAgIHBhcnRzLnNwbGljZShpLCAxKTsKCSAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHsKCSAgICAgIHBhcnRzLnNwbGljZShpLCAxKTsKCSAgICAgIHVwKys7CgkgICAgfSBlbHNlIGlmICh1cCkgewoJICAgICAgcGFydHMuc3BsaWNlKGksIDEpOwoJICAgICAgdXAtLTsKCSAgICB9CgkgIH0KCgkgIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnMKCSAgaWYgKGFsbG93QWJvdmVSb290KSB7CgkgICAgZm9yICg7IHVwLS07IHVwKSB7CgkgICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpOwoJICAgIH0KCSAgfQoKCSAgcmV0dXJuIHBhcnRzOwoJfQoKCS8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uCgkvLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLgoJdmFyIHNwbGl0UGF0aFJlID0KCSAgICAvXihcLz98KShbXHNcU10qPykoKD86XC57MSwyfXxbXlwvXSs/fCkoXC5bXi5cL10qfCkpKD86W1wvXSopJC87Cgl2YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHsKCSAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpOwoJfTsKCgkvLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pCgkvLyBwb3NpeCB2ZXJzaW9uCglmdW5jdGlvbiByZXNvbHZlKCkgewoJICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsCgkgICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7CgoJICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkgewoJICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiAnLyc7CgoJICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllcwoJICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHsKCSAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7CgkgICAgfSBlbHNlIGlmICghcGF0aCkgewoJICAgICAgY29udGludWU7CgkgICAgfQoKCSAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoOwoJICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nOwoJICB9CgoJICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0CgkgIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKQoKCSAgLy8gTm9ybWFsaXplIHRoZSBwYXRoCgkgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkgewoJICAgIHJldHVybiAhIXA7CgkgIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpOwoKCSAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nOwoJfQoJLy8gcGF0aC5ub3JtYWxpemUocGF0aCkKCS8vIHBvc2l4IHZlcnNpb24KCWZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7CgkgIHZhciBpc1BhdGhBYnNvbHV0ZSA9IGlzQWJzb2x1dGUocGF0aCksCgkgICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nOwoKCSAgLy8gTm9ybWFsaXplIHRoZSBwYXRoCgkgIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7CgkgICAgcmV0dXJuICEhcDsKCSAgfSksICFpc1BhdGhBYnNvbHV0ZSkuam9pbignLycpOwoKCSAgaWYgKCFwYXRoICYmICFpc1BhdGhBYnNvbHV0ZSkgewoJICAgIHBhdGggPSAnLic7CgkgIH0KCSAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkgewoJICAgIHBhdGggKz0gJy8nOwoJICB9CgoJICByZXR1cm4gKGlzUGF0aEFic29sdXRlID8gJy8nIDogJycpICsgcGF0aDsKCX0KCS8vIHBvc2l4IHZlcnNpb24KCWZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aCkgewoJICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJzsKCX0KCgkvLyBwb3NpeCB2ZXJzaW9uCglmdW5jdGlvbiBqb2luKCkgewoJICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApOwoJICByZXR1cm4gbm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHsKCSAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7CgkgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpOwoJICAgIH0KCSAgICByZXR1cm4gcDsKCSAgfSkuam9pbignLycpKTsKCX0KCgoJLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bykKCS8vIHBvc2l4IHZlcnNpb24KCWZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7CgkgIGZyb20gPSByZXNvbHZlKGZyb20pLnN1YnN0cigxKTsKCSAgdG8gPSByZXNvbHZlKHRvKS5zdWJzdHIoMSk7CgoJICBmdW5jdGlvbiB0cmltKGFycikgewoJICAgIHZhciBzdGFydCA9IDA7CgkgICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykgewoJICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhazsKCSAgICB9CgoJICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTsKCSAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7CgkgICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhazsKCSAgICB9CgoJICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdOwoJICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7CgkgIH0KCgkgIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7CgkgIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTsKCgkgIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7CgkgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7CgkgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKCSAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7CgkgICAgICBzYW1lUGFydHNMZW5ndGggPSBpOwoJICAgICAgYnJlYWs7CgkgICAgfQoJICB9CgoJICB2YXIgb3V0cHV0UGFydHMgPSBbXTsKCSAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykgewoJICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7CgkgIH0KCgkgIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7CgoJICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpOwoJfQoKCXZhciBzZXAgPSAnLyc7Cgl2YXIgZGVsaW1pdGVyJDEgPSAnOic7CgoJZnVuY3Rpb24gZGlybmFtZShwYXRoKSB7CgkgIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksCgkgICAgICByb290ID0gcmVzdWx0WzBdLAoJICAgICAgZGlyID0gcmVzdWx0WzFdOwoKCSAgaWYgKCFyb290ICYmICFkaXIpIHsKCSAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXIKCSAgICByZXR1cm4gJy4nOwoJICB9CgoJICBpZiAoZGlyKSB7CgkgICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2gKCSAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTsKCSAgfQoKCSAgcmV0dXJuIHJvb3QgKyBkaXI7Cgl9CgoJZnVuY3Rpb24gYmFzZW5hbWUocGF0aCwgZXh0KSB7CgkgIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdOwoJICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/CgkgIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7CgkgICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7CgkgIH0KCSAgcmV0dXJuIGY7Cgl9CgoKCWZ1bmN0aW9uIGV4dG5hbWUocGF0aCkgewoJICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdOwoJfQoJdmFyIHJlcXVpcmUkJDEgPSB7CgkgIGV4dG5hbWU6IGV4dG5hbWUsCgkgIGJhc2VuYW1lOiBiYXNlbmFtZSwKCSAgZGlybmFtZTogZGlybmFtZSwKCSAgc2VwOiBzZXAsCgkgIGRlbGltaXRlcjogZGVsaW1pdGVyJDEsCgkgIHJlbGF0aXZlOiByZWxhdGl2ZSwKCSAgam9pbjogam9pbiwKCSAgaXNBYnNvbHV0ZTogaXNBYnNvbHV0ZSwKCSAgbm9ybWFsaXplOiBub3JtYWxpemUsCgkgIHJlc29sdmU6IHJlc29sdmUKCX07CglmdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7CgkgICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTsKCSAgICB2YXIgcmVzID0gW107CgkgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykgewoJICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7CgkgICAgfQoJICAgIHJldHVybiByZXM7Cgl9CgoJLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOAoJdmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InID8KCSAgICBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH0gOgoJICAgIGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsKCSAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7CgkgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pOwoJICAgIH0KCTsKCgkoZnVuY3Rpb24gKG1vZHVsZSkgewoKCXZhciBNb2R1bGUgPSByZXF1aXJlJCQwJDE7Cgl2YXIgcGF0aCA9IHJlcXVpcmUkJDE7CgoJbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlRnJvbVN0cmluZyhjb2RlLCBmaWxlbmFtZSwgb3B0cykgewoJCWlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnKSB7CgkJCW9wdHMgPSBmaWxlbmFtZTsKCQkJZmlsZW5hbWUgPSB1bmRlZmluZWQ7CgkJfQoKCQlvcHRzID0gb3B0cyB8fCB7fTsKCQlmaWxlbmFtZSA9IGZpbGVuYW1lIHx8ICcnOwoKCQlvcHRzLmFwcGVuZFBhdGhzID0gb3B0cy5hcHBlbmRQYXRocyB8fCBbXTsKCQlvcHRzLnByZXBlbmRQYXRocyA9IG9wdHMucHJlcGVuZFBhdGhzIHx8IFtdOwoKCQlpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnKSB7CgkJCXRocm93IG5ldyBFcnJvcignY29kZSBtdXN0IGJlIGEgc3RyaW5nLCBub3QgJyArIHR5cGVvZiBjb2RlKTsKCQl9CgoJCXZhciBwYXRocyA9IE1vZHVsZS5fbm9kZU1vZHVsZVBhdGhzKHBhdGguZGlybmFtZShmaWxlbmFtZSkpOwoKCQl2YXIgcGFyZW50ID0gbW9kdWxlLnBhcmVudDsKCQl2YXIgbSA9IG5ldyBNb2R1bGUoZmlsZW5hbWUsIHBhcmVudCk7CgkJbS5maWxlbmFtZSA9IGZpbGVuYW1lOwoJCW0ucGF0aHMgPSBbXS5jb25jYXQob3B0cy5wcmVwZW5kUGF0aHMpLmNvbmNhdChwYXRocykuY29uY2F0KG9wdHMuYXBwZW5kUGF0aHMpOwoJCW0uX2NvbXBpbGUoY29kZSwgZmlsZW5hbWUpOwoKCQl2YXIgZXhwb3J0cyA9IG0uZXhwb3J0czsKCQlwYXJlbnQgJiYgcGFyZW50LmNoaWxkcmVuICYmIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UocGFyZW50LmNoaWxkcmVuLmluZGV4T2YobSksIDEpOwoKCQlyZXR1cm4gZXhwb3J0czsKCX07Cgl9KHJlcXVpcmVGcm9tU3RyaW5nJDEpKTsKCgl2YXIgZm9sbG93UmVkaXJlY3RzID0ge2V4cG9ydHM6IHt9fTsKCgkvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqLwoKCgkvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovCgl2YXIgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMQoKCS8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi8KCXZhciBiYXNlID0gMzY7Cgl2YXIgdE1pbiA9IDE7Cgl2YXIgdE1heCA9IDI2OwoJdmFyIHNrZXcgPSAzODsKCXZhciBkYW1wID0gNzAwOwoJdmFyIGluaXRpYWxCaWFzID0gNzI7Cgl2YXIgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODAKCXZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdceDJEJwoJdmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15ceDIwLVx4N0VdLzsgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnMKCXZhciByZWdleFNlcGFyYXRvcnMgPSAvW1x4MkVcdTMwMDJcdUZGMEVcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnMKCgkvKiogRXJyb3IgbWVzc2FnZXMgKi8KCXZhciBlcnJvcnMgPSB7CgkgICdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsCgkgICdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsCgkgICdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnCgl9OwoKCS8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi8KCXZhciBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47Cgl2YXIgZmxvb3IgPSBNYXRoLmZsb29yOwoJdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7CgoJLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovCgoJLyoqCgkgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi4KCSAqIEBwcml2YXRlCgkgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS4KCSAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS4KCSAqLwoJZnVuY3Rpb24gZXJyb3IodHlwZSkgewoJICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pOwoJfQoKCS8qKgoJICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uCgkgKiBAcHJpdmF0ZQoJICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci4KCSAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheQoJICogaXRlbS4KCSAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi4KCSAqLwoJZnVuY3Rpb24gbWFwJDEoYXJyYXksIGZuKSB7CgkgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7CgkgIHZhciByZXN1bHQgPSBbXTsKCSAgd2hpbGUgKGxlbmd0aC0tKSB7CgkgICAgcmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTsKCSAgfQoJICByZXR1cm4gcmVzdWx0OwoJfQoKCS8qKgoJICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsCgkgKiBhZGRyZXNzZXMuCgkgKiBAcHJpdmF0ZQoJICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy4KCSAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeQoJICogY2hhcmFjdGVyLgoJICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sKCSAqIGZ1bmN0aW9uLgoJICovCglmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikgewoJICB2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTsKCSAgdmFyIHJlc3VsdCA9ICcnOwoJICBpZiAocGFydHMubGVuZ3RoID4gMSkgewoJICAgIC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmUKCSAgICAvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LgoJICAgIHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnOwoJICAgIHN0cmluZyA9IHBhcnRzWzFdOwoJICB9CgkgIC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy4KCSAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXHgyRScpOwoJICB2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7CgkgIHZhciBlbmNvZGVkID0gbWFwJDEobGFiZWxzLCBmbikuam9pbignLicpOwoJICByZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDsKCX0KCgkvKioKCSAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGUKCSAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSwKCSAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoCgkgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCwKCSAqIG1hdGNoaW5nIFVURi0xNi4KCSAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYAoJICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+CgkgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMgoJICogQG5hbWUgZGVjb2RlCgkgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLgoJICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLgoJICovCglmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykgewoJICB2YXIgb3V0cHV0ID0gW10sCgkgICAgY291bnRlciA9IDAsCgkgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCwKCSAgICB2YWx1ZSwKCSAgICBleHRyYTsKCSAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHsKCSAgICB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7CgkgICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkgewoJICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyCgkgICAgICBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7CgkgICAgICBpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZQoJICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApOwoJICAgICAgfSBlbHNlIHsKCSAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHQKCSAgICAgICAgLy8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyCgkgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTsKCSAgICAgICAgY291bnRlci0tOwoJICAgICAgfQoJICAgIH0gZWxzZSB7CgkgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7CgkgICAgfQoJICB9CgkgIHJldHVybiBvdXRwdXQ7Cgl9CgoJLyoqCgkgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuCgkgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWAKCSAqIEBwcml2YXRlCgkgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LgoJICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3IKCSAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlCgkgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXMKCSAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkCgkgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLgoJICovCglmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHsKCSAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLloKCSAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45CgkgIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7Cgl9CgoJLyoqCgkgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLgoJICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjQKCSAqIEBwcml2YXRlCgkgKi8KCWZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkgewoJICB2YXIgayA9IDA7CgkgIGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7CgkgIGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTsKCSAgZm9yICggLyogbm8gaW5pdGlhbGl6YXRpb24gKi8gOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkgewoJICAgIGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTsKCSAgfQoJICByZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTsKCX0KCgkvKioKCSAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhCgkgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLgoJICogQG1lbWJlck9mIHB1bnljb2RlCgkgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuCgkgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuCgkgKi8KCWZ1bmN0aW9uIGVuY29kZShpbnB1dCkgewoJICB2YXIgbiwKCSAgICBkZWx0YSwKCSAgICBoYW5kbGVkQ1BDb3VudCwKCSAgICBiYXNpY0xlbmd0aCwKCSAgICBiaWFzLAoJICAgIGosCgkgICAgbSwKCSAgICBxLAoJICAgIGssCgkgICAgdCwKCSAgICBjdXJyZW50VmFsdWUsCgkgICAgb3V0cHV0ID0gW10sCgkgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi8KCSAgICBpbnB1dExlbmd0aCwKCSAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi8KCSAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsCgkgICAgYmFzZU1pbnVzVCwKCSAgICBxTWludXNUOwoKCSAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZQoJICBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpOwoKCSAgLy8gQ2FjaGUgdGhlIGxlbmd0aAoJICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDsKCgkgIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlCgkgIG4gPSBpbml0aWFsTjsKCSAgZGVsdGEgPSAwOwoJICBiaWFzID0gaW5pdGlhbEJpYXM7CgoJICAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzCgkgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7CgkgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07CgkgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHsKCSAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTsKCSAgICB9CgkgIH0KCgkgIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoOwoKCSAgLy8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7CgkgIC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy4KCgkgIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlcgoJICBpZiAoYmFzaWNMZW5ndGgpIHsKCSAgICBvdXRwdXQucHVzaChkZWxpbWl0ZXIpOwoJICB9CgoJICAvLyBNYWluIGVuY29kaW5nIGxvb3A6CgkgIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7CgoJICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHQKCSAgICAvLyBsYXJnZXIgb25lOgoJICAgIGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7CgkgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTsKCSAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7CgkgICAgICAgIG0gPSBjdXJyZW50VmFsdWU7CgkgICAgICB9CgkgICAgfQoKCSAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sCgkgICAgLy8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cKCSAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7CgkgICAgaWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHsKCSAgICAgIGVycm9yKCdvdmVyZmxvdycpOwoJICAgIH0KCgkgICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTsKCSAgICBuID0gbTsKCgkgICAgZm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHsKCSAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdOwoKCSAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHsKCSAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7CgkgICAgICB9CgoJICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7CgkgICAgICAgIC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyCgkgICAgICAgIGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovIDsgayArPSBiYXNlKSB7CgkgICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7CgkgICAgICAgICAgaWYgKHEgPCB0KSB7CgkgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICB9CgkgICAgICAgICAgcU1pbnVzVCA9IHEgLSB0OwoJICAgICAgICAgIGJhc2VNaW51c1QgPSBiYXNlIC0gdDsKCSAgICAgICAgICBvdXRwdXQucHVzaCgKCSAgICAgICAgICAgIHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSkKCSAgICAgICAgICApOwoJICAgICAgICAgIHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7CgkgICAgICAgIH0KCgkgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTsKCSAgICAgICAgYmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTsKCSAgICAgICAgZGVsdGEgPSAwOwoJICAgICAgICArK2hhbmRsZWRDUENvdW50OwoJICAgICAgfQoJICAgIH0KCgkgICAgKytkZWx0YTsKCSAgICArK247CgoJICB9CgkgIHJldHVybiBvdXRwdXQuam9pbignJyk7Cgl9CgoJLyoqCgkgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG8KCSAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLAoJICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluCgkgKiBBU0NJSS4KCSAqIEBtZW1iZXJPZiBwdW55Y29kZQoJICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGEKCSAqIFVuaWNvZGUgc3RyaW5nLgoJICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvcgoJICogZW1haWwgYWRkcmVzcy4KCSAqLwoJZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkgewoJICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHsKCSAgICByZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgPwoJICAgICAgJ3huLS0nICsgZW5jb2RlKHN0cmluZykgOgoJICAgICAgc3RyaW5nOwoJICB9KTsKCX0KCgkvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KCS8vCgkvLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQoJLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQoJLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwoJLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAoJLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAoJLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCgkvLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKCS8vCgkvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAoJLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCgkvLwoJLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKCS8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKCS8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KCS8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAoJLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCgkvLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCgkvLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKCgkvLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nCgkvLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay4KCS8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3CglmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHsKCSAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOwoJfQoJdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykgewoJICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJzsKCX07CglmdW5jdGlvbiBzdHJpbmdpZnlQcmltaXRpdmUodikgewoJICBzd2l0Y2ggKHR5cGVvZiB2KSB7CgkgICAgY2FzZSAnc3RyaW5nJzoKCSAgICAgIHJldHVybiB2OwoKCSAgICBjYXNlICdib29sZWFuJzoKCSAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJzsKCgkgICAgY2FzZSAnbnVtYmVyJzoKCSAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJzsKCgkgICAgZGVmYXVsdDoKCSAgICAgIHJldHVybiAnJzsKCSAgfQoJfQoKCWZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCBzZXAsIGVxLCBuYW1lKSB7CgkgIHNlcCA9IHNlcCB8fCAnJic7CgkgIGVxID0gZXEgfHwgJz0nOwoJICBpZiAob2JqID09PSBudWxsKSB7CgkgICAgb2JqID0gdW5kZWZpbmVkOwoJICB9CgoJICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHsKCSAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykgewoJICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTsKCSAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHsKCSAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHsKCSAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTsKCSAgICAgICAgfSkuam9pbihzZXApOwoJICAgICAgfSBlbHNlIHsKCSAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTsKCSAgICAgIH0KCSAgICB9KS5qb2luKHNlcCk7CgoJICB9CgoJICBpZiAoIW5hbWUpIHJldHVybiAnJzsKCSAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgKwoJICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTsKCX0KCWZ1bmN0aW9uIG1hcCAoeHMsIGYpIHsKCSAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTsKCSAgdmFyIHJlcyA9IFtdOwoJICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7CgkgICAgcmVzLnB1c2goZih4c1tpXSwgaSkpOwoJICB9CgkgIHJldHVybiByZXM7Cgl9CgoJdmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7CgkgIHZhciByZXMgPSBbXTsKCSAgZm9yICh2YXIga2V5IGluIG9iaikgewoJICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpOwoJICB9CgkgIHJldHVybiByZXM7Cgl9OwoKCWZ1bmN0aW9uIHBhcnNlJDEocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHsKCSAgc2VwID0gc2VwIHx8ICcmJzsKCSAgZXEgPSBlcSB8fCAnPSc7CgkgIHZhciBvYmogPSB7fTsKCgkgIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkgewoJICAgIHJldHVybiBvYmo7CgkgIH0KCgkgIHZhciByZWdleHAgPSAvXCsvZzsKCSAgcXMgPSBxcy5zcGxpdChzZXApOwoKCSAgdmFyIG1heEtleXMgPSAxMDAwOwoJICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykgewoJICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7CgkgIH0KCgkgIHZhciBsZW4gPSBxcy5sZW5ndGg7CgkgIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudAoJICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykgewoJICAgIGxlbiA9IG1heEtleXM7CgkgIH0KCgkgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHsKCSAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksCgkgICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksCgkgICAgICAgIGtzdHIsIHZzdHIsIGssIHY7CgoJICAgIGlmIChpZHggPj0gMCkgewoJICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7CgkgICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7CgkgICAgfSBlbHNlIHsKCSAgICAgIGtzdHIgPSB4OwoJICAgICAgdnN0ciA9ICcnOwoJICAgIH0KCgkgICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTsKCSAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpOwoKCSAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHsKCSAgICAgIG9ialtrXSA9IHY7CgkgICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHsKCSAgICAgIG9ialtrXS5wdXNoKHYpOwoJICAgIH0gZWxzZSB7CgkgICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTsKCSAgICB9CgkgIH0KCgkgIHJldHVybiBvYmo7Cgl9CgoJLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCgl2YXIgcmVxdWlyZSQkMCA9IHsKCSAgcGFyc2U6IHVybFBhcnNlLAoJICByZXNvbHZlOiB1cmxSZXNvbHZlLAoJICByZXNvbHZlT2JqZWN0OiB1cmxSZXNvbHZlT2JqZWN0LAoJICBmb3JtYXQ6IHVybEZvcm1hdCwKCSAgVXJsOiBVcmwKCX07CglmdW5jdGlvbiBVcmwoKSB7CgkgIHRoaXMucHJvdG9jb2wgPSBudWxsOwoJICB0aGlzLnNsYXNoZXMgPSBudWxsOwoJICB0aGlzLmF1dGggPSBudWxsOwoJICB0aGlzLmhvc3QgPSBudWxsOwoJICB0aGlzLnBvcnQgPSBudWxsOwoJICB0aGlzLmhvc3RuYW1lID0gbnVsbDsKCSAgdGhpcy5oYXNoID0gbnVsbDsKCSAgdGhpcy5zZWFyY2ggPSBudWxsOwoJICB0aGlzLnF1ZXJ5ID0gbnVsbDsKCSAgdGhpcy5wYXRobmFtZSA9IG51bGw7CgkgIHRoaXMucGF0aCA9IG51bGw7CgkgIHRoaXMuaHJlZiA9IG51bGw7Cgl9CgoJLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2CgoJLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmUKCS8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLgoJdmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksCgkgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLywKCgkgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkwKCSAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcL1wvPyg/IVwvKVteXD9cc10qKShcP1teXHNdKik/JC8sCgoJICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLgoJICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLgoJICBkZWxpbXMgPSBbJzwnLCAnPicsICciJywgJ2AnLCAnICcsICdccicsICdcbicsICdcdCddLAoKCSAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy4KCSAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSwKCgkgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS4KCSAgYXV0b0VzY2FwZSA9IFsnXCcnXS5jb25jYXQodW53aXNlKSwKCSAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS4KCSAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZQoJICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGgKCSAgLy8gdGhlbS4KCSAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksCgkgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSwKCSAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsCgkgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sCgkgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLAoJICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgInVuc2FmZSIgYW5kICJ1bndpc2UiIGNoYXJzLgoJICB1bnNhZmVQcm90b2NvbCA9IHsKCSAgICAnamF2YXNjcmlwdCc6IHRydWUsCgkgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZQoJICB9LAoJICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuCgkgIGhvc3RsZXNzUHJvdG9jb2wgPSB7CgkgICAgJ2phdmFzY3JpcHQnOiB0cnVlLAoJICAgICdqYXZhc2NyaXB0Oic6IHRydWUKCSAgfSwKCSAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuCgkgIHNsYXNoZWRQcm90b2NvbCA9IHsKCSAgICAnaHR0cCc6IHRydWUsCgkgICAgJ2h0dHBzJzogdHJ1ZSwKCSAgICAnZnRwJzogdHJ1ZSwKCSAgICAnZ29waGVyJzogdHJ1ZSwKCSAgICAnZmlsZSc6IHRydWUsCgkgICAgJ2h0dHA6JzogdHJ1ZSwKCSAgICAnaHR0cHM6JzogdHJ1ZSwKCSAgICAnZnRwOic6IHRydWUsCgkgICAgJ2dvcGhlcjonOiB0cnVlLAoJICAgICdmaWxlOic6IHRydWUKCSAgfTsKCglmdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7CgkgIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7CgoJICB2YXIgdSA9IG5ldyBVcmw7CgkgIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7CgkgIHJldHVybiB1OwoJfQoJVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHsKCSAgcmV0dXJuIHBhcnNlKHRoaXMsIHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpOwoJfTsKCglmdW5jdGlvbiBwYXJzZShzZWxmLCB1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7CgkgIGlmICghaXNTdHJpbmcodXJsKSkgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBcJ3VybFwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCAnICsgdHlwZW9mIHVybCk7CgkgIH0KCgkgIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLgoJICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXMKCSAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTYKCSAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLAoJICAgIHNwbGl0dGVyID0KCSAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLAoJICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksCgkgICAgc2xhc2hSZWdleCA9IC9cXC9nOwoJICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpOwoJICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7CgoJICB2YXIgcmVzdCA9IHVybDsKCgkgIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuCgkgIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlICIgIGh0dHA6Ly9mb28uY29tICBcbiIKCSAgcmVzdCA9IHJlc3QudHJpbSgpOwoKCSAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHsKCSAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cAoJICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTsKCSAgICBpZiAoc2ltcGxlUGF0aCkgewoJICAgICAgc2VsZi5wYXRoID0gcmVzdDsKCSAgICAgIHNlbGYuaHJlZiA9IHJlc3Q7CgkgICAgICBzZWxmLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTsKCSAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7CgkgICAgICAgIHNlbGYuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTsKCSAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHsKCSAgICAgICAgICBzZWxmLnF1ZXJ5ID0gcGFyc2UkMShzZWxmLnNlYXJjaC5zdWJzdHIoMSkpOwoJICAgICAgICB9IGVsc2UgewoJICAgICAgICAgIHNlbGYucXVlcnkgPSBzZWxmLnNlYXJjaC5zdWJzdHIoMSk7CgkgICAgICAgIH0KCSAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykgewoJICAgICAgICBzZWxmLnNlYXJjaCA9ICcnOwoJICAgICAgICBzZWxmLnF1ZXJ5ID0ge307CgkgICAgICB9CgkgICAgICByZXR1cm4gc2VsZjsKCSAgICB9CgkgIH0KCgkgIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpOwoJICBpZiAocHJvdG8pIHsKCSAgICBwcm90byA9IHByb3RvWzBdOwoJICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTsKCSAgICBzZWxmLnByb3RvY29sID0gbG93ZXJQcm90bzsKCSAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTsKCSAgfQoKCSAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3QKCSAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybAoJICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzCgkgIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLgoJICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlwvXC9bXkBcL10rQFteQFwvXSsvKSkgewoJICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7CgkgICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHsKCSAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTsKCSAgICAgIHNlbGYuc2xhc2hlcyA9IHRydWU7CgkgICAgfQoJICB9CgkgIHZhciBpLCBoZWMsIGwsIHA7CgkgIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiYKCSAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkgewoKCSAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuCgkgICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC4KCSAgICAvLwoJICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWQKCSAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlcgoJICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uCgkgICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLgoJICAgIC8vCgkgICAgLy8gZXg6CgkgICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmMKCSAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjCgoJICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy4KCSAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LgoKCSAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzCgkgICAgdmFyIGhvc3RFbmQgPSAtMTsKCSAgICBmb3IgKGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7CgkgICAgICBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTsKCSAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkKCSAgICAgICAgaG9zdEVuZCA9IGhlYzsKCSAgICB9CgoJICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZQoJICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLgoJICAgIHZhciBhdXRoLCBhdFNpZ247CgkgICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7CgkgICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLgoJICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpOwoJICAgIH0gZWxzZSB7CgkgICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uCgkgICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZAoJICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpOwoJICAgIH0KCgkgICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguCgkgICAgLy8gUHVsbCB0aGF0IG9mZi4KCSAgICBpZiAoYXRTaWduICE9PSAtMSkgewoJICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTsKCSAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpOwoJICAgICAgc2VsZi5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpOwoJICAgIH0KCgkgICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhcgoJICAgIGhvc3RFbmQgPSAtMTsKCSAgICBmb3IgKGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7CgkgICAgICBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTsKCSAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkKCSAgICAgICAgaG9zdEVuZCA9IGhlYzsKCSAgICB9CgkgICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LgoJICAgIGlmIChob3N0RW5kID09PSAtMSkKCSAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDsKCgkgICAgc2VsZi5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTsKCSAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTsKCgkgICAgLy8gcHVsbCBvdXQgcG9ydC4KCSAgICBwYXJzZUhvc3Qoc2VsZik7CgoJICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsCgkgICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC4KCSAgICBzZWxmLmhvc3RuYW1lID0gc2VsZi5ob3N0bmFtZSB8fCAnJzsKCgkgICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF0KCSAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy4KCSAgICB2YXIgaXB2Nkhvc3RuYW1lID0gc2VsZi5ob3N0bmFtZVswXSA9PT0gJ1snICYmCgkgICAgICBzZWxmLmhvc3RuYW1lW3NlbGYuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJzsKCgkgICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuCgkgICAgaWYgKCFpcHY2SG9zdG5hbWUpIHsKCSAgICAgIHZhciBob3N0cGFydHMgPSBzZWxmLmhvc3RuYW1lLnNwbGl0KC9cLi8pOwoJICAgICAgZm9yIChpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKCSAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07CgkgICAgICAgIGlmICghcGFydCkgY29udGludWU7CgkgICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkgewoJICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7CgkgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykgewoJICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykgewoJICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXIKCSAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdAoJICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nCgkgICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnOwoJICAgICAgICAgICAgfSBlbHNlIHsKCSAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdOwoJICAgICAgICAgICAgfQoJICAgICAgICAgIH0KCSAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5CgkgICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7CgkgICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTsKCSAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTsKCSAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTsKCSAgICAgICAgICAgIGlmIChiaXQpIHsKCSAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7CgkgICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pOwoJICAgICAgICAgICAgfQoJICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7CgkgICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7CgkgICAgICAgICAgICB9CgkgICAgICAgICAgICBzZWxmLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7CgkgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICB9CgkgICAgICAgIH0KCSAgICAgIH0KCSAgICB9CgoJICAgIGlmIChzZWxmLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7CgkgICAgICBzZWxmLmhvc3RuYW1lID0gJyc7CgkgICAgfSBlbHNlIHsKCSAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuCgkgICAgICBzZWxmLmhvc3RuYW1lID0gc2VsZi5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpOwoJICAgIH0KCgkgICAgaWYgKCFpcHY2SG9zdG5hbWUpIHsKCSAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiAiZG9tYWluIi4KCSAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXQKCSAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYKCSAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuCgkgICAgICBzZWxmLmhvc3RuYW1lID0gdG9BU0NJSShzZWxmLmhvc3RuYW1lKTsKCSAgICB9CgoJICAgIHAgPSBzZWxmLnBvcnQgPyAnOicgKyBzZWxmLnBvcnQgOiAnJzsKCSAgICB2YXIgaCA9IHNlbGYuaG9zdG5hbWUgfHwgJyc7CgkgICAgc2VsZi5ob3N0ID0gaCArIHA7CgkgICAgc2VsZi5ocmVmICs9IHNlbGYuaG9zdDsKCgkgICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZQoJICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoCgkgICAgaWYgKGlwdjZIb3N0bmFtZSkgewoJICAgICAgc2VsZi5ob3N0bmFtZSA9IHNlbGYuaG9zdG5hbWUuc3Vic3RyKDEsIHNlbGYuaG9zdG5hbWUubGVuZ3RoIC0gMik7CgkgICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7CgkgICAgICAgIHJlc3QgPSAnLycgKyByZXN0OwoJICAgICAgfQoJICAgIH0KCSAgfQoKCSAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuCgkgIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy4KCSAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkgewoKCSAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgImF1dG9Fc2NhcGUiIGNoYXJzIGdldAoJICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleQoJICAgIC8vIG5lZWQgdG8gYmUuCgkgICAgZm9yIChpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CgkgICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldOwoJICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKQoJICAgICAgICBjb250aW51ZTsKCSAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpOwoJICAgICAgaWYgKGVzYyA9PT0gYWUpIHsKCSAgICAgICAgZXNjID0gZXNjYXBlKGFlKTsKCSAgICAgIH0KCSAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7CgkgICAgfQoJICB9CgoKCSAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC4KCSAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTsKCSAgaWYgKGhhc2ggIT09IC0xKSB7CgkgICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLgoJICAgIHNlbGYuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpOwoJICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpOwoJICB9CgkgIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpOwoJICBpZiAocW0gIT09IC0xKSB7CgkgICAgc2VsZi5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7CgkgICAgc2VsZi5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7CgkgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHsKCSAgICAgIHNlbGYucXVlcnkgPSBwYXJzZSQxKHNlbGYucXVlcnkpOwoJICAgIH0KCSAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7CgkgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykgewoJICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkCgkgICAgc2VsZi5zZWFyY2ggPSAnJzsKCSAgICBzZWxmLnF1ZXJ5ID0ge307CgkgIH0KCSAgaWYgKHJlc3QpIHNlbGYucGF0aG5hbWUgPSByZXN0OwoJICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmCgkgICAgc2VsZi5ob3N0bmFtZSAmJiAhc2VsZi5wYXRobmFtZSkgewoJICAgIHNlbGYucGF0aG5hbWUgPSAnLyc7CgkgIH0KCgkgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3QKCSAgaWYgKHNlbGYucGF0aG5hbWUgfHwgc2VsZi5zZWFyY2gpIHsKCSAgICBwID0gc2VsZi5wYXRobmFtZSB8fCAnJzsKCSAgICB2YXIgcyA9IHNlbGYuc2VhcmNoIHx8ICcnOwoJICAgIHNlbGYucGF0aCA9IHAgKyBzOwoJICB9CgoJICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC4KCSAgc2VsZi5ocmVmID0gZm9ybWF0KHNlbGYpOwoJICByZXR1cm4gc2VsZjsKCX0KCgkvLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nCglmdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7CgkgIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuCgkgIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuCgkgIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3MKCSAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy4KCSAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHBhcnNlKHt9LCBvYmopOwoJICByZXR1cm4gZm9ybWF0KG9iaik7Cgl9CgoJZnVuY3Rpb24gZm9ybWF0KHNlbGYpIHsKCSAgdmFyIGF1dGggPSBzZWxmLmF1dGggfHwgJyc7CgkgIGlmIChhdXRoKSB7CgkgICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTsKCSAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTsKCSAgICBhdXRoICs9ICdAJzsKCSAgfQoKCSAgdmFyIHByb3RvY29sID0gc2VsZi5wcm90b2NvbCB8fCAnJywKCSAgICBwYXRobmFtZSA9IHNlbGYucGF0aG5hbWUgfHwgJycsCgkgICAgaGFzaCA9IHNlbGYuaGFzaCB8fCAnJywKCSAgICBob3N0ID0gZmFsc2UsCgkgICAgcXVlcnkgPSAnJzsKCgkgIGlmIChzZWxmLmhvc3QpIHsKCSAgICBob3N0ID0gYXV0aCArIHNlbGYuaG9zdDsKCSAgfSBlbHNlIGlmIChzZWxmLmhvc3RuYW1lKSB7CgkgICAgaG9zdCA9IGF1dGggKyAoc2VsZi5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID8KCSAgICAgIHNlbGYuaG9zdG5hbWUgOgoJICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7CgkgICAgaWYgKHNlbGYucG9ydCkgewoJICAgICAgaG9zdCArPSAnOicgKyBzZWxmLnBvcnQ7CgkgICAgfQoJICB9CgoJICBpZiAoc2VsZi5xdWVyeSAmJgoJICAgIGlzT2JqZWN0KHNlbGYucXVlcnkpICYmCgkgICAgT2JqZWN0LmtleXMoc2VsZi5xdWVyeSkubGVuZ3RoKSB7CgkgICAgcXVlcnkgPSBzdHJpbmdpZnkoc2VsZi5xdWVyeSk7CgkgIH0KCgkgIHZhciBzZWFyY2ggPSBzZWxmLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7CgoJICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7CgoJICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy4KCSAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC4KCSAgaWYgKHNlbGYuc2xhc2hlcyB8fAoJICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHsKCSAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTsKCSAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7CgkgIH0gZWxzZSBpZiAoIWhvc3QpIHsKCSAgICBob3N0ID0gJyc7CgkgIH0KCgkgIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoOwoJICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoOwoKCSAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7CgkgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7CgkgIH0pOwoJICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTsKCgkgIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7Cgl9CgoJVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHsKCSAgcmV0dXJuIGZvcm1hdCh0aGlzKTsKCX07CgoJZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7CgkgIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTsKCX0KCglVcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkgewoJICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpOwoJfTsKCglmdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHsKCSAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTsKCSAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpOwoJfQoKCVVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7CgkgIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHsKCSAgICB2YXIgcmVsID0gbmV3IFVybCgpOwoJICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpOwoJICAgIHJlbGF0aXZlID0gcmVsOwoJICB9CgoJICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpOwoJICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTsKCSAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykgewoJICAgIHZhciB0a2V5ID0gdGtleXNbdGtdOwoJICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07CgkgIH0KCgkgIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LgoJICAvLyBldmVuIGhyZWY9IiIgd2lsbCByZW1vdmUgaXQuCgkgIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDsKCgkgIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS4KCSAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7CgkgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CgkgICAgcmV0dXJuIHJlc3VsdDsKCSAgfQoKCSAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuCgkgIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkgewoJICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmUKCSAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7CgkgICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykgewoJICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107CgkgICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJykKCSAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07CgkgICAgfQoKCSAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbQoJICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJgoJICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHsKCSAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nOwoJICAgIH0KCgkgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CgkgICAgcmV0dXJuIHJlc3VsdDsKCSAgfQoJICB2YXIgcmVsUGF0aDsKCSAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHsKCSAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nCgkgICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzCgkgICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsCgkgICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGgKCSAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguCgkgICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCwKCSAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy4KCSAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuCgkgICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7CgkgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTsKCSAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykgewoJICAgICAgICB2YXIgayA9IGtleXNbdl07CgkgICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdOwoJICAgICAgfQoJICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CgkgICAgICByZXR1cm4gcmVzdWx0OwoJICAgIH0KCgkgICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7CgkgICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkgewoJICAgICAgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTsKCSAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTsKCSAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnOwoJICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJzsKCSAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTsKCSAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7CgkgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTsKCSAgICB9IGVsc2UgewoJICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7CgkgICAgfQoJICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7CgkgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7CgkgICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnOwoJICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDsKCSAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0OwoJICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDsKCSAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdAoJICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkgewoJICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7CgkgICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7CgkgICAgICByZXN1bHQucGF0aCA9IHAgKyBzOwoJICAgIH0KCSAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7CgkgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7CgkgICAgcmV0dXJuIHJlc3VsdDsKCSAgfQoKCSAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLAoJICAgIGlzUmVsQWJzID0gKAoJICAgICAgcmVsYXRpdmUuaG9zdCB8fAoJICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycKCSAgICApLAoJICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHwKCSAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLAoJICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLAoJICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sCgkgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTsKCSAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW107CgkgIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmUKCSAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZQoJICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuCgkgIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuCgkgIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLgoJICBpZiAocHN5Y2hvdGljKSB7CgkgICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7CgkgICAgcmVzdWx0LnBvcnQgPSBudWxsOwoJICAgIGlmIChyZXN1bHQuaG9zdCkgewoJICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7CgkgICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7CgkgICAgfQoJICAgIHJlc3VsdC5ob3N0ID0gJyc7CgkgICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7CgkgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7CgkgICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDsKCSAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7CgkgICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7CgkgICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpOwoJICAgICAgfQoJICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7CgkgICAgfQoJICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7CgkgIH0KCSAgdmFyIGF1dGhJbkhvc3Q7CgkgIGlmIChpc1JlbEFicykgewoJICAgIC8vIGl0J3MgYWJzb2x1dGUuCgkgICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgPwoJICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0OwoJICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID8KCSAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lOwoJICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7CgkgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7CgkgICAgc3JjUGF0aCA9IHJlbFBhdGg7CgkgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuCgkgIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHsKCSAgICAvLyBpdCdzIHJlbGF0aXZlCgkgICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuCgkgICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107CgkgICAgc3JjUGF0aC5wb3AoKTsKCSAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7CgkgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDsKCSAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTsKCSAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkgewoJICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC4KCSAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLgoJICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFucwoJICAgIGlmIChwc3ljaG90aWMpIHsKCSAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpOwoJICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdAoJICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlCgkgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKQoJICAgICAgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgPwoJICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7CgkgICAgICBpZiAoYXV0aEluSG9zdCkgewoJICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTsKCSAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7CgkgICAgICB9CgkgICAgfQoJICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7CgkgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7CgkgICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdAoJICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkgewoJICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICsKCSAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpOwoJICAgIH0KCSAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTsKCSAgICByZXR1cm4gcmVzdWx0OwoJICB9CgoJICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7CgkgICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LgoJICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuCgkgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDsKCSAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0CgkgICAgaWYgKHJlc3VsdC5zZWFyY2gpIHsKCSAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDsKCSAgICB9IGVsc2UgewoJICAgICAgcmVzdWx0LnBhdGggPSBudWxsOwoJICAgIH0KCSAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTsKCSAgICByZXR1cm4gcmVzdWx0OwoJICB9CgoJICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC4KCSAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksCgkgIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guCgkgIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07CgkgIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKAoJICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiYKCSAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTsKCgkgIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXIKCSAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDAKCSAgdmFyIHVwID0gMDsKCSAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkgewoJICAgIGxhc3QgPSBzcmNQYXRoW2ldOwoJICAgIGlmIChsYXN0ID09PSAnLicpIHsKCSAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpOwoJICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykgewoJICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7CgkgICAgICB1cCsrOwoJICAgIH0gZWxzZSBpZiAodXApIHsKCSAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpOwoJICAgICAgdXAtLTsKCSAgICB9CgkgIH0KCgkgIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnMKCSAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7CgkgICAgZm9yICg7IHVwLS07IHVwKSB7CgkgICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7CgkgICAgfQoJICB9CgoJICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJgoJICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkgewoJICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7CgkgIH0KCgkgIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7CgkgICAgc3JjUGF0aC5wdXNoKCcnKTsKCSAgfQoKCSAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fAoJICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpOwoKCSAgLy8gcHV0IHRoZSBob3N0IGJhY2sKCSAgaWYgKHBzeWNob3RpYykgewoJICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDoKCSAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7CgkgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdAoJICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZQoJICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpCgkgICAgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgPwoJICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlOwoJICAgIGlmIChhdXRoSW5Ib3N0KSB7CgkgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTsKCSAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpOwoJICAgIH0KCSAgfQoKCSAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTsKCgkgIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7CgkgICAgc3JjUGF0aC51bnNoaWZ0KCcnKTsKCSAgfQoKCSAgaWYgKCFzcmNQYXRoLmxlbmd0aCkgewoJICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7CgkgICAgcmVzdWx0LnBhdGggPSBudWxsOwoJICB9IGVsc2UgewoJICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpOwoJICB9CgoJICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwCgkgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkgewoJICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArCgkgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7CgkgIH0KCSAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoOwoJICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7CgkgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpOwoJICByZXR1cm4gcmVzdWx0OwoJfTsKCglVcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkgewoJICByZXR1cm4gcGFyc2VIb3N0KHRoaXMpOwoJfTsKCglmdW5jdGlvbiBwYXJzZUhvc3Qoc2VsZikgewoJICB2YXIgaG9zdCA9IHNlbGYuaG9zdDsKCSAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpOwoJICBpZiAocG9ydCkgewoJICAgIHBvcnQgPSBwb3J0WzBdOwoJICAgIGlmIChwb3J0ICE9PSAnOicpIHsKCSAgICAgIHNlbGYucG9ydCA9IHBvcnQuc3Vic3RyKDEpOwoJICAgIH0KCSAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7CgkgIH0KCSAgaWYgKGhvc3QpIHNlbGYuaG9zdG5hbWUgPSBob3N0OwoJfQoKCXZhciBoYXNGZXRjaCA9IGlzRnVuY3Rpb24oZ2xvYmFsJDEuZmV0Y2gpICYmIGlzRnVuY3Rpb24oZ2xvYmFsJDEuUmVhZGFibGVTdHJlYW0pOwoKCXZhciBfYmxvYkNvbnN0cnVjdG9yOwoJZnVuY3Rpb24gYmxvYkNvbnN0cnVjdG9yKCkgewoJICBpZiAodHlwZW9mIF9ibG9iQ29uc3RydWN0b3IgIT09ICd1bmRlZmluZWQnKSB7CgkgICAgcmV0dXJuIF9ibG9iQ29uc3RydWN0b3I7CgkgIH0KCSAgdHJ5IHsKCSAgICBuZXcgZ2xvYmFsJDEuQmxvYihbbmV3IEFycmF5QnVmZmVyKDEpXSk7CgkgICAgX2Jsb2JDb25zdHJ1Y3RvciA9IHRydWU7CgkgIH0gY2F0Y2ggKGUpIHsKCSAgICBfYmxvYkNvbnN0cnVjdG9yID0gZmFsc2U7CgkgIH0KCSAgcmV0dXJuIF9ibG9iQ29uc3RydWN0b3IKCX0KCXZhciB4aHI7CgoJZnVuY3Rpb24gY2hlY2tUeXBlU3VwcG9ydCh0eXBlKSB7CgkgIGlmICgheGhyKSB7CgkgICAgeGhyID0gbmV3IGdsb2JhbCQxLlhNTEh0dHBSZXF1ZXN0KCk7CgkgICAgLy8gSWYgbG9jYXRpb24uaG9zdCBpcyBlbXB0eSwgZS5nLiBpZiB0aGlzIHBhZ2Uvd29ya2VyIHdhcyBsb2FkZWQKCSAgICAvLyBmcm9tIGEgQmxvYiwgdGhlbiB1c2UgZXhhbXBsZS5jb20gdG8gYXZvaWQgYW4gZXJyb3IKCSAgICB4aHIub3BlbignR0VUJywgZ2xvYmFsJDEubG9jYXRpb24uaG9zdCA/ICcvJyA6ICdodHRwczovL2V4YW1wbGUuY29tJyk7CgkgIH0KCSAgdHJ5IHsKCSAgICB4aHIucmVzcG9uc2VUeXBlID0gdHlwZTsKCSAgICByZXR1cm4geGhyLnJlc3BvbnNlVHlwZSA9PT0gdHlwZQoJICB9IGNhdGNoIChlKSB7CgkgICAgcmV0dXJuIGZhbHNlCgkgIH0KCgl9CgoJLy8gRm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIFNhZmFyaSA3LjAgcmVwb3J0cyB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnb2JqZWN0Jy4KCS8vIFNhZmFyaSA3LjEgYXBwZWFycyB0byBoYXZlIGZpeGVkIHRoaXMgYnVnLgoJdmFyIGhhdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBnbG9iYWwkMS5BcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7Cgl2YXIgaGF2ZVNsaWNlID0gaGF2ZUFycmF5QnVmZmVyICYmIGlzRnVuY3Rpb24oZ2xvYmFsJDEuQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKTsKCgl2YXIgYXJyYXlidWZmZXIgPSBoYXZlQXJyYXlCdWZmZXIgJiYgY2hlY2tUeXBlU3VwcG9ydCgnYXJyYXlidWZmZXInKTsKCSAgLy8gVGhlc2UgbmV4dCB0d28gdGVzdHMgdW5hdm9pZGFibHkgc2hvdyB3YXJuaW5ncyBpbiBDaHJvbWUuIFNpbmNlIGZldGNoIHdpbGwgYWx3YXlzCgkgIC8vIGJlIHVzZWQgaWYgaXQncyBhdmFpbGFibGUsIGp1c3QgcmV0dXJuIGZhbHNlIGZvciB0aGVzZSB0byBhdm9pZCB0aGUgd2FybmluZ3MuCgl2YXIgbXNzdHJlYW0gPSAhaGFzRmV0Y2ggJiYgaGF2ZVNsaWNlICYmIGNoZWNrVHlwZVN1cHBvcnQoJ21zLXN0cmVhbScpOwoJdmFyIG1vemNodW5rZWRhcnJheWJ1ZmZlciA9ICFoYXNGZXRjaCAmJiBoYXZlQXJyYXlCdWZmZXIgJiYKCSAgY2hlY2tUeXBlU3VwcG9ydCgnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKTsKCXZhciBvdmVycmlkZU1pbWVUeXBlID0gaXNGdW5jdGlvbih4aHIub3ZlcnJpZGVNaW1lVHlwZSk7Cgl2YXIgdmJBcnJheSA9IGlzRnVuY3Rpb24oZ2xvYmFsJDEuVkJBcnJheSk7CgoJZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkgewoJICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nCgl9CgoJeGhyID0gbnVsbDsgLy8gSGVscCBnYwoKCXZhciBkb21haW47CgoJLy8gVGhpcyBjb25zdHJ1Y3RvciBpcyB1c2VkIHRvIHN0b3JlIGV2ZW50IGhhbmRsZXJzLiBJbnN0YW50aWF0aW5nIHRoaXMgaXMKCS8vIGZhc3RlciB0aGFuIGV4cGxpY2l0bHkgY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgdG8gZ2V0IGEgImNsZWFuIiBlbXB0eQoJLy8gb2JqZWN0ICh0ZXN0ZWQgd2l0aCB2OCB2NC45KS4KCWZ1bmN0aW9uIEV2ZW50SGFuZGxlcnMoKSB7fQoJRXZlbnRIYW5kbGVycy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpOwoKCWZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHsKCSAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTsKCX0KCgkvLyBub2RlanMgb2RkaXR5CgkvLyByZXF1aXJlKCdldmVudHMnKSA9PT0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyCglFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyOwoKCUV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMgPSBmYWxzZTsKCglFdmVudEVtaXR0ZXIucHJvdG90eXBlLmRvbWFpbiA9IHVuZGVmaW5lZDsKCUV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDsKCUV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDsKCgkvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmUKCS8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuCglFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwOwoKCUV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7CgkgIHRoaXMuZG9tYWluID0gbnVsbDsKCSAgaWYgKEV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMpIHsKCSAgICAvLyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgZG9tYWluLCB0aGVuIGF0dGFjaCB0byBpdC4KCSAgICBpZiAoZG9tYWluLmFjdGl2ZSApIDsKCSAgfQoKCSAgaWYgKCF0aGlzLl9ldmVudHMgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykgewoJICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7CgkgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwOwoJICB9CgoJICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkOwoJfTsKCgkvLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3MKCS8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLgoJRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikgewoJICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKQoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJuIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7CgkgIHRoaXMuX21heExpc3RlbmVycyA9IG47CgkgIHJldHVybiB0aGlzOwoJfTsKCglmdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHsKCSAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKQoJICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVyczsKCSAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVyczsKCX0KCglFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHsKCSAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7Cgl9OwoKCS8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnQKCS8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2YKCS8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlCgkvLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlCgkvLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuCglmdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7CgkgIGlmIChpc0ZuKQoJICAgIGhhbmRsZXIuY2FsbChzZWxmKTsKCSAgZWxzZSB7CgkgICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoOwoJICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7CgkgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkKCSAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpOwoJICB9Cgl9CglmdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHsKCSAgaWYgKGlzRm4pCgkgICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpOwoJICBlbHNlIHsKCSAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7CgkgICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTsKCSAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKQoJICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7CgkgIH0KCX0KCWZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikgewoJICBpZiAoaXNGbikKCSAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7CgkgIGVsc2UgewoJICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDsKCSAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pOwoJICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpCgkgICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTsKCSAgfQoJfQoJZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHsKCSAgaWYgKGlzRm4pCgkgICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpOwoJICBlbHNlIHsKCSAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7CgkgICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTsKCSAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKQoJICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7CgkgIH0KCX0KCglmdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7CgkgIGlmIChpc0ZuKQoJICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7CgkgIGVsc2UgewoJICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDsKCSAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pOwoJICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpCgkgICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7CgkgIH0KCX0KCglFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHsKCSAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cywgZG9tYWluOwoJICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTsKCgkgIGV2ZW50cyA9IHRoaXMuX2V2ZW50czsKCSAgaWYgKGV2ZW50cykKCSAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpOwoJICBlbHNlIGlmICghZG9FcnJvcikKCSAgICByZXR1cm4gZmFsc2U7CgoJICBkb21haW4gPSB0aGlzLmRvbWFpbjsKCgkgIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy4KCSAgaWYgKGRvRXJyb3IpIHsKCSAgICBlciA9IGFyZ3VtZW50c1sxXTsKCSAgICBpZiAoZG9tYWluKSB7CgkgICAgICBpZiAoIWVyKQoJICAgICAgICBlciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkICJlcnJvciIgZXZlbnQnKTsKCSAgICAgIGVyLmRvbWFpbkVtaXR0ZXIgPSB0aGlzOwoJICAgICAgZXIuZG9tYWluID0gZG9tYWluOwoJICAgICAgZXIuZG9tYWluVGhyb3duID0gZmFsc2U7CgkgICAgICBkb21haW4uZW1pdCgnZXJyb3InLCBlcik7CgkgICAgfSBlbHNlIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7CgkgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnQKCSAgICB9IGVsc2UgewoJICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlcgoJICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkICJlcnJvciIgZXZlbnQuICgnICsgZXIgKyAnKScpOwoJICAgICAgZXJyLmNvbnRleHQgPSBlcjsKCSAgICAgIHRocm93IGVycjsKCSAgICB9CgkgICAgcmV0dXJuIGZhbHNlOwoJICB9CgoJICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdOwoKCSAgaWYgKCFoYW5kbGVyKQoJICAgIHJldHVybiBmYWxzZTsKCgkgIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7CgkgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7CgkgIHN3aXRjaCAobGVuKSB7CgkgICAgLy8gZmFzdCBjYXNlcwoJICAgIGNhc2UgMToKCSAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpOwoJICAgICAgYnJlYWs7CgkgICAgY2FzZSAyOgoJICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pOwoJICAgICAgYnJlYWs7CgkgICAgY2FzZSAzOgoJICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7CgkgICAgICBicmVhazsKCSAgICBjYXNlIDQ6CgkgICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7CgkgICAgICBicmVhazsKCSAgICAvLyBzbG93ZXIKCSAgICBkZWZhdWx0OgoJICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsKCSAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykKCSAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07CgkgICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTsKCSAgfQoKCSAgcmV0dXJuIHRydWU7Cgl9OwoKCWZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7CgkgIHZhciBtOwoJICB2YXIgZXZlbnRzOwoJICB2YXIgZXhpc3Rpbmc7CgoJICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKQoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0ZW5lciIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgoJICBldmVudHMgPSB0YXJnZXQuX2V2ZW50czsKCSAgaWYgKCFldmVudHMpIHsKCSAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7CgkgICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7CgkgIH0gZWxzZSB7CgkgICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gIm5ld0xpc3RlbmVyIiEgQmVmb3JlCgkgICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgIm5ld0xpc3RlbmVyIi4KCSAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7CgkgICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLAoJICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTsKCgkgICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlCgkgICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0CgkgICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50czsKCSAgICB9CgkgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07CgkgIH0KCgkgIGlmICghZXhpc3RpbmcpIHsKCSAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC4KCSAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyOwoJICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDsKCSAgfSBlbHNlIHsKCSAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7CgkgICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS4KCSAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDoKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtleGlzdGluZywgbGlzdGVuZXJdOwoJICAgIH0gZWxzZSB7CgkgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuCgkgICAgICBpZiAocHJlcGVuZCkgewoJICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTsKCSAgICAgIH0gZWxzZSB7CgkgICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpOwoJICAgICAgfQoJICAgIH0KCgkgICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWsKCSAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkgewoJICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTsKCSAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHsKCSAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTsKCSAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgdHlwZSArICcgbGlzdGVuZXJzIGFkZGVkLiAnICsKCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQnKTsKCSAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7CgkgICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDsKCSAgICAgICAgdy50eXBlID0gdHlwZTsKCSAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDsKCSAgICAgICAgZW1pdFdhcm5pbmcodyk7CgkgICAgICB9CgkgICAgfQoJICB9CgoJICByZXR1cm4gdGFyZ2V0OwoJfQoJZnVuY3Rpb24gZW1pdFdhcm5pbmcoZSkgewoJICB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nID8gY29uc29sZS53YXJuKGUpIDogY29uc29sZS5sb2coZSk7Cgl9CglFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKCSAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpOwoJfTsKCglFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjsKCglFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9CgkgICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7CgkgICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTsKCSAgICB9OwoKCWZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7CgkgIHZhciBmaXJlZCA9IGZhbHNlOwoJICBmdW5jdGlvbiBnKCkgewoJICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTsKCSAgICBpZiAoIWZpcmVkKSB7CgkgICAgICBmaXJlZCA9IHRydWU7CgkgICAgICBsaXN0ZW5lci5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7CgkgICAgfQoJICB9CgkgIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjsKCSAgcmV0dXJuIGc7Cgl9CgoJRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikgewoJICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKQoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0ZW5lciIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgkgIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7CgkgIHJldHVybiB0aGlzOwoJfTsKCglFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPQoJICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKCSAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpCgkgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0ZW5lciIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgkgICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTsKCSAgICAgIHJldHVybiB0aGlzOwoJICAgIH07CgoJLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQKCUV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPQoJICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7CgkgICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjsKCgkgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKQoJICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdGVuZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpOwoKCSAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50czsKCSAgICAgIGlmICghZXZlbnRzKQoJICAgICAgICByZXR1cm4gdGhpczsKCgkgICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdOwoJICAgICAgaWYgKCFsaXN0KQoJICAgICAgICByZXR1cm4gdGhpczsKCgkgICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgKGxpc3QubGlzdGVuZXIgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7CgkgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKQoJICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7CgkgICAgICAgIGVsc2UgewoJICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07CgkgICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcikKCSAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTsKCSAgICAgICAgfQoJICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykgewoJICAgICAgICBwb3NpdGlvbiA9IC0xOwoKCSAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGg7IGktLSA+IDA7KSB7CgkgICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8CgkgICAgICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkgewoJICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7CgkgICAgICAgICAgICBwb3NpdGlvbiA9IGk7CgkgICAgICAgICAgICBicmVhazsKCSAgICAgICAgICB9CgkgICAgICAgIH0KCgkgICAgICAgIGlmIChwb3NpdGlvbiA8IDApCgkgICAgICAgICAgcmV0dXJuIHRoaXM7CgoJICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHsKCSAgICAgICAgICBsaXN0WzBdID0gdW5kZWZpbmVkOwoJICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB7CgkgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpOwoJICAgICAgICAgICAgcmV0dXJuIHRoaXM7CgkgICAgICAgICAgfSBlbHNlIHsKCSAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07CgkgICAgICAgICAgfQoJICAgICAgICB9IGVsc2UgewoJICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7CgkgICAgICAgIH0KCgkgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpCgkgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpOwoJICAgICAgfQoKCSAgICAgIHJldHVybiB0aGlzOwoJICAgIH07CgoJRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPQoJICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7CgkgICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHM7CgoJICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzOwoJICAgICAgaWYgKCFldmVudHMpCgkgICAgICAgIHJldHVybiB0aGlzOwoKCSAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXQKCSAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7CgkgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7CgkgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTsKCSAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7CgkgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7CgkgICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApCgkgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpOwoJICAgICAgICAgIGVsc2UKCSAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07CgkgICAgICAgIH0KCSAgICAgICAgcmV0dXJuIHRoaXM7CgkgICAgICB9CgoJICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzCgkgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgewoJICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7CgkgICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXk7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7CgkgICAgICAgICAga2V5ID0ga2V5c1tpXTsKCSAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTsKCSAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpOwoJICAgICAgICB9CgkgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpOwoJICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpOwoJICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7CgkgICAgICAgIHJldHVybiB0aGlzOwoJICAgICAgfQoKCSAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTsKCgkgICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykgewoJICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7CgkgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykgewoJICAgICAgICAvLyBMSUZPIG9yZGVyCgkgICAgICAgIGRvIHsKCSAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pOwoJICAgICAgICB9IHdoaWxlIChsaXN0ZW5lcnNbMF0pOwoJICAgICAgfQoKCSAgICAgIHJldHVybiB0aGlzOwoJICAgIH07CgoJRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkgewoJICB2YXIgZXZsaXN0ZW5lcjsKCSAgdmFyIHJldDsKCSAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50czsKCgkgIGlmICghZXZlbnRzKQoJICAgIHJldCA9IFtdOwoJICBlbHNlIHsKCSAgICBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdOwoJICAgIGlmICghZXZsaXN0ZW5lcikKCSAgICAgIHJldCA9IFtdOwoJICAgIGVsc2UgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKQoJICAgICAgcmV0ID0gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl07CgkgICAgZWxzZQoJICAgICAgcmV0ID0gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpOwoJICB9CgoJICByZXR1cm4gcmV0OwoJfTsKCglFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHsKCSAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHsKCSAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpOwoJICB9IGVsc2UgewoJICAgIHJldHVybiBsaXN0ZW5lckNvdW50JDEuY2FsbChlbWl0dGVyLCB0eXBlKTsKCSAgfQoJfTsKCglFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50JDE7CglmdW5jdGlvbiBsaXN0ZW5lckNvdW50JDEodHlwZSkgewoJICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzOwoKCSAgaWYgKGV2ZW50cykgewoJICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdOwoKCSAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHsKCSAgICAgIHJldHVybiAxOwoJICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikgewoJICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoOwoJICAgIH0KCSAgfQoKCSAgcmV0dXJuIDA7Cgl9CgoJRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHsKCSAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107Cgl9OwoKCS8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS4KCWZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkgewoJICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpCgkgICAgbGlzdFtpXSA9IGxpc3Rba107CgkgIGxpc3QucG9wKCk7Cgl9CgoJZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIGkpIHsKCSAgdmFyIGNvcHkgPSBuZXcgQXJyYXkoaSk7CgkgIHdoaWxlIChpLS0pCgkgICAgY29weVtpXSA9IGFycltpXTsKCSAgcmV0dXJuIGNvcHk7Cgl9CgoJZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikgewoJICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOwoJICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkgewoJICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07CgkgIH0KCSAgcmV0dXJuIHJldDsKCX0KCglmdW5jdGlvbiBCdWZmZXJMaXN0KCkgewoJICB0aGlzLmhlYWQgPSBudWxsOwoJICB0aGlzLnRhaWwgPSBudWxsOwoJICB0aGlzLmxlbmd0aCA9IDA7Cgl9CgoJQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2KSB7CgkgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9OwoJICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7CgkgIHRoaXMudGFpbCA9IGVudHJ5OwoJICArK3RoaXMubGVuZ3RoOwoJfTsKCglCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKHYpIHsKCSAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTsKCSAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTsKCSAgdGhpcy5oZWFkID0gZW50cnk7CgkgICsrdGhpcy5sZW5ndGg7Cgl9OwoKCUJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkgewoJICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjsKCSAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhOwoJICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDsKCSAgLS10aGlzLmxlbmd0aDsKCSAgcmV0dXJuIHJldDsKCX07CgoJQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7CgkgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7CgkgIHRoaXMubGVuZ3RoID0gMDsKCX07CgoJQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChzKSB7CgkgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnOwoJICB2YXIgcCA9IHRoaXMuaGVhZDsKCSAgdmFyIHJldCA9ICcnICsgcC5kYXRhOwoJICB3aGlsZSAocCA9IHAubmV4dCkgewoJICAgIHJldCArPSBzICsgcC5kYXRhOwoJICB9cmV0dXJuIHJldDsKCX07CgoJQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG4pIHsKCSAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyJDEuYWxsb2MoMCk7CgkgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhOwoJICB2YXIgcmV0ID0gQnVmZmVyJDEuYWxsb2NVbnNhZmUobiA+Pj4gMCk7CgkgIHZhciBwID0gdGhpcy5oZWFkOwoJICB2YXIgaSA9IDA7CgkgIHdoaWxlIChwKSB7CgkgICAgcC5kYXRhLmNvcHkocmV0LCBpKTsKCSAgICBpICs9IHAuZGF0YS5sZW5ndGg7CgkgICAgcCA9IHAubmV4dDsKCSAgfQoJICByZXR1cm4gcmV0OwoJfTsKCgl2YXIgc3RyaW5nX2RlY29kZXIgPSB7fTsKCgl2YXIgc2FmZUJ1ZmZlciA9IHtleHBvcnRzOiB7fX07CgoJLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovCgoJKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHsKCS8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi8KCXZhciBidWZmZXIgPSBidWZmZXJFczY7Cgl2YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcjsKCgkvLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzCglmdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7CgkgIGZvciAodmFyIGtleSBpbiBzcmMpIHsKCSAgICBkc3Rba2V5XSA9IHNyY1trZXldOwoJICB9Cgl9CglpZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7CgkgIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyOwoJfSBlbHNlIHsKCSAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJykKCSAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cyk7CgkgIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlcjsKCX0KCglmdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewoJICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQoJfQoKCVNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTsKCgkvLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyCgljb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKTsKCglTYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKCSAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKQoJICB9CgkgIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCgl9OwoKCVNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHsKCSAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQoJICB9CgkgIHZhciBidWYgPSBCdWZmZXIoc2l6ZSk7CgkgIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHsKCSAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgewoJICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpOwoJICAgIH0gZWxzZSB7CgkgICAgICBidWYuZmlsbChmaWxsKTsKCSAgICB9CgkgIH0gZWxzZSB7CgkgICAgYnVmLmZpbGwoMCk7CgkgIH0KCSAgcmV0dXJuIGJ1ZgoJfTsKCglTYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHsKCSAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQoJICB9CgkgIHJldHVybiBCdWZmZXIoc2l6ZSkKCX07CgoJU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkgewoJICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpCgkgIH0KCSAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpCgl9OwoJfShzYWZlQnVmZmVyLCBzYWZlQnVmZmVyLmV4cG9ydHMpKTsKCgkvKjxyZXBsYWNlbWVudD4qLwoKCXZhciBCdWZmZXIgPSBzYWZlQnVmZmVyLmV4cG9ydHMuQnVmZmVyOwoJLyo8L3JlcGxhY2VtZW50PiovCgoJdmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHsKCSAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nOwoJICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHsKCSAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzoKCSAgICAgIHJldHVybiB0cnVlOwoJICAgIGRlZmF1bHQ6CgkgICAgICByZXR1cm4gZmFsc2U7CgkgIH0KCX07CgoJZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykgewoJICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JzsKCSAgdmFyIHJldHJpZWQ7CgkgIHdoaWxlICh0cnVlKSB7CgkgICAgc3dpdGNoIChlbmMpIHsKCSAgICAgIGNhc2UgJ3V0ZjgnOgoJICAgICAgY2FzZSAndXRmLTgnOgoJICAgICAgICByZXR1cm4gJ3V0ZjgnOwoJICAgICAgY2FzZSAndWNzMic6CgkgICAgICBjYXNlICd1Y3MtMic6CgkgICAgICBjYXNlICd1dGYxNmxlJzoKCSAgICAgIGNhc2UgJ3V0Zi0xNmxlJzoKCSAgICAgICAgcmV0dXJuICd1dGYxNmxlJzsKCSAgICAgIGNhc2UgJ2xhdGluMSc6CgkgICAgICBjYXNlICdiaW5hcnknOgoJICAgICAgICByZXR1cm4gJ2xhdGluMSc7CgkgICAgICBjYXNlICdiYXNlNjQnOgoJICAgICAgY2FzZSAnYXNjaWknOgoJICAgICAgY2FzZSAnaGV4JzoKCSAgICAgICAgcmV0dXJuIGVuYzsKCSAgICAgIGRlZmF1bHQ6CgkgICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZAoJICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7CgkgICAgICAgIHJldHJpZWQgPSB0cnVlOwoJICAgIH0KCSAgfQoJfQoJLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lCgkvLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzCglmdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHsKCSAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTsKCSAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7CgkgIHJldHVybiBuZW5jIHx8IGVuYzsKCX0KCgkvLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mCgkvLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGUKCS8vIGNoYXJhY3RlcnMuCgl2YXIgU3RyaW5nRGVjb2Rlcl8xID0gc3RyaW5nX2RlY29kZXIuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXIkMTsKCWZ1bmN0aW9uIFN0cmluZ0RlY29kZXIkMShlbmNvZGluZykgewoJICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpOwoJICB2YXIgbmI7CgkgIHN3aXRjaCAodGhpcy5lbmNvZGluZykgewoJICAgIGNhc2UgJ3V0ZjE2bGUnOgoJICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0OwoJICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDsKCSAgICAgIG5iID0gNDsKCSAgICAgIGJyZWFrOwoJICAgIGNhc2UgJ3V0ZjgnOgoJICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDsKCSAgICAgIG5iID0gNDsKCSAgICAgIGJyZWFrOwoJICAgIGNhc2UgJ2Jhc2U2NCc6CgkgICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0OwoJICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7CgkgICAgICBuYiA9IDM7CgkgICAgICBicmVhazsKCSAgICBkZWZhdWx0OgoJICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlOwoJICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7CgkgICAgICByZXR1cm47CgkgIH0KCSAgdGhpcy5sYXN0TmVlZCA9IDA7CgkgIHRoaXMubGFzdFRvdGFsID0gMDsKCSAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7Cgl9CgoJU3RyaW5nRGVjb2RlciQxLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHsKCSAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJzsKCSAgdmFyIHI7CgkgIHZhciBpOwoJICBpZiAodGhpcy5sYXN0TmVlZCkgewoJICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7CgkgICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnOwoJICAgIGkgPSB0aGlzLmxhc3ROZWVkOwoJICAgIHRoaXMubGFzdE5lZWQgPSAwOwoJICB9IGVsc2UgewoJICAgIGkgPSAwOwoJICB9CgkgIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTsKCSAgcmV0dXJuIHIgfHwgJyc7Cgl9OwoKCVN0cmluZ0RlY29kZXIkMS5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDsKCgkvLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlcgoJU3RyaW5nRGVjb2RlciQxLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7CgoJLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlcgoJU3RyaW5nRGVjb2RlciQxLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHsKCSAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkgewoJICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7CgkgICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpOwoJICB9CgkgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7CgkgIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKCX07CgoJLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYQoJLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuCglmdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHsKCSAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7CgkgIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yOwoJfQoKCS8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW4KCS8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpCgkvLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLgoJZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHsKCSAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTsKCSAgaWYgKGogPCBpKSByZXR1cm4gMDsKCSAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pOwoJICBpZiAobmIgPj0gMCkgewoJICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7CgkgICAgcmV0dXJuIG5iOwoJICB9CgkgIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7CgkgIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pOwoJICBpZiAobmIgPj0gMCkgewoJICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7CgkgICAgcmV0dXJuIG5iOwoJICB9CgkgIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7CgkgIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pOwoJICBpZiAobmIgPj0gMCkgewoJICAgIGlmIChuYiA+IDApIHsKCSAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMzsKCSAgICB9CgkgICAgcmV0dXJuIG5iOwoJICB9CgkgIHJldHVybiAwOwoJfQoKCS8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhcwoJLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3QKCS8vIG9uZSwgd2UgInJlcGxhY2UiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGgKCS8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1x1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nCgkvLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlCgkvLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLgoJLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYQoJLy8gbG9vcC4KCWZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7CgkgIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHsKCSAgICBzZWxmLmxhc3ROZWVkID0gMDsKCSAgICByZXR1cm4gJ1x1ZmZmZCc7CgkgIH0KCSAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7CgkgICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkgewoJICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7CgkgICAgICByZXR1cm4gJ1x1ZmZmZCc7CgkgICAgfQoJICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikgewoJICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkgewoJICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjsKCSAgICAgICAgcmV0dXJuICdcdWZmZmQnOwoJICAgICAgfQoJICAgIH0KCSAgfQoJfQoKCS8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci4KCWZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHsKCSAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7CgkgIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYpOwoJICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjsKCSAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkgewoJICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpOwoJICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTsKCSAgfQoJICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTsKCSAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoOwoJfQoKCS8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYQoJLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkCgkvLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS4KCWZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkgewoJICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7CgkgIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpOwoJICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsOwoJICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpOwoJICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpOwoJICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTsKCX0KCgkvLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbAoJLy8gY2hhcmFjdGVyLgoJZnVuY3Rpb24gdXRmOEVuZChidWYpIHsKCSAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnOwoJICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXHVmZmZkJzsKCSAgcmV0dXJuIHI7Cgl9CgoJLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW4KCS8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoCgkvLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG8KCS8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuCglmdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7CgkgIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkgewoJICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7CgkgICAgaWYgKHIpIHsKCSAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7CgkgICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHsKCSAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7CgkgICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDsKCSAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07CgkgICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdOwoJICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7CgkgICAgICB9CgkgICAgfQoJICAgIHJldHVybiByOwoJICB9CgkgIHRoaXMubGFzdE5lZWQgPSAxOwoJICB0aGlzLmxhc3RUb3RhbCA9IDI7CgkgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdOwoJICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpOwoJfQoKCS8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlCgkvLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC4KCWZ1bmN0aW9uIHV0ZjE2RW5kKGJ1ZikgewoJICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7CgkgIGlmICh0aGlzLmxhc3ROZWVkKSB7CgkgICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDsKCSAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpOwoJICB9CgkgIHJldHVybiByOwoJfQoKCWZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7CgkgIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7CgkgIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTsKCSAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuOwoJICB0aGlzLmxhc3RUb3RhbCA9IDM7CgkgIGlmIChuID09PSAxKSB7CgkgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CgkgIH0gZWxzZSB7CgkgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07CgkgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CgkgIH0KCSAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pOwoJfQoKCWZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHsKCSAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnOwoJICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7CgkgIHJldHVybiByOwoJfQoKCS8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleCkKCWZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1ZikgewoJICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOwoJfQoKCWZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHsKCSAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7Cgl9CgoJUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7CgoJdmFyIGRlYnVnJDIgPSBkZWJ1Z2xvZygnc3RyZWFtJyk7Cglpbmhlcml0cyQxKFJlYWRhYmxlLCBFdmVudEVtaXR0ZXIpOwoKCWZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHsKCSAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd24KCSAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uCgkgIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHsKCSAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsKCSAgfSBlbHNlIHsKCSAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55CgkgICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzCgkgICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZQoJICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay4KCSAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkKCSAgICAgIGVtaXR0ZXIub24oZXZlbnQsIGZuKTsKCSAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKQoJICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTsKCSAgICBlbHNlCgkgICAgICBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTsKCSAgfQoJfQoJZnVuY3Rpb24gbGlzdGVuZXJDb3VudCAoZW1pdHRlciwgdHlwZSkgewoJICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoOwoJfQoJZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHsKCgkgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwoKCSAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG8KCSAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXkKCSAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7CgoJICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsKCgkgIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyCgkgIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXIiCgkgIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7CgkgIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7CgkgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtOwoKCSAgLy8gY2FzdCB0byBpbnRzLgoJICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7CgoJICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZQoJICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhbgoJICAvLyBhcnJheS5zaGlmdCgpCgkgIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTsKCSAgdGhpcy5sZW5ndGggPSAwOwoJICB0aGlzLnBpcGVzID0gbnVsbDsKCSAgdGhpcy5waXBlc0NvdW50ID0gMDsKCSAgdGhpcy5mbG93aW5nID0gbnVsbDsKCSAgdGhpcy5lbmRlZCA9IGZhbHNlOwoJICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTsKCSAgdGhpcy5yZWFkaW5nID0gZmFsc2U7CgoJICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSwKCSAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnkKCSAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgImxhdGVyIiBzaG91bGQgZ2VuZXJhbGx5IGFsc28KCSAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuCgkgIHRoaXMuc3luYyA9IHRydWU7CgoJICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheQoJICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi4KCSAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTsKCSAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKCSAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlOwoJICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlOwoKCSAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZwoJICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuCgkgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC4KCSAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7CgoJICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuCgkgIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suCgkgIHRoaXMucmFuT3V0ID0gZmFsc2U7CgoJICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpcwoJICB0aGlzLmF3YWl0RHJhaW4gPSAwOwoKCSAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZAoJICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7CgoJICB0aGlzLmRlY29kZXIgPSBudWxsOwoJICB0aGlzLmVuY29kaW5nID0gbnVsbDsKCSAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHsKCSAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2Rlcl8xKG9wdGlvbnMuZW5jb2RpbmcpOwoJICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nOwoJICB9Cgl9CglmdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7CgoJICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOwoKCSAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpOwoKCSAgLy8gbGVnYWN5CgkgIHRoaXMucmVhZGFibGUgPSB0cnVlOwoKCSAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDsKCgkgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpOwoJfQoKCS8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLgoJLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsCgkvLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkCgkvLyB3cml0ZSgpIHNvbWUgbW9yZS4KCVJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykgewoJICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwoKCSAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHsKCSAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZzsKCSAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7CgkgICAgICBjaHVuayA9IEJ1ZmZlciQxLmZyb20oY2h1bmssIGVuY29kaW5nKTsKCSAgICAgIGVuY29kaW5nID0gJyc7CgkgICAgfQoJICB9CgoJICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7Cgl9OwoKCS8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpCglSZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykgewoJICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwoJICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTsKCX07CgoJUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkgewoJICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTsKCX07CgoJZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHsKCSAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7CgkgIGlmIChlcikgewoJICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKCSAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkgewoJICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTsKCSAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpOwoJICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkgewoJICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkgewoJICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7CgkgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTsKCSAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkgewoJICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpOwoJICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpOwoJICAgIH0gZWxzZSB7CgkgICAgICB2YXIgc2tpcEFkZDsKCSAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykgewoJICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOwoJICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwOwoJICAgICAgfQoKCSAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlOwoKCSAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZAoJICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlCgkgICAgICBpZiAoIXNraXBBZGQpIHsKCSAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC4KCSAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7CgkgICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7CgkgICAgICAgICAgc3RyZWFtLnJlYWQoMCk7CgkgICAgICAgIH0gZWxzZSB7CgkgICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby4KCSAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CgkgICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTsKCgkgICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7CgkgICAgICAgIH0KCSAgICAgIH0KCgkgICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpOwoJICAgIH0KCSAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkgewoJICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTsKCSAgfQoKCSAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7Cgl9CgoJLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS4KCS8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lCgkvLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwKCS8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhCgkvLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXQKCS8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyCgkvLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLgoJZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7CgkgIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7Cgl9CgoJLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuCglSZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7CgkgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyXzEoZW5jKTsKCSAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYzsKCSAgcmV0dXJuIHRoaXM7Cgl9OwoKCS8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUIKCXZhciBNQVhfSFdNID0gMHg4MDAwMDA7CglmdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7CgkgIGlmIChuID49IE1BWF9IV00pIHsKCSAgICBuID0gTUFYX0hXTTsKCSAgfSBlbHNlIHsKCSAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW4KCSAgICAvLyB0aW55IGFtb3VudHMKCSAgICBuLS07CgkgICAgbiB8PSBuID4+PiAxOwoJICAgIG4gfD0gbiA+Pj4gMjsKCSAgICBuIHw9IG4gPj4+IDQ7CgkgICAgbiB8PSBuID4+PiA4OwoJICAgIG4gfD0gbiA+Pj4gMTY7CgkgICAgbisrOwoJICB9CgkgIHJldHVybiBuOwoJfQoKCS8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCgkvLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LgoJZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkgewoJICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7CgkgIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTsKCSAgaWYgKG4gIT09IG4pIHsKCSAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWUKCSAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7CgkgIH0KCSAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uCgkgIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pOwoJICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOwoJICAvLyBEb24ndCBoYXZlIGVub3VnaAoJICBpZiAoIXN0YXRlLmVuZGVkKSB7CgkgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKCSAgICByZXR1cm4gMDsKCSAgfQoJICByZXR1cm4gc3RhdGUubGVuZ3RoOwoJfQoKCS8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuCglSZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7CgkgIGRlYnVnJDIoJ3JlYWQnLCBuKTsKCSAgbiA9IHBhcnNlSW50KG4sIDEwKTsKCSAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKCSAgdmFyIG5PcmlnID0gbjsKCgkgIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKCgkgIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2UKCSAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlcgoJICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi4KCSAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHsKCSAgICBkZWJ1ZyQyKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTsKCSAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTsKCSAgICByZXR1cm4gbnVsbDsKCSAgfQoKCSAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOwoKCSAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLgoJICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgewoJICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpOwoJICAgIHJldHVybiBudWxsOwoJICB9CgoJICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlCgkgIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpbgoJICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkCgkgIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2UKCSAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW4KCSAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guCgkgIC8vCgkgIC8vIFNvLCB0aGUgc3RlcHMgYXJlOgoJICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvCgkgIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuCgkgIC8vCgkgIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuCgkgIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpcwoJICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW4KCSAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZQoJICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLgoJICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGwKCSAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdAoJICAvLyAncmVhZGFibGUnIGV0Yy4KCSAgLy8KCSAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLgoKCSAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLgoJICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlOwoJICBkZWJ1ZyQyKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsKCgkgIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZQoJICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7CgkgICAgZG9SZWFkID0gdHJ1ZTsKCSAgICBkZWJ1ZyQyKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7CgkgIH0KCgkgIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5CgkgIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS4KCSAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHsKCSAgICBkb1JlYWQgPSBmYWxzZTsKCSAgICBkZWJ1ZyQyKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTsKCSAgfSBlbHNlIGlmIChkb1JlYWQpIHsKCSAgICBkZWJ1ZyQyKCdkbyByZWFkJyk7CgkgICAgc3RhdGUucmVhZGluZyA9IHRydWU7CgkgICAgc3RhdGUuc3luYyA9IHRydWU7CgkgICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC4KCSAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwoJICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2QKCSAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspOwoJICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsKCSAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLAoJICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci4KCSAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7CgkgIH0KCgkgIHZhciByZXQ7CgkgIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDsKCgkgIGlmIChyZXQgPT09IG51bGwpIHsKCSAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwoJICAgIG4gPSAwOwoJICB9IGVsc2UgewoJICAgIHN0YXRlLmxlbmd0aCAtPSBuOwoJICB9CgoJICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7CgkgICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93CgkgICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLgoJICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CgoJICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay4KCSAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpOwoJICB9CgoJICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpOwoKCSAgcmV0dXJuIHJldDsKCX07CgoJZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykgewoJICB2YXIgZXIgPSBudWxsOwoJICBpZiAoIUJ1ZmZlciQxLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHsKCSAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTsKCSAgfQoJICByZXR1cm4gZXI7Cgl9CgoJZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7CgkgIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuOwoJICBpZiAoc3RhdGUuZGVjb2RlcikgewoJICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7CgkgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgewoJICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspOwoJICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwoJICAgIH0KCSAgfQoJICBzdGF0ZS5lbmRlZCA9IHRydWU7CgoJICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC4KCSAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7Cgl9CgoJLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyCgkvLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXIKCS8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC4KCWZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHsKCSAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwoJICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTsKCSAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHsKCSAgICBkZWJ1ZyQyKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTsKCSAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlOwoJICAgIGlmIChzdGF0ZS5zeW5jKSBuZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pOwoJICB9Cgl9CgoJZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHsKCSAgZGVidWckMignZW1pdCByZWFkYWJsZScpOwoJICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTsKCSAgZmxvdyhzdHJlYW0pOwoJfQoKCS8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsCgkvLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkCgkvLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZgoJLy8gaXQncyBpbiBwcm9ncmVzcy4KCS8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sCgkvLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LgoJZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7CgkgIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHsKCSAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7CgkgICAgbmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpOwoJICB9Cgl9CgoJZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkgewoJICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoOwoJICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHsKCSAgICBkZWJ1ZyQyKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpOwoJICAgIHN0cmVhbS5yZWFkKDApOwoJICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkKCSAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuCgkgICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDsKCSAgfQoJICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlOwoJfQoKCS8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy4KCS8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguCgkvLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgImxlbmd0aCIgaXMgc29tZXdoYXQKCS8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC4KCVJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7CgkgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTsKCX07CgoJUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHsKCSAgdmFyIHNyYyA9IHRoaXM7CgkgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CgoJICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHsKCSAgICBjYXNlIDA6CgkgICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7CgkgICAgICBicmVhazsKCSAgICBjYXNlIDE6CgkgICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07CgkgICAgICBicmVhazsKCSAgICBkZWZhdWx0OgoJICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTsKCSAgICAgIGJyZWFrOwoJICB9CgkgIHN0YXRlLnBpcGVzQ291bnQgKz0gMTsKCSAgZGVidWckMigncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpOwoKCSAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKTsKCgkgIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwOwoJICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgbmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTsKCgkgIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTsKCSAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHsKCSAgICBkZWJ1ZyQyKCdvbnVucGlwZScpOwoJICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7CgkgICAgICBjbGVhbnVwKCk7CgkgICAgfQoJICB9CgoJICBmdW5jdGlvbiBvbmVuZCgpIHsKCSAgICBkZWJ1ZyQyKCdvbmVuZCcpOwoJICAgIGRlc3QuZW5kKCk7CgkgIH0KCgkgIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXIKCSAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpCgkgIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzCgkgIC8vIHRvbyBzbG93LgoJICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7CgkgIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7CgoJICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7CgkgIGZ1bmN0aW9uIGNsZWFudXAoKSB7CgkgICAgZGVidWckMignY2xlYW51cCcpOwoJICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW4KCSAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpOwoJICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCSAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pOwoJICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CgkgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpOwoJICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpOwoJICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7CgkgICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTsKCgkgICAgY2xlYW5lZFVwID0gdHJ1ZTsKCgkgICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpcwoJICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydAoJICAgIC8vIGZsb3dpbmcgYWdhaW4uCgkgICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LgoJICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS4KCSAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7CgkgIH0KCgkgIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwCgkgIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlCgkgIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuCgkgIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi4KCSAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTsKCSAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTsKCSAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7CgkgICAgZGVidWckMignb25kYXRhJyk7CgkgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlOwoJICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTsKCSAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikgewoJICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlCgkgICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZQoJICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS4KCSAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLgoJICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkgewoJICAgICAgICBkZWJ1ZyQyKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7CgkgICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7CgkgICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlOwoJICAgICAgfQoJICAgICAgc3JjLnBhdXNlKCk7CgkgICAgfQoJICB9CgoJICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC4KCSAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLgoJICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7CgkgICAgZGVidWckMignb25lcnJvcicsIGVyKTsKCSAgICB1bnBpcGUoKTsKCSAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpOwoJICAgIGlmIChsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpOwoJICB9CgoJICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuCgkgIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsKCgkgIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuCgkgIGZ1bmN0aW9uIG9uY2xvc2UoKSB7CgkgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpOwoJICAgIHVucGlwZSgpOwoJICB9CgkgIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTsKCSAgZnVuY3Rpb24gb25maW5pc2goKSB7CgkgICAgZGVidWckMignb25maW5pc2gnKTsKCSAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpOwoJICAgIHVucGlwZSgpOwoJICB9CgkgIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpOwoKCSAgZnVuY3Rpb24gdW5waXBlKCkgewoJICAgIGRlYnVnJDIoJ3VucGlwZScpOwoJICAgIHNyYy51bnBpcGUoZGVzdCk7CgkgIH0KCgkgIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvCgkgIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7CgoJICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuCgkgIGlmICghc3RhdGUuZmxvd2luZykgewoJICAgIGRlYnVnJDIoJ3BpcGUgcmVzdW1lJyk7CgkgICAgc3JjLnJlc3VtZSgpOwoJICB9CgoJICByZXR1cm4gZGVzdDsKCX07CgoJZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7CgkgIHJldHVybiBmdW5jdGlvbiAoKSB7CgkgICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlOwoJICAgIGRlYnVnJDIoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7CgkgICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTsKCSAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBzcmMubGlzdGVuZXJzKCdkYXRhJykubGVuZ3RoKSB7CgkgICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsKCSAgICAgIGZsb3coc3JjKTsKCSAgICB9CgkgIH07Cgl9CgoJUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7CgkgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CgoJICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuCgkgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsKCgkgIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS4KCSAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHsKCSAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS4KCSAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7CgoJICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOwoKCSAgICAvLyBnb3QgYSBtYXRjaC4KCSAgICBzdGF0ZS5waXBlcyA9IG51bGw7CgkgICAgc3RhdGUucGlwZXNDb3VudCA9IDA7CgkgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlOwoJICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpOwoJICAgIHJldHVybiB0aGlzOwoJICB9CgoJICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLgoKCSAgaWYgKCFkZXN0KSB7CgkgICAgLy8gcmVtb3ZlIGFsbC4KCSAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlczsKCSAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDsKCSAgICBzdGF0ZS5waXBlcyA9IG51bGw7CgkgICAgc3RhdGUucGlwZXNDb3VudCA9IDA7CgkgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlOwoKCSAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7CgkgICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7CgkgICAgfXJldHVybiB0aGlzOwoJICB9CgoJICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLgoJICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpOwoJICBpZiAoaSA9PT0gLTEpIHJldHVybiB0aGlzOwoKCSAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpOwoJICBzdGF0ZS5waXBlc0NvdW50IC09IDE7CgkgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdOwoKCSAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTsKCgkgIHJldHVybiB0aGlzOwoJfTsKCgkvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yCgkvLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZwoJUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikgewoJICB2YXIgcmVzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7CgoJICBpZiAoZXYgPT09ICdkYXRhJykgewoJICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZAoJICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpOwoJICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7CgkgICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKCSAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7CgkgICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CgkgICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKCSAgICAgIGlmICghc3RhdGUucmVhZGluZykgewoJICAgICAgICBuZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTsKCSAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7CgkgICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTsKCSAgICAgIH0KCSAgICB9CgkgIH0KCgkgIHJldHVybiByZXM7Cgl9OwoJUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uOwoKCWZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikgewoJICBkZWJ1ZyQyKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTsKCSAgc2VsZi5yZWFkKDApOwoJfQoKCS8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUEkKCS8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS4KCVJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7CgkgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CgkgIGlmICghc3RhdGUuZmxvd2luZykgewoJICAgIGRlYnVnJDIoJ3Jlc3VtZScpOwoJICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOwoJICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7CgkgIH0KCSAgcmV0dXJuIHRoaXM7Cgl9OwoKCWZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7CgkgIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7CgkgICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTsKCSAgICBuZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTsKCSAgfQoJfQoKCWZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkgewoJICBpZiAoIXN0YXRlLnJlYWRpbmcpIHsKCSAgICBkZWJ1ZyQyKCdyZXN1bWUgcmVhZCAwJyk7CgkgICAgc3RyZWFtLnJlYWQoMCk7CgkgIH0KCgkgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlOwoJICBzdGF0ZS5hd2FpdERyYWluID0gMDsKCSAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpOwoJICBmbG93KHN0cmVhbSk7CgkgIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTsKCX0KCglSZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7CgkgIGRlYnVnJDIoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7CgkgIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7CgkgICAgZGVidWckMigncGF1c2UnKTsKCSAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTsKCSAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7CgkgIH0KCSAgcmV0dXJuIHRoaXM7Cgl9OwoKCWZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7CgkgIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKCSAgZGVidWckMignZmxvdycsIHN0YXRlLmZsb3dpbmcpOwoJICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fQoJfQoKCS8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuCgkvLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuCgkvLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS4KCVJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkgewoJICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwoJICB2YXIgcGF1c2VkID0gZmFsc2U7CgoJICB2YXIgc2VsZiA9IHRoaXM7CgkgIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkgewoJICAgIGRlYnVnJDIoJ3dyYXBwZWQgZW5kJyk7CgkgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7CgkgICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpOwoJICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTsKCSAgICB9CgoJICAgIHNlbGYucHVzaChudWxsKTsKCSAgfSk7CgoJICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHsKCSAgICBkZWJ1ZyQyKCd3cmFwcGVkIGRhdGEnKTsKCSAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsKCgkgICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlCgkgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuOwoKCSAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTsKCSAgICBpZiAoIXJldCkgewoJICAgICAgcGF1c2VkID0gdHJ1ZTsKCSAgICAgIHN0cmVhbS5wYXVzZSgpOwoJICAgIH0KCSAgfSk7CgoJICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuCgkgIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLgoJICBmb3IgKHZhciBpIGluIHN0cmVhbSkgewoJICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykgewoJICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHsKCSAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKCSAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpOwoJICAgICAgICB9OwoJICAgICAgfShpKTsKCSAgICB9CgkgIH0KCgkgIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy4KCSAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTsKCSAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikgewoJICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTsKCSAgfSk7CgoJICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlCgkgIC8vIHVuZGVybHlpbmcgc3RyZWFtLgoJICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHsKCSAgICBkZWJ1ZyQyKCd3cmFwcGVkIF9yZWFkJywgbik7CgkgICAgaWYgKHBhdXNlZCkgewoJICAgICAgcGF1c2VkID0gZmFsc2U7CgkgICAgICBzdHJlYW0ucmVzdW1lKCk7CgkgICAgfQoJICB9OwoKCSAgcmV0dXJuIHNlbGY7Cgl9OwoKCS8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS4KCVJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0OwoKCS8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy4KCS8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuCgkvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZwoJLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KCWZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7CgkgIC8vIG5vdGhpbmcgYnVmZmVyZWQKCSAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7CgoJICB2YXIgcmV0OwoJICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHsKCSAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3QKCSAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7CgkgICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7CgkgIH0gZWxzZSB7CgkgICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3QKCSAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTsKCSAgfQoKCSAgcmV0dXJuIHJldDsKCX0KCgkvLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuCgkvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZwoJLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KCWZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7CgkgIHZhciByZXQ7CgkgIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7CgkgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MKCSAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTsKCSAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pOwoJICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkgewoJICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaAoJICAgIHJldCA9IGxpc3Quc2hpZnQoKTsKCSAgfSBlbHNlIHsKCSAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIKCSAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTsKCSAgfQoJICByZXR1cm4gcmV0OwoJfQoKCS8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEKCS8vIGNodW5rcy4KCS8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCgkvLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LgoJZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgewoJICB2YXIgcCA9IGxpc3QuaGVhZDsKCSAgdmFyIGMgPSAxOwoJICB2YXIgcmV0ID0gcC5kYXRhOwoJICBuIC09IHJldC5sZW5ndGg7CgkgIHdoaWxlIChwID0gcC5uZXh0KSB7CgkgICAgdmFyIHN0ciA9IHAuZGF0YTsKCSAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuOwoJICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7CgkgICAgbiAtPSBuYjsKCSAgICBpZiAobiA9PT0gMCkgewoJICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7CgkgICAgICAgICsrYzsKCSAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDsKCSAgICAgIH0gZWxzZSB7CgkgICAgICAgIGxpc3QuaGVhZCA9IHA7CgkgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7CgkgICAgICB9CgkgICAgICBicmVhazsKCSAgICB9CgkgICAgKytjOwoJICB9CgkgIGxpc3QubGVuZ3RoIC09IGM7CgkgIHJldHVybiByZXQ7Cgl9CgoJLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLgoJLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKCS8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCglmdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7CgkgIHZhciByZXQgPSBCdWZmZXIkMS5hbGxvY1Vuc2FmZShuKTsKCSAgdmFyIHAgPSBsaXN0LmhlYWQ7CgkgIHZhciBjID0gMTsKCSAgcC5kYXRhLmNvcHkocmV0KTsKCSAgbiAtPSBwLmRhdGEubGVuZ3RoOwoJICB3aGlsZSAocCA9IHAubmV4dCkgewoJICAgIHZhciBidWYgPSBwLmRhdGE7CgkgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjsKCSAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7CgkgICAgbiAtPSBuYjsKCSAgICBpZiAobiA9PT0gMCkgewoJICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7CgkgICAgICAgICsrYzsKCSAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDsKCSAgICAgIH0gZWxzZSB7CgkgICAgICAgIGxpc3QuaGVhZCA9IHA7CgkgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7CgkgICAgICB9CgkgICAgICBicmVhazsKCSAgICB9CgkgICAgKytjOwoJICB9CgkgIGxpc3QubGVuZ3RoIC09IGM7CgkgIHJldHVybiByZXQ7Cgl9CgoJZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7CgkgIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKCgkgIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGEKCSAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLgoJICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCciZW5kUmVhZGFibGUoKSIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTsKCgkgIGlmICghc3RhdGUuZW5kRW1pdHRlZCkgewoJICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTsKCSAgICBuZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTsKCSAgfQoJfQoKCWZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkgewoJICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC4KCSAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkgewoJICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlOwoJICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlOwoJICAgIHN0cmVhbS5lbWl0KCdlbmQnKTsKCSAgfQoJfQoKCWZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHsKCSAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKCSAgICBmKHhzW2ldLCBpKTsKCSAgfQoJfQoKCWZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHsKCSAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKCSAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpOwoJICB9CgkgIHJldHVybiAtMTsKCX0KCgkvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy4KCVdyaXRhYmxlJDEuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7Cglpbmhlcml0cyQxKFdyaXRhYmxlJDEsIEV2ZW50RW1pdHRlcik7CgoJZnVuY3Rpb24gbm9wKCkge30KCglmdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7CgkgIHRoaXMuY2h1bmsgPSBjaHVuazsKCSAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nOwoJICB0aGlzLmNhbGxiYWNrID0gY2I7CgkgIHRoaXMubmV4dCA9IG51bGw7Cgl9CgoJZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHsKCSAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidWZmZXInLCB7CgkgICAgZ2V0OiBkZXByZWNhdGUoZnVuY3Rpb24gKCkgewoJICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7CgkgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKQoJICB9KTsKCSAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CgoJICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW0KCSAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLgoJICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTsKCgkgIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOwoKCSAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZQoJICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZgoJICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpCgkgIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7CgkgIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7CgkgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtOwoKCSAgLy8gY2FzdCB0byBpbnRzLgoJICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7CgoJICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOwoJICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKQoJICB0aGlzLmVuZGluZyA9IGZhbHNlOwoJICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkCgkgIHRoaXMuZW5kZWQgPSBmYWxzZTsKCSAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkCgkgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsKCgkgIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlPwoJICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmcKCSAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC4KCSAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTsKCSAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOwoKCSAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZwoJICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuCgkgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC4KCSAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7CgoJICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudAoJICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nCgkgIC8vIHNvY2tldCBvciBmaWxlLgoJICB0aGlzLmxlbmd0aCA9IDA7CgoJICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLgoJICB0aGlzLndyaXRpbmcgPSBmYWxzZTsKCgkgIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGwKCSAgdGhpcy5jb3JrZWQgPSAwOwoKCSAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksCgkgIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55CgkgIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsICJsYXRlciIgc2hvdWxkIGdlbmVyYWxseSBhbHNvCgkgIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLgoJICB0aGlzLnN5bmMgPSB0cnVlOwoKCSAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaAoJICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndAoJICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi4KCSAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7CgoJICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpCgkgIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikgewoJICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7CgkgIH07CgoJICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYikKCSAgdGhpcy53cml0ZWNiID0gbnVsbDsKCgkgIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC4KCSAgdGhpcy53cml0ZWxlbiA9IDA7CgoJICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CgkgIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CgoJICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrcwoJICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWQKCSAgdGhpcy5wZW5kaW5nY2IgPSAwOwoKCSAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNicwoJICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtcwoJICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7CgoJICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpbgoJICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOwoKCSAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHMKCSAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7CgoJICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzCgkgIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d28KCSAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTsKCX0KCglXcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkgewoJICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0OwoJICB2YXIgb3V0ID0gW107CgkgIHdoaWxlIChjdXJyZW50KSB7CgkgICAgb3V0LnB1c2goY3VycmVudCk7CgkgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDsKCSAgfQoJICByZXR1cm4gb3V0OwoJfTsKCWZ1bmN0aW9uIFdyaXRhYmxlJDEob3B0aW9ucykgewoKCSAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3QKCSAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLgoJICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUkMSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBXcml0YWJsZSQxKG9wdGlvbnMpOwoKCSAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpOwoKCSAgLy8gbGVnYWN5LgoJICB0aGlzLndyaXRhYmxlID0gdHJ1ZTsKCgkgIGlmIChvcHRpb25zKSB7CgkgICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7CgoJICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2OwoJICB9CgoJICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTsKCX0KCgkvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuCglXcml0YWJsZSQxLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkgewoJICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpOwoJfTsKCglmdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHsKCSAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTsKCSAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2IKCSAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwoJICBuZXh0VGljayhjYiwgZXIpOwoJfQoKCS8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLAoJLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci4KCS8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZQoJLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuCgkvLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLgoJZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHsKCSAgdmFyIHZhbGlkID0gdHJ1ZTsKCSAgdmFyIGVyID0gZmFsc2U7CgkgIC8vIEFsd2F5cyB0aHJvdyBlcnJvciBpZiBhIG51bGwgaXMgd3JpdHRlbgoJICAvLyBpZiB3ZSBhcmUgbm90IGluIG9iamVjdCBtb2RlIHRoZW4gdGhyb3cKCSAgLy8gaWYgaXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG9yIHVuZGVmaW5lZC4KCSAgaWYgKGNodW5rID09PSBudWxsKSB7CgkgICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpOwoJICB9IGVsc2UgaWYgKCFCdWZmZXIkMS5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7CgkgICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7CgkgIH0KCSAgaWYgKGVyKSB7CgkgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwoJICAgIG5leHRUaWNrKGNiLCBlcik7CgkgICAgdmFsaWQgPSBmYWxzZTsKCSAgfQoJICByZXR1cm4gdmFsaWQ7Cgl9CgoJV3JpdGFibGUkMS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewoJICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlOwoJICB2YXIgcmV0ID0gZmFsc2U7CgoJICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7CgkgICAgY2IgPSBlbmNvZGluZzsKCSAgICBlbmNvZGluZyA9IG51bGw7CgkgIH0KCgkgIGlmIChCdWZmZXIkMS5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZzsKCgkgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wOwoKCSAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7CgkgICAgc3RhdGUucGVuZGluZ2NiKys7CgkgICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7CgkgIH0KCgkgIHJldHVybiByZXQ7Cgl9OwoKCVdyaXRhYmxlJDEucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7CgkgIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CgoJICBzdGF0ZS5jb3JrZWQrKzsKCX07CgoJV3JpdGFibGUkMS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkgewoJICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlOwoKCSAgaWYgKHN0YXRlLmNvcmtlZCkgewoJICAgIHN0YXRlLmNvcmtlZC0tOwoKCSAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7CgkgIH0KCX07CgoJV3JpdGFibGUkMS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7CgkgIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLgoJICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpOwoJICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpOwoJICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nOwoJICByZXR1cm4gdGhpczsKCX07CgoJZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykgewoJICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykgewoJICAgIGNodW5rID0gQnVmZmVyJDEuZnJvbShjaHVuaywgZW5jb2RpbmcpOwoJICB9CgkgIHJldHVybiBjaHVuazsKCX0KCgkvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXMKCS8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlCgkvLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLgoJZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7CgkgIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7CgoJICBpZiAoQnVmZmVyJDEuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInOwoJICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CgoJICBzdGF0ZS5sZW5ndGggKz0gbGVuOwoKCSAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7CgkgIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLgoJICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTsKCgkgIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkgewoJICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDsKCSAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpOwoJICAgIGlmIChsYXN0KSB7CgkgICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0OwoJICAgIH0gZWxzZSB7CgkgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0OwoJICAgIH0KCSAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxOwoJICB9IGVsc2UgewoJICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7CgkgIH0KCgkgIHJldHVybiByZXQ7Cgl9CgoJZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikgewoJICBzdGF0ZS53cml0ZWxlbiA9IGxlbjsKCSAgc3RhdGUud3JpdGVjYiA9IGNiOwoJICBzdGF0ZS53cml0aW5nID0gdHJ1ZTsKCSAgc3RhdGUuc3luYyA9IHRydWU7CgkgIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTsKCSAgc3RhdGUuc3luYyA9IGZhbHNlOwoJfQoKCWZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHsKCSAgLS1zdGF0ZS5wZW5kaW5nY2I7CgkgIGlmIChzeW5jKSBuZXh0VGljayhjYiwgZXIpO2Vsc2UgY2IoZXIpOwoKCSAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CgkgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKCX0KCglmdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHsKCSAgc3RhdGUud3JpdGluZyA9IGZhbHNlOwoJICBzdGF0ZS53cml0ZWNiID0gbnVsbDsKCSAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuOwoJICBzdGF0ZS53cml0ZWxlbiA9IDA7Cgl9CgoJZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7CgkgIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTsKCSAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jOwoJICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiOwoKCSAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTsKCgkgIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7CgkgICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXQKCSAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTsKCgkgICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgewoJICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7CgkgICAgfQoKCSAgICBpZiAoc3luYykgewoJICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki8KCSAgICAgICAgbmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTsKCSAgICAgIC8qPC9yZXBsYWNlbWVudD4qLwoJICAgIH0gZWxzZSB7CgkgICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTsKCSAgICAgIH0KCSAgfQoJfQoKCWZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7CgkgIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTsKCSAgc3RhdGUucGVuZGluZ2NiLS07CgkgIGNiKCk7CgkgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpOwoJfQoKCS8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0CgkvLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuCgkvLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLgoJZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHsKCSAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHsKCSAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTsKCSAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTsKCSAgfQoJfQoKCS8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0CglmdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7CgkgIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlOwoJICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7CgoJICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkgewoJICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KCkKCSAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50OwoJICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7CgkgICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTsKCSAgICBob2xkZXIuZW50cnkgPSBlbnRyeTsKCgkgICAgdmFyIGNvdW50ID0gMDsKCSAgICB3aGlsZSAoZW50cnkpIHsKCSAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTsKCSAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKCSAgICAgIGNvdW50ICs9IDE7CgkgICAgfQoKCSAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7CgoJICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lCgkgICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlCgkgICAgc3RhdGUucGVuZGluZ2NiKys7CgkgICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CgkgICAgaWYgKGhvbGRlci5uZXh0KSB7CgkgICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDsKCSAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDsKCSAgICB9IGVsc2UgewoJICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpOwoJICAgIH0KCSAgfSBlbHNlIHsKCSAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lCgkgICAgd2hpbGUgKGVudHJ5KSB7CgkgICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuazsKCSAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nOwoJICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7CgkgICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CgoJICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTsKCSAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKCSAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuCgkgICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLgoJICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseQoJICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uCgkgICAgICBpZiAoc3RhdGUud3JpdGluZykgewoJICAgICAgICBicmVhazsKCSAgICAgIH0KCSAgICB9CgoJICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CgkgIH0KCgkgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsKCSAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7CgkgIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsKCX0KCglXcml0YWJsZSQxLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewoJICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTsKCX07CgoJV3JpdGFibGUkMS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7CgoJV3JpdGFibGUkMS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKCSAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTsKCgkgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHsKCSAgICBjYiA9IGNodW5rOwoJICAgIGNodW5rID0gbnVsbDsKCSAgICBlbmNvZGluZyA9IG51bGw7CgkgIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7CgkgICAgY2IgPSBlbmNvZGluZzsKCSAgICBlbmNvZGluZyA9IG51bGw7CgkgIH0KCgkgIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7CgoJICAvLyAuZW5kKCkgZnVsbHkgdW5jb3JrcwoJICBpZiAoc3RhdGUuY29ya2VkKSB7CgkgICAgc3RhdGUuY29ya2VkID0gMTsKCSAgICB0aGlzLnVuY29yaygpOwoJICB9CgoJICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuCgkgIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTsKCX07CgoJZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkgewoJICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nOwoJfQoKCWZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7CgkgIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHsKCSAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7CgkgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpOwoJICB9Cgl9CgoJZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkgewoJICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpOwoJICBpZiAobmVlZCkgewoJICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHsKCSAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTsKCSAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTsKCSAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTsKCSAgICB9IGVsc2UgewoJICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpOwoJICAgIH0KCSAgfQoJICByZXR1cm4gbmVlZDsKCX0KCglmdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikgewoJICBzdGF0ZS5lbmRpbmcgPSB0cnVlOwoJICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKCSAgaWYgKGNiKSB7CgkgICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBuZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpOwoJICB9CgkgIHN0YXRlLmVuZGVkID0gdHJ1ZTsKCSAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7Cgl9CgoJLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90CgkvLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW0KCWZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHsKCSAgdmFyIF90aGlzID0gdGhpczsKCgkgIHRoaXMubmV4dCA9IG51bGw7CgkgIHRoaXMuZW50cnkgPSBudWxsOwoKCSAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7CgkgICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7CgkgICAgX3RoaXMuZW50cnkgPSBudWxsOwoJICAgIHdoaWxlIChlbnRyeSkgewoJICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7CgkgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTsKCSAgICAgIGNiKGVycik7CgkgICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7CgkgICAgfQoJICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHsKCSAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7CgkgICAgfSBlbHNlIHsKCSAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzOwoJICAgIH0KCSAgfTsKCX0KCglpbmhlcml0cyQxKER1cGxleCwgUmVhZGFibGUpOwoKCXZhciBrZXlzID0gT2JqZWN0LmtleXMoV3JpdGFibGUkMS5wcm90b3R5cGUpOwoJZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7CgkgIHZhciBtZXRob2QgPSBrZXlzW3ZdOwoJICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUkMS5wcm90b3R5cGVbbWV0aG9kXTsKCX0KCWZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7CgkgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTsKCgkgIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7CgkgIFdyaXRhYmxlJDEuY2FsbCh0aGlzLCBvcHRpb25zKTsKCgkgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7CgoJICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlOwoKCSAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTsKCSAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7CgoJICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTsKCX0KCgkvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyCglmdW5jdGlvbiBvbmVuZCgpIHsKCSAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwKCSAgLy8gdGhlbiB3ZSdyZSBvay4KCSAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47CgoJICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uCgkgIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLgoJICBuZXh0VGljayhvbkVuZE5ULCB0aGlzKTsKCX0KCglmdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHsKCSAgc2VsZi5lbmQoKTsKCX0KCgkvLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvCglpbmhlcml0cyQxKFRyYW5zZm9ybSwgRHVwbGV4KTsKCglmdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHsKCSAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkgewoJICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTsKCSAgfTsKCgkgIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlOwoJICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlOwoJICB0aGlzLndyaXRlY2IgPSBudWxsOwoJICB0aGlzLndyaXRlY2h1bmsgPSBudWxsOwoJICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsOwoJfQoKCWZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHsKCSAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTsKCSAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7CgoJICB2YXIgY2IgPSB0cy53cml0ZWNiOwoKCSAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7CgoJICB0cy53cml0ZWNodW5rID0gbnVsbDsKCSAgdHMud3JpdGVjYiA9IG51bGw7CgoJICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpOwoKCSAgY2IoZXIpOwoKCSAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwoJICBycy5yZWFkaW5nID0gZmFsc2U7CgkgIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgewoJICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTsKCSAgfQoJfQoJZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHsKCSAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpOwoKCSAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7CgoJICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTsKCgkgIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy4KCSAgdmFyIHN0cmVhbSA9IHRoaXM7CgoJICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC4KCSAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwoKCSAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzCgkgIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGUKCSAgLy8gc3luYyBndWFyZCBmbGFnLgoJICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTsKCgkgIGlmIChvcHRpb25zKSB7CgkgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07CgoJICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoOwoJICB9CgoJICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHsKCSAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIpIHsKCSAgICAgIGRvbmUoc3RyZWFtLCBlcik7CgkgICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7CgkgIH0pOwoJfQoKCVRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHsKCSAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlOwoJICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTsKCX07CgoJLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhCgkvLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuCgkvLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLgoJLy8KCS8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dAoJLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy4KCS8vCgkvLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzcwoJLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdQoJLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay4KCVRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CgkgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7Cgl9OwoKCVRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKCSAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7CgkgIHRzLndyaXRlY2IgPSBjYjsKCSAgdHMud3JpdGVjaHVuayA9IGNodW5rOwoJICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7CgkgIGlmICghdHMudHJhbnNmb3JtaW5nKSB7CgkgICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKCSAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTsKCSAgfQoJfTsKCgkvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLgoJLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay4KCS8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuCglUcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHsKCSAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7CgoJICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHsKCSAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlOwoJICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7CgkgIH0gZWxzZSB7CgkgICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpbgoJICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LgoJICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlOwoJICB9Cgl9OwoKCWZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikgewoJICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CgoJICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zCgkgIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZAoJICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7CgkgIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7CgoJICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpOwoKCSAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7CgoJICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7Cgl9CgoJaW5oZXJpdHMkMShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTsKCWZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHsKCSAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTsKCgkgIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpOwoJfQoKCVBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKCSAgY2IobnVsbCwgY2h1bmspOwoJfTsKCglpbmhlcml0cyQxKFN0cmVhbSwgRXZlbnRFbWl0dGVyKTsKCVN0cmVhbS5SZWFkYWJsZSA9IFJlYWRhYmxlOwoJU3RyZWFtLldyaXRhYmxlID0gV3JpdGFibGUkMTsKCVN0cmVhbS5EdXBsZXggPSBEdXBsZXg7CglTdHJlYW0uVHJhbnNmb3JtID0gVHJhbnNmb3JtOwoJU3RyZWFtLlBhc3NUaHJvdWdoID0gUGFzc1Rocm91Z2g7CgoJLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LngKCVN0cmVhbS5TdHJlYW0gPSBTdHJlYW07CgoJLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudAoJLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy4KCglmdW5jdGlvbiBTdHJlYW0oKSB7CgkgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpOwoJfQoKCVN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHsKCSAgdmFyIHNvdXJjZSA9IHRoaXM7CgoJICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHsKCSAgICBpZiAoZGVzdC53cml0YWJsZSkgewoJICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHsKCSAgICAgICAgc291cmNlLnBhdXNlKCk7CgkgICAgICB9CgkgICAgfQoJICB9CgoJICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpOwoKCSAgZnVuY3Rpb24gb25kcmFpbigpIHsKCSAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHsKCSAgICAgIHNvdXJjZS5yZXN1bWUoKTsKCSAgICB9CgkgIH0KCgkgIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7CgoJICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuCgkgIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLgoJICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHsKCSAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTsKCSAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7CgkgIH0KCgkgIHZhciBkaWRPbkVuZCA9IGZhbHNlOwoJICBmdW5jdGlvbiBvbmVuZCgpIHsKCSAgICBpZiAoZGlkT25FbmQpIHJldHVybjsKCSAgICBkaWRPbkVuZCA9IHRydWU7CgoJICAgIGRlc3QuZW5kKCk7CgkgIH0KCgoJICBmdW5jdGlvbiBvbmNsb3NlKCkgewoJICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuOwoJICAgIGRpZE9uRW5kID0gdHJ1ZTsKCgkgICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpOwoJICB9CgoJICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuCgkgIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHsKCSAgICBjbGVhbnVwKCk7CgkgICAgaWYgKEV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7CgkgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLgoJICAgIH0KCSAgfQoKCSAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpOwoJICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpOwoKCSAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC4KCSAgZnVuY3Rpb24gY2xlYW51cCgpIHsKCSAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpOwoJICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7CgoJICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpOwoJICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTsKCgkgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpOwoJICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CgoJICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7CgkgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApOwoKCSAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApOwoJICB9CgoJICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApOwoJICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7CgoJICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApOwoKCSAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTsKCgkgIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpCgkgIHJldHVybiBkZXN0OwoJfTsKCgl2YXIgclN0YXRlcyA9IHsKCSAgVU5TRU5UOiAwLAoJICBPUEVORUQ6IDEsCgkgIEhFQURFUlNfUkVDRUlWRUQ6IDIsCgkgIExPQURJTkc6IDMsCgkgIERPTkU6IDQKCX07CglmdW5jdGlvbiBJbmNvbWluZ01lc3NhZ2UoeGhyLCByZXNwb25zZSwgbW9kZSkgewoJICB2YXIgc2VsZiA9IHRoaXM7CgkgIFJlYWRhYmxlLmNhbGwoc2VsZik7CgoJICBzZWxmLl9tb2RlID0gbW9kZTsKCSAgc2VsZi5oZWFkZXJzID0ge307CgkgIHNlbGYucmF3SGVhZGVycyA9IFtdOwoJICBzZWxmLnRyYWlsZXJzID0ge307CgkgIHNlbGYucmF3VHJhaWxlcnMgPSBbXTsKCgkgIC8vIEZha2UgdGhlICdjbG9zZScgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgJ2VuZCcgZmlyZXMKCSAgc2VsZi5vbignZW5kJywgZnVuY3Rpb24oKSB7CgkgICAgLy8gVGhlIG5leHRUaWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHRoZSAncmVxdWVzdCcgbW9kdWxlIGZyb20gY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wCgkgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsKCSAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKTsKCSAgICB9KTsKCSAgfSk7CgkgIHZhciByZWFkOwoJICBpZiAobW9kZSA9PT0gJ2ZldGNoJykgewoJICAgIHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZTsKCgkgICAgc2VsZi51cmwgPSByZXNwb25zZS51cmw7CgkgICAgc2VsZi5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzOwoJICAgIHNlbGYuc3RhdHVzTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHQ7CgkgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSB2ZXJzaW9uIG9mIGZvciAoPGl0ZW0+IG9mIDxpdGVyYWJsZT4pOgoJICAgICAgLy8gZm9yICh2YXIgPGl0ZW0+LF9pLF9pdCA9IDxpdGVyYWJsZT5bU3ltYm9sLml0ZXJhdG9yXSgpOyA8aXRlbT4gPSAoX2kgPSBfaXQubmV4dCgpKS52YWx1ZSwhX2kuZG9uZTspCgkgICAgZm9yICh2YXIgaGVhZGVyLCBfaSwgX2l0ID0gcmVzcG9uc2UuaGVhZGVyc1tTeW1ib2wuaXRlcmF0b3JdKCk7IGhlYWRlciA9IChfaSA9IF9pdC5uZXh0KCkpLnZhbHVlLCAhX2kuZG9uZTspIHsKCSAgICAgIHNlbGYuaGVhZGVyc1toZWFkZXJbMF0udG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJbMV07CgkgICAgICBzZWxmLnJhd0hlYWRlcnMucHVzaChoZWFkZXJbMF0sIGhlYWRlclsxXSk7CgkgICAgfQoKCSAgICAvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgcmVzcGVjdCBiYWNrcHJlc3N1cmUuIE9uY2UgV3JpdGFibGVTdHJlYW0gaXMgYXZhaWxhYmxlLCB0aGlzIGNhbiBiZSBmaXhlZAoJICAgIHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpOwoKCSAgICByZWFkID0gZnVuY3Rpb24gKCkgewoJICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkgewoJICAgICAgICBpZiAoc2VsZi5fZGVzdHJveWVkKQoJICAgICAgICAgIHJldHVybgoJICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHsKCSAgICAgICAgICBzZWxmLnB1c2gobnVsbCk7CgkgICAgICAgICAgcmV0dXJuCgkgICAgICAgIH0KCSAgICAgICAgc2VsZi5wdXNoKG5ldyBCdWZmZXIkMShyZXN1bHQudmFsdWUpKTsKCSAgICAgICAgcmVhZCgpOwoJICAgICAgfSk7CgkgICAgfTsKCSAgICByZWFkKCk7CgoJICB9IGVsc2UgewoJICAgIHNlbGYuX3hociA9IHhocjsKCSAgICBzZWxmLl9wb3MgPSAwOwoKCSAgICBzZWxmLnVybCA9IHhoci5yZXNwb25zZVVSTDsKCSAgICBzZWxmLnN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzOwoJICAgIHNlbGYuc3RhdHVzTWVzc2FnZSA9IHhoci5zdGF0dXNUZXh0OwoJICAgIHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KC9ccj9cbi8pOwoJICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHsKCSAgICAgIHZhciBtYXRjaGVzID0gaGVhZGVyLm1hdGNoKC9eKFteOl0rKTpccyooLiopLyk7CgkgICAgICBpZiAobWF0Y2hlcykgewoJICAgICAgICB2YXIga2V5ID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpOwoJICAgICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHsKCSAgICAgICAgICBpZiAoc2VsZi5oZWFkZXJzW2tleV0gPT09IHVuZGVmaW5lZCkgewoJICAgICAgICAgICAgc2VsZi5oZWFkZXJzW2tleV0gPSBbXTsKCSAgICAgICAgICB9CgkgICAgICAgICAgc2VsZi5oZWFkZXJzW2tleV0ucHVzaChtYXRjaGVzWzJdKTsKCSAgICAgICAgfSBlbHNlIGlmIChzZWxmLmhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7CgkgICAgICAgICAgc2VsZi5oZWFkZXJzW2tleV0gKz0gJywgJyArIG1hdGNoZXNbMl07CgkgICAgICAgIH0gZWxzZSB7CgkgICAgICAgICAgc2VsZi5oZWFkZXJzW2tleV0gPSBtYXRjaGVzWzJdOwoJICAgICAgICB9CgkgICAgICAgIHNlbGYucmF3SGVhZGVycy5wdXNoKG1hdGNoZXNbMV0sIG1hdGNoZXNbMl0pOwoJICAgICAgfQoJICAgIH0pOwoKCSAgICBzZWxmLl9jaGFyc2V0ID0gJ3gtdXNlci1kZWZpbmVkJzsKCSAgICBpZiAoIW92ZXJyaWRlTWltZVR5cGUpIHsKCSAgICAgIHZhciBtaW1lVHlwZSA9IHNlbGYucmF3SGVhZGVyc1snbWltZS10eXBlJ107CgkgICAgICBpZiAobWltZVR5cGUpIHsKCSAgICAgICAgdmFyIGNoYXJzZXRNYXRjaCA9IG1pbWVUeXBlLm1hdGNoKC87XHMqY2hhcnNldD0oW147XSkoO3wkKS8pOwoJICAgICAgICBpZiAoY2hhcnNldE1hdGNoKSB7CgkgICAgICAgICAgc2VsZi5fY2hhcnNldCA9IGNoYXJzZXRNYXRjaFsxXS50b0xvd2VyQ2FzZSgpOwoJICAgICAgICB9CgkgICAgICB9CgkgICAgICBpZiAoIXNlbGYuX2NoYXJzZXQpCgkgICAgICAgIHNlbGYuX2NoYXJzZXQgPSAndXRmLTgnOyAvLyBiZXN0IGd1ZXNzCgkgICAgfQoJICB9Cgl9CgoJaW5oZXJpdHMkMShJbmNvbWluZ01lc3NhZ2UsIFJlYWRhYmxlKTsKCglJbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7fTsKCglJbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9vblhIUlByb2dyZXNzID0gZnVuY3Rpb24oKSB7CgkgIHZhciBzZWxmID0gdGhpczsKCgkgIHZhciB4aHIgPSBzZWxmLl94aHI7CgoJICB2YXIgcmVzcG9uc2UgPSBudWxsOwoJICBzd2l0Y2ggKHNlbGYuX21vZGUpIHsKCSAgY2FzZSAndGV4dDp2YmFycmF5JzogLy8gRm9yIElFOQoJICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5ET05FKQoJICAgICAgYnJlYWsKCSAgICB0cnkgewoJICAgICAgLy8gVGhpcyBmYWlscyBpbiBJRTgKCSAgICAgIHJlc3BvbnNlID0gbmV3IGdsb2JhbCQxLlZCQXJyYXkoeGhyLnJlc3BvbnNlQm9keSkudG9BcnJheSgpOwoJICAgIH0gY2F0Y2ggKGUpIHsKCSAgICAgIC8vIHBhc3MKCSAgICB9CgkgICAgaWYgKHJlc3BvbnNlICE9PSBudWxsKSB7CgkgICAgICBzZWxmLnB1c2gobmV3IEJ1ZmZlciQxKHJlc3BvbnNlKSk7CgkgICAgICBicmVhawoJICAgIH0KCSAgICAvLyBGYWxscyB0aHJvdWdoIGluIElFOAoJICBjYXNlICd0ZXh0JzoKCSAgICB0cnkgeyAvLyBUaGlzIHdpbGwgZmFpbCB3aGVuIHJlYWR5U3RhdGUgPSAzIGluIElFOS4gU3dpdGNoIG1vZGUgYW5kIHdhaXQgZm9yIHJlYWR5U3RhdGUgPSA0CgkgICAgICByZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHQ7CgkgICAgfSBjYXRjaCAoZSkgewoJICAgICAgc2VsZi5fbW9kZSA9ICd0ZXh0OnZiYXJyYXknOwoJICAgICAgYnJlYWsKCSAgICB9CgkgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA+IHNlbGYuX3BvcykgewoJICAgICAgdmFyIG5ld0RhdGEgPSByZXNwb25zZS5zdWJzdHIoc2VsZi5fcG9zKTsKCSAgICAgIGlmIChzZWxmLl9jaGFyc2V0ID09PSAneC11c2VyLWRlZmluZWQnKSB7CgkgICAgICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyJDEobmV3RGF0YS5sZW5ndGgpOwoJICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspCgkgICAgICAgICAgYnVmZmVyW2ldID0gbmV3RGF0YS5jaGFyQ29kZUF0KGkpICYgMHhmZjsKCgkgICAgICAgIHNlbGYucHVzaChidWZmZXIpOwoJICAgICAgfSBlbHNlIHsKCSAgICAgICAgc2VsZi5wdXNoKG5ld0RhdGEsIHNlbGYuX2NoYXJzZXQpOwoJICAgICAgfQoJICAgICAgc2VsZi5fcG9zID0gcmVzcG9uc2UubGVuZ3RoOwoJICAgIH0KCSAgICBicmVhawoJICBjYXNlICdhcnJheWJ1ZmZlcic6CgkgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUgfHwgIXhoci5yZXNwb25zZSkKCSAgICAgIGJyZWFrCgkgICAgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2U7CgkgICAgc2VsZi5wdXNoKG5ldyBCdWZmZXIkMShuZXcgVWludDhBcnJheShyZXNwb25zZSkpKTsKCSAgICBicmVhawoJICBjYXNlICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcic6IC8vIHRha2Ugd2hvbGUKCSAgICByZXNwb25zZSA9IHhoci5yZXNwb25zZTsKCSAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORyB8fCAhcmVzcG9uc2UpCgkgICAgICBicmVhawoJICAgIHNlbGYucHVzaChuZXcgQnVmZmVyJDEobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSk7CgkgICAgYnJlYWsKCSAgY2FzZSAnbXMtc3RyZWFtJzoKCSAgICByZXNwb25zZSA9IHhoci5yZXNwb25zZTsKCSAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORykKCSAgICAgIGJyZWFrCgkgICAgdmFyIHJlYWRlciA9IG5ldyBnbG9iYWwkMS5NU1N0cmVhbVJlYWRlcigpOwoJICAgIHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7CgkgICAgICBpZiAocmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoID4gc2VsZi5fcG9zKSB7CgkgICAgICAgIHNlbGYucHVzaChuZXcgQnVmZmVyJDEobmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdC5zbGljZShzZWxmLl9wb3MpKSkpOwoJICAgICAgICBzZWxmLl9wb3MgPSByZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGg7CgkgICAgICB9CgkgICAgfTsKCSAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7CgkgICAgICBzZWxmLnB1c2gobnVsbCk7CgkgICAgfTsKCSAgICAgIC8vIHJlYWRlci5vbmVycm9yID0gPz8/IC8vIFRPRE86IHRoaXMKCSAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocmVzcG9uc2UpOwoJICAgIGJyZWFrCgkgIH0KCgkgIC8vIFRoZSBtcy1zdHJlYW0gY2FzZSBoYW5kbGVzIGVuZCBzZXBhcmF0ZWx5IGluIHJlYWRlci5vbmxvYWQoKQoJICBpZiAoc2VsZi5feGhyLnJlYWR5U3RhdGUgPT09IHJTdGF0ZXMuRE9ORSAmJiBzZWxmLl9tb2RlICE9PSAnbXMtc3RyZWFtJykgewoJICAgIHNlbGYucHVzaChudWxsKTsKCSAgfQoJfTsKCgkvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qaGllc2V5L3RvLWFycmF5YnVmZmVyL2Jsb2IvNjUwMmQ5ODUwZTcwYmE3OTM1YTdkZjRhZDg2YjM1OGZjMjE2ZjlmMC9pbmRleC5qcwoJZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoYnVmKSB7CgkgIC8vIElmIHRoZSBidWZmZXIgaXMgYmFja2VkIGJ5IGEgVWludDhBcnJheSwgYSBmYXN0ZXIgdmVyc2lvbiB3aWxsIHdvcmsKCSAgaWYgKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHsKCSAgICAvLyBJZiB0aGUgYnVmZmVyIGlzbid0IGEgc3ViYXJyYXksIHJldHVybiB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlcgoJICAgIGlmIChidWYuYnl0ZU9mZnNldCA9PT0gMCAmJiBidWYuYnl0ZUxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7CgkgICAgICByZXR1cm4gYnVmLmJ1ZmZlcgoJICAgIH0gZWxzZSBpZiAodHlwZW9mIGJ1Zi5idWZmZXIuc2xpY2UgPT09ICdmdW5jdGlvbicpIHsKCSAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGdldCBhIHByb3BlciBjb3B5CgkgICAgICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCkKCSAgICB9CgkgIH0KCgkgIGlmIChpc0J1ZmZlciQxKGJ1ZikpIHsKCSAgICAvLyBUaGlzIGlzIHRoZSBzbG93IHZlcnNpb24gdGhhdCB3aWxsIHdvcmsgd2l0aCBhbnkgQnVmZmVyCgkgICAgLy8gaW1wbGVtZW50YXRpb24gKGV2ZW4gaW4gb2xkIGJyb3dzZXJzKQoJICAgIHZhciBhcnJheUNvcHkgPSBuZXcgVWludDhBcnJheShidWYubGVuZ3RoKTsKCSAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDsKCSAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CgkgICAgICBhcnJheUNvcHlbaV0gPSBidWZbaV07CgkgICAgfQoJICAgIHJldHVybiBhcnJheUNvcHkuYnVmZmVyCgkgIH0gZWxzZSB7CgkgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJykKCSAgfQoJfQoKCWZ1bmN0aW9uIGRlY2lkZU1vZGUocHJlZmVyQmluYXJ5LCB1c2VGZXRjaCkgewoJICBpZiAoaGFzRmV0Y2ggJiYgdXNlRmV0Y2gpIHsKCSAgICByZXR1cm4gJ2ZldGNoJwoJICB9IGVsc2UgaWYgKG1vemNodW5rZWRhcnJheWJ1ZmZlcikgewoJICAgIHJldHVybiAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInCgkgIH0gZWxzZSBpZiAobXNzdHJlYW0pIHsKCSAgICByZXR1cm4gJ21zLXN0cmVhbScKCSAgfSBlbHNlIGlmIChhcnJheWJ1ZmZlciAmJiBwcmVmZXJCaW5hcnkpIHsKCSAgICByZXR1cm4gJ2FycmF5YnVmZmVyJwoJICB9IGVsc2UgaWYgKHZiQXJyYXkgJiYgcHJlZmVyQmluYXJ5KSB7CgkgICAgcmV0dXJuICd0ZXh0OnZiYXJyYXknCgkgIH0gZWxzZSB7CgkgICAgcmV0dXJuICd0ZXh0JwoJICB9Cgl9CgoJZnVuY3Rpb24gQ2xpZW50UmVxdWVzdChvcHRzKSB7CgkgIHZhciBzZWxmID0gdGhpczsKCSAgV3JpdGFibGUkMS5jYWxsKHNlbGYpOwoKCSAgc2VsZi5fb3B0cyA9IG9wdHM7CgkgIHNlbGYuX2JvZHkgPSBbXTsKCSAgc2VsZi5faGVhZGVycyA9IHt9OwoJICBpZiAob3B0cy5hdXRoKQoJICAgIHNlbGYuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBuZXcgQnVmZmVyJDEob3B0cy5hdXRoKS50b1N0cmluZygnYmFzZTY0JykpOwoJICBPYmplY3Qua2V5cyhvcHRzLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkgewoJICAgIHNlbGYuc2V0SGVhZGVyKG5hbWUsIG9wdHMuaGVhZGVyc1tuYW1lXSk7CgkgIH0pOwoKCSAgdmFyIHByZWZlckJpbmFyeTsKCSAgdmFyIHVzZUZldGNoID0gdHJ1ZTsKCSAgaWYgKG9wdHMubW9kZSA9PT0gJ2Rpc2FibGUtZmV0Y2gnKSB7CgkgICAgLy8gSWYgdGhlIHVzZSBvZiBYSFIgc2hvdWxkIGJlIHByZWZlcnJlZCBhbmQgaW5jbHVkZXMgcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyCgkgICAgdXNlRmV0Y2ggPSBmYWxzZTsKCSAgICBwcmVmZXJCaW5hcnkgPSB0cnVlOwoJICB9IGVsc2UgaWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7CgkgICAgLy8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kCgkgICAgLy8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0CgkgICAgcHJlZmVyQmluYXJ5ID0gZmFsc2U7CgkgIH0gZWxzZSBpZiAob3B0cy5tb2RlID09PSAnYWxsb3ctd3JvbmctY29udGVudC10eXBlJykgewoJICAgIC8vIElmIHN0cmVhbWluZyBpcyBtb3JlIGltcG9ydGFudCB0aGFuIHByZXNlcnZpbmcgdGhlICdjb250ZW50LXR5cGUnIGhlYWRlcgoJICAgIHByZWZlckJpbmFyeSA9ICFvdmVycmlkZU1pbWVUeXBlOwoJICB9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7CgkgICAgLy8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWQKCSAgICBwcmVmZXJCaW5hcnkgPSB0cnVlOwoJICB9IGVsc2UgewoJICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igb3B0cy5tb2RlJykKCSAgfQoJICBzZWxmLl9tb2RlID0gZGVjaWRlTW9kZShwcmVmZXJCaW5hcnksIHVzZUZldGNoKTsKCgkgIHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkgewoJICAgIHNlbGYuX29uRmluaXNoKCk7CgkgIH0pOwoJfQoKCWluaGVyaXRzJDEoQ2xpZW50UmVxdWVzdCwgV3JpdGFibGUkMSk7CgkvLyBUYWtlbiBmcm9tIGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0LyN0aGUtc2V0cmVxdWVzdGhlYWRlciUyOCUyOS1tZXRob2QKCXZhciB1bnNhZmVIZWFkZXJzID0gWwoJICAnYWNjZXB0LWNoYXJzZXQnLAoJICAnYWNjZXB0LWVuY29kaW5nJywKCSAgJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycycsCgkgICdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZCcsCgkgICdjb25uZWN0aW9uJywKCSAgJ2NvbnRlbnQtbGVuZ3RoJywKCSAgJ2Nvb2tpZScsCgkgICdjb29raWUyJywKCSAgJ2RhdGUnLAoJICAnZG50JywKCSAgJ2V4cGVjdCcsCgkgICdob3N0JywKCSAgJ2tlZXAtYWxpdmUnLAoJICAnb3JpZ2luJywKCSAgJ3JlZmVyZXInLAoJICAndGUnLAoJICAndHJhaWxlcicsCgkgICd0cmFuc2Zlci1lbmNvZGluZycsCgkgICd1cGdyYWRlJywKCSAgJ3VzZXItYWdlbnQnLAoJICAndmlhJwoJXTsKCUNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7CgkgIHZhciBzZWxmID0gdGhpczsKCSAgdmFyIGxvd2VyTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTsKCSAgICAvLyBUaGlzIGNoZWNrIGlzIG5vdCBuZWNlc3NhcnksIGJ1dCBpdCBwcmV2ZW50cyB3YXJuaW5ncyBmcm9tIGJyb3dzZXJzIGFib3V0IHNldHRpbmcgdW5zYWZlCgkgICAgLy8gaGVhZGVycy4gVG8gYmUgaG9uZXN0IEknbSBub3QgZW50aXJlbHkgc3VyZSBoaWRpbmcgdGhlc2Ugd2FybmluZ3MgaXMgYSBnb29kIHRoaW5nLCBidXQKCSAgICAvLyBodHRwLWJyb3dzZXJpZnkgZGlkIGl0LCBzbyBJIHdpbGwgdG9vLgoJICBpZiAodW5zYWZlSGVhZGVycy5pbmRleE9mKGxvd2VyTmFtZSkgIT09IC0xKQoJICAgIHJldHVybgoKCSAgc2VsZi5faGVhZGVyc1tsb3dlck5hbWVdID0gewoJICAgIG5hbWU6IG5hbWUsCgkgICAgdmFsdWU6IHZhbHVlCgkgIH07Cgl9OwoKCUNsaWVudFJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uKG5hbWUpIHsKCSAgdmFyIHNlbGYgPSB0aGlzOwoJICByZXR1cm4gc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldLnZhbHVlCgl9OwoKCUNsaWVudFJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uKG5hbWUpIHsKCSAgdmFyIHNlbGYgPSB0aGlzOwoJICBkZWxldGUgc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldOwoJfTsKCglDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbigpIHsKCSAgdmFyIHNlbGYgPSB0aGlzOwoKCSAgaWYgKHNlbGYuX2Rlc3Ryb3llZCkKCSAgICByZXR1cm4KCSAgdmFyIG9wdHMgPSBzZWxmLl9vcHRzOwoKCSAgdmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzOwoJICB2YXIgYm9keTsKCSAgaWYgKG9wdHMubWV0aG9kID09PSAnUE9TVCcgfHwgb3B0cy5tZXRob2QgPT09ICdQVVQnIHx8IG9wdHMubWV0aG9kID09PSAnUEFUQ0gnKSB7CgkgICAgaWYgKGJsb2JDb25zdHJ1Y3RvcigpKSB7CgkgICAgICBib2R5ID0gbmV3IGdsb2JhbCQxLkJsb2Ioc2VsZi5fYm9keS5tYXAoZnVuY3Rpb24oYnVmZmVyKSB7CgkgICAgICAgIHJldHVybiB0b0FycmF5QnVmZmVyKGJ1ZmZlcikKCSAgICAgIH0pLCB7CgkgICAgICAgIHR5cGU6IChoZWFkZXJzT2JqWydjb250ZW50LXR5cGUnXSB8fCB7fSkudmFsdWUgfHwgJycKCSAgICAgIH0pOwoJICAgIH0gZWxzZSB7CgkgICAgICAvLyBnZXQgdXRmOCBzdHJpbmcKCSAgICAgIGJvZHkgPSBCdWZmZXIkMS5jb25jYXQoc2VsZi5fYm9keSkudG9TdHJpbmcoKTsKCSAgICB9CgkgIH0KCgkgIGlmIChzZWxmLl9tb2RlID09PSAnZmV0Y2gnKSB7CgkgICAgdmFyIGhlYWRlcnMgPSBPYmplY3Qua2V5cyhoZWFkZXJzT2JqKS5tYXAoZnVuY3Rpb24obmFtZSkgewoJICAgICAgcmV0dXJuIFtoZWFkZXJzT2JqW25hbWVdLm5hbWUsIGhlYWRlcnNPYmpbbmFtZV0udmFsdWVdCgkgICAgfSk7CgoJICAgIGdsb2JhbCQxLmZldGNoKHNlbGYuX29wdHMudXJsLCB7CgkgICAgICBtZXRob2Q6IHNlbGYuX29wdHMubWV0aG9kLAoJICAgICAgaGVhZGVyczogaGVhZGVycywKCSAgICAgIGJvZHk6IGJvZHksCgkgICAgICBtb2RlOiAnY29ycycsCgkgICAgICBjcmVkZW50aWFsczogb3B0cy53aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnc2FtZS1vcmlnaW4nCgkgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkgewoJICAgICAgc2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlOwoJICAgICAgc2VsZi5fY29ubmVjdCgpOwoJICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikgewoJICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIHJlYXNvbik7CgkgICAgfSk7CgkgIH0gZWxzZSB7CgkgICAgdmFyIHhociA9IHNlbGYuX3hociA9IG5ldyBnbG9iYWwkMS5YTUxIdHRwUmVxdWVzdCgpOwoJICAgIHRyeSB7CgkgICAgICB4aHIub3BlbihzZWxmLl9vcHRzLm1ldGhvZCwgc2VsZi5fb3B0cy51cmwsIHRydWUpOwoJICAgIH0gY2F0Y2ggKGVycikgewoJICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsKCSAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7CgkgICAgICB9KTsKCSAgICAgIHJldHVybgoJICAgIH0KCgkgICAgLy8gQ2FuJ3Qgc2V0IHJlc3BvbnNlVHlwZSBvbiByZWFsbHkgb2xkIGJyb3dzZXJzCgkgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhocikKCSAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBzZWxmLl9tb2RlLnNwbGl0KCc6JylbMF07CgoJICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpCgkgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRzLndpdGhDcmVkZW50aWFsczsKCgkgICAgaWYgKHNlbGYuX21vZGUgPT09ICd0ZXh0JyAmJiAnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKQoJICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKTsKCgkgICAgT2JqZWN0LmtleXMoaGVhZGVyc09iaikuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7CgkgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJzT2JqW25hbWVdLm5hbWUsIGhlYWRlcnNPYmpbbmFtZV0udmFsdWUpOwoJICAgIH0pOwoKCSAgICBzZWxmLl9yZXNwb25zZSA9IG51bGw7CgkgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkgewoJICAgICAgc3dpdGNoICh4aHIucmVhZHlTdGF0ZSkgewoJICAgICAgY2FzZSByU3RhdGVzLkxPQURJTkc6CgkgICAgICBjYXNlIHJTdGF0ZXMuRE9ORToKCSAgICAgICAgc2VsZi5fb25YSFJQcm9ncmVzcygpOwoJICAgICAgICBicmVhawoJICAgICAgfQoJICAgIH07CgkgICAgICAvLyBOZWNlc3NhcnkgZm9yIHN0cmVhbWluZyBpbiBGaXJlZm94LCBzaW5jZSB4aHIucmVzcG9uc2UgaXMgT05MWSBkZWZpbmVkCgkgICAgICAvLyBpbiBvbnByb2dyZXNzLCBub3QgaW4gb25yZWFkeXN0YXRlY2hhbmdlIHdpdGggeGhyLnJlYWR5U3RhdGUgPSAzCgkgICAgaWYgKHNlbGYuX21vZGUgPT09ICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcicpIHsKCSAgICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7CgkgICAgICAgIHNlbGYuX29uWEhSUHJvZ3Jlc3MoKTsKCSAgICAgIH07CgkgICAgfQoKCSAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkgewoJICAgICAgaWYgKHNlbGYuX2Rlc3Ryb3llZCkKCSAgICAgICAgcmV0dXJuCgkgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdYSFIgZXJyb3InKSk7CgkgICAgfTsKCgkgICAgdHJ5IHsKCSAgICAgIHhoci5zZW5kKGJvZHkpOwoJICAgIH0gY2F0Y2ggKGVycikgewoJICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsKCSAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7CgkgICAgICB9KTsKCSAgICAgIHJldHVybgoJICAgIH0KCSAgfQoJfTsKCgkvKioKCSAqIENoZWNrcyBpZiB4aHIuc3RhdHVzIGlzIHJlYWRhYmxlIGFuZCBub24temVybywgaW5kaWNhdGluZyBubyBlcnJvci4KCSAqIEV2ZW4gdGhvdWdoIHRoZSBzcGVjIHNheXMgaXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBpbiByZWFkeVN0YXRlIDMsCgkgKiBhY2Nlc3NpbmcgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpbiBJRTgKCSAqLwoJZnVuY3Rpb24gc3RhdHVzVmFsaWQoeGhyKSB7CgkgIHRyeSB7CgkgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7CgkgICAgcmV0dXJuIChzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSAwKQoJICB9IGNhdGNoIChlKSB7CgkgICAgcmV0dXJuIGZhbHNlCgkgIH0KCX0KCglDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uKCkgewoJICB2YXIgc2VsZiA9IHRoaXM7CgoJICBpZiAoIXN0YXR1c1ZhbGlkKHNlbGYuX3hocikgfHwgc2VsZi5fZGVzdHJveWVkKQoJICAgIHJldHVybgoKCSAgaWYgKCFzZWxmLl9yZXNwb25zZSkKCSAgICBzZWxmLl9jb25uZWN0KCk7CgoJICBzZWxmLl9yZXNwb25zZS5fb25YSFJQcm9ncmVzcygpOwoJfTsKCglDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkgewoJICB2YXIgc2VsZiA9IHRoaXM7CgoJICBpZiAoc2VsZi5fZGVzdHJveWVkKQoJICAgIHJldHVybgoKCSAgc2VsZi5fcmVzcG9uc2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKHNlbGYuX3hociwgc2VsZi5fZmV0Y2hSZXNwb25zZSwgc2VsZi5fbW9kZSk7CgkgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCBzZWxmLl9yZXNwb25zZSk7Cgl9OwoKCUNsaWVudFJlcXVlc3QucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHsKCSAgdmFyIHNlbGYgPSB0aGlzOwoKCSAgc2VsZi5fYm9keS5wdXNoKGNodW5rKTsKCSAgY2IoKTsKCX07CgoJQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7CgkgIHZhciBzZWxmID0gdGhpczsKCSAgc2VsZi5fZGVzdHJveWVkID0gdHJ1ZTsKCSAgaWYgKHNlbGYuX3Jlc3BvbnNlKQoJICAgIHNlbGYuX3Jlc3BvbnNlLl9kZXN0cm95ZWQgPSB0cnVlOwoJICBpZiAoc2VsZi5feGhyKQoJICAgIHNlbGYuX3hoci5hYm9ydCgpOwoJICAgIC8vIEN1cnJlbnRseSwgdGhlcmUgaXNuJ3QgYSB3YXkgdG8gdHJ1bHkgYWJvcnQgYSBmZXRjaC4KCSAgICAvLyBJZiB5b3UgbGlrZSBiaWtlc2hlZGRpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8yNwoJfTsKCglDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhLCBlbmNvZGluZywgY2IpIHsKCSAgdmFyIHNlbGYgPSB0aGlzOwoJICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHsKCSAgICBjYiA9IGRhdGE7CgkgICAgZGF0YSA9IHVuZGVmaW5lZDsKCSAgfQoKCSAgV3JpdGFibGUkMS5wcm90b3R5cGUuZW5kLmNhbGwoc2VsZiwgZGF0YSwgZW5jb2RpbmcsIGNiKTsKCX07CgoJQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZmx1c2hIZWFkZXJzID0gZnVuY3Rpb24oKSB7fTsKCUNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHt9OwoJQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0Tm9EZWxheSA9IGZ1bmN0aW9uKCkge307CglDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRTb2NrZXRLZWVwQWxpdmUgPSBmdW5jdGlvbigpIHt9OwoKCWZ1bmN0aW9uIHJlcXVlc3Qob3B0cywgY2IpIHsKCSAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykKCSAgICBvcHRzID0gdXJsUGFyc2Uob3B0cyk7CgoKCSAgLy8gTm9ybWFsbHksIHRoZSBwYWdlIGlzIGxvYWRlZCBmcm9tIGh0dHAgb3IgaHR0cHMsIHNvIG5vdCBzcGVjaWZ5aW5nIGEgcHJvdG9jb2wKCSAgLy8gd2lsbCByZXN1bHQgaW4gYSAodmFsaWQpIHByb3RvY29sLXJlbGF0aXZlIHVybC4gSG93ZXZlciwgdGhpcyB3b24ndCB3b3JrIGlmCgkgIC8vIHRoZSBwcm90b2NvbCBpcyBzb21ldGhpbmcgZWxzZSwgbGlrZSAnZmlsZTonCgkgIHZhciBkZWZhdWx0UHJvdG9jb2wgPSBnbG9iYWwkMS5sb2NhdGlvbi5wcm90b2NvbC5zZWFyY2goL15odHRwcz86JC8pID09PSAtMSA/ICdodHRwOicgOiAnJzsKCgkgIHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgfHwgZGVmYXVsdFByb3RvY29sOwoJICB2YXIgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0OwoJICB2YXIgcG9ydCA9IG9wdHMucG9ydDsKCSAgdmFyIHBhdGggPSBvcHRzLnBhdGggfHwgJy8nOwoKCSAgLy8gTmVjZXNzYXJ5IGZvciBJUHY2IGFkZHJlc3NlcwoJICBpZiAoaG9zdCAmJiBob3N0LmluZGV4T2YoJzonKSAhPT0gLTEpCgkgICAgaG9zdCA9ICdbJyArIGhvc3QgKyAnXSc7CgoJICAvLyBUaGlzIG1heSBiZSBhIHJlbGF0aXZlIHVybC4gVGhlIGJyb3dzZXIgc2hvdWxkIGFsd2F5cyBiZSBhYmxlIHRvIGludGVycHJldCBpdCBjb3JyZWN0bHkuCgkgIG9wdHMudXJsID0gKGhvc3QgPyAocHJvdG9jb2wgKyAnLy8nICsgaG9zdCkgOiAnJykgKyAocG9ydCA/ICc6JyArIHBvcnQgOiAnJykgKyBwYXRoOwoJICBvcHRzLm1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKTsKCSAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9OwoKCSAgLy8gQWxzbyB2YWxpZCBvcHRzLmF1dGgsIG9wdHMubW9kZQoKCSAgdmFyIHJlcSA9IG5ldyBDbGllbnRSZXF1ZXN0KG9wdHMpOwoJICBpZiAoY2IpCgkgICAgcmVxLm9uKCdyZXNwb25zZScsIGNiKTsKCSAgcmV0dXJuIHJlcQoJfQoKCWZ1bmN0aW9uIGdldChvcHRzLCBjYikgewoJICB2YXIgcmVxID0gcmVxdWVzdChvcHRzLCBjYik7CgkgIHJlcS5lbmQoKTsKCSAgcmV0dXJuIHJlcQoJfQoKCWZ1bmN0aW9uIEFnZW50KCkge30KCUFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNDsKCgl2YXIgTUVUSE9EUyA9IFsKCSAgJ0NIRUNLT1VUJywKCSAgJ0NPTk5FQ1QnLAoJICAnQ09QWScsCgkgICdERUxFVEUnLAoJICAnR0VUJywKCSAgJ0hFQUQnLAoJICAnTE9DSycsCgkgICdNLVNFQVJDSCcsCgkgICdNRVJHRScsCgkgICdNS0FDVElWSVRZJywKCSAgJ01LQ09MJywKCSAgJ01PVkUnLAoJICAnTk9USUZZJywKCSAgJ09QVElPTlMnLAoJICAnUEFUQ0gnLAoJICAnUE9TVCcsCgkgICdQUk9QRklORCcsCgkgICdQUk9QUEFUQ0gnLAoJICAnUFVSR0UnLAoJICAnUFVUJywKCSAgJ1JFUE9SVCcsCgkgICdTRUFSQ0gnLAoJICAnU1VCU0NSSUJFJywKCSAgJ1RSQUNFJywKCSAgJ1VOTE9DSycsCgkgICdVTlNVQlNDUklCRScKCV07Cgl2YXIgU1RBVFVTX0NPREVTID0gewoJICAxMDA6ICdDb250aW51ZScsCgkgIDEwMTogJ1N3aXRjaGluZyBQcm90b2NvbHMnLAoJICAxMDI6ICdQcm9jZXNzaW5nJywgLy8gUkZDIDI1MTgsIG9ic29sZXRlZCBieSBSRkMgNDkxOAoJICAyMDA6ICdPSycsCgkgIDIwMTogJ0NyZWF0ZWQnLAoJICAyMDI6ICdBY2NlcHRlZCcsCgkgIDIwMzogJ05vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uJywKCSAgMjA0OiAnTm8gQ29udGVudCcsCgkgIDIwNTogJ1Jlc2V0IENvbnRlbnQnLAoJICAyMDY6ICdQYXJ0aWFsIENvbnRlbnQnLAoJICAyMDc6ICdNdWx0aS1TdGF0dXMnLCAvLyBSRkMgNDkxOAoJICAzMDA6ICdNdWx0aXBsZSBDaG9pY2VzJywKCSAgMzAxOiAnTW92ZWQgUGVybWFuZW50bHknLAoJICAzMDI6ICdNb3ZlZCBUZW1wb3JhcmlseScsCgkgIDMwMzogJ1NlZSBPdGhlcicsCgkgIDMwNDogJ05vdCBNb2RpZmllZCcsCgkgIDMwNTogJ1VzZSBQcm94eScsCgkgIDMwNzogJ1RlbXBvcmFyeSBSZWRpcmVjdCcsCgkgIDQwMDogJ0JhZCBSZXF1ZXN0JywKCSAgNDAxOiAnVW5hdXRob3JpemVkJywKCSAgNDAyOiAnUGF5bWVudCBSZXF1aXJlZCcsCgkgIDQwMzogJ0ZvcmJpZGRlbicsCgkgIDQwNDogJ05vdCBGb3VuZCcsCgkgIDQwNTogJ01ldGhvZCBOb3QgQWxsb3dlZCcsCgkgIDQwNjogJ05vdCBBY2NlcHRhYmxlJywKCSAgNDA3OiAnUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnLAoJICA0MDg6ICdSZXF1ZXN0IFRpbWUtb3V0JywKCSAgNDA5OiAnQ29uZmxpY3QnLAoJICA0MTA6ICdHb25lJywKCSAgNDExOiAnTGVuZ3RoIFJlcXVpcmVkJywKCSAgNDEyOiAnUHJlY29uZGl0aW9uIEZhaWxlZCcsCgkgIDQxMzogJ1JlcXVlc3QgRW50aXR5IFRvbyBMYXJnZScsCgkgIDQxNDogJ1JlcXVlc3QtVVJJIFRvbyBMYXJnZScsCgkgIDQxNTogJ1Vuc3VwcG9ydGVkIE1lZGlhIFR5cGUnLAoJICA0MTY6ICdSZXF1ZXN0ZWQgUmFuZ2UgTm90IFNhdGlzZmlhYmxlJywKCSAgNDE3OiAnRXhwZWN0YXRpb24gRmFpbGVkJywKCSAgNDE4OiAnSVwnbSBhIHRlYXBvdCcsIC8vIFJGQyAyMzI0CgkgIDQyMjogJ1VucHJvY2Vzc2FibGUgRW50aXR5JywgLy8gUkZDIDQ5MTgKCSAgNDIzOiAnTG9ja2VkJywgLy8gUkZDIDQ5MTgKCSAgNDI0OiAnRmFpbGVkIERlcGVuZGVuY3knLCAvLyBSRkMgNDkxOAoJICA0MjU6ICdVbm9yZGVyZWQgQ29sbGVjdGlvbicsIC8vIFJGQyA0OTE4CgkgIDQyNjogJ1VwZ3JhZGUgUmVxdWlyZWQnLCAvLyBSRkMgMjgxNwoJICA0Mjg6ICdQcmVjb25kaXRpb24gUmVxdWlyZWQnLCAvLyBSRkMgNjU4NQoJICA0Mjk6ICdUb28gTWFueSBSZXF1ZXN0cycsIC8vIFJGQyA2NTg1CgkgIDQzMTogJ1JlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2UnLCAvLyBSRkMgNjU4NQoJICA1MDA6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLAoJICA1MDE6ICdOb3QgSW1wbGVtZW50ZWQnLAoJICA1MDI6ICdCYWQgR2F0ZXdheScsCgkgIDUwMzogJ1NlcnZpY2UgVW5hdmFpbGFibGUnLAoJICA1MDQ6ICdHYXRld2F5IFRpbWUtb3V0JywKCSAgNTA1OiAnSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWQnLAoJICA1MDY6ICdWYXJpYW50IEFsc28gTmVnb3RpYXRlcycsIC8vIFJGQyAyMjk1CgkgIDUwNzogJ0luc3VmZmljaWVudCBTdG9yYWdlJywgLy8gUkZDIDQ5MTgKCSAgNTA5OiAnQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkJywKCSAgNTEwOiAnTm90IEV4dGVuZGVkJywgLy8gUkZDIDI3NzQKCSAgNTExOiAnTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcgLy8gUkZDIDY1ODUKCX07CgoJdmFyIHJlcXVpcmUkJDIgPSB7CgkgIHJlcXVlc3QsCgkgIGdldCwKCSAgQWdlbnQsCgkgIE1FVEhPRFMsCgkgIFNUQVRVU19DT0RFUwoJfTsKCgl2YXIgZGVidWckMTsKCgl2YXIgZGVidWdfMSA9IGZ1bmN0aW9uICgpIHsKCSAgaWYgKCFkZWJ1ZyQxKSB7CgkgICAgdHJ5IHsKCSAgICAgIC8qIGVzbGludCBnbG9iYWwtcmVxdWlyZTogb2ZmICovCgkgICAgICBkZWJ1ZyQxID0gcmVxdWlyZSgiZGVidWciKSgiZm9sbG93LXJlZGlyZWN0cyIpOwoJICAgIH0KCSAgICBjYXRjaCAoZXJyb3IpIHsgLyogKi8gfQoJICAgIGlmICh0eXBlb2YgZGVidWckMSAhPT0gImZ1bmN0aW9uIikgewoJICAgICAgZGVidWckMSA9IGZ1bmN0aW9uICgpIHsgLyogKi8gfTsKCSAgICB9CgkgIH0KCSAgZGVidWckMS5hcHBseShudWxsLCBhcmd1bWVudHMpOwoJfTsKCgl2YXIgdXJsID0gcmVxdWlyZSQkMDsKCXZhciBVUkwgPSB1cmwuVVJMOwoJdmFyIGh0dHAgPSByZXF1aXJlJCQyOwoJdmFyIGh0dHBzJDEgPSByZXF1aXJlJCQyOwoJdmFyIFdyaXRhYmxlID0gU3RyZWFtLldyaXRhYmxlOwoJdmFyIGFzc2VydCQxID0gYXNzZXJ0JDM7Cgl2YXIgZGVidWcgPSBkZWJ1Z18xOwoKCS8vIENyZWF0ZSBoYW5kbGVycyB0aGF0IHBhc3MgZXZlbnRzIGZyb20gbmF0aXZlIHJlcXVlc3RzCgl2YXIgZXZlbnRzID0gWyJhYm9ydCIsICJhYm9ydGVkIiwgImNvbm5lY3QiLCAiZXJyb3IiLCAic29ja2V0IiwgInRpbWVvdXQiXTsKCXZhciBldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKCWV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgewoJICBldmVudEhhbmRsZXJzW2V2ZW50XSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyLCBhcmczKSB7CgkgICAgdGhpcy5fcmVkaXJlY3RhYmxlLmVtaXQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMpOwoJICB9OwoJfSk7CgoJLy8gRXJyb3IgdHlwZXMgd2l0aCBjb2RlcwoJdmFyIFJlZGlyZWN0aW9uRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoCgkgICJFUlJfRlJfUkVESVJFQ1RJT05fRkFJTFVSRSIsCgkgICJSZWRpcmVjdGVkIHJlcXVlc3QgZmFpbGVkIgoJKTsKCXZhciBUb29NYW55UmVkaXJlY3RzRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoCgkgICJFUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTIiwKCSAgIk1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0cyBleGNlZWRlZCIKCSk7Cgl2YXIgTWF4Qm9keUxlbmd0aEV4Y2VlZGVkRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoCgkgICJFUlJfRlJfTUFYX0JPRFlfTEVOR1RIX0VYQ0VFREVEIiwKCSAgIlJlcXVlc3QgYm9keSBsYXJnZXIgdGhhbiBtYXhCb2R5TGVuZ3RoIGxpbWl0IgoJKTsKCXZhciBXcml0ZUFmdGVyRW5kRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoCgkgICJFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCIsCgkgICJ3cml0ZSBhZnRlciBlbmQiCgkpOwoKCS8vIEFuIEhUVFAoUykgcmVxdWVzdCB0aGF0IGNhbiBiZSByZWRpcmVjdGVkCglmdW5jdGlvbiBSZWRpcmVjdGFibGVSZXF1ZXN0KG9wdGlvbnMsIHJlc3BvbnNlQ2FsbGJhY2spIHsKCSAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVxdWVzdAoJICBXcml0YWJsZS5jYWxsKHRoaXMpOwoJICB0aGlzLl9zYW5pdGl6ZU9wdGlvbnMob3B0aW9ucyk7CgkgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zOwoJICB0aGlzLl9lbmRlZCA9IGZhbHNlOwoJICB0aGlzLl9lbmRpbmcgPSBmYWxzZTsKCSAgdGhpcy5fcmVkaXJlY3RDb3VudCA9IDA7CgkgIHRoaXMuX3JlZGlyZWN0cyA9IFtdOwoJICB0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCA9IDA7CgkgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdOwoKCSAgLy8gQXR0YWNoIGEgY2FsbGJhY2sgaWYgcGFzc2VkCgkgIGlmIChyZXNwb25zZUNhbGxiYWNrKSB7CgkgICAgdGhpcy5vbigicmVzcG9uc2UiLCByZXNwb25zZUNhbGxiYWNrKTsKCSAgfQoKCSAgLy8gUmVhY3QgdG8gcmVzcG9uc2VzIG9mIG5hdGl2ZSByZXF1ZXN0cwoJICB2YXIgc2VsZiA9IHRoaXM7CgkgIHRoaXMuX29uTmF0aXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHsKCSAgICBzZWxmLl9wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpOwoJICB9OwoKCSAgLy8gUGVyZm9ybSB0aGUgZmlyc3QgcmVxdWVzdAoJICB0aGlzLl9wZXJmb3JtUmVxdWVzdCgpOwoJfQoJUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlLnByb3RvdHlwZSk7CgoJUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7CgkgIGFib3J0UmVxdWVzdCh0aGlzLl9jdXJyZW50UmVxdWVzdCk7CgkgIHRoaXMuZW1pdCgiYWJvcnQiKTsKCX07CgoJLy8gV3JpdGVzIGJ1ZmZlcmVkIGRhdGEgdG8gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3QKCVJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykgewoJICAvLyBXcml0aW5nIGlzIG5vdCBhbGxvd2VkIGlmIGVuZCBoYXMgYmVlbiBjYWxsZWQKCSAgaWYgKHRoaXMuX2VuZGluZykgewoJICAgIHRocm93IG5ldyBXcml0ZUFmdGVyRW5kRXJyb3IoKTsKCSAgfQoKCSAgLy8gVmFsaWRhdGUgaW5wdXQgYW5kIHNoaWZ0IHBhcmFtZXRlcnMgaWYgbmVjZXNzYXJ5CgkgIGlmICghKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIiB8fCB0eXBlb2YgZGF0YSA9PT0gIm9iamVjdCIgJiYgKCJsZW5ndGgiIGluIGRhdGEpKSkgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImRhdGEgc2hvdWxkIGJlIGEgc3RyaW5nLCBCdWZmZXIgb3IgVWludDhBcnJheSIpOwoJICB9CgkgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICJmdW5jdGlvbiIpIHsKCSAgICBjYWxsYmFjayA9IGVuY29kaW5nOwoJICAgIGVuY29kaW5nID0gbnVsbDsKCSAgfQoKCSAgLy8gSWdub3JlIGVtcHR5IGJ1ZmZlcnMsIHNpbmNlIHdyaXRpbmcgdGhlbSBkb2Vzbid0IGludm9rZSB0aGUgY2FsbGJhY2sKCSAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yMjA2NgoJICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHsKCSAgICBpZiAoY2FsbGJhY2spIHsKCSAgICAgIGNhbGxiYWNrKCk7CgkgICAgfQoJICAgIHJldHVybjsKCSAgfQoJICAvLyBPbmx5IHdyaXRlIHdoZW4gd2UgZG9uJ3QgZXhjZWVkIHRoZSBtYXhpbXVtIGJvZHkgbGVuZ3RoCgkgIGlmICh0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCArIGRhdGEubGVuZ3RoIDw9IHRoaXMuX29wdGlvbnMubWF4Qm9keUxlbmd0aCkgewoJICAgIHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoICs9IGRhdGEubGVuZ3RoOwoJICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycy5wdXNoKHsgZGF0YTogZGF0YSwgZW5jb2Rpbmc6IGVuY29kaW5nIH0pOwoJICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LndyaXRlKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjayk7CgkgIH0KCSAgLy8gRXJyb3Igd2hlbiB3ZSBleGNlZWQgdGhlIG1heGltdW0gYm9keSBsZW5ndGgKCSAgZWxzZSB7CgkgICAgdGhpcy5lbWl0KCJlcnJvciIsIG5ldyBNYXhCb2R5TGVuZ3RoRXhjZWVkZWRFcnJvcigpKTsKCSAgICB0aGlzLmFib3J0KCk7CgkgIH0KCX07CgoJLy8gRW5kcyB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdAoJUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykgewoJICAvLyBTaGlmdCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeQoJICBpZiAodHlwZW9mIGRhdGEgPT09ICJmdW5jdGlvbiIpIHsKCSAgICBjYWxsYmFjayA9IGRhdGE7CgkgICAgZGF0YSA9IGVuY29kaW5nID0gbnVsbDsKCSAgfQoJICBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICJmdW5jdGlvbiIpIHsKCSAgICBjYWxsYmFjayA9IGVuY29kaW5nOwoJICAgIGVuY29kaW5nID0gbnVsbDsKCSAgfQoKCSAgLy8gV3JpdGUgZGF0YSBpZiBuZWVkZWQgYW5kIGVuZAoJICBpZiAoIWRhdGEpIHsKCSAgICB0aGlzLl9lbmRlZCA9IHRoaXMuX2VuZGluZyA9IHRydWU7CgkgICAgdGhpcy5fY3VycmVudFJlcXVlc3QuZW5kKG51bGwsIG51bGwsIGNhbGxiYWNrKTsKCSAgfQoJICBlbHNlIHsKCSAgICB2YXIgc2VsZiA9IHRoaXM7CgkgICAgdmFyIGN1cnJlbnRSZXF1ZXN0ID0gdGhpcy5fY3VycmVudFJlcXVlc3Q7CgkgICAgdGhpcy53cml0ZShkYXRhLCBlbmNvZGluZywgZnVuY3Rpb24gKCkgewoJICAgICAgc2VsZi5fZW5kZWQgPSB0cnVlOwoJICAgICAgY3VycmVudFJlcXVlc3QuZW5kKG51bGwsIG51bGwsIGNhbGxiYWNrKTsKCSAgICB9KTsKCSAgICB0aGlzLl9lbmRpbmcgPSB0cnVlOwoJICB9Cgl9OwoKCS8vIFNldHMgYSBoZWFkZXIgdmFsdWUgb24gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3QKCVJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgewoJICB0aGlzLl9vcHRpb25zLmhlYWRlcnNbbmFtZV0gPSB2YWx1ZTsKCSAgdGhpcy5fY3VycmVudFJlcXVlc3Quc2V0SGVhZGVyKG5hbWUsIHZhbHVlKTsKCX07CgoJLy8gQ2xlYXJzIGEgaGVhZGVyIHZhbHVlIG9uIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0CglSZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkgewoJICBkZWxldGUgdGhpcy5fb3B0aW9ucy5oZWFkZXJzW25hbWVdOwoJICB0aGlzLl9jdXJyZW50UmVxdWVzdC5yZW1vdmVIZWFkZXIobmFtZSk7Cgl9OwoKCS8vIEdsb2JhbCB0aW1lb3V0IGZvciBhbGwgdW5kZXJseWluZyByZXF1ZXN0cwoJUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChtc2VjcywgY2FsbGJhY2spIHsKCSAgdmFyIHNlbGYgPSB0aGlzOwoKCSAgLy8gRGVzdHJveXMgdGhlIHNvY2tldCBvbiB0aW1lb3V0CgkgIGZ1bmN0aW9uIGRlc3Ryb3lPblRpbWVvdXQoc29ja2V0KSB7CgkgICAgc29ja2V0LnNldFRpbWVvdXQobXNlY3MpOwoJICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcigidGltZW91dCIsIHNvY2tldC5kZXN0cm95KTsKCSAgICBzb2NrZXQuYWRkTGlzdGVuZXIoInRpbWVvdXQiLCBzb2NrZXQuZGVzdHJveSk7CgkgIH0KCgkgIC8vIFNldHMgdXAgYSB0aW1lciB0byB0cmlnZ2VyIGEgdGltZW91dCBldmVudAoJICBmdW5jdGlvbiBzdGFydFRpbWVyKHNvY2tldCkgewoJICAgIGlmIChzZWxmLl90aW1lb3V0KSB7CgkgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fdGltZW91dCk7CgkgICAgfQoJICAgIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKCSAgICAgIHNlbGYuZW1pdCgidGltZW91dCIpOwoJICAgICAgY2xlYXJUaW1lcigpOwoJICAgIH0sIG1zZWNzKTsKCSAgICBkZXN0cm95T25UaW1lb3V0KHNvY2tldCk7CgkgIH0KCgkgIC8vIFN0b3BzIGEgdGltZW91dCBmcm9tIHRyaWdnZXJpbmcKCSAgZnVuY3Rpb24gY2xlYXJUaW1lcigpIHsKCSAgICAvLyBDbGVhciB0aGUgdGltZW91dAoJICAgIGlmIChzZWxmLl90aW1lb3V0KSB7CgkgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fdGltZW91dCk7CgkgICAgICBzZWxmLl90aW1lb3V0ID0gbnVsbDsKCSAgICB9CgoJICAgIC8vIENsZWFuIHVwIGFsbCBhdHRhY2hlZCBsaXN0ZW5lcnMKCSAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCJhYm9ydCIsIGNsZWFyVGltZXIpOwoJICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoImVycm9yIiwgY2xlYXJUaW1lcik7CgkgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigicmVzcG9uc2UiLCBjbGVhclRpbWVyKTsKCSAgICBpZiAoY2FsbGJhY2spIHsKCSAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoInRpbWVvdXQiLCBjYWxsYmFjayk7CgkgICAgfQoJICAgIGlmICghc2VsZi5zb2NrZXQpIHsKCSAgICAgIHNlbGYuX2N1cnJlbnRSZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCJzb2NrZXQiLCBzdGFydFRpbWVyKTsKCSAgICB9CgkgIH0KCgkgIC8vIEF0dGFjaCBjYWxsYmFjayBpZiBwYXNzZWQKCSAgaWYgKGNhbGxiYWNrKSB7CgkgICAgdGhpcy5vbigidGltZW91dCIsIGNhbGxiYWNrKTsKCSAgfQoKCSAgLy8gU3RhcnQgdGhlIHRpbWVyIGlmIG9yIHdoZW4gdGhlIHNvY2tldCBpcyBvcGVuZWQKCSAgaWYgKHRoaXMuc29ja2V0KSB7CgkgICAgc3RhcnRUaW1lcih0aGlzLnNvY2tldCk7CgkgIH0KCSAgZWxzZSB7CgkgICAgdGhpcy5fY3VycmVudFJlcXVlc3Qub25jZSgic29ja2V0Iiwgc3RhcnRUaW1lcik7CgkgIH0KCgkgIC8vIENsZWFuIHVwIG9uIGV2ZW50cwoJICB0aGlzLm9uKCJzb2NrZXQiLCBkZXN0cm95T25UaW1lb3V0KTsKCSAgdGhpcy5vbigiYWJvcnQiLCBjbGVhclRpbWVyKTsKCSAgdGhpcy5vbigiZXJyb3IiLCBjbGVhclRpbWVyKTsKCSAgdGhpcy5vbigicmVzcG9uc2UiLCBjbGVhclRpbWVyKTsKCgkgIHJldHVybiB0aGlzOwoJfTsKCgkvLyBQcm94eSBhbGwgb3RoZXIgcHVibGljIENsaWVudFJlcXVlc3QgbWV0aG9kcwoJWwoJICAiZmx1c2hIZWFkZXJzIiwgImdldEhlYWRlciIsCgkgICJzZXROb0RlbGF5IiwgInNldFNvY2tldEtlZXBBbGl2ZSIsCgldLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgewoJICBSZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGEsIGIpIHsKCSAgICByZXR1cm4gdGhpcy5fY3VycmVudFJlcXVlc3RbbWV0aG9kXShhLCBiKTsKCSAgfTsKCX0pOwoKCS8vIFByb3h5IGFsbCBwdWJsaWMgQ2xpZW50UmVxdWVzdCBwcm9wZXJ0aWVzCglbImFib3J0ZWQiLCAiY29ubmVjdGlvbiIsICJzb2NrZXQiXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkgewoJICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUsIHByb3BlcnR5LCB7CgkgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFtwcm9wZXJ0eV07IH0sCgkgIH0pOwoJfSk7CgoJUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3Nhbml0aXplT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7CgkgIC8vIEVuc3VyZSBoZWFkZXJzIGFyZSBhbHdheXMgcHJlc2VudAoJICBpZiAoIW9wdGlvbnMuaGVhZGVycykgewoJICAgIG9wdGlvbnMuaGVhZGVycyA9IHt9OwoJICB9CgoJICAvLyBTaW5jZSBodHRwLnJlcXVlc3QgdHJlYXRzIGhvc3QgYXMgYW4gYWxpYXMgb2YgaG9zdG5hbWUsCgkgIC8vIGJ1dCB0aGUgdXJsIG1vZHVsZSBpbnRlcnByZXRzIGhvc3QgYXMgaG9zdG5hbWUgcGx1cyBwb3J0LAoJICAvLyBlbGltaW5hdGUgdGhlIGhvc3QgcHJvcGVydHkgdG8gYXZvaWQgY29uZnVzaW9uLgoJICBpZiAob3B0aW9ucy5ob3N0KSB7CgkgICAgLy8gVXNlIGhvc3RuYW1lIGlmIHNldCwgYmVjYXVzZSBpdCBoYXMgcHJlY2VkZW5jZQoJICAgIGlmICghb3B0aW9ucy5ob3N0bmFtZSkgewoJICAgICAgb3B0aW9ucy5ob3N0bmFtZSA9IG9wdGlvbnMuaG9zdDsKCSAgICB9CgkgICAgZGVsZXRlIG9wdGlvbnMuaG9zdDsKCSAgfQoKCSAgLy8gQ29tcGxldGUgdGhlIFVSTCBvYmplY3Qgd2hlbiBuZWNlc3NhcnkKCSAgaWYgKCFvcHRpb25zLnBhdGhuYW1lICYmIG9wdGlvbnMucGF0aCkgewoJICAgIHZhciBzZWFyY2hQb3MgPSBvcHRpb25zLnBhdGguaW5kZXhPZigiPyIpOwoJICAgIGlmIChzZWFyY2hQb3MgPCAwKSB7CgkgICAgICBvcHRpb25zLnBhdGhuYW1lID0gb3B0aW9ucy5wYXRoOwoJICAgIH0KCSAgICBlbHNlIHsKCSAgICAgIG9wdGlvbnMucGF0aG5hbWUgPSBvcHRpb25zLnBhdGguc3Vic3RyaW5nKDAsIHNlYXJjaFBvcyk7CgkgICAgICBvcHRpb25zLnNlYXJjaCA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoc2VhcmNoUG9zKTsKCSAgICB9CgkgIH0KCX07CgoKCS8vIEV4ZWN1dGVzIHRoZSBuZXh0IG5hdGl2ZSByZXF1ZXN0IChpbml0aWFsIG9yIHJlZGlyZWN0KQoJUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3BlcmZvcm1SZXF1ZXN0ID0gZnVuY3Rpb24gKCkgewoJICAvLyBMb2FkIHRoZSBuYXRpdmUgcHJvdG9jb2wKCSAgdmFyIHByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5wcm90b2NvbDsKCSAgdmFyIG5hdGl2ZVByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5uYXRpdmVQcm90b2NvbHNbcHJvdG9jb2xdOwoJICBpZiAoIW5hdGl2ZVByb3RvY29sKSB7CgkgICAgdGhpcy5lbWl0KCJlcnJvciIsIG5ldyBUeXBlRXJyb3IoIlVuc3VwcG9ydGVkIHByb3RvY29sICIgKyBwcm90b2NvbCkpOwoJICAgIHJldHVybjsKCSAgfQoKCSAgLy8gSWYgc3BlY2lmaWVkLCB1c2UgdGhlIGFnZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3RvY29sCgkgIC8vIChIVFRQIGFuZCBIVFRQUyB1c2UgZGlmZmVyZW50IHR5cGVzIG9mIGFnZW50cykKCSAgaWYgKHRoaXMuX29wdGlvbnMuYWdlbnRzKSB7CgkgICAgdmFyIHNjaGVtZSA9IHByb3RvY29sLnN1YnN0cigwLCBwcm90b2NvbC5sZW5ndGggLSAxKTsKCSAgICB0aGlzLl9vcHRpb25zLmFnZW50ID0gdGhpcy5fb3B0aW9ucy5hZ2VudHNbc2NoZW1lXTsKCSAgfQoKCSAgLy8gQ3JlYXRlIHRoZSBuYXRpdmUgcmVxdWVzdAoJICB2YXIgcmVxdWVzdCA9IHRoaXMuX2N1cnJlbnRSZXF1ZXN0ID0KCSAgICAgICAgbmF0aXZlUHJvdG9jb2wucmVxdWVzdCh0aGlzLl9vcHRpb25zLCB0aGlzLl9vbk5hdGl2ZVJlc3BvbnNlKTsKCSAgdGhpcy5fY3VycmVudFVybCA9IHVybC5mb3JtYXQodGhpcy5fb3B0aW9ucyk7CgoJICAvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMKCSAgcmVxdWVzdC5fcmVkaXJlY3RhYmxlID0gdGhpczsKCSAgZm9yICh2YXIgZSA9IDA7IGUgPCBldmVudHMubGVuZ3RoOyBlKyspIHsKCSAgICByZXF1ZXN0Lm9uKGV2ZW50c1tlXSwgZXZlbnRIYW5kbGVyc1tldmVudHNbZV1dKTsKCSAgfQoKCSAgLy8gRW5kIGEgcmVkaXJlY3RlZCByZXF1ZXN0CgkgIC8vIChUaGUgZmlyc3QgcmVxdWVzdCBtdXN0IGJlIGVuZGVkIGV4cGxpY2l0bHkgd2l0aCBSZWRpcmVjdGFibGVSZXF1ZXN0I2VuZCkKCSAgaWYgKHRoaXMuX2lzUmVkaXJlY3QpIHsKCSAgICAvLyBXcml0ZSB0aGUgcmVxdWVzdCBlbnRpdHkgYW5kIGVuZC4KCSAgICB2YXIgaSA9IDA7CgkgICAgdmFyIHNlbGYgPSB0aGlzOwoJICAgIHZhciBidWZmZXJzID0gdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzOwoJICAgIChmdW5jdGlvbiB3cml0ZU5leHQoZXJyb3IpIHsKCSAgICAgIC8vIE9ubHkgd3JpdGUgaWYgdGhpcyByZXF1ZXN0IGhhcyBub3QgYmVlbiByZWRpcmVjdGVkIHlldAoJICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi8KCSAgICAgIGlmIChyZXF1ZXN0ID09PSBzZWxmLl9jdXJyZW50UmVxdWVzdCkgewoJICAgICAgICAvLyBSZXBvcnQgYW55IHdyaXRlIGVycm9ycwoJICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8KCSAgICAgICAgaWYgKGVycm9yKSB7CgkgICAgICAgICAgc2VsZi5lbWl0KCJlcnJvciIsIGVycm9yKTsKCSAgICAgICAgfQoJICAgICAgICAvLyBXcml0ZSB0aGUgbmV4dCBidWZmZXIgaWYgdGhlcmUgYXJlIHN0aWxsIGxlZnQKCSAgICAgICAgZWxzZSBpZiAoaSA8IGJ1ZmZlcnMubGVuZ3RoKSB7CgkgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbaSsrXTsKCSAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLwoJICAgICAgICAgIGlmICghcmVxdWVzdC5maW5pc2hlZCkgewoJICAgICAgICAgICAgcmVxdWVzdC53cml0ZShidWZmZXIuZGF0YSwgYnVmZmVyLmVuY29kaW5nLCB3cml0ZU5leHQpOwoJICAgICAgICAgIH0KCSAgICAgICAgfQoJICAgICAgICAvLyBFbmQgdGhlIHJlcXVlc3QgaWYgYGVuZGAgaGFzIGJlZW4gY2FsbGVkIG9uIHVzCgkgICAgICAgIGVsc2UgaWYgKHNlbGYuX2VuZGVkKSB7CgkgICAgICAgICAgcmVxdWVzdC5lbmQoKTsKCSAgICAgICAgfQoJICAgICAgfQoJICAgIH0oKSk7CgkgIH0KCX07CgoJLy8gUHJvY2Vzc2VzIGEgcmVzcG9uc2UgZnJvbSB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdAoJUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3Byb2Nlc3NSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkgewoJICAvLyBTdG9yZSB0aGUgcmVkaXJlY3RlZCByZXNwb25zZQoJICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7CgkgIGlmICh0aGlzLl9vcHRpb25zLnRyYWNrUmVkaXJlY3RzKSB7CgkgICAgdGhpcy5fcmVkaXJlY3RzLnB1c2goewoJICAgICAgdXJsOiB0aGlzLl9jdXJyZW50VXJsLAoJICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycywKCSAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsCgkgICAgfSk7CgkgIH0KCgkgIC8vIFJGQzcyMzHCpzYuNDogVGhlIDN4eCAoUmVkaXJlY3Rpb24pIGNsYXNzIG9mIHN0YXR1cyBjb2RlIGluZGljYXRlcwoJICAvLyB0aGF0IGZ1cnRoZXIgYWN0aW9uIG5lZWRzIHRvIGJlIHRha2VuIGJ5IHRoZSB1c2VyIGFnZW50IGluIG9yZGVyIHRvCgkgIC8vIGZ1bGZpbGwgdGhlIHJlcXVlc3QuIElmIGEgTG9jYXRpb24gaGVhZGVyIGZpZWxkIGlzIHByb3ZpZGVkLAoJICAvLyB0aGUgdXNlciBhZ2VudCBNQVkgYXV0b21hdGljYWxseSByZWRpcmVjdCBpdHMgcmVxdWVzdCB0byB0aGUgVVJJCgkgIC8vIHJlZmVyZW5jZWQgYnkgdGhlIExvY2F0aW9uIGZpZWxkIHZhbHVlLAoJICAvLyBldmVuIGlmIHRoZSBzcGVjaWZpYyBzdGF0dXMgY29kZSBpcyBub3QgdW5kZXJzdG9vZC4KCgkgIC8vIElmIHRoZSByZXNwb25zZSBpcyBub3QgYSByZWRpcmVjdDsgcmV0dXJuIGl0IGFzLWlzCgkgIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247CgkgIGlmICghbG9jYXRpb24gfHwgdGhpcy5fb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgPT09IGZhbHNlIHx8CgkgICAgICBzdGF0dXNDb2RlIDwgMzAwIHx8IHN0YXR1c0NvZGUgPj0gNDAwKSB7CgkgICAgcmVzcG9uc2UucmVzcG9uc2VVcmwgPSB0aGlzLl9jdXJyZW50VXJsOwoJICAgIHJlc3BvbnNlLnJlZGlyZWN0cyA9IHRoaXMuX3JlZGlyZWN0czsKCSAgICB0aGlzLmVtaXQoInJlc3BvbnNlIiwgcmVzcG9uc2UpOwoKCSAgICAvLyBDbGVhbiB1cAoJICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdOwoJICAgIHJldHVybjsKCSAgfQoKCSAgLy8gVGhlIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QsIHNvIGFib3J0IHRoZSBjdXJyZW50IHJlcXVlc3QKCSAgYWJvcnRSZXF1ZXN0KHRoaXMuX2N1cnJlbnRSZXF1ZXN0KTsKCSAgLy8gRGlzY2FyZCB0aGUgcmVtYWluZGVyIG9mIHRoZSByZXNwb25zZSB0byBhdm9pZCB3YWl0aW5nIGZvciBkYXRhCgkgIHJlc3BvbnNlLmRlc3Ryb3koKTsKCgkgIC8vIFJGQzcyMzHCpzYuNDogQSBjbGllbnQgU0hPVUxEIGRldGVjdCBhbmQgaW50ZXJ2ZW5lCgkgIC8vIGluIGN5Y2xpY2FsIHJlZGlyZWN0aW9ucyAoaS5lLiwgImluZmluaXRlIiByZWRpcmVjdGlvbiBsb29wcykuCgkgIGlmICgrK3RoaXMuX3JlZGlyZWN0Q291bnQgPiB0aGlzLl9vcHRpb25zLm1heFJlZGlyZWN0cykgewoJICAgIHRoaXMuZW1pdCgiZXJyb3IiLCBuZXcgVG9vTWFueVJlZGlyZWN0c0Vycm9yKCkpOwoJICAgIHJldHVybjsKCSAgfQoKCSAgLy8gUkZDNzIzMcKnNi40OiBBdXRvbWF0aWMgcmVkaXJlY3Rpb24gbmVlZHMgdG8gZG9uZSB3aXRoCgkgIC8vIGNhcmUgZm9yIG1ldGhvZHMgbm90IGtub3duIHRvIGJlIHNhZmUsIFvigKZdCgkgIC8vIFJGQzcyMzHCpzYuNC4y4oCTMzogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgYSB1c2VyIGFnZW50IE1BWSBjaGFuZ2UKCSAgLy8gdGhlIHJlcXVlc3QgbWV0aG9kIGZyb20gUE9TVCB0byBHRVQgZm9yIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3QuCgkgIGlmICgoc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHN0YXR1c0NvZGUgPT09IDMwMikgJiYgdGhpcy5fb3B0aW9ucy5tZXRob2QgPT09ICJQT1NUIiB8fAoJICAgICAgLy8gUkZDNzIzMcKnNi40LjQ6IFRoZSAzMDMgKFNlZSBPdGhlcikgc3RhdHVzIGNvZGUgaW5kaWNhdGVzIHRoYXQKCSAgICAgIC8vIHRoZSBzZXJ2ZXIgaXMgcmVkaXJlY3RpbmcgdGhlIHVzZXIgYWdlbnQgdG8gYSBkaWZmZXJlbnQgcmVzb3VyY2UgW+KApl0KCSAgICAgIC8vIEEgdXNlciBhZ2VudCBjYW4gcGVyZm9ybSBhIHJldHJpZXZhbCByZXF1ZXN0IHRhcmdldGluZyB0aGF0IFVSSQoJICAgICAgLy8gKGEgR0VUIG9yIEhFQUQgcmVxdWVzdCBpZiB1c2luZyBIVFRQKSBb4oCmXQoJICAgICAgKHN0YXR1c0NvZGUgPT09IDMwMykgJiYgIS9eKD86R0VUfEhFQUQpJC8udGVzdCh0aGlzLl9vcHRpb25zLm1ldGhvZCkpIHsKCSAgICB0aGlzLl9vcHRpb25zLm1ldGhvZCA9ICJHRVQiOwoJICAgIC8vIERyb3AgYSBwb3NzaWJsZSBlbnRpdHkgYW5kIGhlYWRlcnMgcmVsYXRlZCB0byBpdAoJICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdOwoJICAgIHJlbW92ZU1hdGNoaW5nSGVhZGVycygvXmNvbnRlbnQtL2ksIHRoaXMuX29wdGlvbnMuaGVhZGVycyk7CgkgIH0KCgkgIC8vIERyb3AgdGhlIEhvc3QgaGVhZGVyLCBhcyB0aGUgcmVkaXJlY3QgbWlnaHQgbGVhZCB0byBhIGRpZmZlcmVudCBob3N0CgkgIHZhciBjdXJyZW50SG9zdEhlYWRlciA9IHJlbW92ZU1hdGNoaW5nSGVhZGVycygvXmhvc3QkL2ksIHRoaXMuX29wdGlvbnMuaGVhZGVycyk7CgoJICAvLyBJZiB0aGUgcmVkaXJlY3QgaXMgcmVsYXRpdmUsIGNhcnJ5IG92ZXIgdGhlIGhvc3Qgb2YgdGhlIGxhc3QgcmVxdWVzdAoJICB2YXIgY3VycmVudFVybFBhcnRzID0gdXJsLnBhcnNlKHRoaXMuX2N1cnJlbnRVcmwpOwoJICB2YXIgY3VycmVudEhvc3QgPSBjdXJyZW50SG9zdEhlYWRlciB8fCBjdXJyZW50VXJsUGFydHMuaG9zdDsKCSAgdmFyIGN1cnJlbnRVcmwgPSAvXlx3KzovLnRlc3QobG9jYXRpb24pID8gdGhpcy5fY3VycmVudFVybCA6CgkgICAgdXJsLmZvcm1hdChPYmplY3QuYXNzaWduKGN1cnJlbnRVcmxQYXJ0cywgeyBob3N0OiBjdXJyZW50SG9zdCB9KSk7CgoJICAvLyBEZXRlcm1pbmUgdGhlIFVSTCBvZiB0aGUgcmVkaXJlY3Rpb24KCSAgdmFyIHJlZGlyZWN0VXJsOwoJICB0cnkgewoJICAgIHJlZGlyZWN0VXJsID0gdXJsLnJlc29sdmUoY3VycmVudFVybCwgbG9jYXRpb24pOwoJICB9CgkgIGNhdGNoIChjYXVzZSkgewoJICAgIHRoaXMuZW1pdCgiZXJyb3IiLCBuZXcgUmVkaXJlY3Rpb25FcnJvcihjYXVzZSkpOwoJICAgIHJldHVybjsKCSAgfQoKCSAgLy8gQ3JlYXRlIHRoZSByZWRpcmVjdGVkIHJlcXVlc3QKCSAgZGVidWcoInJlZGlyZWN0aW5nIHRvIiwgcmVkaXJlY3RVcmwpOwoJICB0aGlzLl9pc1JlZGlyZWN0ID0gdHJ1ZTsKCSAgdmFyIHJlZGlyZWN0VXJsUGFydHMgPSB1cmwucGFyc2UocmVkaXJlY3RVcmwpOwoJICBPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsIHJlZGlyZWN0VXJsUGFydHMpOwoKCSAgLy8gRHJvcCBjb25maWRlbnRpYWwgaGVhZGVycyB3aGVuIHJlZGlyZWN0aW5nIHRvIGEgbGVzcyBzZWN1cmUgcHJvdG9jb2wKCSAgLy8gb3IgdG8gYSBkaWZmZXJlbnQgZG9tYWluIHRoYXQgaXMgbm90IGEgc3VwZXJkb21haW4KCSAgaWYgKHJlZGlyZWN0VXJsUGFydHMucHJvdG9jb2wgIT09IGN1cnJlbnRVcmxQYXJ0cy5wcm90b2NvbCAmJgoJICAgICByZWRpcmVjdFVybFBhcnRzLnByb3RvY29sICE9PSAiaHR0cHM6IiB8fAoJICAgICByZWRpcmVjdFVybFBhcnRzLmhvc3QgIT09IGN1cnJlbnRIb3N0ICYmCgkgICAgICFpc1N1YmRvbWFpbihyZWRpcmVjdFVybFBhcnRzLmhvc3QsIGN1cnJlbnRIb3N0KSkgewoJICAgIHJlbW92ZU1hdGNoaW5nSGVhZGVycygvXig/OmF1dGhvcml6YXRpb258Y29va2llKSQvaSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTsKCSAgfQoKCSAgLy8gRXZhbHVhdGUgdGhlIGJlZm9yZVJlZGlyZWN0IGNhbGxiYWNrCgkgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5iZWZvcmVSZWRpcmVjdCA9PT0gImZ1bmN0aW9uIikgewoJICAgIHZhciByZXNwb25zZURldGFpbHMgPSB7IGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMgfTsKCSAgICB0cnkgewoJICAgICAgdGhpcy5fb3B0aW9ucy5iZWZvcmVSZWRpcmVjdC5jYWxsKG51bGwsIHRoaXMuX29wdGlvbnMsIHJlc3BvbnNlRGV0YWlscyk7CgkgICAgfQoJICAgIGNhdGNoIChlcnIpIHsKCSAgICAgIHRoaXMuZW1pdCgiZXJyb3IiLCBlcnIpOwoJICAgICAgcmV0dXJuOwoJICAgIH0KCSAgICB0aGlzLl9zYW5pdGl6ZU9wdGlvbnModGhpcy5fb3B0aW9ucyk7CgkgIH0KCgkgIC8vIFBlcmZvcm0gdGhlIHJlZGlyZWN0ZWQgcmVxdWVzdAoJICB0cnkgewoJICAgIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KCk7CgkgIH0KCSAgY2F0Y2ggKGNhdXNlKSB7CgkgICAgdGhpcy5lbWl0KCJlcnJvciIsIG5ldyBSZWRpcmVjdGlvbkVycm9yKGNhdXNlKSk7CgkgIH0KCX07CgoJLy8gV3JhcHMgdGhlIGtleS92YWx1ZSBvYmplY3Qgb2YgcHJvdG9jb2xzIHdpdGggcmVkaXJlY3QgZnVuY3Rpb25hbGl0eQoJZnVuY3Rpb24gd3JhcChwcm90b2NvbHMpIHsKCSAgLy8gRGVmYXVsdCBzZXR0aW5ncwoJICB2YXIgZXhwb3J0cyA9IHsKCSAgICBtYXhSZWRpcmVjdHM6IDIxLAoJICAgIG1heEJvZHlMZW5ndGg6IDEwICogMTAyNCAqIDEwMjQsCgkgIH07CgoJICAvLyBXcmFwIGVhY2ggcHJvdG9jb2wKCSAgdmFyIG5hdGl2ZVByb3RvY29scyA9IHt9OwoJICBPYmplY3Qua2V5cyhwcm90b2NvbHMpLmZvckVhY2goZnVuY3Rpb24gKHNjaGVtZSkgewoJICAgIHZhciBwcm90b2NvbCA9IHNjaGVtZSArICI6IjsKCSAgICB2YXIgbmF0aXZlUHJvdG9jb2wgPSBuYXRpdmVQcm90b2NvbHNbcHJvdG9jb2xdID0gcHJvdG9jb2xzW3NjaGVtZV07CgkgICAgdmFyIHdyYXBwZWRQcm90b2NvbCA9IGV4cG9ydHNbc2NoZW1lXSA9IE9iamVjdC5jcmVhdGUobmF0aXZlUHJvdG9jb2wpOwoKCSAgICAvLyBFeGVjdXRlcyBhIHJlcXVlc3QsIGZvbGxvd2luZyByZWRpcmVjdHMKCSAgICBmdW5jdGlvbiByZXF1ZXN0KGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaykgewoJICAgICAgLy8gUGFyc2UgcGFyYW1ldGVycwoJICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gInN0cmluZyIpIHsKCSAgICAgICAgdmFyIHVybFN0ciA9IGlucHV0OwoJICAgICAgICB0cnkgewoJICAgICAgICAgIGlucHV0ID0gdXJsVG9PcHRpb25zKG5ldyBVUkwodXJsU3RyKSk7CgkgICAgICAgIH0KCSAgICAgICAgY2F0Y2ggKGVycikgewoJICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovCgkgICAgICAgICAgaW5wdXQgPSB1cmwucGFyc2UodXJsU3RyKTsKCSAgICAgICAgfQoJICAgICAgfQoJICAgICAgZWxzZSB7CgkgICAgICAgIGNhbGxiYWNrID0gb3B0aW9uczsKCSAgICAgICAgb3B0aW9ucyA9IGlucHV0OwoJICAgICAgICBpbnB1dCA9IHsgcHJvdG9jb2w6IHByb3RvY29sIH07CgkgICAgICB9CgkgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICJmdW5jdGlvbiIpIHsKCSAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zOwoJICAgICAgICBvcHRpb25zID0gbnVsbDsKCSAgICAgIH0KCgkgICAgICAvLyBTZXQgZGVmYXVsdHMKCSAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsKCSAgICAgICAgbWF4UmVkaXJlY3RzOiBleHBvcnRzLm1heFJlZGlyZWN0cywKCSAgICAgICAgbWF4Qm9keUxlbmd0aDogZXhwb3J0cy5tYXhCb2R5TGVuZ3RoLAoJICAgICAgfSwgaW5wdXQsIG9wdGlvbnMpOwoJICAgICAgb3B0aW9ucy5uYXRpdmVQcm90b2NvbHMgPSBuYXRpdmVQcm90b2NvbHM7CgoJICAgICAgYXNzZXJ0JDEuZXF1YWwob3B0aW9ucy5wcm90b2NvbCwgcHJvdG9jb2wsICJwcm90b2NvbCBtaXNtYXRjaCIpOwoJICAgICAgZGVidWcoIm9wdGlvbnMiLCBvcHRpb25zKTsKCSAgICAgIHJldHVybiBuZXcgUmVkaXJlY3RhYmxlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7CgkgICAgfQoKCSAgICAvLyBFeGVjdXRlcyBhIEdFVCByZXF1ZXN0LCBmb2xsb3dpbmcgcmVkaXJlY3RzCgkgICAgZnVuY3Rpb24gZ2V0KGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaykgewoJICAgICAgdmFyIHdyYXBwZWRSZXF1ZXN0ID0gd3JhcHBlZFByb3RvY29sLnJlcXVlc3QoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKTsKCSAgICAgIHdyYXBwZWRSZXF1ZXN0LmVuZCgpOwoJICAgICAgcmV0dXJuIHdyYXBwZWRSZXF1ZXN0OwoJICAgIH0KCgkgICAgLy8gRXhwb3NlIHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSB3cmFwcGVkIHByb3RvY29sCgkgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZFByb3RvY29sLCB7CgkgICAgICByZXF1ZXN0OiB7IHZhbHVlOiByZXF1ZXN0LCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sCgkgICAgICBnZXQ6IHsgdmFsdWU6IGdldCwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LAoJICAgIH0pOwoJICB9KTsKCSAgcmV0dXJuIGV4cG9ydHM7Cgl9CgoJLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8KCWZ1bmN0aW9uIG5vb3AoKSB7IC8qIGVtcHR5ICovIH0KCgkvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvdXJsLmpzCglmdW5jdGlvbiB1cmxUb09wdGlvbnModXJsT2JqZWN0KSB7CgkgIHZhciBvcHRpb25zID0gewoJICAgIHByb3RvY29sOiB1cmxPYmplY3QucHJvdG9jb2wsCgkgICAgaG9zdG5hbWU6IHVybE9iamVjdC5ob3N0bmFtZS5zdGFydHNXaXRoKCJbIikgPwoJICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8KCSAgICAgIHVybE9iamVjdC5ob3N0bmFtZS5zbGljZSgxLCAtMSkgOgoJICAgICAgdXJsT2JqZWN0Lmhvc3RuYW1lLAoJICAgIGhhc2g6IHVybE9iamVjdC5oYXNoLAoJICAgIHNlYXJjaDogdXJsT2JqZWN0LnNlYXJjaCwKCSAgICBwYXRobmFtZTogdXJsT2JqZWN0LnBhdGhuYW1lLAoJICAgIHBhdGg6IHVybE9iamVjdC5wYXRobmFtZSArIHVybE9iamVjdC5zZWFyY2gsCgkgICAgaHJlZjogdXJsT2JqZWN0LmhyZWYsCgkgIH07CgkgIGlmICh1cmxPYmplY3QucG9ydCAhPT0gIiIpIHsKCSAgICBvcHRpb25zLnBvcnQgPSBOdW1iZXIodXJsT2JqZWN0LnBvcnQpOwoJICB9CgkgIHJldHVybiBvcHRpb25zOwoJfQoKCWZ1bmN0aW9uIHJlbW92ZU1hdGNoaW5nSGVhZGVycyhyZWdleCwgaGVhZGVycykgewoJICB2YXIgbGFzdFZhbHVlOwoJICBmb3IgKHZhciBoZWFkZXIgaW4gaGVhZGVycykgewoJICAgIGlmIChyZWdleC50ZXN0KGhlYWRlcikpIHsKCSAgICAgIGxhc3RWYWx1ZSA9IGhlYWRlcnNbaGVhZGVyXTsKCSAgICAgIGRlbGV0ZSBoZWFkZXJzW2hlYWRlcl07CgkgICAgfQoJICB9CgkgIHJldHVybiAobGFzdFZhbHVlID09PSBudWxsIHx8IHR5cGVvZiBsYXN0VmFsdWUgPT09ICJ1bmRlZmluZWQiKSA/CgkgICAgdW5kZWZpbmVkIDogU3RyaW5nKGxhc3RWYWx1ZSkudHJpbSgpOwoJfQoKCWZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBkZWZhdWx0TWVzc2FnZSkgewoJICBmdW5jdGlvbiBDdXN0b21FcnJvcihjYXVzZSkgewoJICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpOwoJICAgIGlmICghY2F1c2UpIHsKCSAgICAgIHRoaXMubWVzc2FnZSA9IGRlZmF1bHRNZXNzYWdlOwoJICAgIH0KCSAgICBlbHNlIHsKCSAgICAgIHRoaXMubWVzc2FnZSA9IGRlZmF1bHRNZXNzYWdlICsgIjogIiArIGNhdXNlLm1lc3NhZ2U7CgkgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7CgkgICAgfQoJICB9CgkgIEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpOwoJICBDdXN0b21FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjsKCSAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLm5hbWUgPSAiRXJyb3IgWyIgKyBjb2RlICsgIl0iOwoJICBDdXN0b21FcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7CgkgIHJldHVybiBDdXN0b21FcnJvcjsKCX0KCglmdW5jdGlvbiBhYm9ydFJlcXVlc3QocmVxdWVzdCkgewoJICBmb3IgKHZhciBlID0gMDsgZSA8IGV2ZW50cy5sZW5ndGg7IGUrKykgewoJICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoZXZlbnRzW2VdLCBldmVudEhhbmRsZXJzW2V2ZW50c1tlXV0pOwoJICB9CgkgIHJlcXVlc3Qub24oImVycm9yIiwgbm9vcCk7CgkgIHJlcXVlc3QuYWJvcnQoKTsKCX0KCglmdW5jdGlvbiBpc1N1YmRvbWFpbihzdWJkb21haW4sIGRvbWFpbikgewoJICBjb25zdCBkb3QgPSBzdWJkb21haW4ubGVuZ3RoIC0gZG9tYWluLmxlbmd0aCAtIDE7CgkgIHJldHVybiBkb3QgPiAwICYmIHN1YmRvbWFpbltkb3RdID09PSAiLiIgJiYgc3ViZG9tYWluLmVuZHNXaXRoKGRvbWFpbik7Cgl9CgoJLy8gRXhwb3J0cwoJZm9sbG93UmVkaXJlY3RzLmV4cG9ydHMgPSB3cmFwKHsgaHR0cDogaHR0cCwgaHR0cHM6IGh0dHBzJDEgfSk7Cglmb2xsb3dSZWRpcmVjdHMuZXhwb3J0cy53cmFwID0gd3JhcDsKCgl2YXIgU1RSRUFNID0gU3RyZWFtLAoJICAgIFVUSUwgPSByZXF1aXJlJCQxJDEsCgkgICAgU3RyaW5nRGVjb2RlciA9IHN0cmluZ19kZWNvZGVyLlN0cmluZ0RlY29kZXI7CgoJZnVuY3Rpb24gTWVtb3J5UmVhZGFibGVTdHJlYW0oZGF0YSwgb3B0aW9ucykgewoJICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNZW1vcnlSZWFkYWJsZVN0cmVhbSkpCgkgICAgICAgIHJldHVybiBuZXcgTWVtb3J5UmVhZGFibGVTdHJlYW0oZGF0YSwgb3B0aW9ucyk7CgkgICAgTWVtb3J5UmVhZGFibGVTdHJlYW0uc3VwZXJfLmNhbGwodGhpcywgb3B0aW9ucyk7CgkgICAgdGhpcy5pbml0KGRhdGEsIG9wdGlvbnMpOwoJfQoJVVRJTC5pbmhlcml0cyhNZW1vcnlSZWFkYWJsZVN0cmVhbSwgU1RSRUFNLlJlYWRhYmxlKTsKCgoJZnVuY3Rpb24gTWVtb3J5V3JpdGFibGVTdHJlYW0oZGF0YSwgb3B0aW9ucykgewoJICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNZW1vcnlXcml0YWJsZVN0cmVhbSkpCgkgICAgICAgIHJldHVybiBuZXcgTWVtb3J5V3JpdGFibGVTdHJlYW0oZGF0YSwgb3B0aW9ucyk7CgkgICAgTWVtb3J5V3JpdGFibGVTdHJlYW0uc3VwZXJfLmNhbGwodGhpcywgb3B0aW9ucyk7CgkgICAgdGhpcy5pbml0KGRhdGEsIG9wdGlvbnMpOwoJfQoJVVRJTC5pbmhlcml0cyhNZW1vcnlXcml0YWJsZVN0cmVhbSwgU1RSRUFNLldyaXRhYmxlKTsKCgoJZnVuY3Rpb24gTWVtb3J5RHVwbGV4U3RyZWFtKGRhdGEsIG9wdGlvbnMpIHsKCSAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWVtb3J5RHVwbGV4U3RyZWFtKSkKCSAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlEdXBsZXhTdHJlYW0oZGF0YSwgb3B0aW9ucyk7CgkgICAgTWVtb3J5RHVwbGV4U3RyZWFtLnN1cGVyXy5jYWxsKHRoaXMsIG9wdGlvbnMpOwoJICAgIHRoaXMuaW5pdChkYXRhLCBvcHRpb25zKTsKCX0KCVVUSUwuaW5oZXJpdHMoTWVtb3J5RHVwbGV4U3RyZWFtLCBTVFJFQU0uRHVwbGV4KTsKCgoJTWVtb3J5UmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLmluaXQgPQoJTWVtb3J5V3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmluaXQgPQoJTWVtb3J5RHVwbGV4U3RyZWFtLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoZGF0YSwgb3B0aW9ucykgewoJICAgIHZhciBzZWxmID0gdGhpczsKCSAgICB0aGlzLnF1ZXVlID0gW107CgoJICAgIGlmIChkYXRhKSB7CgkgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkgewoJICAgICAgICAgICAgZGF0YSA9IFsgZGF0YSBdOwoJICAgICAgICB9CgoJICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7CgkgICAgICAgICAgICBpZiAoIShjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlciQxKSkgewoJICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IEJ1ZmZlciQxKGNodW5rKTsKCSAgICAgICAgICAgIH0KCSAgICAgICAgICAgIHNlbGYucXVldWUucHVzaChjaHVuayk7CgkgICAgICAgIH0pOwoKCSAgICB9CgkgICAgCgkgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CgkgICAgCgkgICAgdGhpcy5tYXhidWZzaXplID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbWF4YnVmc2l6ZScpID8gb3B0aW9ucy5tYXhidWZzaXplCgkgICAgICAgICAgICA6IG51bGw7CgkgICAgdGhpcy5idWZvdmVyZmxvdyA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2J1Zm92ZXJmbG93JykgPyBvcHRpb25zLmJ1Zm92ZXJmbG93CgkgICAgICAgICAgICA6IG51bGw7CgkgICAgdGhpcy5mcmVxdWVuY2UgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdmcmVxdWVuY2UnKSA/IG9wdGlvbnMuZnJlcXVlbmNlCgkgICAgICAgICAgICA6IG51bGw7Cgl9OwoKCWZ1bmN0aW9uIE1lbW9yeVN0cmVhbSQxIChkYXRhLCBvcHRpb25zKSB7CgkgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1lbW9yeVN0cmVhbSQxKSkKCSAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlTdHJlYW0kMShkYXRhLCBvcHRpb25zKTsKCSAgICAKCSAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKCSAgICAKCSAgICB2YXIgcmVhZGFibGUgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdyZWFkYWJsZScpID8gb3B0aW9ucy5yZWFkYWJsZSA6IHRydWUsCgkgICAgICAgIHdyaXRhYmxlID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnd3JpdGFibGUnKSA/IG9wdGlvbnMud3JpdGFibGUgOiB0cnVlOwoJICAgIAoJICAgIGlmIChyZWFkYWJsZSAmJiB3cml0YWJsZSkgewoJICAgICAgICByZXR1cm4gbmV3IE1lbW9yeUR1cGxleFN0cmVhbShkYXRhLCBvcHRpb25zKTsKCSAgICB9IGVsc2UgaWYgKHJlYWRhYmxlKSB7CgkgICAgICAgIHJldHVybiBuZXcgTWVtb3J5UmVhZGFibGVTdHJlYW0oZGF0YSwgb3B0aW9ucyk7CgkgICAgfSBlbHNlIGlmICh3cml0YWJsZSkgewoJICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVdyaXRhYmxlU3RyZWFtKGRhdGEsIG9wdGlvbnMpOwoJICAgIH0gZWxzZSB7CgkgICAgICAgIHRocm93IG5ldyBFcnJvcigiVW5rbm93biBzdHJlYW0gdHlwZSAgUmVhZGFibGUsIFdyaXRhYmxlIG9yIER1cGxleCAiKTsKCSAgICB9Cgl9CgoKCU1lbW9yeVN0cmVhbSQxLmNyZWF0ZVJlYWRTdHJlYW0gPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykgewoJICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwoJICAgIG9wdGlvbnMucmVhZGFibGUgPSB0cnVlOwoJICAgIG9wdGlvbnMud3JpdGFibGUgPSBmYWxzZTsKCgkgICAgcmV0dXJuIG5ldyBNZW1vcnlTdHJlYW0kMShkYXRhLCBvcHRpb25zKTsKCX07CgoKCU1lbW9yeVN0cmVhbSQxLmNyZWF0ZVdyaXRlU3RyZWFtID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHsKCSAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKCSAgICBvcHRpb25zLnJlYWRhYmxlID0gZmFsc2U7CgkgICAgb3B0aW9ucy53cml0YWJsZSA9IHRydWU7CgoJICAgIHJldHVybiBuZXcgTWVtb3J5U3RyZWFtJDEoZGF0YSwgb3B0aW9ucyk7Cgl9OwoKCglNZW1vcnlSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPQoJTWVtb3J5RHVwbGV4U3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIF9yZWFkIChuKSB7CgkgICAgdmFyIHNlbGYgPSB0aGlzLAoJICAgICAgICBmcmVxdWVuY2UgPSBzZWxmLmZyZXF1ZW5jZSB8fCAwLAoJICAgICAgICB3YWl0X2RhdGEgPSB0aGlzIGluc3RhbmNlb2YgU1RSRUFNLkR1cGxleCAmJiAhIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPyB0cnVlIDogZmFsc2U7CgkgICAgaWYgKCAhIHRoaXMucXVldWUubGVuZ3RoICYmICEgd2FpdF9kYXRhKSB7CgkgICAgICAgIHRoaXMucHVzaChudWxsKTsvLyBmaW5pc2ggc3RyZWFtCgkgICAgfSBlbHNlIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCkgewoJICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKCSAgICAgICAgICAgIGlmIChzZWxmLnF1ZXVlLmxlbmd0aCkgewoJICAgICAgICAgICAgICAgIHZhciBjaHVuayA9IHNlbGYucXVldWUuc2hpZnQoKTsKCSAgICAgICAgICAgICAgICBpZiAoY2h1bmsgJiYgISBzZWxmLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSB7CgkgICAgICAgICAgICAgICAgICAgIGlmICggISBzZWxmLnB1c2goY2h1bmspICkgewoJICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5xdWV1ZS51bnNoaWZ0KGNodW5rKTsKCSAgICAgICAgICAgICAgICAgICAgfQoJICAgICAgICAgICAgICAgIH0KCSAgICAgICAgICAgIH0KCSAgICAgICAgfSwgZnJlcXVlbmNlKTsKCSAgICB9Cgl9OwoKCglNZW1vcnlXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0KCU1lbW9yeUR1cGxleFN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CgkgICAgdmFyIGRlY29kZXIgPSBudWxsOwoJICAgIHRyeSB7CgkgICAgICAgIGRlY29kZXIgPSB0aGlzLmRlY29kZVN0cmluZ3MgJiYgZW5jb2RpbmcgPyBuZXcgU3RyaW5nRGVjb2RlcihlbmNvZGluZykgOiBudWxsOwoJICAgIH0gY2F0Y2ggKGVycil7CgkgICAgICAgIHJldHVybiBjYihlcnIpOwoJICAgIH0KCSAgICAKCSAgICB2YXIgZGVjb2RlZF9jaHVuayA9IGRlY29kZXIgPyBkZWNvZGVyLndyaXRlKGNodW5rKSA6IGNodW5rLAoJICAgICAgICBxdWV1ZV9zaXplID0gdGhpcy5fZ2V0UXVldWVTaXplKCksCgkgICAgICAgIGNodW5rX3NpemUgPSBkZWNvZGVkX2NodW5rLmxlbmd0aDsKCSAgICAKCSAgICBpZiAodGhpcy5tYXhidWZzaXplICYmIChxdWV1ZV9zaXplICsgY2h1bmtfc2l6ZSkgPiB0aGlzLm1heGJ1ZnNpemUgKSB7CgkgICAgICAgIGlmICh0aGlzLmJ1Zm92ZXJmbG93KSB7CgkgICAgICAgICAgICByZXR1cm4gY2IoIkJ1ZmZlciBvdmVyZmxvd2VkICgiICsgdGhpcy5idWZvdmVyZmxvdyArICIvIiArIHF1ZXVlX3NpemUgKyAiKSIpOwoJICAgICAgICB9IGVsc2UgewoJICAgICAgICAgICAgcmV0dXJuIGNiKCk7CgkgICAgICAgIH0KCSAgICB9CgkgICAgCgkgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTVFJFQU0uRHVwbGV4KSB7CgkgICAgICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCkgewoJICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMucXVldWUuc2hpZnQoKSk7CgkgICAgICAgIH0KCSAgICAgICAgdGhpcy5wdXNoKGRlY29kZWRfY2h1bmspOwoJICAgIH0gZWxzZSB7CgkgICAgICAgIHRoaXMucXVldWUucHVzaChkZWNvZGVkX2NodW5rKTsKCSAgICB9CgkgICAgY2IoKTsKCX07CgoKCU1lbW9yeUR1cGxleFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKCSAgICB2YXIgc2VsZiA9IHRoaXM7CgkgICAgcmV0dXJuIE1lbW9yeUR1cGxleFN0cmVhbS5zdXBlcl8ucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZnVuY3Rpb24gKCkgewoJICAgICAgICBzZWxmLnB1c2gobnVsbCk7Ly9maW5pc2ggcmVhZGJsZSBzdHJlYW0gdG9vCgkgICAgICAgIGlmIChjYikgY2IoKTsKCSAgICB9KTsKCX07CgoKCU1lbW9yeVJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5fZ2V0UXVldWVTaXplID0gIAoJTWVtb3J5V3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLl9nZXRRdWV1ZVNpemUgPSAKCU1lbW9yeUR1cGxleFN0cmVhbS5wcm90b3R5cGUuX2dldFF1ZXVlU2l6ZSA9IGZ1bmN0aW9uICgpIHsKCSAgICB2YXIgcXVldWVzaXplID0gMCwgaTsKCSAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5xdWV1ZS5sZW5ndGg7IGkrKykgewoJICAgICAgICBxdWV1ZXNpemUgKz0gQXJyYXkuaXNBcnJheSh0aGlzLnF1ZXVlW2ldKSA/IHRoaXMucXVldWVbaV1bMF0ubGVuZ3RoCgkgICAgICAgICAgICAgICAgOiB0aGlzLnF1ZXVlW2ldLmxlbmd0aDsKCSAgICB9CgkgICAgcmV0dXJuIHF1ZXVlc2l6ZTsKCX07CgoKCU1lbW9yeVdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS50b1N0cmluZyA9IAoJTWVtb3J5RHVwbGV4U3RyZWFtLnByb3RvdHlwZS50b1N0cmluZyA9IAoJTWVtb3J5UmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnRvU3RyaW5nID0gCglNZW1vcnlXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuZ2V0QWxsID0gCglNZW1vcnlEdXBsZXhTdHJlYW0ucHJvdG90eXBlLmdldEFsbCA9IAoJTWVtb3J5UmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uICgpIHsKCSAgICB2YXIgcmV0ID0gJyc7CgkgICAgdGhpcy5xdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7CgkgICAgICAgIHJldCArPSBkYXRhOwoJICAgIH0pOwoJICAgIHJldHVybiByZXQ7Cgl9OwoKCglNZW1vcnlXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUudG9CdWZmZXIgPSAKCU1lbW9yeUR1cGxleFN0cmVhbS5wcm90b3R5cGUudG9CdWZmZXIgPSAKCU1lbW9yeVJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uICgpIHsKCSAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlciQxKHRoaXMuX2dldFF1ZXVlU2l6ZSgpKSwKCSAgICAgICAgY3VycmVudE9mZnNldCA9IDA7CgoJICAgIHRoaXMucXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkgewoJICAgICAgICB2YXIgZGF0YV9idWZmZXIgPSBkYXRhIGluc3RhbmNlb2YgQnVmZmVyJDEgPyBkYXRhIDogbmV3IEJ1ZmZlciQxKGRhdGEpOwoJICAgICAgICBkYXRhX2J1ZmZlci5jb3B5KGJ1ZmZlciwgY3VycmVudE9mZnNldCk7CgkgICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gZGF0YS5sZW5ndGg7CgkgICAgfSk7CgkgICAgcmV0dXJuIGJ1ZmZlcjsKCX07CgoKCXZhciBtZW1vcnlzdHJlYW0gPSBNZW1vcnlTdHJlYW0kMTsKCgl2YXIgc2VtdmVyJDEgPSB7ZXhwb3J0czoge319OwoKCShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7CglleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTZW1WZXI7CgoJdmFyIGRlYnVnOwoJLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8KCWlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYKCSAgICBwcm9jZXNzLmVudiAmJgoJICAgIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiYKCSAgICAvXGJzZW12ZXJcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykpIHsKCSAgZGVidWcgPSBmdW5jdGlvbiAoKSB7CgkgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApOwoJICAgIGFyZ3MudW5zaGlmdCgnU0VNVkVSJyk7CgkgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7CgkgIH07Cgl9IGVsc2UgewoJICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9OwoJfQoKCS8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHMKCS8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS4KCWV4cG9ydHMuU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCc7CgoJdmFyIE1BWF9MRU5HVEggPSAyNTY7Cgl2YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8CgkgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTE7CgoJLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLgoJdmFyIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNjsKCgkvLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZQoJdmFyIHJlID0gZXhwb3J0cy5yZSA9IFtdOwoJdmFyIHNyYyA9IGV4cG9ydHMuc3JjID0gW107Cgl2YXIgUiA9IDA7CgoJLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLAoJLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy4KCgkvLyAjIyBOdW1lcmljIElkZW50aWZpZXIKCS8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLgoKCXZhciBOVU1FUklDSURFTlRJRklFUiA9IFIrKzsKCXNyY1tOVU1FUklDSURFTlRJRklFUl0gPSAnMHxbMS05XVxcZConOwoJdmFyIE5VTUVSSUNJREVOVElGSUVSTE9PU0UgPSBSKys7CglzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gPSAnWzAtOV0rJzsKCgkvLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyCgkvLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3IKCS8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLgoKCXZhciBOT05OVU1FUklDSURFTlRJRklFUiA9IFIrKzsKCXNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gPSAnXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonOwoKCS8vICMjIE1haW4gVmVyc2lvbgoJLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLgoKCXZhciBNQUlOVkVSU0lPTiA9IFIrKzsKCXNyY1tNQUlOVkVSU0lPTl0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXC4nICsKCSAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXC4nICsKCSAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJyknOwoKCXZhciBNQUlOVkVSU0lPTkxPT1NFID0gUisrOwoJc3JjW01BSU5WRVJTSU9OTE9PU0VdID0gJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXC4nICsKCSAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFwuJyArCgkgICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKSc7CgoJLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyCgkvLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLgoKCXZhciBQUkVSRUxFQVNFSURFTlRJRklFUiA9IFIrKzsKCXNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKwoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7CgoJdmFyIFBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UgPSBSKys7CglzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArCgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknOwoKCS8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24KCS8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uCgkvLyBpZGVudGlmaWVycy4KCgl2YXIgUFJFUkVMRUFTRSA9IFIrKzsKCXNyY1tQUkVSRUxFQVNFXSA9ICcoPzotKCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdICsKCSAgICAgICAgICAgICAgICAgICcoPzpcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArICcpKikpJzsKCgl2YXIgUFJFUkVMRUFTRUxPT1NFID0gUisrOwoJc3JjW1BSRVJFTEVBU0VMT09TRV0gPSAnKD86LT8oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArCgkgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICsgJykqKSknOwoKCS8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXIKCS8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuCgoJdmFyIEJVSUxESURFTlRJRklFUiA9IFIrKzsKCXNyY1tCVUlMRElERU5USUZJRVJdID0gJ1swLTlBLVphLXotXSsnOwoKCS8vICMjIEJ1aWxkIE1ldGFkYXRhCgkvLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGEKCS8vIGlkZW50aWZpZXJzLgoKCXZhciBCVUlMRCA9IFIrKzsKCXNyY1tCVUlMRF0gPSAnKD86XFwrKCcgKyBzcmNbQlVJTERJREVOVElGSUVSXSArCgkgICAgICAgICAgICAgJyg/OlxcLicgKyBzcmNbQlVJTERJREVOVElGSUVSXSArICcpKikpJzsKCgkvLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nCgkvLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kCgkvLyBidWlsZCBtZXRhZGF0YS4KCgkvLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mCgkvLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGEKCS8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uCgkvLyBjb21wYXJpc29uLgoKCXZhciBGVUxMID0gUisrOwoJdmFyIEZVTExQTEFJTiA9ICd2PycgKyBzcmNbTUFJTlZFUlNJT05dICsKCSAgICAgICAgICAgICAgICBzcmNbUFJFUkVMRUFTRV0gKyAnPycgKwoJICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPyc7CgoJc3JjW0ZVTExdID0gJ14nICsgRlVMTFBMQUlOICsgJyQnOwoKCS8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy4KCS8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5CgkvLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS4KCXZhciBMT09TRVBMQUlOID0gJ1t2PVxcc10qJyArIHNyY1tNQUlOVkVSU0lPTkxPT1NFXSArCgkgICAgICAgICAgICAgICAgIHNyY1tQUkVSRUxFQVNFTE9PU0VdICsgJz8nICsKCSAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JzsKCgl2YXIgTE9PU0UgPSBSKys7CglzcmNbTE9PU0VdID0gJ14nICsgTE9PU0VQTEFJTiArICckJzsKCgl2YXIgR1RMVCA9IFIrKzsKCXNyY1tHVExUXSA9ICcoKD86PHw+KT89PyknOwoKCS8vIFNvbWV0aGluZyBsaWtlICIyLioiIG9yICIxLjIueCIuCgkvLyBOb3RlIHRoYXQgIngueCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nICJhbnkgdmVyc2lvbiIKCS8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuCgl2YXIgWFJBTkdFSURFTlRJRklFUkxPT1NFID0gUisrOwoJc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnfHh8WHxcXConOwoJdmFyIFhSQU5HRUlERU5USUZJRVIgPSBSKys7CglzcmNbWFJBTkdFSURFTlRJRklFUl0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJ3x4fFh8XFwqJzsKCgl2YXIgWFJBTkdFUExBSU4gPSBSKys7CglzcmNbWFJBTkdFUExBSU5dID0gJ1t2PVxcc10qKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgKwoJICAgICAgICAgICAgICAgICAgICcoPzpcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArCgkgICAgICAgICAgICAgICAgICAgJyg/OlxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICsKCSAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFXSArICcpPycgKwoJICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgKwoJICAgICAgICAgICAgICAgICAgICcpPyk/JzsKCgl2YXIgWFJBTkdFUExBSU5MT09TRSA9IFIrKzsKCXNyY1tYUkFOR0VQTEFJTkxPT1NFXSA9ICdbdj1cXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgKwoJICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgKwoJICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgKwoJICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbUFJFUkVMRUFTRUxPT1NFXSArICcpPycgKwoJICAgICAgICAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JyArCgkgICAgICAgICAgICAgICAgICAgICAgICAnKT8pPyc7CgoJdmFyIFhSQU5HRSA9IFIrKzsKCXNyY1tYUkFOR0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xccyonICsgc3JjW1hSQU5HRVBMQUlOXSArICckJzsKCXZhciBYUkFOR0VMT09TRSA9IFIrKzsKCXNyY1tYUkFOR0VMT09TRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxzKicgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7CgoJLy8gQ29lcmNpb24uCgkvLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyCgl2YXIgQ09FUkNFID0gUisrOwoJc3JjW0NPRVJDRV0gPSAnKD86XnxbXlxcZF0pJyArCgkgICAgICAgICAgICAgICcoXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSknICsKCSAgICAgICAgICAgICAgJyg/OlxcLihcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KSk/JyArCgkgICAgICAgICAgICAgICcoPzpcXC4oXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSkpPycgKwoJICAgICAgICAgICAgICAnKD86JHxbXlxcZF0pJzsKCgkvLyBUaWxkZSByYW5nZXMuCgkvLyBNZWFuaW5nIGlzICJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhbiIKCXZhciBMT05FVElMREUgPSBSKys7CglzcmNbTE9ORVRJTERFXSA9ICcoPzp+Pj8pJzsKCgl2YXIgVElMREVUUklNID0gUisrOwoJc3JjW1RJTERFVFJJTV0gPSAnKFxccyopJyArIHNyY1tMT05FVElMREVdICsgJ1xccysnOwoJcmVbVElMREVUUklNXSA9IG5ldyBSZWdFeHAoc3JjW1RJTERFVFJJTV0sICdnJyk7Cgl2YXIgdGlsZGVUcmltUmVwbGFjZSA9ICckMX4nOwoKCXZhciBUSUxERSA9IFIrKzsKCXNyY1tUSUxERV0gPSAnXicgKyBzcmNbTE9ORVRJTERFXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7Cgl2YXIgVElMREVMT09TRSA9IFIrKzsKCXNyY1tUSUxERUxPT1NFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnOwoKCS8vIENhcmV0IHJhbmdlcy4KCS8vIE1lYW5pbmcgaXMgImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoIgoJdmFyIExPTkVDQVJFVCA9IFIrKzsKCXNyY1tMT05FQ0FSRVRdID0gJyg/OlxcXiknOwoKCXZhciBDQVJFVFRSSU0gPSBSKys7CglzcmNbQ0FSRVRUUklNXSA9ICcoXFxzKiknICsgc3JjW0xPTkVDQVJFVF0gKyAnXFxzKyc7CglyZVtDQVJFVFRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ0FSRVRUUklNXSwgJ2cnKTsKCXZhciBjYXJldFRyaW1SZXBsYWNlID0gJyQxXic7CgoJdmFyIENBUkVUID0gUisrOwoJc3JjW0NBUkVUXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJzsKCXZhciBDQVJFVExPT1NFID0gUisrOwoJc3JjW0NBUkVUTE9PU0VdID0gJ14nICsgc3JjW0xPTkVDQVJFVF0gKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7CgoJLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgIiIgdG8gaW5kaWNhdGUgImFueSB2ZXJzaW9uIgoJdmFyIENPTVBBUkFUT1JMT09TRSA9IFIrKzsKCXNyY1tDT01QQVJBVE9STE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xccyooJyArIExPT1NFUExBSU4gKyAnKSR8XiQnOwoJdmFyIENPTVBBUkFUT1IgPSBSKys7CglzcmNbQ09NUEFSQVRPUl0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxzKignICsgRlVMTFBMQUlOICsgJykkfF4kJzsKCgkvLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZwoJLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYAoJdmFyIENPTVBBUkFUT1JUUklNID0gUisrOwoJc3JjW0NPTVBBUkFUT1JUUklNXSA9ICcoXFxzKiknICsgc3JjW0dUTFRdICsKCSAgICAgICAgICAgICAgICAgICAgICAnXFxzKignICsgTE9PU0VQTEFJTiArICd8JyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKSc7CgoJLy8gdGhpcyBvbmUgaGFzIHRvIHVzZSB0aGUgL2cgZmxhZwoJcmVbQ09NUEFSQVRPUlRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ09NUEFSQVRPUlRSSU1dLCAnZycpOwoJdmFyIGNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnOwoKCS8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YAoJLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZQoJLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybQoJLy8gbGF0ZXIuCgl2YXIgSFlQSEVOUkFOR0UgPSBSKys7CglzcmNbSFlQSEVOUkFOR0VdID0gJ15cXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknICsKCSAgICAgICAgICAgICAgICAgICAnXFxzKy1cXHMrJyArCgkgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJyArCgkgICAgICAgICAgICAgICAgICAgJ1xccyokJzsKCgl2YXIgSFlQSEVOUkFOR0VMT09TRSA9IFIrKzsKCXNyY1tIWVBIRU5SQU5HRUxPT1NFXSA9ICdeXFxzKignICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyknICsKCSAgICAgICAgICAgICAgICAgICAgICAgICdcXHMrLVxccysnICsKCSAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArCgkgICAgICAgICAgICAgICAgICAgICAgICAnXFxzKiQnOwoKCS8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC4KCXZhciBTVEFSID0gUisrOwoJc3JjW1NUQVJdID0gJyg8fD4pPz0/XFxzKlxcKic7CgoJLy8gQ29tcGlsZSB0byBhY3R1YWwgcmVnZXhwIG9iamVjdHMuCgkvLyBBbGwgYXJlIGZsYWctZnJlZSwgdW5sZXNzIHRoZXkgd2VyZSBjcmVhdGVkIGFib3ZlIHdpdGggYSBmbGFnLgoJZm9yICh2YXIgaSA9IDA7IGkgPCBSOyBpKyspIHsKCSAgZGVidWcoaSwgc3JjW2ldKTsKCSAgaWYgKCFyZVtpXSkgewoJICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pOwoJICB9Cgl9CgoJZXhwb3J0cy5wYXJzZSA9IHBhcnNlOwoJZnVuY3Rpb24gcGFyc2UgKHZlcnNpb24sIG9wdGlvbnMpIHsKCSAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JykgewoJICAgIG9wdGlvbnMgPSB7CgkgICAgICBsb29zZTogISFvcHRpb25zLAoJICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlCgkgICAgfTsKCSAgfQoKCSAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHsKCSAgICByZXR1cm4gdmVyc2lvbgoJICB9CgoJICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7CgkgICAgcmV0dXJuIG51bGwKCSAgfQoKCSAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkgewoJICAgIHJldHVybiBudWxsCgkgIH0KCgkgIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW0xPT1NFXSA6IHJlW0ZVTExdOwoJICBpZiAoIXIudGVzdCh2ZXJzaW9uKSkgewoJICAgIHJldHVybiBudWxsCgkgIH0KCgkgIHRyeSB7CgkgICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucykKCSAgfSBjYXRjaCAoZXIpIHsKCSAgICByZXR1cm4gbnVsbAoJICB9Cgl9CgoJZXhwb3J0cy52YWxpZCA9IHZhbGlkOwoJZnVuY3Rpb24gdmFsaWQgKHZlcnNpb24sIG9wdGlvbnMpIHsKCSAgdmFyIHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKTsKCSAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsCgl9CgoJZXhwb3J0cy5jbGVhbiA9IGNsZWFuOwoJZnVuY3Rpb24gY2xlYW4gKHZlcnNpb24sIG9wdGlvbnMpIHsKCSAgdmFyIHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpOwoJICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGwKCX0KCglleHBvcnRzLlNlbVZlciA9IFNlbVZlcjsKCglmdW5jdGlvbiBTZW1WZXIgKHZlcnNpb24sIG9wdGlvbnMpIHsKCSAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JykgewoJICAgIG9wdGlvbnMgPSB7CgkgICAgICBsb29zZTogISFvcHRpb25zLAoJICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlCgkgICAgfTsKCSAgfQoJICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikgewoJICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSBvcHRpb25zLmxvb3NlKSB7CgkgICAgICByZXR1cm4gdmVyc2lvbgoJICAgIH0gZWxzZSB7CgkgICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uOwoJICAgIH0KCSAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHsKCSAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKQoJICB9CgoJICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmVyc2lvbiBpcyBsb25nZXIgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpCgkgIH0KCgkgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZW1WZXIpKSB7CgkgICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucykKCSAgfQoKCSAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpOwoJICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOwoJICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlOwoKCSAgdmFyIG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF0pOwoKCSAgaWYgKCFtKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbikKCSAgfQoKCSAgdGhpcy5yYXcgPSB2ZXJzaW9uOwoKCSAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnMKCSAgdGhpcy5tYWpvciA9ICttWzFdOwoJICB0aGlzLm1pbm9yID0gK21bMl07CgkgIHRoaXMucGF0Y2ggPSArbVszXTsKCgkgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWFqb3IgdmVyc2lvbicpCgkgIH0KCgkgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpCgkgIH0KCgkgIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMCkgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpCgkgIH0KCgkgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkcwoJICBpZiAoIW1bNF0pIHsKCSAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTsKCSAgfSBlbHNlIHsKCSAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uIChpZCkgewoJICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHsKCSAgICAgICAgdmFyIG51bSA9ICtpZDsKCSAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpIHsKCSAgICAgICAgICByZXR1cm4gbnVtCgkgICAgICAgIH0KCSAgICAgIH0KCSAgICAgIHJldHVybiBpZAoJICAgIH0pOwoJICB9CgoJICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdOwoJICB0aGlzLmZvcm1hdCgpOwoJfQoKCVNlbVZlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkgewoJICB0aGlzLnZlcnNpb24gPSB0aGlzLm1ham9yICsgJy4nICsgdGhpcy5taW5vciArICcuJyArIHRoaXMucGF0Y2g7CgkgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7CgkgICAgdGhpcy52ZXJzaW9uICs9ICctJyArIHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJyk7CgkgIH0KCSAgcmV0dXJuIHRoaXMudmVyc2lvbgoJfTsKCglTZW1WZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgewoJICByZXR1cm4gdGhpcy52ZXJzaW9uCgl9OwoKCVNlbVZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikgewoJICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpOwoJICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHsKCSAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucyk7CgkgIH0KCgkgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpCgl9OwoKCVNlbVZlci5wcm90b3R5cGUuY29tcGFyZU1haW4gPSBmdW5jdGlvbiAob3RoZXIpIHsKCSAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7CgkgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpOwoJICB9CgoJICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWFqb3IsIG90aGVyLm1ham9yKSB8fAoJICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fAoJICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKQoJfTsKCglTZW1WZXIucHJvdG90eXBlLmNvbXBhcmVQcmUgPSBmdW5jdGlvbiAob3RoZXIpIHsKCSAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7CgkgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpOwoJICB9CgoJICAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmUKCSAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7CgkgICAgcmV0dXJuIC0xCgkgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHsKCSAgICByZXR1cm4gMQoJICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkgewoJICAgIHJldHVybiAwCgkgIH0KCgkgIHZhciBpID0gMDsKCSAgZG8gewoJICAgIHZhciBhID0gdGhpcy5wcmVyZWxlYXNlW2ldOwoJICAgIHZhciBiID0gb3RoZXIucHJlcmVsZWFzZVtpXTsKCSAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYik7CgkgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHsKCSAgICAgIHJldHVybiAwCgkgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHsKCSAgICAgIHJldHVybiAxCgkgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHsKCSAgICAgIHJldHVybiAtMQoJICAgIH0gZWxzZSBpZiAoYSA9PT0gYikgewoJICAgICAgY29udGludWUKCSAgICB9IGVsc2UgewoJICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKQoJICAgIH0KCSAgfSB3aGlsZSAoKytpKQoJfTsKCgkvLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5CgkvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuCglTZW1WZXIucHJvdG90eXBlLmluYyA9IGZ1bmN0aW9uIChyZWxlYXNlLCBpZGVudGlmaWVyKSB7CgkgIHN3aXRjaCAocmVsZWFzZSkgewoJICAgIGNhc2UgJ3ByZW1ham9yJzoKCSAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwOwoJICAgICAgdGhpcy5wYXRjaCA9IDA7CgkgICAgICB0aGlzLm1pbm9yID0gMDsKCSAgICAgIHRoaXMubWFqb3IrKzsKCSAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTsKCSAgICAgIGJyZWFrCgkgICAgY2FzZSAncHJlbWlub3InOgoJICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7CgkgICAgICB0aGlzLnBhdGNoID0gMDsKCSAgICAgIHRoaXMubWlub3IrKzsKCSAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTsKCSAgICAgIGJyZWFrCgkgICAgY2FzZSAncHJlcGF0Y2gnOgoJICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb24KCSAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90CgkgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LgoJICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7CgkgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTsKCSAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTsKCSAgICAgIGJyZWFrCgkgICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzCgkgICAgLy8gcHJlcGF0Y2guCgkgICAgY2FzZSAncHJlcmVsZWFzZSc6CgkgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkgewoJICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTsKCSAgICAgIH0KCSAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTsKCSAgICAgIGJyZWFrCgoJICAgIGNhc2UgJ21ham9yJzoKCSAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLgoJICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci4KCSAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjAKCSAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wCgkgICAgICBpZiAodGhpcy5taW5vciAhPT0gMCB8fAoJICAgICAgICAgIHRoaXMucGF0Y2ggIT09IDAgfHwKCSAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7CgkgICAgICAgIHRoaXMubWFqb3IrKzsKCSAgICAgIH0KCSAgICAgIHRoaXMubWlub3IgPSAwOwoJICAgICAgdGhpcy5wYXRjaCA9IDA7CgkgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTsKCSAgICAgIGJyZWFrCgkgICAgY2FzZSAnbWlub3InOgoJICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uCgkgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLgoJICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMAoJICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjAKCSAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHsKCSAgICAgICAgdGhpcy5taW5vcisrOwoJICAgICAgfQoJICAgICAgdGhpcy5wYXRjaCA9IDA7CgkgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTsKCSAgICAgIGJyZWFrCgkgICAgY2FzZSAncGF0Y2gnOgoJICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guCgkgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLgoJICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wCgkgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xCgkgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkgewoJICAgICAgICB0aGlzLnBhdGNoKys7CgkgICAgICB9CgkgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTsKCSAgICAgIGJyZWFrCgkgICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS4KCSAgICAvLyAxLjAuMCAicHJlIiB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLgoJICAgIGNhc2UgJ3ByZSc6CgkgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkgewoJICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF07CgkgICAgICB9IGVsc2UgewoJICAgICAgICB2YXIgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGg7CgkgICAgICAgIHdoaWxlICgtLWkgPj0gMCkgewoJICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykgewoJICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKys7CgkgICAgICAgICAgICBpID0gLTI7CgkgICAgICAgICAgfQoJICAgICAgICB9CgkgICAgICAgIGlmIChpID09PSAtMSkgewoJICAgICAgICAgIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmcKCSAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKTsKCSAgICAgICAgfQoJICAgICAgfQoJICAgICAgaWYgKGlkZW50aWZpZXIpIHsKCSAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMiwKCSAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjAKCSAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZVswXSA9PT0gaWRlbnRpZmllcikgewoJICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7CgkgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07CgkgICAgICAgICAgfQoJICAgICAgICB9IGVsc2UgewoJICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTsKCSAgICAgICAgfQoJICAgICAgfQoJICAgICAgYnJlYWsKCgkgICAgZGVmYXVsdDoKCSAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICcgKyByZWxlYXNlKQoJICB9CgkgIHRoaXMuZm9ybWF0KCk7CgkgIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uOwoJICByZXR1cm4gdGhpcwoJfTsKCglleHBvcnRzLmluYyA9IGluYzsKCWZ1bmN0aW9uIGluYyAodmVyc2lvbiwgcmVsZWFzZSwgbG9vc2UsIGlkZW50aWZpZXIpIHsKCSAgaWYgKHR5cGVvZiAobG9vc2UpID09PSAnc3RyaW5nJykgewoJICAgIGlkZW50aWZpZXIgPSBsb29zZTsKCSAgICBsb29zZSA9IHVuZGVmaW5lZDsKCSAgfQoKCSAgdHJ5IHsKCSAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb24KCSAgfSBjYXRjaCAoZXIpIHsKCSAgICByZXR1cm4gbnVsbAoJICB9Cgl9CgoJZXhwb3J0cy5kaWZmID0gZGlmZjsKCWZ1bmN0aW9uIGRpZmYgKHZlcnNpb24xLCB2ZXJzaW9uMikgewoJICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkgewoJICAgIHJldHVybiBudWxsCgkgIH0gZWxzZSB7CgkgICAgdmFyIHYxID0gcGFyc2UodmVyc2lvbjEpOwoJICAgIHZhciB2MiA9IHBhcnNlKHZlcnNpb24yKTsKCSAgICB2YXIgcHJlZml4ID0gJyc7CgkgICAgaWYgKHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoKSB7CgkgICAgICBwcmVmaXggPSAncHJlJzsKCSAgICAgIHZhciBkZWZhdWx0UmVzdWx0ID0gJ3ByZXJlbGVhc2UnOwoJICAgIH0KCSAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHsKCSAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykgewoJICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkgewoJICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXkKCSAgICAgICAgfQoJICAgICAgfQoJICAgIH0KCSAgICByZXR1cm4gZGVmYXVsdFJlc3VsdCAvLyBtYXkgYmUgdW5kZWZpbmVkCgkgIH0KCX0KCglleHBvcnRzLmNvbXBhcmVJZGVudGlmaWVycyA9IGNvbXBhcmVJZGVudGlmaWVyczsKCgl2YXIgbnVtZXJpYyA9IC9eWzAtOV0rJC87CglmdW5jdGlvbiBjb21wYXJlSWRlbnRpZmllcnMgKGEsIGIpIHsKCSAgdmFyIGFudW0gPSBudW1lcmljLnRlc3QoYSk7CgkgIHZhciBibnVtID0gbnVtZXJpYy50ZXN0KGIpOwoKCSAgaWYgKGFudW0gJiYgYm51bSkgewoJICAgIGEgPSArYTsKCSAgICBiID0gK2I7CgkgIH0KCgkgIHJldHVybiBhID09PSBiID8gMAoJICAgIDogKGFudW0gJiYgIWJudW0pID8gLTEKCSAgICA6IChibnVtICYmICFhbnVtKSA/IDEKCSAgICA6IGEgPCBiID8gLTEKCSAgICA6IDEKCX0KCglleHBvcnRzLnJjb21wYXJlSWRlbnRpZmllcnMgPSByY29tcGFyZUlkZW50aWZpZXJzOwoJZnVuY3Rpb24gcmNvbXBhcmVJZGVudGlmaWVycyAoYSwgYikgewoJICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpCgl9CgoJZXhwb3J0cy5tYWpvciA9IG1ham9yOwoJZnVuY3Rpb24gbWFqb3IgKGEsIGxvb3NlKSB7CgkgIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvcgoJfQoKCWV4cG9ydHMubWlub3IgPSBtaW5vcjsKCWZ1bmN0aW9uIG1pbm9yIChhLCBsb29zZSkgewoJICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3IKCX0KCglleHBvcnRzLnBhdGNoID0gcGF0Y2g7CglmdW5jdGlvbiBwYXRjaCAoYSwgbG9vc2UpIHsKCSAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoCgl9CgoJZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTsKCWZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIsIGxvb3NlKSB7CgkgIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKQoJfQoKCWV4cG9ydHMuY29tcGFyZUxvb3NlID0gY29tcGFyZUxvb3NlOwoJZnVuY3Rpb24gY29tcGFyZUxvb3NlIChhLCBiKSB7CgkgIHJldHVybiBjb21wYXJlKGEsIGIsIHRydWUpCgl9CgoJZXhwb3J0cy5yY29tcGFyZSA9IHJjb21wYXJlOwoJZnVuY3Rpb24gcmNvbXBhcmUgKGEsIGIsIGxvb3NlKSB7CgkgIHJldHVybiBjb21wYXJlKGIsIGEsIGxvb3NlKQoJfQoKCWV4cG9ydHMuc29ydCA9IHNvcnQ7CglmdW5jdGlvbiBzb3J0IChsaXN0LCBsb29zZSkgewoJICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7CgkgICAgcmV0dXJuIGV4cG9ydHMuY29tcGFyZShhLCBiLCBsb29zZSkKCSAgfSkKCX0KCglleHBvcnRzLnJzb3J0ID0gcnNvcnQ7CglmdW5jdGlvbiByc29ydCAobGlzdCwgbG9vc2UpIHsKCSAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikgewoJICAgIHJldHVybiBleHBvcnRzLnJjb21wYXJlKGEsIGIsIGxvb3NlKQoJICB9KQoJfQoKCWV4cG9ydHMuZ3QgPSBndDsKCWZ1bmN0aW9uIGd0IChhLCBiLCBsb29zZSkgewoJICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwCgl9CgoJZXhwb3J0cy5sdCA9IGx0OwoJZnVuY3Rpb24gbHQgKGEsIGIsIGxvb3NlKSB7CgkgIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDAKCX0KCglleHBvcnRzLmVxID0gZXE7CglmdW5jdGlvbiBlcSAoYSwgYiwgbG9vc2UpIHsKCSAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwCgl9CgoJZXhwb3J0cy5uZXEgPSBuZXE7CglmdW5jdGlvbiBuZXEgKGEsIGIsIGxvb3NlKSB7CgkgIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMAoJfQoKCWV4cG9ydHMuZ3RlID0gZ3RlOwoJZnVuY3Rpb24gZ3RlIChhLCBiLCBsb29zZSkgewoJICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMAoJfQoKCWV4cG9ydHMubHRlID0gbHRlOwoJZnVuY3Rpb24gbHRlIChhLCBiLCBsb29zZSkgewoJICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMAoJfQoKCWV4cG9ydHMuY21wID0gY21wOwoJZnVuY3Rpb24gY21wIChhLCBvcCwgYiwgbG9vc2UpIHsKCSAgc3dpdGNoIChvcCkgewoJICAgIGNhc2UgJz09PSc6CgkgICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKQoJICAgICAgICBhID0gYS52ZXJzaW9uOwoJICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykKCSAgICAgICAgYiA9IGIudmVyc2lvbjsKCSAgICAgIHJldHVybiBhID09PSBiCgoJICAgIGNhc2UgJyE9PSc6CgkgICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKQoJICAgICAgICBhID0gYS52ZXJzaW9uOwoJICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykKCSAgICAgICAgYiA9IGIudmVyc2lvbjsKCSAgICAgIHJldHVybiBhICE9PSBiCgoJICAgIGNhc2UgJyc6CgkgICAgY2FzZSAnPSc6CgkgICAgY2FzZSAnPT0nOgoJICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKQoKCSAgICBjYXNlICchPSc6CgkgICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKQoKCSAgICBjYXNlICc+JzoKCSAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSkKCgkgICAgY2FzZSAnPj0nOgoJICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSkKCgkgICAgY2FzZSAnPCc6CgkgICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpCgoJICAgIGNhc2UgJzw9JzoKCSAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpCgoJICAgIGRlZmF1bHQ6CgkgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9wZXJhdG9yOiAnICsgb3ApCgkgIH0KCX0KCglleHBvcnRzLkNvbXBhcmF0b3IgPSBDb21wYXJhdG9yOwoJZnVuY3Rpb24gQ29tcGFyYXRvciAoY29tcCwgb3B0aW9ucykgewoJICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7CgkgICAgb3B0aW9ucyA9IHsKCSAgICAgIGxvb3NlOiAhIW9wdGlvbnMsCgkgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2UKCSAgICB9OwoJICB9CgoJICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHsKCSAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7CgkgICAgICByZXR1cm4gY29tcAoJICAgIH0gZWxzZSB7CgkgICAgICBjb21wID0gY29tcC52YWx1ZTsKCSAgICB9CgkgIH0KCgkgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkgewoJICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBvcHRpb25zKQoJICB9CgoJICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpOwoJICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOwoJICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlOwoJICB0aGlzLnBhcnNlKGNvbXApOwoKCSAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHsKCSAgICB0aGlzLnZhbHVlID0gJyc7CgkgIH0gZWxzZSB7CgkgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uOwoJICB9CgoJICBkZWJ1ZygnY29tcCcsIHRoaXMpOwoJfQoKCXZhciBBTlkgPSB7fTsKCUNvbXBhcmF0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvbXApIHsKCSAgdmFyIHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07CgkgIHZhciBtID0gY29tcC5tYXRjaChyKTsKCgkgIGlmICghbSkgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY29tcGFyYXRvcjogJyArIGNvbXApCgkgIH0KCgkgIHRoaXMub3BlcmF0b3IgPSBtWzFdOwoJICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKSB7CgkgICAgdGhpcy5vcGVyYXRvciA9ICcnOwoJICB9CgoJICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy4KCSAgaWYgKCFtWzJdKSB7CgkgICAgdGhpcy5zZW12ZXIgPSBBTlk7CgkgIH0gZWxzZSB7CgkgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSk7CgkgIH0KCX07CgoJQ29tcGFyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7CgkgIHJldHVybiB0aGlzLnZhbHVlCgl9OwoKCUNvbXBhcmF0b3IucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodmVyc2lvbikgewoJICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKTsKCgkgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7CgkgICAgcmV0dXJuIHRydWUKCSAgfQoKCSAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykgewoJICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucyk7CgkgIH0KCgkgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucykKCX07CgoJQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChjb21wLCBvcHRpb25zKSB7CgkgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkgewoJICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpCgkgIH0KCgkgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHsKCSAgICBvcHRpb25zID0gewoJICAgICAgbG9vc2U6ICEhb3B0aW9ucywKCSAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZQoJICAgIH07CgkgIH0KCgkgIHZhciByYW5nZVRtcDsKCgkgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykgewoJICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpOwoJICAgIHJldHVybiBzYXRpc2ZpZXModGhpcy52YWx1ZSwgcmFuZ2VUbXAsIG9wdGlvbnMpCgkgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHsKCSAgICByYW5nZVRtcCA9IG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKTsKCSAgICByZXR1cm4gc2F0aXNmaWVzKGNvbXAuc2VtdmVyLCByYW5nZVRtcCwgb3B0aW9ucykKCSAgfQoKCSAgdmFyIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID0KCSAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmCgkgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKTsKCSAgdmFyIHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nID0KCSAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmCgkgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKTsKCSAgdmFyIHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uOwoJICB2YXIgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9CgkgICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzw9JykgJiYKCSAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKTsKCSAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID0KCSAgICBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmCgkgICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiYKCSAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpKTsKCSAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID0KCSAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmCgkgICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiYKCSAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpKTsKCgkgIHJldHVybiBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fAoJICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8CgkgICAgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHwgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW4KCX07CgoJZXhwb3J0cy5SYW5nZSA9IFJhbmdlOwoJZnVuY3Rpb24gUmFuZ2UgKHJhbmdlLCBvcHRpb25zKSB7CgkgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHsKCSAgICBvcHRpb25zID0gewoJICAgICAgbG9vc2U6ICEhb3B0aW9ucywKCSAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZQoJICAgIH07CgkgIH0KCgkgIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7CgkgICAgaWYgKHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiYKCSAgICAgICAgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkgewoJICAgICAgcmV0dXJuIHJhbmdlCgkgICAgfSBlbHNlIHsKCSAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKQoJICAgIH0KCSAgfQoKCSAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikgewoJICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UudmFsdWUsIG9wdGlvbnMpCgkgIH0KCgkgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHsKCSAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKQoJICB9CgoJICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOwoJICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlOwoJICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlOwoKCSAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHwKCSAgdGhpcy5yYXcgPSByYW5nZTsKCSAgdGhpcy5zZXQgPSByYW5nZS5zcGxpdCgvXHMqXHxcfFxzKi8pLm1hcChmdW5jdGlvbiAocmFuZ2UpIHsKCSAgICByZXR1cm4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSkKCSAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uIChjKSB7CgkgICAgLy8gdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgcmVsZXZhbnQgZm9yIHdoYXRldmVyIHJlYXNvbgoJICAgIHJldHVybiBjLmxlbmd0aAoJICB9KTsKCgkgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7CgkgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSkKCSAgfQoKCSAgdGhpcy5mb3JtYXQoKTsKCX0KCglSYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkgewoJICB0aGlzLnJhbmdlID0gdGhpcy5zZXQubWFwKGZ1bmN0aW9uIChjb21wcykgewoJICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpCgkgIH0pLmpvaW4oJ3x8JykudHJpbSgpOwoJICByZXR1cm4gdGhpcy5yYW5nZQoJfTsKCglSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7CgkgIHJldHVybiB0aGlzLnJhbmdlCgl9OwoKCVJhbmdlLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7CgkgIHZhciBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZTsKCSAgcmFuZ2UgPSByYW5nZS50cmltKCk7CgkgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YAoJICB2YXIgaHIgPSBsb29zZSA/IHJlW0hZUEhFTlJBTkdFTE9PU0VdIDogcmVbSFlQSEVOUkFOR0VdOwoJICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UpOwoJICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSk7CgkgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YAoJICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpOwoJICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW0NPTVBBUkFUT1JUUklNXSk7CgoJICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2AKCSAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW1RJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpOwoKCSAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgCgkgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKTsKCgkgIC8vIG5vcm1hbGl6ZSBzcGFjZXMKCSAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXHMrLykuam9pbignICcpOwoKCSAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmQKCSAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy4KCgkgIHZhciBjb21wUmUgPSBsb29zZSA/IHJlW0NPTVBBUkFUT1JMT09TRV0gOiByZVtDT01QQVJBVE9SXTsKCSAgdmFyIHNldCA9IHJhbmdlLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChjb21wKSB7CgkgICAgcmV0dXJuIHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpCgkgIH0sIHRoaXMpLmpvaW4oJyAnKS5zcGxpdCgvXHMrLyk7CgkgIGlmICh0aGlzLm9wdGlvbnMubG9vc2UpIHsKCSAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9ycwoJICAgIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24gKGNvbXApIHsKCSAgICAgIHJldHVybiAhIWNvbXAubWF0Y2goY29tcFJlKQoJICAgIH0pOwoJICB9CgkgIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKGNvbXApIHsKCSAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKQoJICB9LCB0aGlzKTsKCgkgIHJldHVybiBzZXQKCX07CgoJUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAocmFuZ2UsIG9wdGlvbnMpIHsKCSAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHsKCSAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJykKCSAgfQoKCSAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoZnVuY3Rpb24gKHRoaXNDb21wYXJhdG9ycykgewoJICAgIHJldHVybiB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24gKHRoaXNDb21wYXJhdG9yKSB7CgkgICAgICByZXR1cm4gcmFuZ2Uuc2V0LnNvbWUoZnVuY3Rpb24gKHJhbmdlQ29tcGFyYXRvcnMpIHsKCSAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24gKHJhbmdlQ29tcGFyYXRvcikgewoJICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucykKCSAgICAgICAgfSkKCSAgICAgIH0pCgkgICAgfSkKCSAgfSkKCX07CgoJLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29ucwoJZXhwb3J0cy50b0NvbXBhcmF0b3JzID0gdG9Db21wYXJhdG9yczsKCWZ1bmN0aW9uIHRvQ29tcGFyYXRvcnMgKHJhbmdlLCBvcHRpb25zKSB7CgkgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldC5tYXAoZnVuY3Rpb24gKGNvbXApIHsKCSAgICByZXR1cm4gY29tcC5tYXAoZnVuY3Rpb24gKGMpIHsKCSAgICAgIHJldHVybiBjLnZhbHVlCgkgICAgfSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpCgkgIH0pCgl9CgoJLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC4KCS8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXMKCS8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLgoJZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yIChjb21wLCBvcHRpb25zKSB7CgkgIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucyk7CgkgIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpOwoJICBkZWJ1ZygnY2FyZXQnLCBjb21wKTsKCSAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucyk7CgkgIGRlYnVnKCd0aWxkZXMnLCBjb21wKTsKCSAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpOwoJICBkZWJ1ZygneHJhbmdlJywgY29tcCk7CgkgIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucyk7CgkgIGRlYnVnKCdzdGFycycsIGNvbXApOwoJICByZXR1cm4gY29tcAoJfQoKCWZ1bmN0aW9uIGlzWCAoaWQpIHsKCSAgcmV0dXJuICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJwoJfQoKCS8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KQoJLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMAoJLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjAKCS8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wCgkvLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wCgkvLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wCglmdW5jdGlvbiByZXBsYWNlVGlsZGVzIChjb21wLCBvcHRpb25zKSB7CgkgIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXHMrLykubWFwKGZ1bmN0aW9uIChjb21wKSB7CgkgICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKQoJICB9KS5qb2luKCcgJykKCX0KCglmdW5jdGlvbiByZXBsYWNlVGlsZGUgKGNvbXAsIG9wdGlvbnMpIHsKCSAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbVElMREVMT09TRV0gOiByZVtUSUxERV07CgkgIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKF8sIE0sIG0sIHAsIHByKSB7CgkgICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpOwoJICAgIHZhciByZXQ7CgoJICAgIGlmIChpc1goTSkpIHsKCSAgICAgIHJldCA9ICcnOwoJICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7CgkgICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7CgkgICAgfSBlbHNlIGlmIChpc1gocCkpIHsKCSAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjAKCSAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7CgkgICAgfSBlbHNlIGlmIChwcikgewoJICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKTsKCSAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnLScgKyBwciArCgkgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJzsKCSAgICB9IGVsc2UgewoJICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wCgkgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsKCSAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnOwoJICAgIH0KCgkgICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldCk7CgkgICAgcmV0dXJuIHJldAoJICB9KQoJfQoKCS8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpCgkvLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMAoJLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMAoJLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMAoJLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMAoJLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMAoJZnVuY3Rpb24gcmVwbGFjZUNhcmV0cyAoY29tcCwgb3B0aW9ucykgewoJICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xzKy8pLm1hcChmdW5jdGlvbiAoY29tcCkgewoJICAgIHJldHVybiByZXBsYWNlQ2FyZXQoY29tcCwgb3B0aW9ucykKCSAgfSkuam9pbignICcpCgl9CgoJZnVuY3Rpb24gcmVwbGFjZUNhcmV0IChjb21wLCBvcHRpb25zKSB7CgkgIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpOwoJICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVtDQVJFVExPT1NFXSA6IHJlW0NBUkVUXTsKCSAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbiAoXywgTSwgbSwgcCwgcHIpIHsKCSAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7CgkgICAgdmFyIHJldDsKCgkgICAgaWYgKGlzWChNKSkgewoJICAgICAgcmV0ID0gJyc7CgkgICAgfSBlbHNlIGlmIChpc1gobSkpIHsKCSAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJzsKCSAgICB9IGVsc2UgaWYgKGlzWChwKSkgewoJICAgICAgaWYgKE0gPT09ICcwJykgewoJICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnOwoJICAgICAgfSBlbHNlIHsKCSAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7CgkgICAgICB9CgkgICAgfSBlbHNlIGlmIChwcikgewoJICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKTsKCSAgICAgIGlmIChNID09PSAnMCcpIHsKCSAgICAgICAgaWYgKG0gPT09ICcwJykgewoJICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnLScgKyBwciArCgkgICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSk7CgkgICAgICAgIH0gZWxzZSB7CgkgICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICsKCSAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJzsKCSAgICAgICAgfQoJICAgICAgfSBlbHNlIHsKCSAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICsKCSAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnOwoJICAgICAgfQoJICAgIH0gZWxzZSB7CgkgICAgICBkZWJ1Zygnbm8gcHInKTsKCSAgICAgIGlmIChNID09PSAnMCcpIHsKCSAgICAgICAgaWYgKG0gPT09ICcwJykgewoJICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKwoJICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpOwoJICAgICAgICB9IGVsc2UgewoJICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKwoJICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnOwoJICAgICAgICB9CgkgICAgICB9IGVsc2UgewoJICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsKCSAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnOwoJICAgICAgfQoJICAgIH0KCgkgICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldCk7CgkgICAgcmV0dXJuIHJldAoJICB9KQoJfQoKCWZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2VzIChjb21wLCBvcHRpb25zKSB7CgkgIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpOwoJICByZXR1cm4gY29tcC5zcGxpdCgvXHMrLykubWFwKGZ1bmN0aW9uIChjb21wKSB7CgkgICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgb3B0aW9ucykKCSAgfSkuam9pbignICcpCgl9CgoJZnVuY3Rpb24gcmVwbGFjZVhSYW5nZSAoY29tcCwgb3B0aW9ucykgewoJICBjb21wID0gY29tcC50cmltKCk7CgkgIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW1hSQU5HRUxPT1NFXSA6IHJlW1hSQU5HRV07CgkgIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpIHsKCSAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcik7CgkgICAgdmFyIHhNID0gaXNYKE0pOwoJICAgIHZhciB4bSA9IHhNIHx8IGlzWChtKTsKCSAgICB2YXIgeHAgPSB4bSB8fCBpc1gocCk7CgkgICAgdmFyIGFueVggPSB4cDsKCgkgICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKSB7CgkgICAgICBndGx0ID0gJyc7CgkgICAgfQoKCSAgICBpZiAoeE0pIHsKCSAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7CgkgICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZAoJICAgICAgICByZXQgPSAnPDAuMC4wJzsKCSAgICAgIH0gZWxzZSB7CgkgICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuCgkgICAgICAgIHJldCA9ICcqJzsKCSAgICAgIH0KCSAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkgewoJICAgICAgLy8gd2Uga25vdyBwYXRjaCBpcyBhbiB4LCBiZWNhdXNlIHdlIGhhdmUgYW55IHggYXQgYWxsLgoJICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMAoJICAgICAgaWYgKHhtKSB7CgkgICAgICAgIG0gPSAwOwoJICAgICAgfQoJICAgICAgcCA9IDA7CgoJICAgICAgaWYgKGd0bHQgPT09ICc+JykgewoJICAgICAgICAvLyA+MSA9PiA+PTIuMC4wCgkgICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMAoJICAgICAgICAvLyA+MS4yLjMgPT4gPj0gMS4yLjQKCSAgICAgICAgZ3RsdCA9ICc+PSc7CgkgICAgICAgIGlmICh4bSkgewoJICAgICAgICAgIE0gPSArTSArIDE7CgkgICAgICAgICAgbSA9IDA7CgkgICAgICAgICAgcCA9IDA7CgkgICAgICAgIH0gZWxzZSB7CgkgICAgICAgICAgbSA9ICttICsgMTsKCSAgICAgICAgICBwID0gMDsKCSAgICAgICAgfQoJICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7CgkgICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkCgkgICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLgoJICAgICAgICBndGx0ID0gJzwnOwoJICAgICAgICBpZiAoeG0pIHsKCSAgICAgICAgICBNID0gK00gKyAxOwoJICAgICAgICB9IGVsc2UgewoJICAgICAgICAgIG0gPSArbSArIDE7CgkgICAgICAgIH0KCSAgICAgIH0KCgkgICAgICByZXQgPSBndGx0ICsgTSArICcuJyArIG0gKyAnLicgKyBwOwoJICAgIH0gZWxzZSBpZiAoeG0pIHsKCSAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJzsKCSAgICB9IGVsc2UgaWYgKHhwKSB7CgkgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnOwoJICAgIH0KCgkgICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpOwoKCSAgICByZXR1cm4gcmV0CgkgIH0pCgl9CgoJLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvciwKCS8vIGFuZCAnJyBtZWFucyAiYW55IHZlcnNpb24iLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuCglmdW5jdGlvbiByZXBsYWNlU3RhcnMgKGNvbXAsIG9wdGlvbnMpIHsKCSAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpOwoJICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyEKCSAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbU1RBUl0sICcnKQoJfQoKCS8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW0hZUEhFTlJBTkdFXSkKCS8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZAoJLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41CgkvLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMCBBbnkgMy40Lnggd2lsbCBkbwoJLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wCglmdW5jdGlvbiBoeXBoZW5SZXBsYWNlICgkMCwKCSAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYiwKCSAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpIHsKCSAgaWYgKGlzWChmTSkpIHsKCSAgICBmcm9tID0gJyc7CgkgIH0gZWxzZSBpZiAoaXNYKGZtKSkgewoJICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLjAuMCc7CgkgIH0gZWxzZSBpZiAoaXNYKGZwKSkgewoJICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLicgKyBmbSArICcuMCc7CgkgIH0gZWxzZSB7CgkgICAgZnJvbSA9ICc+PScgKyBmcm9tOwoJICB9CgoJICBpZiAoaXNYKHRNKSkgewoJICAgIHRvID0gJyc7CgkgIH0gZWxzZSBpZiAoaXNYKHRtKSkgewoJICAgIHRvID0gJzwnICsgKCt0TSArIDEpICsgJy4wLjAnOwoJICB9IGVsc2UgaWYgKGlzWCh0cCkpIHsKCSAgICB0byA9ICc8JyArIHRNICsgJy4nICsgKCt0bSArIDEpICsgJy4wJzsKCSAgfSBlbHNlIGlmICh0cHIpIHsKCSAgICB0byA9ICc8PScgKyB0TSArICcuJyArIHRtICsgJy4nICsgdHAgKyAnLScgKyB0cHI7CgkgIH0gZWxzZSB7CgkgICAgdG8gPSAnPD0nICsgdG87CgkgIH0KCgkgIHJldHVybiAoZnJvbSArICcgJyArIHRvKS50cmltKCkKCX0KCgkvLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzCglSYW5nZS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7CgkgIGlmICghdmVyc2lvbikgewoJICAgIHJldHVybiBmYWxzZQoJICB9CgoJICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7CgkgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKTsKCSAgfQoKCSAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykgewoJICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7CgkgICAgICByZXR1cm4gdHJ1ZQoJICAgIH0KCSAgfQoJICByZXR1cm4gZmFsc2UKCX07CgoJZnVuY3Rpb24gdGVzdFNldCAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSB7CgkgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7CgkgICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkgewoJICAgICAgcmV0dXJuIGZhbHNlCgkgICAgfQoJICB9CgoJICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkgewoJICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXMKCSAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMAoJICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLgoJICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLAoJICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLgoJICAgIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHsKCSAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpOwoJICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IEFOWSkgewoJICAgICAgICBjb250aW51ZQoJICAgICAgfQoKCSAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkgewoJICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXI7CgkgICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmCgkgICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmCgkgICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKSB7CgkgICAgICAgICAgcmV0dXJuIHRydWUKCSAgICAgICAgfQoJICAgICAgfQoJICAgIH0KCgkgICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuCgkgICAgcmV0dXJuIGZhbHNlCgkgIH0KCgkgIHJldHVybiB0cnVlCgl9CgoJZXhwb3J0cy5zYXRpc2ZpZXMgPSBzYXRpc2ZpZXM7CglmdW5jdGlvbiBzYXRpc2ZpZXMgKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7CgkgIHRyeSB7CgkgICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpOwoJICB9IGNhdGNoIChlcikgewoJICAgIHJldHVybiBmYWxzZQoJICB9CgkgIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pCgl9CgoJZXhwb3J0cy5tYXhTYXRpc2Z5aW5nID0gbWF4U2F0aXNmeWluZzsKCWZ1bmN0aW9uIG1heFNhdGlzZnlpbmcgKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgewoJICB2YXIgbWF4ID0gbnVsbDsKCSAgdmFyIG1heFNWID0gbnVsbDsKCSAgdHJ5IHsKCSAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpOwoJICB9IGNhdGNoIChlcikgewoJICAgIHJldHVybiBudWxsCgkgIH0KCSAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikgewoJICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7CgkgICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpCgkgICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkgewoJICAgICAgICAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSkKCSAgICAgICAgbWF4ID0gdjsKCSAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucyk7CgkgICAgICB9CgkgICAgfQoJICB9KTsKCSAgcmV0dXJuIG1heAoJfQoKCWV4cG9ydHMubWluU2F0aXNmeWluZyA9IG1pblNhdGlzZnlpbmc7CglmdW5jdGlvbiBtaW5TYXRpc2Z5aW5nICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpIHsKCSAgdmFyIG1pbiA9IG51bGw7CgkgIHZhciBtaW5TViA9IG51bGw7CgkgIHRyeSB7CgkgICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTsKCSAgfSBjYXRjaCAoZXIpIHsKCSAgICByZXR1cm4gbnVsbAoJICB9CgkgIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHsKCSAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkgewoJICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKQoJICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkgewoJICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSkKCSAgICAgICAgbWluID0gdjsKCSAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucyk7CgkgICAgICB9CgkgICAgfQoJICB9KTsKCSAgcmV0dXJuIG1pbgoJfQoKCWV4cG9ydHMubWluVmVyc2lvbiA9IG1pblZlcnNpb247CglmdW5jdGlvbiBtaW5WZXJzaW9uIChyYW5nZSwgbG9vc2UpIHsKCSAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTsKCgkgIHZhciBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMCcpOwoJICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7CgkgICAgcmV0dXJuIG1pbnZlcgoJICB9CgoJICBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMC0wJyk7CgkgIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHsKCSAgICByZXR1cm4gbWludmVyCgkgIH0KCgkgIG1pbnZlciA9IG51bGw7CgkgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7CgkgICAgdmFyIGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldOwoKCSAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wYXJhdG9yKSB7CgkgICAgICAvLyBDbG9uZSB0byBhdm9pZCBtYW5pcHVsYXRpbmcgdGhlIGNvbXBhcmF0b3IncyBzZW12ZXIgb2JqZWN0LgoJICAgICAgdmFyIGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pOwoJICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7CgkgICAgICAgIGNhc2UgJz4nOgoJICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7CgkgICAgICAgICAgICBjb21wdmVyLnBhdGNoKys7CgkgICAgICAgICAgfSBlbHNlIHsKCSAgICAgICAgICAgIGNvbXB2ZXIucHJlcmVsZWFzZS5wdXNoKDApOwoJICAgICAgICAgIH0KCSAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KCk7CgkgICAgICAgICAgLyogZmFsbHRocm91Z2ggKi8KCSAgICAgICAgY2FzZSAnJzoKCSAgICAgICAgY2FzZSAnPj0nOgoJICAgICAgICAgIGlmICghbWludmVyIHx8IGd0KG1pbnZlciwgY29tcHZlcikpIHsKCSAgICAgICAgICAgIG1pbnZlciA9IGNvbXB2ZXI7CgkgICAgICAgICAgfQoJICAgICAgICAgIGJyZWFrCgkgICAgICAgIGNhc2UgJzwnOgoJICAgICAgICBjYXNlICc8PSc6CgkgICAgICAgICAgLyogSWdub3JlIG1heGltdW0gdmVyc2lvbnMgKi8KCSAgICAgICAgICBicmVhawoJICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLwoJICAgICAgICBkZWZhdWx0OgoJICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBvcGVyYXRpb246ICcgKyBjb21wYXJhdG9yLm9wZXJhdG9yKQoJICAgICAgfQoJICAgIH0pOwoJICB9CgoJICBpZiAobWludmVyICYmIHJhbmdlLnRlc3QobWludmVyKSkgewoJICAgIHJldHVybiBtaW52ZXIKCSAgfQoKCSAgcmV0dXJuIG51bGwKCX0KCglleHBvcnRzLnZhbGlkUmFuZ2UgPSB2YWxpZFJhbmdlOwoJZnVuY3Rpb24gdmFsaWRSYW5nZSAocmFuZ2UsIG9wdGlvbnMpIHsKCSAgdHJ5IHsKCSAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLgoJICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5CgkgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonCgkgIH0gY2F0Y2ggKGVyKSB7CgkgICAgcmV0dXJuIG51bGwKCSAgfQoJfQoKCS8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZQoJZXhwb3J0cy5sdHIgPSBsdHI7CglmdW5jdGlvbiBsdHIgKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7CgkgIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpCgl9CgoJLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLgoJZXhwb3J0cy5ndHIgPSBndHI7CglmdW5jdGlvbiBndHIgKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7CgkgIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpCgl9CgoJZXhwb3J0cy5vdXRzaWRlID0gb3V0c2lkZTsKCWZ1bmN0aW9uIG91dHNpZGUgKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSB7CgkgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpOwoJICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7CgoJICB2YXIgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wOwoJICBzd2l0Y2ggKGhpbG8pIHsKCSAgICBjYXNlICc+JzoKCSAgICAgIGd0Zm4gPSBndDsKCSAgICAgIGx0ZWZuID0gbHRlOwoJICAgICAgbHRmbiA9IGx0OwoJICAgICAgY29tcCA9ICc+JzsKCSAgICAgIGVjb21wID0gJz49JzsKCSAgICAgIGJyZWFrCgkgICAgY2FzZSAnPCc6CgkgICAgICBndGZuID0gbHQ7CgkgICAgICBsdGVmbiA9IGd0ZTsKCSAgICAgIGx0Zm4gPSBndDsKCSAgICAgIGNvbXAgPSAnPCc7CgkgICAgICBlY29tcCA9ICc8PSc7CgkgICAgICBicmVhawoJICAgIGRlZmF1bHQ6CgkgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiAiPCIgb3IgIj4iJykKCSAgfQoKCSAgLy8gSWYgaXQgc2F0aXNpZmVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZQoJICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkgewoJICAgIHJldHVybiBmYWxzZQoJICB9CgoJICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluICJndHIiIG1vZGUuCgkgIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgImx0ciIgZnVuY3Rpb24uCgoJICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkgewoJICAgIHZhciBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXTsKCgkgICAgdmFyIGhpZ2ggPSBudWxsOwoJICAgIHZhciBsb3cgPSBudWxsOwoKCSAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wYXJhdG9yKSB7CgkgICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkgewoJICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKTsKCSAgICAgIH0KCSAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3I7CgkgICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvcjsKCSAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHsKCSAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3I7CgkgICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7CgkgICAgICAgIGxvdyA9IGNvbXBhcmF0b3I7CgkgICAgICB9CgkgICAgfSk7CgoJICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uCgkgICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdAoJICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7CgkgICAgICByZXR1cm4gZmFsc2UKCSAgICB9CgoJICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb24KCSAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2UKCSAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJgoJICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkgewoJICAgICAgcmV0dXJuIGZhbHNlCgkgICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHsKCSAgICAgIHJldHVybiBmYWxzZQoJICAgIH0KCSAgfQoJICByZXR1cm4gdHJ1ZQoJfQoKCWV4cG9ydHMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7CglmdW5jdGlvbiBwcmVyZWxlYXNlICh2ZXJzaW9uLCBvcHRpb25zKSB7CgkgIHZhciBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKTsKCSAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbAoJfQoKCWV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7CglmdW5jdGlvbiBpbnRlcnNlY3RzIChyMSwgcjIsIG9wdGlvbnMpIHsKCSAgcjEgPSBuZXcgUmFuZ2UocjEsIG9wdGlvbnMpOwoJICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucyk7CgkgIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKQoJfQoKCWV4cG9ydHMuY29lcmNlID0gY29lcmNlOwoJZnVuY3Rpb24gY29lcmNlICh2ZXJzaW9uKSB7CgkgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7CgkgICAgcmV0dXJuIHZlcnNpb24KCSAgfQoKCSAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykgewoJICAgIHJldHVybiBudWxsCgkgIH0KCgkgIHZhciBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbQ09FUkNFXSk7CgoJICBpZiAobWF0Y2ggPT0gbnVsbCkgewoJICAgIHJldHVybiBudWxsCgkgIH0KCgkgIHJldHVybiBwYXJzZShtYXRjaFsxXSArCgkgICAgJy4nICsgKG1hdGNoWzJdIHx8ICcwJykgKwoJICAgICcuJyArIChtYXRjaFszXSB8fCAnMCcpKQoJfQoJfShzZW12ZXIkMSwgc2VtdmVyJDEuZXhwb3J0cykpOwoKCXZhciBhc3NlcnQgPSBhc3NlcnQkMzsKCXZhciB0cmFuc2xhdGUgPSB0cmFuc2xhdGUkMTsKCXZhciByZXF1aXJlRnJvbVN0cmluZyA9IHJlcXVpcmVGcm9tU3RyaW5nJDEuZXhwb3J0czsKCXZhciBodHRwcyA9IGZvbGxvd1JlZGlyZWN0cy5leHBvcnRzLmh0dHBzOwoJdmFyIE1lbW9yeVN0cmVhbSA9IG1lbW9yeXN0cmVhbTsKCXZhciBzZW12ZXIgPSBzZW12ZXIkMS5leHBvcnRzOwoKCWZ1bmN0aW9uIHNldHVwTWV0aG9kcyAoc29sanNvbikgewoJICB2YXIgdmVyc2lvbjsKCSAgaWYgKCdfc29saWRpdHlfdmVyc2lvbicgaW4gc29sanNvbikgewoJICAgIHZlcnNpb24gPSBzb2xqc29uLmN3cmFwKCdzb2xpZGl0eV92ZXJzaW9uJywgJ3N0cmluZycsIFtdKTsKCSAgfSBlbHNlIHsKCSAgICB2ZXJzaW9uID0gc29sanNvbi5jd3JhcCgndmVyc2lvbicsICdzdHJpbmcnLCBbXSk7CgkgIH0KCgkgIHZhciB2ZXJzaW9uVG9TZW12ZXIgPSBmdW5jdGlvbiAoKSB7CgkgICAgcmV0dXJuIHRyYW5zbGF0ZS52ZXJzaW9uVG9TZW12ZXIodmVyc2lvbigpKTsKCSAgfTsKCgkgIHZhciBpc1ZlcnNpb242ID0gc2VtdmVyLmd0KHZlcnNpb25Ub1NlbXZlcigpLCAnMC41Ljk5Jyk7CgoJICB2YXIgbGljZW5zZTsKCSAgaWYgKCdfc29saWRpdHlfbGljZW5zZScgaW4gc29sanNvbikgewoJICAgIGxpY2Vuc2UgPSBzb2xqc29uLmN3cmFwKCdzb2xpZGl0eV9saWNlbnNlJywgJ3N0cmluZycsIFtdKTsKCSAgfSBlbHNlIGlmICgnX2xpY2Vuc2UnIGluIHNvbGpzb24pIHsKCSAgICBsaWNlbnNlID0gc29sanNvbi5jd3JhcCgnbGljZW5zZScsICdzdHJpbmcnLCBbXSk7CgkgIH0gZWxzZSB7CgkgICAgLy8gcHJlIDAuNC4xNAoJICAgIGxpY2Vuc2UgPSBmdW5jdGlvbiAoKSB7CgkgICAgICAvLyByZXR1cm4gdW5kZWZpbmVkCgkgICAgfTsKCSAgfQoKCSAgdmFyIGFsbG9jOwoJICBpZiAoJ19zb2xpZGl0eV9hbGxvYycgaW4gc29sanNvbikgewoJICAgIGFsbG9jID0gc29sanNvbi5jd3JhcCgnc29saWRpdHlfYWxsb2MnLCAnbnVtYmVyJywgWyAnbnVtYmVyJyBdKTsKCSAgfSBlbHNlIHsKCSAgICBhbGxvYyA9IHNvbGpzb24uX21hbGxvYzsKCSAgICBhc3NlcnQoYWxsb2MsICdFeHBlY3RlZCBtYWxsb2MgdG8gYmUgcHJlc2VudC4nKTsKCSAgfQoKCSAgdmFyIHJlc2V0OwoJICBpZiAoJ19zb2xpZGl0eV9yZXNldCcgaW4gc29sanNvbikgewoJICAgIHJlc2V0ID0gc29sanNvbi5jd3JhcCgnc29saWRpdHlfcmVzZXQnLCBudWxsLCBbXSk7CgkgIH0KCgkgIHZhciBjb3B5VG9DU3RyaW5nID0gZnVuY3Rpb24gKHN0ciwgcHRyKSB7CgkgICAgdmFyIGxlbmd0aCA9IHNvbGpzb24ubGVuZ3RoQnl0ZXNVVEY4KHN0cik7CgkgICAgLy8gVGhpcyBpcyBhbGxvY2F0aW5nIG1lbW9yeSB1c2luZyBzb2xjJ3MgYWxsb2NhdG9yLgoJICAgIC8vCgkgICAgLy8gQmVmb3JlIDAuNi4wOgoJICAgIC8vICAgQXNzdW1pbmcgY29weVRvQ1N0cmluZyBpcyBvbmx5IHVzZWQgaW4gdGhlIGNvbnRleHQgb2Ygd3JhcENhbGxiYWNrLCBzb2xjIHdpbGwgZnJlZSB0aGVzZSBwb2ludGVycy4KCSAgICAvLyAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vc29saWRpdHkvYmxvYi92MC41LjEzL2xpYnNvbGMvbGlic29sYy5oI0wzNy1MNDAKCSAgICAvLwoJICAgIC8vIEFmdGVyIDAuNi4wOgoJICAgIC8vICAgVGhlIGR1dHkgaXMgb24gc29sYy1qcyB0byBmcmVlIHRoZXNlIHBvaW50ZXJzLiBXZSBhY2NvbXBsaXNoIHRoYXQgYnkgY2FsbGluZyBgcmVzZXRgIGF0IHRoZSBlbmQuCgkgICAgdmFyIGJ1ZmZlciA9IGFsbG9jKGxlbmd0aCArIDEpOwoJICAgIHNvbGpzb24uc3RyaW5nVG9VVEY4KHN0ciwgYnVmZmVyLCBsZW5ndGggKyAxKTsKCSAgICBzb2xqc29uLnNldFZhbHVlKHB0ciwgYnVmZmVyLCAnKicpOwoJICB9OwoKCSAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IG11bHRpcGxlIHZlcnNpb25zIG9mIEVtc2NyaXB0ZW4uCgkgIC8vIFRha2UgYSBzaW5nbGUgYHB0cmAgYW5kIHJldHVybnMgYSBgc3RyYC4KCSAgdmFyIGNvcHlGcm9tQ1N0cmluZyA9IHNvbGpzb24uVVRGOFRvU3RyaW5nIHx8IHNvbGpzb24uUG9pbnRlcl9zdHJpbmdpZnk7CgoJICB2YXIgd3JhcENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7CgkgICAgYXNzZXJ0KHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgY2FsbGJhY2sgc3BlY2lmaWVkLicpOwoJICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgY29udGVudHMsIGVycm9yKSB7CgkgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soY29weUZyb21DU3RyaW5nKGRhdGEpKTsKCSAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmNvbnRlbnRzID09PSAnc3RyaW5nJykgewoJICAgICAgICBjb3B5VG9DU3RyaW5nKHJlc3VsdC5jb250ZW50cywgY29udGVudHMpOwoJICAgICAgfQoJICAgICAgaWYgKHR5cGVvZiByZXN1bHQuZXJyb3IgPT09ICdzdHJpbmcnKSB7CgkgICAgICAgIGNvcHlUb0NTdHJpbmcocmVzdWx0LmVycm9yLCBlcnJvcik7CgkgICAgICB9CgkgICAgfTsKCSAgfTsKCgkgIHZhciB3cmFwQ2FsbGJhY2tXaXRoS2luZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykgewoJICAgIGFzc2VydCh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIGNhbGxiYWNrIHNwZWNpZmllZC4nKTsKCSAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIGtpbmQsIGRhdGEsIGNvbnRlbnRzLCBlcnJvcikgewoJICAgICAgLy8gTXVzdCBiZSBhIG51bGwgcG9pbnRlci4KCSAgICAgIGFzc2VydChjb250ZXh0ID09PSAwLCAnQ2FsbGJhY2sgY29udGV4dCBtdXN0IGJlIG51bGwuJyk7CgkgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soY29weUZyb21DU3RyaW5nKGtpbmQpLCBjb3B5RnJvbUNTdHJpbmcoZGF0YSkpOwoJICAgICAgaWYgKHR5cGVvZiByZXN1bHQuY29udGVudHMgPT09ICdzdHJpbmcnKSB7CgkgICAgICAgIGNvcHlUb0NTdHJpbmcocmVzdWx0LmNvbnRlbnRzLCBjb250ZW50cyk7CgkgICAgICB9CgkgICAgICBpZiAodHlwZW9mIHJlc3VsdC5lcnJvciA9PT0gJ3N0cmluZycpIHsKCSAgICAgICAgY29weVRvQ1N0cmluZyhyZXN1bHQuZXJyb3IsIGVycm9yKTsKCSAgICAgIH0KCSAgICB9OwoJICB9OwoKCSAgLy8gVGhpcyBjYWxscyBjb21waWxlKCkgd2l0aCBhcmdzIHx8IGNiCgkgIHZhciBydW5XaXRoQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGNhbGxiYWNrcywgY29tcGlsZSwgYXJncykgewoJICAgIGlmIChjYWxsYmFja3MpIHsKCSAgICAgIGFzc2VydCh0eXBlb2YgY2FsbGJhY2tzID09PSAnb2JqZWN0JywgJ0ludmFsaWQgY2FsbGJhY2sgb2JqZWN0IHNwZWNpZmllZC4nKTsKCSAgICB9IGVsc2UgewoJICAgICAgY2FsbGJhY2tzID0ge307CgkgICAgfQoKCSAgICB2YXIgcmVhZENhbGxiYWNrID0gY2FsbGJhY2tzLmltcG9ydDsKCSAgICBpZiAocmVhZENhbGxiYWNrID09PSB1bmRlZmluZWQpIHsKCSAgICAgIHJlYWRDYWxsYmFjayA9IGZ1bmN0aW9uIChkYXRhKSB7CgkgICAgICAgIHJldHVybiB7CgkgICAgICAgICAgZXJyb3I6ICdGaWxlIGltcG9ydCBjYWxsYmFjayBub3Qgc3VwcG9ydGVkJwoJICAgICAgICB9OwoJICAgICAgfTsKCSAgICB9CgoJICAgIHZhciBzaW5nbGVDYWxsYmFjazsKCSAgICBpZiAoaXNWZXJzaW9uNikgewoJICAgICAgLy8gQWZ0ZXIgMC42LnggbXVsdGlwbGUga2luZCBvZiBjYWxsYmFja3MgYXJlIHN1cHBvcnRlZC4KCSAgICAgIHZhciBzbXRTb2x2ZXJDYWxsYmFjayA9IGNhbGxiYWNrcy5zbXRTb2x2ZXI7CgkgICAgICBpZiAoc210U29sdmVyQ2FsbGJhY2sgPT09IHVuZGVmaW5lZCkgewoJICAgICAgICBzbXRTb2x2ZXJDYWxsYmFjayA9IGZ1bmN0aW9uIChkYXRhKSB7CgkgICAgICAgICAgcmV0dXJuIHsKCSAgICAgICAgICAgIGVycm9yOiAnU01UIHNvbHZlciBjYWxsYmFjayBub3Qgc3VwcG9ydGVkJwoJICAgICAgICAgIH07CgkgICAgICAgIH07CgkgICAgICB9CgoJICAgICAgc2luZ2xlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoa2luZCwgZGF0YSkgewoJICAgICAgICBpZiAoa2luZCA9PT0gJ3NvdXJjZScpIHsKCSAgICAgICAgICByZXR1cm4gcmVhZENhbGxiYWNrKGRhdGEpOwoJICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICdzbXQtcXVlcnknKSB7CgkgICAgICAgICAgcmV0dXJuIHNtdFNvbHZlckNhbGxiYWNrKGRhdGEpOwoJICAgICAgICB9IGVsc2UgewoJICAgICAgICAgIGFzc2VydChmYWxzZSwgJ0ludmFsaWQgY2FsbGJhY2sga2luZCBzcGVjaWZpZWQuJyk7CgkgICAgICAgIH0KCSAgICAgIH07CgoJICAgICAgc2luZ2xlQ2FsbGJhY2sgPSB3cmFwQ2FsbGJhY2tXaXRoS2luZChzaW5nbGVDYWxsYmFjayk7CgkgICAgfSBlbHNlIHsKCSAgICAgIC8vIE9sZCBTb2xpZGl0eSB2ZXJzaW9uIG9ubHkgc3VwcG9ydGVkIGltcG9ydHMuCgkgICAgICBzaW5nbGVDYWxsYmFjayA9IHdyYXBDYWxsYmFjayhyZWFkQ2FsbGJhY2spOwoJICAgIH0KCgkgICAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IG11bHRpcGxlIHZlcnNpb25zIG9mIEVtc2NyaXB0ZW4uCgkgICAgdmFyIGFkZEZ1bmN0aW9uID0gc29sanNvbi5hZGRGdW5jdGlvbiB8fCBzb2xqc29uLlJ1bnRpbWUuYWRkRnVuY3Rpb247CgkgICAgdmFyIHJlbW92ZUZ1bmN0aW9uID0gc29sanNvbi5yZW1vdmVGdW5jdGlvbiB8fCBzb2xqc29uLlJ1bnRpbWUucmVtb3ZlRnVuY3Rpb247CgoJICAgIHZhciBjYiA9IGFkZEZ1bmN0aW9uKHNpbmdsZUNhbGxiYWNrLCAndmlpaWlpJyk7CgkgICAgdmFyIG91dHB1dDsKCSAgICB0cnkgewoJICAgICAgYXJncy5wdXNoKGNiKTsKCSAgICAgIGlmIChpc1ZlcnNpb242KSB7CgkgICAgICAgIC8vIENhbGxiYWNrIGNvbnRleHQuCgkgICAgICAgIGFyZ3MucHVzaChudWxsKTsKCSAgICAgIH0KCSAgICAgIG91dHB1dCA9IGNvbXBpbGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsKCSAgICB9IGNhdGNoIChlKSB7CgkgICAgICByZW1vdmVGdW5jdGlvbihjYik7CgkgICAgICB0aHJvdyBlOwoJICAgIH0KCSAgICByZW1vdmVGdW5jdGlvbihjYik7CgkgICAgaWYgKHJlc2V0KSB7CgkgICAgICAvLyBFeHBsaWNpdGx5IGZyZWUgbWVtb3J5LgoJICAgICAgLy8KCSAgICAgIC8vIE5PVEU6IGN3cmFwKCkgb2YgImNvbXBpbGUiIHdpbGwgY29weSB0aGUgcmV0dXJuZWQgcG9pbnRlciBpbnRvIGEKCSAgICAgIC8vICAgICAgIEphdmFzY3JpcHQgc3RyaW5nIGFuZCBpdCBpcyBub3QgcG9zc2libGUgdG8gY2FsbCBmcmVlKCkgb24gaXQuCgkgICAgICAvLyAgICAgICByZXNldCgpIGhvd2V2ZXIgd2lsbCBjbGVhciB1cCBhbGwgYWxsb2NhdGlvbnMuCgkgICAgICByZXNldCgpOwoJICAgIH0KCSAgICByZXR1cm4gb3V0cHV0OwoJICB9OwoKCSAgdmFyIGNvbXBpbGVKU09OID0gbnVsbDsKCSAgaWYgKCdfY29tcGlsZUpTT04nIGluIHNvbGpzb24pIHsKCSAgICAvLyBpbnB1dCAodGV4dCksIG9wdGltaXplIChib29sKSAtPiBvdXRwdXQgKGpzb250ZXh0KQoJICAgIGNvbXBpbGVKU09OID0gc29sanNvbi5jd3JhcCgnY29tcGlsZUpTT04nLCAnc3RyaW5nJywgWydzdHJpbmcnLCAnbnVtYmVyJ10pOwoJICB9CgoJICB2YXIgY29tcGlsZUpTT05NdWx0aSA9IG51bGw7CgkgIGlmICgnX2NvbXBpbGVKU09OTXVsdGknIGluIHNvbGpzb24pIHsKCSAgICAvLyBpbnB1dCAoanNvbnRleHQpLCBvcHRpbWl6ZSAoYm9vbCkgLT4gb3V0cHV0IChqc29udGV4dCkKCSAgICBjb21waWxlSlNPTk11bHRpID0gc29sanNvbi5jd3JhcCgnY29tcGlsZUpTT05NdWx0aScsICdzdHJpbmcnLCBbJ3N0cmluZycsICdudW1iZXInXSk7CgkgIH0KCgkgIHZhciBjb21waWxlSlNPTkNhbGxiYWNrID0gbnVsbDsKCSAgaWYgKCdfY29tcGlsZUpTT05DYWxsYmFjaycgaW4gc29sanNvbikgewoJICAgIC8vIGlucHV0IChqc29udGV4dCksIG9wdGltaXplIChib29sKSwgY2FsbGJhY2sgKHB0cikgLT4gb3V0cHV0IChqc29udGV4dCkKCSAgICB2YXIgY29tcGlsZUludGVybmFsID0gc29sanNvbi5jd3JhcCgnY29tcGlsZUpTT05DYWxsYmFjaycsICdzdHJpbmcnLCBbJ3N0cmluZycsICdudW1iZXInLCAnbnVtYmVyJ10pOwoJICAgIGNvbXBpbGVKU09OQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGltaXplLCByZWFkQ2FsbGJhY2spIHsKCSAgICAgIHJldHVybiBydW5XaXRoQ2FsbGJhY2tzKHJlYWRDYWxsYmFjaywgY29tcGlsZUludGVybmFsLCBbIGlucHV0LCBvcHRpbWl6ZSBdKTsKCSAgICB9OwoJICB9CgoJICB2YXIgY29tcGlsZVN0YW5kYXJkID0gbnVsbDsKCSAgaWYgKCdfY29tcGlsZVN0YW5kYXJkJyBpbiBzb2xqc29uKSB7CgkgICAgLy8gaW5wdXQgKGpzb250ZXh0KSwgY2FsbGJhY2sgKHB0cikgLT4gb3V0cHV0IChqc29udGV4dCkKCSAgICB2YXIgY29tcGlsZVN0YW5kYXJkSW50ZXJuYWwgPSBzb2xqc29uLmN3cmFwKCdjb21waWxlU3RhbmRhcmQnLCAnc3RyaW5nJywgWydzdHJpbmcnLCAnbnVtYmVyJ10pOwoJICAgIGNvbXBpbGVTdGFuZGFyZCA9IGZ1bmN0aW9uIChpbnB1dCwgcmVhZENhbGxiYWNrKSB7CgkgICAgICByZXR1cm4gcnVuV2l0aENhbGxiYWNrcyhyZWFkQ2FsbGJhY2ssIGNvbXBpbGVTdGFuZGFyZEludGVybmFsLCBbIGlucHV0IF0pOwoJICAgIH07CgkgIH0KCSAgaWYgKCdfc29saWRpdHlfY29tcGlsZScgaW4gc29sanNvbikgewoJICAgIHZhciBzb2xpZGl0eUNvbXBpbGU7CgkgICAgaWYgKGlzVmVyc2lvbjYpIHsKCSAgICAgIC8vIGlucHV0IChqc29udGV4dCksIGNhbGxiYWNrIChwdHIpLCBjYWxsYmFja19jb250ZXh0IChwdHIpIC0+IG91dHB1dCAoanNvbnRleHQpCgkgICAgICBzb2xpZGl0eUNvbXBpbGUgPSBzb2xqc29uLmN3cmFwKCdzb2xpZGl0eV9jb21waWxlJywgJ3N0cmluZycsIFsnc3RyaW5nJywgJ251bWJlcicsICdudW1iZXInXSk7CgkgICAgfSBlbHNlIHsKCSAgICAgIC8vIGlucHV0IChqc29udGV4dCksIGNhbGxiYWNrIChwdHIpIC0+IG91dHB1dCAoanNvbnRleHQpCgkgICAgICBzb2xpZGl0eUNvbXBpbGUgPSBzb2xqc29uLmN3cmFwKCdzb2xpZGl0eV9jb21waWxlJywgJ3N0cmluZycsIFsnc3RyaW5nJywgJ251bWJlciddKTsKCSAgICB9CgkgICAgY29tcGlsZVN0YW5kYXJkID0gZnVuY3Rpb24gKGlucHV0LCBjYWxsYmFja3MpIHsKCSAgICAgIHJldHVybiBydW5XaXRoQ2FsbGJhY2tzKGNhbGxiYWNrcywgc29saWRpdHlDb21waWxlLCBbIGlucHV0IF0pOwoJICAgIH07CgkgIH0KCgkgIC8vIEV4cGVjdHMgYSBTdGFuZGFyZCBKU09OIEkvTyBidXQgc3VwcG9ydHMgb2xkIGNvbXBpbGVycwoJICB2YXIgY29tcGlsZVN0YW5kYXJkV3JhcHBlciA9IGZ1bmN0aW9uIChpbnB1dCwgcmVhZENhbGxiYWNrKSB7CgkgICAgaWYgKGNvbXBpbGVTdGFuZGFyZCAhPT0gbnVsbCkgewoJICAgICAgcmV0dXJuIGNvbXBpbGVTdGFuZGFyZChpbnB1dCwgcmVhZENhbGxiYWNrKTsKCSAgICB9CgoJICAgIGZ1bmN0aW9uIGZvcm1hdEZhdGFsRXJyb3IgKG1lc3NhZ2UpIHsKCSAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7CgkgICAgICAgIGVycm9yczogWwoJICAgICAgICAgIHsKCSAgICAgICAgICAgICd0eXBlJzogJ0pTT05FcnJvcicsCgkgICAgICAgICAgICAnY29tcG9uZW50JzogJ3NvbGNqcycsCgkgICAgICAgICAgICAnc2V2ZXJpdHknOiAnZXJyb3InLAoJICAgICAgICAgICAgJ21lc3NhZ2UnOiBtZXNzYWdlLAoJICAgICAgICAgICAgJ2Zvcm1hdHRlZE1lc3NhZ2UnOiAnRXJyb3I6ICcgKyBtZXNzYWdlCgkgICAgICAgICAgfQoJICAgICAgICBdCgkgICAgICB9KTsKCSAgICB9CgoJICAgIHRyeSB7CgkgICAgICBpbnB1dCA9IEpTT04ucGFyc2UoaW5wdXQpOwoJICAgIH0gY2F0Y2ggKGUpIHsKCSAgICAgIHJldHVybiBmb3JtYXRGYXRhbEVycm9yKCdJbnZhbGlkIEpTT04gc3VwcGxpZWQ6ICcgKyBlLm1lc3NhZ2UpOwoJICAgIH0KCgkgICAgaWYgKGlucHV0WydsYW5ndWFnZSddICE9PSAnU29saWRpdHknKSB7CgkgICAgICByZXR1cm4gZm9ybWF0RmF0YWxFcnJvcignT25seSAiU29saWRpdHkiIGlzIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlLicpOwoJICAgIH0KCgkgICAgLy8gTk9URTogdGhpcyBpcyBkZWxpYmVyYXRlbHkgYD09IG51bGxgCgkgICAgaWYgKGlucHV0Wydzb3VyY2VzJ10gPT0gbnVsbCB8fCBpbnB1dFsnc291cmNlcyddLmxlbmd0aCA9PT0gMCkgewoJICAgICAgcmV0dXJuIGZvcm1hdEZhdGFsRXJyb3IoJ05vIGlucHV0IHNvdXJjZXMgc3BlY2lmaWVkLicpOwoJICAgIH0KCgkgICAgZnVuY3Rpb24gaXNPcHRpbWl6ZXJFbmFibGVkIChpbnB1dCkgewoJICAgICAgcmV0dXJuIGlucHV0WydzZXR0aW5ncyddICYmIGlucHV0WydzZXR0aW5ncyddWydvcHRpbWl6ZXInXSAmJiBpbnB1dFsnc2V0dGluZ3MnXVsnb3B0aW1pemVyJ11bJ2VuYWJsZWQnXTsKCSAgICB9CgoJICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVNvdXJjZXMgKGlucHV0KSB7CgkgICAgICB2YXIgc291cmNlcyA9IHt9OwoJICAgICAgZm9yICh2YXIgc291cmNlIGluIGlucHV0Wydzb3VyY2VzJ10pIHsKCSAgICAgICAgaWYgKGlucHV0Wydzb3VyY2VzJ11bc291cmNlXVsnY29udGVudCddICE9PSBudWxsKSB7CgkgICAgICAgICAgc291cmNlc1tzb3VyY2VdID0gaW5wdXRbJ3NvdXJjZXMnXVtzb3VyY2VdWydjb250ZW50J107CgkgICAgICAgIH0gZWxzZSB7CgkgICAgICAgICAgLy8gZm9yY2UgZmFpbHVyZQoJICAgICAgICAgIHJldHVybiBudWxsOwoJICAgICAgICB9CgkgICAgICB9CgkgICAgICByZXR1cm4gc291cmNlczsKCSAgICB9CgoJICAgIGZ1bmN0aW9uIGxpYnJhcmllc1N1cHBsaWVkIChpbnB1dCkgewoJICAgICAgaWYgKGlucHV0WydzZXR0aW5ncyddKSB7CgkgICAgICAgIHJldHVybiBpbnB1dFsnc2V0dGluZ3MnXVsnbGlicmFyaWVzJ107CgkgICAgICB9CgkgICAgfQoKCSAgICBmdW5jdGlvbiB0cmFuc2xhdGVPdXRwdXQgKG91dHB1dCwgbGlicmFyaWVzKSB7CgkgICAgICB0cnkgewoJICAgICAgICBvdXRwdXQgPSBKU09OLnBhcnNlKG91dHB1dCk7CgkgICAgICB9IGNhdGNoIChlKSB7CgkgICAgICAgIHJldHVybiBmb3JtYXRGYXRhbEVycm9yKCdDb21waWxlciByZXR1cm5lZCBpbnZhbGlkIEpTT046ICcgKyBlLm1lc3NhZ2UpOwoJICAgICAgfQoJICAgICAgb3V0cHV0ID0gdHJhbnNsYXRlLnRyYW5zbGF0ZUpzb25Db21waWxlck91dHB1dChvdXRwdXQsIGxpYnJhcmllcyk7CgkgICAgICBpZiAob3V0cHV0ID09IG51bGwpIHsKCSAgICAgICAgcmV0dXJuIGZvcm1hdEZhdGFsRXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIG91dHB1dC4nKTsKCSAgICAgIH0KCSAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvdXRwdXQpOwoJICAgIH0KCgkgICAgdmFyIHNvdXJjZXMgPSB0cmFuc2xhdGVTb3VyY2VzKGlucHV0KTsKCSAgICBpZiAoc291cmNlcyA9PT0gbnVsbCB8fCBPYmplY3Qua2V5cyhzb3VyY2VzKS5sZW5ndGggPT09IDApIHsKCSAgICAgIHJldHVybiBmb3JtYXRGYXRhbEVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyBzb3VyY2VzLicpOwoJICAgIH0KCgkgICAgLy8gVHJ5IGxpbmtpbmcgaWYgbGlicmFyaWVzIHdlcmUgc3VwcGxpZWQKCSAgICB2YXIgbGlicmFyaWVzID0gbGlicmFyaWVzU3VwcGxpZWQoaW5wdXQpOwoKCSAgICAvLyBUcnkgdG8gd3JhcCBhcm91bmQgb2xkIHZlcnNpb25zCgkgICAgaWYgKGNvbXBpbGVKU09OQ2FsbGJhY2sgIT09IG51bGwpIHsKCSAgICAgIHJldHVybiB0cmFuc2xhdGVPdXRwdXQoY29tcGlsZUpTT05DYWxsYmFjayhKU09OLnN0cmluZ2lmeSh7ICdzb3VyY2VzJzogc291cmNlcyB9KSwgaXNPcHRpbWl6ZXJFbmFibGVkKGlucHV0KSwgcmVhZENhbGxiYWNrKSwgbGlicmFyaWVzKTsKCSAgICB9CgoJICAgIGlmIChjb21waWxlSlNPTk11bHRpICE9PSBudWxsKSB7CgkgICAgICByZXR1cm4gdHJhbnNsYXRlT3V0cHV0KGNvbXBpbGVKU09OTXVsdGkoSlNPTi5zdHJpbmdpZnkoeyAnc291cmNlcyc6IHNvdXJjZXMgfSksIGlzT3B0aW1pemVyRW5hYmxlZChpbnB1dCkpLCBsaWJyYXJpZXMpOwoJICAgIH0KCgkgICAgLy8gVHJ5IG91ciBsdWNrIHdpdGggYW4gYW5jaWVudCBjb21waWxlcgoJICAgIGlmIChjb21waWxlSlNPTiAhPT0gbnVsbCkgewoJICAgICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZXMpLmxlbmd0aCAhPT0gMSkgewoJICAgICAgICByZXR1cm4gZm9ybWF0RmF0YWxFcnJvcignTXVsdGlwbGUgc291cmNlcyBwcm92aWRlZCwgYnV0IGNvbXBpbGVyIG9ubHkgc3VwcG9ydHMgc2luZ2xlIGlucHV0LicpOwoJICAgICAgfQoJICAgICAgcmV0dXJuIHRyYW5zbGF0ZU91dHB1dChjb21waWxlSlNPTihzb3VyY2VzW09iamVjdC5rZXlzKHNvdXJjZXMpWzBdXSwgaXNPcHRpbWl6ZXJFbmFibGVkKGlucHV0KSksIGxpYnJhcmllcyk7CgkgICAgfQoKCSAgICByZXR1cm4gZm9ybWF0RmF0YWxFcnJvcignQ29tcGlsZXIgZG9lcyBub3Qgc3VwcG9ydCBhbnkga25vd24gaW50ZXJmYWNlLicpOwoJICB9OwoKCSAgcmV0dXJuIHsKCSAgICB2ZXJzaW9uOiB2ZXJzaW9uLAoJICAgIHNlbXZlcjogdmVyc2lvblRvU2VtdmVyLAoJICAgIGxpY2Vuc2U6IGxpY2Vuc2UsCgkgICAgbG93bGV2ZWw6IHsKCSAgICAgIGNvbXBpbGVTaW5nbGU6IGNvbXBpbGVKU09OLAoJICAgICAgY29tcGlsZU11bHRpOiBjb21waWxlSlNPTk11bHRpLAoJICAgICAgY29tcGlsZUNhbGxiYWNrOiBjb21waWxlSlNPTkNhbGxiYWNrLAoJICAgICAgY29tcGlsZVN0YW5kYXJkOiBjb21waWxlU3RhbmRhcmQKCSAgICB9LAoJICAgIGZlYXR1cmVzOiB7CgkgICAgICBsZWdhY3lTaW5nbGVJbnB1dDogY29tcGlsZUpTT04gIT09IG51bGwsCgkgICAgICBtdWx0aXBsZUlucHV0czogY29tcGlsZUpTT05NdWx0aSAhPT0gbnVsbCB8fCBjb21waWxlU3RhbmRhcmQgIT09IG51bGwsCgkgICAgICBpbXBvcnRDYWxsYmFjazogY29tcGlsZUpTT05DYWxsYmFjayAhPT0gbnVsbCB8fCBjb21waWxlU3RhbmRhcmQgIT09IG51bGwsCgkgICAgICBuYXRpdmVTdGFuZGFyZEpTT046IGNvbXBpbGVTdGFuZGFyZCAhPT0gbnVsbAoJICAgIH0sCgkgICAgY29tcGlsZTogY29tcGlsZVN0YW5kYXJkV3JhcHBlciwKCSAgICAvLyBMb2FkcyB0aGUgY29tcGlsZXIgb2YgdGhlIGdpdmVuIHZlcnNpb24gZnJvbSB0aGUgZ2l0aHViIHJlcG9zaXRvcnkKCSAgICAvLyBpbnN0ZWFkIG9mIGZyb20gdGhlIGxvY2FsIGZpbGVzeXN0ZW0uCgkgICAgbG9hZFJlbW90ZVZlcnNpb246IGZ1bmN0aW9uICh2ZXJzaW9uU3RyaW5nLCBjYikgewoJICAgICAgdmFyIG1lbSA9IG5ldyBNZW1vcnlTdHJlYW0obnVsbCwge3JlYWRhYmxlOiBmYWxzZX0pOwoJICAgICAgdmFyIHVybCA9ICdodHRwczovL2JpbmFyaWVzLnNvbGlkaXR5bGFuZy5vcmcvYmluL3NvbGpzb24tJyArIHZlcnNpb25TdHJpbmcgKyAnLmpzJzsKCSAgICAgIGh0dHBzLmdldCh1cmwsIGZ1bmN0aW9uIChyZXNwb25zZSkgewoJICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwKSB7CgkgICAgICAgICAgY2IobmV3IEVycm9yKCdFcnJvciByZXRyaWV2aW5nIGJpbmFyeTogJyArIHJlc3BvbnNlLnN0YXR1c01lc3NhZ2UpKTsKCSAgICAgICAgfSBlbHNlIHsKCSAgICAgICAgICByZXNwb25zZS5waXBlKG1lbSk7CgkgICAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHsKCSAgICAgICAgICAgIGNiKG51bGwsIHNldHVwTWV0aG9kcyhyZXF1aXJlRnJvbVN0cmluZyhtZW0udG9TdHJpbmcoKSwgJ3NvbGpzb24tJyArIHZlcnNpb25TdHJpbmcgKyAnLmpzJykpKTsKCSAgICAgICAgICB9KTsKCSAgICAgICAgfQoJICAgICAgfSkub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7CgkgICAgICAgIGNiKGVycm9yKTsKCSAgICAgIH0pOwoJICAgIH0sCgkgICAgLy8gVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gYWRkIHdyYXBwZXIgZnVuY3Rpb25zIGFyb3VuZCB0aGUgcHVyZSBtb2R1bGUuCgkgICAgc2V0dXBNZXRob2RzOiBzZXR1cE1ldGhvZHMKCSAgfTsKCX0KCgl2YXIgd3JhcHBlciA9IHNldHVwTWV0aG9kczsKCgl2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IGludGVyb3BSZXF1aXJlRGVmYXVsdC5leHBvcnRzOwoKCXZhciBfd3JhcHBlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQod3JhcHBlcik7CgoJLyogZXNsaW50LWVudiBicm93c2VyICovCgoJLyogZ2xvYmFscyBpbXBvcnRTY3JpcHRzICovCglpbXBvcnRTY3JpcHRzKCJodHRwczovL2JpbmFyaWVzLnNvbGlkaXR5bGFuZy5vcmcvYmluL3NvbGpzb24tdjAuOC45K2NvbW1pdC5lNWVlZDYzYS5qcyIpOwoJdmFyIGNvbXBpbGVyID0gKDAsIF93cmFwcGVyWyJkZWZhdWx0Il0pKHNlbGYuTW9kdWxlKTsKCXNlbGYuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGZ1bmN0aW9uIChfcmVmKSB7CgkgIHZhciBkYXRhID0gX3JlZi5kYXRhOwoKCSAgaWYgKCJjb21waWxlIiA9PT0gZGF0YS50eXBlKSB7CgkgICAgc2VsZi5wb3N0TWVzc2FnZSh7CgkgICAgICBwYXlsb2FkOiBjb21waWxlci5jb21waWxlKGRhdGEucGF5bG9hZCksCgkgICAgICB0eXBlOiAiY29tcGlsZV9yZXN1bHQiCgkgICAgfSk7CgkgIH0KCX0pOwoJc2VsZi5wb3N0TWVzc2FnZSh7CgkgIHR5cGU6ICJsb2FkZWQiCgl9KTsKCglyZXR1cm4gU29saWRpdHlDb21waWxlcl93b3JrZXI7Cgp9KSgpOwoK', 'data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU29saWRpdHlDb21waWxlci53b3JrZXIuanMiLCJzb3VyY2VzIjpbIndvcmtlcjovL3dlYi13b3JrZXIvQGJ1aWRsZXJsYWJzL3JvbGx1cC1wbHVnaW4taGVkZXJhLXN0cmF0by9saWIuY2pzL3BvbGllcy9jb21waWxlci93b3JrZXIvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL2dsb2JhbC5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvQGJ1aWRsZXJsYWJzL3JvbGx1cC1wbHVnaW4taGVkZXJhLXN0cmF0by9saWIuY2pzL3BvbGllcy9jb21waWxlci93b3JrZXIvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvYnVmZmVyLWVzNi5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvQGJ1aWRsZXJsYWJzL3JvbGx1cC1wbHVnaW4taGVkZXJhLXN0cmF0by9saWIuY2pzL3BvbGllcy9jb21waWxlci93b3JrZXIvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcHJvY2Vzcy1lczYuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL2luaGVyaXRzLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy91dGlsLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9hc3NlcnQuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL2pzLXNoYTMvc3JjL3NoYTMuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3NvbGMvbGlua2VyLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9zb2xjL3RyYW5zbGF0ZS5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvQGJ1aWRsZXJsYWJzL3JvbGx1cC1wbHVnaW4taGVkZXJhLXN0cmF0by9saWIuY2pzL3BvbGllcy9jb21waWxlci93b3JrZXIvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvZW1wdHkuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3BhdGguanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3JlcXVpcmUtZnJvbS1zdHJpbmcvaW5kZXguanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3B1bnljb2RlLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9xcy5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvQGJ1aWRsZXJsYWJzL3JvbGx1cC1wbHVnaW4taGVkZXJhLXN0cmF0by9saWIuY2pzL3BvbGllcy9jb21waWxlci93b3JrZXIvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvdXJsLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9odHRwLWxpYi9jYXBhYmlsaXR5LmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9ldmVudHMuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS9idWZmZXItbGlzdC5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvQGJ1aWRsZXJsYWJzL3JvbGx1cC1wbHVnaW4taGVkZXJhLXN0cmF0by9saWIuY2pzL3BvbGllcy9jb21waWxlci93b3JrZXIvc3RyaW5nX2RlY29kZXIvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvQGJ1aWRsZXJsYWJzL3JvbGx1cC1wbHVnaW4taGVkZXJhLXN0cmF0by9saWIuY2pzL3BvbGllcy9jb21waWxlci93b3JrZXIvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3N0cmVhbS5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvQGJ1aWRsZXJsYWJzL3JvbGx1cC1wbHVnaW4taGVkZXJhLXN0cmF0by9saWIuY2pzL3BvbGllcy9jb21waWxlci93b3JrZXIvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvaHR0cC1saWIvcmVzcG9uc2UuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL2h0dHAtbGliL3RvLWFycmF5YnVmZmVyLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9odHRwLWxpYi9yZXF1ZXN0LmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9odHRwLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9mb2xsb3ctcmVkaXJlY3RzL2RlYnVnLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9mb2xsb3ctcmVkaXJlY3RzL2luZGV4LmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9AYnVpZGxlcmxhYnMvcm9sbHVwLXBsdWdpbi1oZWRlcmEtc3RyYXRvL2xpYi5janMvcG9saWVzL2NvbXBpbGVyL3dvcmtlci9tZW1vcnlzdHJlYW0vaW5kZXguanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3NvbGMvbm9kZV9tb2R1bGVzL3NlbXZlci9zZW12ZXIuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL0BidWlkbGVybGFicy9yb2xsdXAtcGx1Z2luLWhlZGVyYS1zdHJhdG8vbGliLmNqcy9wb2xpZXMvY29tcGlsZXIvd29ya2VyL3NvbGMvd3JhcHBlci5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvQGJ1aWRsZXJsYWJzL3JvbGx1cC1wbHVnaW4taGVkZXJhLXN0cmF0by9saWIuY2pzL3BvbGllcy9jb21waWxlci93b3JrZXIvU29saWRpdHlDb21waWxlci53b3JrZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImV4cG9ydCBkZWZhdWx0ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDpcbiAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTsiLCJ2YXIgbG9va3VwID0gW107XG52YXIgcmV2TG9va3VwID0gW107XG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5O1xudmFyIGluaXRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGluaXRlZCA9IHRydWU7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyO1xuICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjM7XG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoO1xuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwO1xuXG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKTtcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlbjtcblxuICB2YXIgTCA9IDA7XG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KTtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXA7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciB0bXA7XG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGg7XG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMzsgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7IC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpO1xuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdO1xuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPT0nO1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pO1xuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gJz0nO1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpO1xuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiByZWFkIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gLTc7XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDA7XG4gIHZhciBkID0gaXNMRSA/IC0xIDogMTtcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZnVuY3Rpb24gd3JpdGUgKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKTtcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKTtcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBJTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWU7XG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbnZhciBfa01heExlbmd0aCA9IGtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnJcbn07XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufTtcblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMDtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5CdWZmZXIuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbmZ1bmN0aW9uIGludGVybmFsSXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihhKSB8fCAhaW50ZXJuYWxJc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59O1xuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59O1xuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlO1xuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXTtcbiAgYltuXSA9IGJbbV07XG4gIGJbbV0gPSBpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNik7XG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgbWF4ID0gSU5TUEVDVF9NQVhfQllURVM7XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnO1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7XG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMDtcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMDtcbiAgZW5kID4+Pj0gMDtcbiAgdGhpc1N0YXJ0ID4+Pj0gMDtcbiAgdGhpc0VuZCA+Pj49IDA7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7XG4gIHZhciB5ID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KTtcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7XG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXTtcbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59O1xuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG4gICAgYnl0ZU9mZnNldCA9IDA7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZjtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDA7XG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OyAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwO1xuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKGludGVybmFsSXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGOyAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxO1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyO1xuICAgICAgYXJyTGVuZ3RoIC89IDI7XG4gICAgICB2YWxMZW5ndGggLz0gMjtcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXg7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7XG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn07XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBvZmZzZXQgPSAwO1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwO1xuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmc7XG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIHZhciBpID0gc3RhcnQ7XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbDtcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDE7XG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KTtcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDA7XG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjtcblxuICB2YXIgb3V0ID0gJyc7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIHN0YXJ0ID0gfn5zdGFydDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuO1xuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwO1xuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgdmFyIG5ld0J1ZjtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydDtcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn07XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdO1xuICB2YXIgbXVsID0gMTtcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXTtcbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59O1xuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gIH1cblxuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMVxufTtcblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogODtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxO1xuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDE7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCk7XG4gIH1cbiAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTtcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDtcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgdmFyIGk7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBsZW5cbn07XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kO1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTU7XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDA7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG5cbiAgaWYgKCF2YWwpIHZhbCA9IDA7XG5cbiAgdmFyIGk7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IGludGVybmFsSXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKTtcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufTtcblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2c7XG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJyk7XG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9JztcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTtcbiAgdmFyIGNvZGVQb2ludDtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgdmFyIGJ5dGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG87XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoaSA9IGMgPj4gODtcbiAgICBsbyA9IGMgJSAyNTY7XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pO1xuICAgIGJ5dGVBcnJheS5wdXNoKGhpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIHRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cbi8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2Vcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbmZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKCEhb2JqLl9pc0J1ZmZlciB8fCBpc0Zhc3RCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNGYXN0QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNGYXN0QnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cblxuZXhwb3J0IHsgQnVmZmVyLCBJTlNQRUNUX01BWF9CWVRFUywgU2xvd0J1ZmZlciwgaXNCdWZmZXIsIF9rTWF4TGVuZ3RoIGFzIGtNYXhMZW5ndGggfTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuLy8gYmFzZWQgb2ZmIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtcHJvY2Vzcy9ibG9iL21hc3Rlci9icm93c2VyLmpzXG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxudmFyIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5pZiAodHlwZW9mIGdsb2JhbC5zZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG59XG5pZiAodHlwZW9mIGdsb2JhbC5jbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG59XG5cbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cbmZ1bmN0aW9uIG5leHRUaWNrKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59XG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xudmFyIHRpdGxlID0gJ2Jyb3dzZXInO1xudmFyIHBsYXRmb3JtID0gJ2Jyb3dzZXInO1xudmFyIGJyb3dzZXIgPSB0cnVlO1xudmFyIGVudiA9IHt9O1xudmFyIGFyZ3YgPSBbXTtcbnZhciB2ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG52YXIgdmVyc2lvbnMgPSB7fTtcbnZhciByZWxlYXNlID0ge307XG52YXIgY29uZmlnID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgb24gPSBub29wO1xudmFyIGFkZExpc3RlbmVyID0gbm9vcDtcbnZhciBvbmNlID0gbm9vcDtcbnZhciBvZmYgPSBub29wO1xudmFyIHJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnZhciByZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xudmFyIGVtaXQgPSBub29wO1xuXG5mdW5jdGlvbiBiaW5kaW5nKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbmZ1bmN0aW9uIGN3ZCAoKSB7IHJldHVybiAnLycgfVxuZnVuY3Rpb24gY2hkaXIgKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59ZnVuY3Rpb24gdW1hc2soKSB7IHJldHVybiAwOyB9XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2t1bWF2aXMvYnJvd3Nlci1wcm9jZXNzLWhydGltZS9ibG9iL21hc3Rlci9pbmRleC5qc1xudmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IHt9O1xudmFyIHBlcmZvcm1hbmNlTm93ID1cbiAgcGVyZm9ybWFuY2Uubm93ICAgICAgICB8fFxuICBwZXJmb3JtYW5jZS5tb3pOb3cgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm1zTm93ICAgICAgfHxcbiAgcGVyZm9ybWFuY2Uub05vdyAgICAgICB8fFxuICBwZXJmb3JtYW5jZS53ZWJraXROb3cgIHx8XG4gIGZ1bmN0aW9uKCl7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH07XG5cbi8vIGdlbmVyYXRlIHRpbWVzdGFtcCBvciBkZWx0YVxuLy8gc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2hydGltZVxuZnVuY3Rpb24gaHJ0aW1lKHByZXZpb3VzVGltZXN0YW1wKXtcbiAgdmFyIGNsb2NrdGltZSA9IHBlcmZvcm1hbmNlTm93LmNhbGwocGVyZm9ybWFuY2UpKjFlLTM7XG4gIHZhciBzZWNvbmRzID0gTWF0aC5mbG9vcihjbG9ja3RpbWUpO1xuICB2YXIgbmFub3NlY29uZHMgPSBNYXRoLmZsb29yKChjbG9ja3RpbWUlMSkqMWU5KTtcbiAgaWYgKHByZXZpb3VzVGltZXN0YW1wKSB7XG4gICAgc2Vjb25kcyA9IHNlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFswXTtcbiAgICBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMV07XG4gICAgaWYgKG5hbm9zZWNvbmRzPDApIHtcbiAgICAgIHNlY29uZHMtLTtcbiAgICAgIG5hbm9zZWNvbmRzICs9IDFlOTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzZWNvbmRzLG5hbm9zZWNvbmRzXVxufVxuXG52YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbmZ1bmN0aW9uIHVwdGltZSgpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgdmFyIGRpZiA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICByZXR1cm4gZGlmIC8gMTAwMDtcbn1cblxudmFyIGJyb3dzZXIkMSA9IHtcbiAgbmV4dFRpY2s6IG5leHRUaWNrLFxuICB0aXRsZTogdGl0bGUsXG4gIGJyb3dzZXI6IGJyb3dzZXIsXG4gIGVudjogZW52LFxuICBhcmd2OiBhcmd2LFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICB2ZXJzaW9uczogdmVyc2lvbnMsXG4gIG9uOiBvbixcbiAgYWRkTGlzdGVuZXI6IGFkZExpc3RlbmVyLFxuICBvbmNlOiBvbmNlLFxuICBvZmY6IG9mZixcbiAgcmVtb3ZlTGlzdGVuZXI6IHJlbW92ZUxpc3RlbmVyLFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IHJlbW92ZUFsbExpc3RlbmVycyxcbiAgZW1pdDogZW1pdCxcbiAgYmluZGluZzogYmluZGluZyxcbiAgY3dkOiBjd2QsXG4gIGNoZGlyOiBjaGRpcixcbiAgdW1hc2s6IHVtYXNrLFxuICBocnRpbWU6IGhydGltZSxcbiAgcGxhdGZvcm06IHBsYXRmb3JtLFxuICByZWxlYXNlOiByZWxlYXNlLFxuICBjb25maWc6IGNvbmZpZyxcbiAgdXB0aW1lOiB1cHRpbWVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJyb3dzZXIkMTtcbmV4cG9ydCB7IGFkZExpc3RlbmVyLCBhcmd2LCBiaW5kaW5nLCBicm93c2VyLCBjaGRpciwgY29uZmlnLCBjd2QsIGVtaXQsIGVudiwgaHJ0aW1lLCBuZXh0VGljaywgb2ZmLCBvbiwgb25jZSwgcGxhdGZvcm0sIHJlbGVhc2UsIHJlbW92ZUFsbExpc3RlbmVycywgcmVtb3ZlTGlzdGVuZXIsIHRpdGxlLCB1bWFzaywgdXB0aW1lLCB2ZXJzaW9uLCB2ZXJzaW9ucyB9O1xuIiwiXG52YXIgaW5oZXJpdHM7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpe1xuICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBpbmhlcml0cztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuaW1wb3J0IHByb2Nlc3MgZnJvbSAncHJvY2Vzcyc7XG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnQgZnVuY3Rpb24gZGVidWdsb2coc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gMDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBfZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnVmZmVyKG1heWJlQnVmKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIobWF5YmVCdWYpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnQgZnVuY3Rpb24gbG9nKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG59XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmltcG9ydCBpbmhlcml0cyBmcm9tICcuL2luaGVyaXRzJztcbmV4cG9ydCB7aW5oZXJpdHN9XG5cbmV4cG9ydCBmdW5jdGlvbiBfZXh0ZW5kKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgX2V4dGVuZDogX2V4dGVuZCxcbiAgbG9nOiBsb2csXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc0Vycm9yOiBpc0Vycm9yLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNTeW1ib2w6IGlzU3ltYm9sLFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGlzTnVsbE9yVW5kZWZpbmVkLFxuICBpc051bGw6IGlzTnVsbCxcbiAgaXNCb29sZWFuOiBpc0Jvb2xlYW4sXG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGluc3BlY3Q6IGluc3BlY3QsXG4gIGRlcHJlY2F0ZTogZGVwcmVjYXRlLFxuICBmb3JtYXQ6IGZvcm1hdCxcbiAgZGVidWdsb2c6IGRlYnVnbG9nXG59XG4iLCJcbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5pbXBvcnQge2lzQnVmZmVyfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHtpc1ByaW1pdGl2ZSwgaW5oZXJpdHMsIGlzRXJyb3IsIGlzRnVuY3Rpb24sIGlzUmVnRXhwLCBpc0RhdGUsIGluc3BlY3QgYXMgdXRpbEluc3BlY3R9IGZyb20gJ3V0aWwnO1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBfZnVuY3Rpb25zSGF2ZU5hbWVzO1xuZnVuY3Rpb24gZnVuY3Rpb25zSGF2ZU5hbWVzKCkge1xuICBpZiAodHlwZW9mIF9mdW5jdGlvbnNIYXZlTmFtZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIF9mdW5jdGlvbnNIYXZlTmFtZXM7XG4gIH1cbiAgcmV0dXJuIF9mdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbiAgfSgpKTtcbn1cbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBvayk7XG59XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcygpKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbmV4cG9ydCBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG5pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMoKSB8fCAhaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWxJbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmV4cG9ydCBmdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5leHBvcnQgZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09Jywgb2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5leHBvcnQge29rIGFzIGFzc2VydH07XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuYXNzZXJ0LmVxdWFsID0gZXF1YWw7XG5leHBvcnQgZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGVxdWFsKTtcbn1cblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuYXNzZXJ0Lm5vdEVxdWFsID0gbm90RXF1YWw7XG5leHBvcnQgZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBub3RFcXVhbCk7XG4gIH1cbn1cblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcbmFzc2VydC5kZWVwRXF1YWwgPSBkZWVwRXF1YWw7XG5leHBvcnQgZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGRlZXBFcXVhbCk7XG4gIH1cbn1cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBkZWVwU3RyaWN0RXF1YWw7XG5leHBvcnQgZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAoaXNEYXRlKGFjdHVhbCkgJiYgaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChhY3R1YWwpICYmIGlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKGlzUHJpbWl0aXZlKGEpIHx8IGlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IG5vdERlZXBFcXVhbDtcbmV4cG9ydCBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBub3REZWVwRXF1YWwpO1xuICB9XG59XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5leHBvcnQgZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBzdHJpY3RFcXVhbDtcbmV4cG9ydCBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09Jywgc3RyaWN0RXF1YWwpO1xuICB9XG59XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gbm90U3RyaWN0RXF1YWw7XG5leHBvcnQgZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIG5vdFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBpc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcbmFzc2VydC50aHJvd3MgPSB0aHJvd3M7XG5leHBvcnQgZnVuY3Rpb24gdGhyb3dzKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGRvZXNOb3RUaHJvdztcbmV4cG9ydCBmdW5jdGlvbiBkb2VzTm90VGhyb3coYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59XG5cbmFzc2VydC5pZkVycm9yID0gaWZFcnJvcjtcbmV4cG9ydCBmdW5jdGlvbiBpZkVycm9yKGVycikge1xuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG4iLCIvKipcbiAqIFtqcy1zaGEzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTN9XG4gKlxuICogQHZlcnNpb24gMC44LjBcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXG4gKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTUtMjAxOFxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgSU5QVVRfRVJST1IgPSAnaW5wdXQgaXMgaW52YWxpZCB0eXBlJztcbiAgdmFyIEZJTkFMSVpFX0VSUk9SID0gJ2ZpbmFsaXplIGFscmVhZHkgY2FsbGVkJztcbiAgdmFyIFdJTkRPVyA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnO1xuICB2YXIgcm9vdCA9IFdJTkRPVyA/IHdpbmRvdyA6IHt9O1xuICBpZiAocm9vdC5KU19TSEEzX05PX1dJTkRPVykge1xuICAgIFdJTkRPVyA9IGZhbHNlO1xuICB9XG4gIHZhciBXRUJfV09SS0VSID0gIVdJTkRPVyAmJiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCc7XG4gIHZhciBOT0RFX0pTID0gIXJvb3QuSlNfU0hBM19OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgaWYgKE5PREVfSlMpIHtcbiAgICByb290ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFdFQl9XT1JLRVIpIHtcbiAgICByb290ID0gc2VsZjtcbiAgfVxuICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBM19OT19DT01NT05fSlMgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHM7XG4gIHZhciBBTUQgPSB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQ7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAhcm9vdC5KU19TSEEzX05PX0FSUkFZX0JVRkZFUiAmJiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgSEVYX0NIQVJTID0gJzAxMjM0NTY3ODlhYmNkZWYnLnNwbGl0KCcnKTtcbiAgdmFyIFNIQUtFX1BBRERJTkcgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl07XG4gIHZhciBDU0hBS0VfUEFERElORyA9IFs0LCAxMDI0LCAyNjIxNDQsIDY3MTA4ODY0XTtcbiAgdmFyIEtFQ0NBS19QQURESU5HID0gWzEsIDI1NiwgNjU1MzYsIDE2Nzc3MjE2XTtcbiAgdmFyIFBBRERJTkcgPSBbNiwgMTUzNiwgMzkzMjE2LCAxMDA2NjMyOTZdO1xuICB2YXIgU0hJRlQgPSBbMCwgOCwgMTYsIDI0XTtcbiAgdmFyIFJDID0gWzEsIDAsIDMyODk4LCAwLCAzMjkwNiwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQxNiwgMjE0NzQ4MzY0OCwgMzI5MDcsIDAsIDIxNDc0ODM2NDksXG4gICAgMCwgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI3NzcsIDIxNDc0ODM2NDgsIDEzOCwgMCwgMTM2LCAwLCAyMTQ3NTE2NDI1LCAwLFxuICAgIDIxNDc0ODM2NTgsIDAsIDIxNDc1MTY1NTUsIDAsIDEzOSwgMjE0NzQ4MzY0OCwgMzI5MDUsIDIxNDc0ODM2NDgsIDMyNzcxLFxuICAgIDIxNDc0ODM2NDgsIDMyNzcwLCAyMTQ3NDgzNjQ4LCAxMjgsIDIxNDc0ODM2NDgsIDMyNzc4LCAwLCAyMTQ3NDgzNjU4LCAyMTQ3NDgzNjQ4LFxuICAgIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyODk2LCAyMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NDI0LCAyMTQ3NDgzNjQ4XTtcbiAgdmFyIEJJVFMgPSBbMjI0LCAyNTYsIDM4NCwgNTEyXTtcbiAgdmFyIFNIQUtFX0JJVFMgPSBbMTI4LCAyNTZdO1xuICB2YXIgT1VUUFVUX1RZUEVTID0gWydoZXgnLCAnYnVmZmVyJywgJ2FycmF5QnVmZmVyJywgJ2FycmF5JywgJ2RpZ2VzdCddO1xuICB2YXIgQ1NIQUtFX0JZVEVQQUQgPSB7XG4gICAgJzEyOCc6IDE2OCxcbiAgICAnMjU2JzogMTM2XG4gIH07XG5cbiAgaWYgKHJvb3QuSlNfU0hBM19OT19OT0RFX0pTIHx8ICFBcnJheS5pc0FycmF5KSB7XG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFSUkFZX0JVRkZFUiAmJiAocm9vdC5KU19TSEEzX05PX0FSUkFZX0JVRkZFUl9JU19WSUVXIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5idWZmZXIgJiYgb2JqLmJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgYml0cykudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlU2hha2VPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlQ3NoYWtlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMsIG4sIHMpIHtcbiAgICAgIHJldHVybiBtZXRob2RzWydjc2hha2UnICsgYml0c10udXBkYXRlKG1lc3NhZ2UsIG91dHB1dEJpdHMsIG4sIHMpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS21hY091dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UsIG91dHB1dEJpdHMsIHMpIHtcbiAgICAgIHJldHVybiBtZXRob2RzWydrbWFjJyArIGJpdHNdLnVwZGF0ZShrZXksIG1lc3NhZ2UsIG91dHB1dEJpdHMsIHMpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kcyA9IGZ1bmN0aW9uIChtZXRob2QsIGNyZWF0ZU1ldGhvZCwgYml0cywgcGFkZGluZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTtcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU1ldGhvZChiaXRzLCBwYWRkaW5nLCB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfTtcblxuICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgYml0cyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKCkudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVTaGFrZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShvdXRwdXRCaXRzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlQ3NoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHNdO1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAob3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgaWYgKCFuICYmICFzKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzWydzaGFrZScgKyBiaXRzXS5jcmVhdGUob3V0cHV0Qml0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS5ieXRlcGFkKFtuLCBzXSwgdyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMsIG4sIHMpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMsIG4sIHMpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlQ3NoYWtlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS21hY01ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIHcgPSBDU0hBS0VfQllURVBBRFtiaXRzXTtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlS21hY091dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChrZXksIG91dHB1dEJpdHMsIHMpIHtcbiAgICAgIHJldHVybiBuZXcgS21hYyhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS5ieXRlcGFkKFsnS01BQycsIHNdLCB3KS5ieXRlcGFkKFtrZXldLCB3KTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShrZXksIG91dHB1dEJpdHMsIHMpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlS21hY091dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGFsZ29yaXRobXMgPSBbXG4gICAgeyBuYW1lOiAna2VjY2FrJywgcGFkZGluZzogS0VDQ0FLX1BBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kIH0sXG4gICAgeyBuYW1lOiAnc2hhMycsIHBhZGRpbmc6IFBBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kIH0sXG4gICAgeyBuYW1lOiAnc2hha2UnLCBwYWRkaW5nOiBTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZVNoYWtlTWV0aG9kIH0sXG4gICAgeyBuYW1lOiAnY3NoYWtlJywgcGFkZGluZzogQ1NIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlQ3NoYWtlTWV0aG9kIH0sXG4gICAgeyBuYW1lOiAna21hYycsIHBhZGRpbmc6IENTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZUttYWNNZXRob2QgfVxuICBdO1xuXG4gIHZhciBtZXRob2RzID0ge30sIG1ldGhvZE5hbWVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGdvcml0aG1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGFsZ29yaXRobSA9IGFsZ29yaXRobXNbaV07XG4gICAgdmFyIGJpdHMgPSBhbGdvcml0aG0uYml0cztcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgIHZhciBtZXRob2ROYW1lID0gYWxnb3JpdGhtLm5hbWUgKyAnXycgKyBiaXRzW2pdO1xuICAgICAgbWV0aG9kTmFtZXMucHVzaChtZXRob2ROYW1lKTtcbiAgICAgIG1ldGhvZHNbbWV0aG9kTmFtZV0gPSBhbGdvcml0aG0uY3JlYXRlTWV0aG9kKGJpdHNbal0sIGFsZ29yaXRobS5wYWRkaW5nKTtcbiAgICAgIGlmIChhbGdvcml0aG0ubmFtZSAhPT0gJ3NoYTMnKSB7XG4gICAgICAgIHZhciBuZXdNZXRob2ROYW1lID0gYWxnb3JpdGhtLm5hbWUgKyBiaXRzW2pdO1xuICAgICAgICBtZXRob2ROYW1lcy5wdXNoKG5ld01ldGhvZE5hbWUpO1xuICAgICAgICBtZXRob2RzW25ld01ldGhvZE5hbWVdID0gbWV0aG9kc1ttZXRob2ROYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykge1xuICAgIHRoaXMuYmxvY2tzID0gW107XG4gICAgdGhpcy5zID0gW107XG4gICAgdGhpcy5wYWRkaW5nID0gcGFkZGluZztcbiAgICB0aGlzLm91dHB1dEJpdHMgPSBvdXRwdXRCaXRzO1xuICAgIHRoaXMucmVzZXQgPSB0cnVlO1xuICAgIHRoaXMuZmluYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5ibG9jayA9IDA7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5ibG9ja0NvdW50ID0gKDE2MDAgLSAoYml0cyA8PCAxKSkgPj4gNTtcbiAgICB0aGlzLmJ5dGVDb3VudCA9IHRoaXMuYmxvY2tDb3VudCA8PCAyO1xuICAgIHRoaXMub3V0cHV0QmxvY2tzID0gb3V0cHV0Qml0cyA+PiA1O1xuICAgIHRoaXMuZXh0cmFCeXRlcyA9IChvdXRwdXRCaXRzICYgMzEpID4+IDM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDUwOyArK2kpIHtcbiAgICAgIHRoaXMuc1tpXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgS2VjY2FrLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEZJTkFMSVpFX0VSUk9SKTtcbiAgICB9XG4gICAgdmFyIG5vdFN0cmluZywgdHlwZSA9IHR5cGVvZiBtZXNzYWdlO1xuICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgfSBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgICBpZiAoIUFSUkFZX0JVRkZFUiB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgYnl0ZUNvdW50ID0gdGhpcy5ieXRlQ291bnQsIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgaW5kZXggPSAwLCBzID0gdGhpcy5zLCBpLCBjb2RlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5yZXNldCkge1xuICAgICAgICB0aGlzLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBibG9ja0NvdW50ICsgMTsgKytpKSB7XG4gICAgICAgICAgYmxvY2tzW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gbWVzc2FnZVtpbmRleF0gPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCBieXRlQ291bnQ7ICsraW5kZXgpIHtcbiAgICAgICAgICBjb2RlID0gbWVzc2FnZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IGNvZGUgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZSA9IDB4MTAwMDAgKyAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChtZXNzYWdlLmNoYXJDb2RlQXQoKytpbmRleCkgJiAweDNmZikpO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZjAgfCAoY29kZSA+PiAxOCkpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcbiAgICAgIGlmIChpID49IGJ5dGVDb3VudCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gaSAtIGJ5dGVDb3VudDtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1tibG9ja0NvdW50XTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQ7ICsraSkge1xuICAgICAgICAgIHNbaV0gXj0gYmxvY2tzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGYocyk7XG4gICAgICAgIHRoaXMucmVzZXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHgsIHJpZ2h0KSB7XG4gICAgdmFyIG8gPSB4ICYgMjU1LCBuID0gMTtcbiAgICB2YXIgYnl0ZXMgPSBbb107XG4gICAgeCA9IHggPj4gODtcbiAgICBvID0geCAmIDI1NTtcbiAgICB3aGlsZSAobyA+IDApIHtcbiAgICAgIGJ5dGVzLnVuc2hpZnQobyk7XG4gICAgICB4ID0geCA+PiA4O1xuICAgICAgbyA9IHggJiAyNTU7XG4gICAgICArK247XG4gICAgfVxuICAgIGlmIChyaWdodCkge1xuICAgICAgYnl0ZXMucHVzaChuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZXMudW5zaGlmdChuKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoYnl0ZXMpO1xuICAgIHJldHVybiBieXRlcy5sZW5ndGg7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5lbmNvZGVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIG5vdFN0cmluZywgdHlwZSA9IHR5cGVvZiBzdHI7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHN0ciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIHN0ci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBzdHIgPSBuZXcgVWludDhBcnJheShzdHIpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHN0cikpIHtcbiAgICAgICAgICBpZiAoIUFSUkFZX0JVRkZFUiB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KHN0cikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgfVxuICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGJ5dGVzID0gMCwgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICBpZiAobm90U3RyaW5nKSB7XG4gICAgICBieXRlcyA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgYnl0ZXMgKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICBieXRlcyArPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICBieXRlcyArPSAzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M2ZmKSk7XG4gICAgICAgICAgYnl0ZXMgKz0gNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBieXRlcyArPSB0aGlzLmVuY29kZShieXRlcyAqIDgpO1xuICAgIHRoaXMudXBkYXRlKHN0cik7XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuYnl0ZXBhZCA9IGZ1bmN0aW9uIChzdHJzLCB3KSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5lbmNvZGUodyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcyArPSB0aGlzLmVuY29kZVN0cmluZyhzdHJzW2ldKTtcbiAgICB9XG4gICAgdmFyIHBhZGRpbmdCeXRlcyA9IHcgLSBieXRlcyAlIHc7XG4gICAgdmFyIHplcm9zID0gW107XG4gICAgemVyb3MubGVuZ3RoID0gcGFkZGluZ0J5dGVzO1xuICAgIHRoaXMudXBkYXRlKHplcm9zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4LCBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zO1xuICAgIGJsb2Nrc1tpID4+IDJdIHw9IHRoaXMucGFkZGluZ1tpICYgM107XG4gICAgaWYgKHRoaXMubGFzdEJ5dGVJbmRleCA9PT0gdGhpcy5ieXRlQ291bnQpIHtcbiAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1tibG9ja0NvdW50XTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBibG9ja0NvdW50ICsgMTsgKytpKSB7XG4gICAgICAgIGJsb2Nrc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGJsb2Nrc1tibG9ja0NvdW50IC0gMV0gfD0gMHg4MDAwMDAwMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG4gICAgICBzW2ldIF49IGJsb2Nrc1tpXTtcbiAgICB9XG4gICAgZihzKTtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLnRvU3RyaW5nID0gS2VjY2FrLnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLFxuICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xuICAgIHZhciBoZXggPSAnJywgYmxvY2s7XG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7XG4gICAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayAmIDB4MEZdICtcbiAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiA4KSAmIDB4MEZdICtcbiAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXSArXG4gICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMjQpICYgMHgwRl07XG4gICAgICB9XG4gICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcbiAgICAgICAgZihzKTtcbiAgICAgICAgaSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBibG9jayA9IHNbaV07XG4gICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl07XG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDEpIHtcbiAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl07XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcbiAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLFxuICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xuICAgIHZhciBieXRlcyA9IHRoaXMub3V0cHV0Qml0cyA+PiAzO1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigob3V0cHV0QmxvY2tzICsgMSkgPDwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcyk7XG4gICAgfVxuICAgIHZhciBhcnJheSA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgICBhcnJheVtqXSA9IHNbaV07XG4gICAgICB9XG4gICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcbiAgICAgICAgZihzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcbiAgICAgIGFycmF5W2ldID0gc1tpXTtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBieXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5idWZmZXIgPSBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyO1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG4gICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGFycmF5ID0gW10sIG9mZnNldCwgYmxvY2s7XG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7XG4gICAgICAgIG9mZnNldCA9IGogPDwgMjtcbiAgICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAweEZGO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XG4gICAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XG4gICAgICAgIGFycmF5W29mZnNldCArIDNdID0gKGJsb2NrID4+IDI0KSAmIDB4RkY7XG4gICAgICB9XG4gICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcbiAgICAgICAgZihzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcbiAgICAgIG9mZnNldCA9IGogPDwgMjtcbiAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7XG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDEpIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAoYmxvY2sgPj4gOCkgJiAweEZGO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XG4gICAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfTtcblxuICBmdW5jdGlvbiBLbWFjKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcbiAgICBLZWNjYWsuY2FsbCh0aGlzLCBiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcbiAgfVxuXG4gIEttYWMucHJvdG90eXBlID0gbmV3IEtlY2NhaygpO1xuXG4gIEttYWMucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5jb2RlKHRoaXMub3V0cHV0Qml0cywgdHJ1ZSk7XG4gICAgcmV0dXJuIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICB2YXIgZiA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdmFyIGgsIGwsIG4sIGMwLCBjMSwgYzIsIGMzLCBjNCwgYzUsIGM2LCBjNywgYzgsIGM5LFxuICAgICAgYjAsIGIxLCBiMiwgYjMsIGI0LCBiNSwgYjYsIGI3LCBiOCwgYjksIGIxMCwgYjExLCBiMTIsIGIxMywgYjE0LCBiMTUsIGIxNiwgYjE3LFxuICAgICAgYjE4LCBiMTksIGIyMCwgYjIxLCBiMjIsIGIyMywgYjI0LCBiMjUsIGIyNiwgYjI3LCBiMjgsIGIyOSwgYjMwLCBiMzEsIGIzMiwgYjMzLFxuICAgICAgYjM0LCBiMzUsIGIzNiwgYjM3LCBiMzgsIGIzOSwgYjQwLCBiNDEsIGI0MiwgYjQzLCBiNDQsIGI0NSwgYjQ2LCBiNDcsIGI0OCwgYjQ5O1xuICAgIGZvciAobiA9IDA7IG4gPCA0ODsgbiArPSAyKSB7XG4gICAgICBjMCA9IHNbMF0gXiBzWzEwXSBeIHNbMjBdIF4gc1szMF0gXiBzWzQwXTtcbiAgICAgIGMxID0gc1sxXSBeIHNbMTFdIF4gc1syMV0gXiBzWzMxXSBeIHNbNDFdO1xuICAgICAgYzIgPSBzWzJdIF4gc1sxMl0gXiBzWzIyXSBeIHNbMzJdIF4gc1s0Ml07XG4gICAgICBjMyA9IHNbM10gXiBzWzEzXSBeIHNbMjNdIF4gc1szM10gXiBzWzQzXTtcbiAgICAgIGM0ID0gc1s0XSBeIHNbMTRdIF4gc1syNF0gXiBzWzM0XSBeIHNbNDRdO1xuICAgICAgYzUgPSBzWzVdIF4gc1sxNV0gXiBzWzI1XSBeIHNbMzVdIF4gc1s0NV07XG4gICAgICBjNiA9IHNbNl0gXiBzWzE2XSBeIHNbMjZdIF4gc1szNl0gXiBzWzQ2XTtcbiAgICAgIGM3ID0gc1s3XSBeIHNbMTddIF4gc1syN10gXiBzWzM3XSBeIHNbNDddO1xuICAgICAgYzggPSBzWzhdIF4gc1sxOF0gXiBzWzI4XSBeIHNbMzhdIF4gc1s0OF07XG4gICAgICBjOSA9IHNbOV0gXiBzWzE5XSBeIHNbMjldIF4gc1szOV0gXiBzWzQ5XTtcblxuICAgICAgaCA9IGM4IF4gKChjMiA8PCAxKSB8IChjMyA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjOSBeICgoYzMgPDwgMSkgfCAoYzIgPj4+IDMxKSk7XG4gICAgICBzWzBdIF49IGg7XG4gICAgICBzWzFdIF49IGw7XG4gICAgICBzWzEwXSBePSBoO1xuICAgICAgc1sxMV0gXj0gbDtcbiAgICAgIHNbMjBdIF49IGg7XG4gICAgICBzWzIxXSBePSBsO1xuICAgICAgc1szMF0gXj0gaDtcbiAgICAgIHNbMzFdIF49IGw7XG4gICAgICBzWzQwXSBePSBoO1xuICAgICAgc1s0MV0gXj0gbDtcbiAgICAgIGggPSBjMCBeICgoYzQgPDwgMSkgfCAoYzUgPj4+IDMxKSk7XG4gICAgICBsID0gYzEgXiAoKGM1IDw8IDEpIHwgKGM0ID4+PiAzMSkpO1xuICAgICAgc1syXSBePSBoO1xuICAgICAgc1szXSBePSBsO1xuICAgICAgc1sxMl0gXj0gaDtcbiAgICAgIHNbMTNdIF49IGw7XG4gICAgICBzWzIyXSBePSBoO1xuICAgICAgc1syM10gXj0gbDtcbiAgICAgIHNbMzJdIF49IGg7XG4gICAgICBzWzMzXSBePSBsO1xuICAgICAgc1s0Ml0gXj0gaDtcbiAgICAgIHNbNDNdIF49IGw7XG4gICAgICBoID0gYzIgXiAoKGM2IDw8IDEpIHwgKGM3ID4+PiAzMSkpO1xuICAgICAgbCA9IGMzIF4gKChjNyA8PCAxKSB8IChjNiA+Pj4gMzEpKTtcbiAgICAgIHNbNF0gXj0gaDtcbiAgICAgIHNbNV0gXj0gbDtcbiAgICAgIHNbMTRdIF49IGg7XG4gICAgICBzWzE1XSBePSBsO1xuICAgICAgc1syNF0gXj0gaDtcbiAgICAgIHNbMjVdIF49IGw7XG4gICAgICBzWzM0XSBePSBoO1xuICAgICAgc1szNV0gXj0gbDtcbiAgICAgIHNbNDRdIF49IGg7XG4gICAgICBzWzQ1XSBePSBsO1xuICAgICAgaCA9IGM0IF4gKChjOCA8PCAxKSB8IChjOSA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjNSBeICgoYzkgPDwgMSkgfCAoYzggPj4+IDMxKSk7XG4gICAgICBzWzZdIF49IGg7XG4gICAgICBzWzddIF49IGw7XG4gICAgICBzWzE2XSBePSBoO1xuICAgICAgc1sxN10gXj0gbDtcbiAgICAgIHNbMjZdIF49IGg7XG4gICAgICBzWzI3XSBePSBsO1xuICAgICAgc1szNl0gXj0gaDtcbiAgICAgIHNbMzddIF49IGw7XG4gICAgICBzWzQ2XSBePSBoO1xuICAgICAgc1s0N10gXj0gbDtcbiAgICAgIGggPSBjNiBeICgoYzAgPDwgMSkgfCAoYzEgPj4+IDMxKSk7XG4gICAgICBsID0gYzcgXiAoKGMxIDw8IDEpIHwgKGMwID4+PiAzMSkpO1xuICAgICAgc1s4XSBePSBoO1xuICAgICAgc1s5XSBePSBsO1xuICAgICAgc1sxOF0gXj0gaDtcbiAgICAgIHNbMTldIF49IGw7XG4gICAgICBzWzI4XSBePSBoO1xuICAgICAgc1syOV0gXj0gbDtcbiAgICAgIHNbMzhdIF49IGg7XG4gICAgICBzWzM5XSBePSBsO1xuICAgICAgc1s0OF0gXj0gaDtcbiAgICAgIHNbNDldIF49IGw7XG5cbiAgICAgIGIwID0gc1swXTtcbiAgICAgIGIxID0gc1sxXTtcbiAgICAgIGIzMiA9IChzWzExXSA8PCA0KSB8IChzWzEwXSA+Pj4gMjgpO1xuICAgICAgYjMzID0gKHNbMTBdIDw8IDQpIHwgKHNbMTFdID4+PiAyOCk7XG4gICAgICBiMTQgPSAoc1syMF0gPDwgMykgfCAoc1syMV0gPj4+IDI5KTtcbiAgICAgIGIxNSA9IChzWzIxXSA8PCAzKSB8IChzWzIwXSA+Pj4gMjkpO1xuICAgICAgYjQ2ID0gKHNbMzFdIDw8IDkpIHwgKHNbMzBdID4+PiAyMyk7XG4gICAgICBiNDcgPSAoc1szMF0gPDwgOSkgfCAoc1szMV0gPj4+IDIzKTtcbiAgICAgIGIyOCA9IChzWzQwXSA8PCAxOCkgfCAoc1s0MV0gPj4+IDE0KTtcbiAgICAgIGIyOSA9IChzWzQxXSA8PCAxOCkgfCAoc1s0MF0gPj4+IDE0KTtcbiAgICAgIGIyMCA9IChzWzJdIDw8IDEpIHwgKHNbM10gPj4+IDMxKTtcbiAgICAgIGIyMSA9IChzWzNdIDw8IDEpIHwgKHNbMl0gPj4+IDMxKTtcbiAgICAgIGIyID0gKHNbMTNdIDw8IDEyKSB8IChzWzEyXSA+Pj4gMjApO1xuICAgICAgYjMgPSAoc1sxMl0gPDwgMTIpIHwgKHNbMTNdID4+PiAyMCk7XG4gICAgICBiMzQgPSAoc1syMl0gPDwgMTApIHwgKHNbMjNdID4+PiAyMik7XG4gICAgICBiMzUgPSAoc1syM10gPDwgMTApIHwgKHNbMjJdID4+PiAyMik7XG4gICAgICBiMTYgPSAoc1szM10gPDwgMTMpIHwgKHNbMzJdID4+PiAxOSk7XG4gICAgICBiMTcgPSAoc1szMl0gPDwgMTMpIHwgKHNbMzNdID4+PiAxOSk7XG4gICAgICBiNDggPSAoc1s0Ml0gPDwgMikgfCAoc1s0M10gPj4+IDMwKTtcbiAgICAgIGI0OSA9IChzWzQzXSA8PCAyKSB8IChzWzQyXSA+Pj4gMzApO1xuICAgICAgYjQwID0gKHNbNV0gPDwgMzApIHwgKHNbNF0gPj4+IDIpO1xuICAgICAgYjQxID0gKHNbNF0gPDwgMzApIHwgKHNbNV0gPj4+IDIpO1xuICAgICAgYjIyID0gKHNbMTRdIDw8IDYpIHwgKHNbMTVdID4+PiAyNik7XG4gICAgICBiMjMgPSAoc1sxNV0gPDwgNikgfCAoc1sxNF0gPj4+IDI2KTtcbiAgICAgIGI0ID0gKHNbMjVdIDw8IDExKSB8IChzWzI0XSA+Pj4gMjEpO1xuICAgICAgYjUgPSAoc1syNF0gPDwgMTEpIHwgKHNbMjVdID4+PiAyMSk7XG4gICAgICBiMzYgPSAoc1szNF0gPDwgMTUpIHwgKHNbMzVdID4+PiAxNyk7XG4gICAgICBiMzcgPSAoc1szNV0gPDwgMTUpIHwgKHNbMzRdID4+PiAxNyk7XG4gICAgICBiMTggPSAoc1s0NV0gPDwgMjkpIHwgKHNbNDRdID4+PiAzKTtcbiAgICAgIGIxOSA9IChzWzQ0XSA8PCAyOSkgfCAoc1s0NV0gPj4+IDMpO1xuICAgICAgYjEwID0gKHNbNl0gPDwgMjgpIHwgKHNbN10gPj4+IDQpO1xuICAgICAgYjExID0gKHNbN10gPDwgMjgpIHwgKHNbNl0gPj4+IDQpO1xuICAgICAgYjQyID0gKHNbMTddIDw8IDIzKSB8IChzWzE2XSA+Pj4gOSk7XG4gICAgICBiNDMgPSAoc1sxNl0gPDwgMjMpIHwgKHNbMTddID4+PiA5KTtcbiAgICAgIGIyNCA9IChzWzI2XSA8PCAyNSkgfCAoc1syN10gPj4+IDcpO1xuICAgICAgYjI1ID0gKHNbMjddIDw8IDI1KSB8IChzWzI2XSA+Pj4gNyk7XG4gICAgICBiNiA9IChzWzM2XSA8PCAyMSkgfCAoc1szN10gPj4+IDExKTtcbiAgICAgIGI3ID0gKHNbMzddIDw8IDIxKSB8IChzWzM2XSA+Pj4gMTEpO1xuICAgICAgYjM4ID0gKHNbNDddIDw8IDI0KSB8IChzWzQ2XSA+Pj4gOCk7XG4gICAgICBiMzkgPSAoc1s0Nl0gPDwgMjQpIHwgKHNbNDddID4+PiA4KTtcbiAgICAgIGIzMCA9IChzWzhdIDw8IDI3KSB8IChzWzldID4+PiA1KTtcbiAgICAgIGIzMSA9IChzWzldIDw8IDI3KSB8IChzWzhdID4+PiA1KTtcbiAgICAgIGIxMiA9IChzWzE4XSA8PCAyMCkgfCAoc1sxOV0gPj4+IDEyKTtcbiAgICAgIGIxMyA9IChzWzE5XSA8PCAyMCkgfCAoc1sxOF0gPj4+IDEyKTtcbiAgICAgIGI0NCA9IChzWzI5XSA8PCA3KSB8IChzWzI4XSA+Pj4gMjUpO1xuICAgICAgYjQ1ID0gKHNbMjhdIDw8IDcpIHwgKHNbMjldID4+PiAyNSk7XG4gICAgICBiMjYgPSAoc1szOF0gPDwgOCkgfCAoc1szOV0gPj4+IDI0KTtcbiAgICAgIGIyNyA9IChzWzM5XSA8PCA4KSB8IChzWzM4XSA+Pj4gMjQpO1xuICAgICAgYjggPSAoc1s0OF0gPDwgMTQpIHwgKHNbNDldID4+PiAxOCk7XG4gICAgICBiOSA9IChzWzQ5XSA8PCAxNCkgfCAoc1s0OF0gPj4+IDE4KTtcblxuICAgICAgc1swXSA9IGIwIF4gKH5iMiAmIGI0KTtcbiAgICAgIHNbMV0gPSBiMSBeICh+YjMgJiBiNSk7XG4gICAgICBzWzEwXSA9IGIxMCBeICh+YjEyICYgYjE0KTtcbiAgICAgIHNbMTFdID0gYjExIF4gKH5iMTMgJiBiMTUpO1xuICAgICAgc1syMF0gPSBiMjAgXiAofmIyMiAmIGIyNCk7XG4gICAgICBzWzIxXSA9IGIyMSBeICh+YjIzICYgYjI1KTtcbiAgICAgIHNbMzBdID0gYjMwIF4gKH5iMzIgJiBiMzQpO1xuICAgICAgc1szMV0gPSBiMzEgXiAofmIzMyAmIGIzNSk7XG4gICAgICBzWzQwXSA9IGI0MCBeICh+YjQyICYgYjQ0KTtcbiAgICAgIHNbNDFdID0gYjQxIF4gKH5iNDMgJiBiNDUpO1xuICAgICAgc1syXSA9IGIyIF4gKH5iNCAmIGI2KTtcbiAgICAgIHNbM10gPSBiMyBeICh+YjUgJiBiNyk7XG4gICAgICBzWzEyXSA9IGIxMiBeICh+YjE0ICYgYjE2KTtcbiAgICAgIHNbMTNdID0gYjEzIF4gKH5iMTUgJiBiMTcpO1xuICAgICAgc1syMl0gPSBiMjIgXiAofmIyNCAmIGIyNik7XG4gICAgICBzWzIzXSA9IGIyMyBeICh+YjI1ICYgYjI3KTtcbiAgICAgIHNbMzJdID0gYjMyIF4gKH5iMzQgJiBiMzYpO1xuICAgICAgc1szM10gPSBiMzMgXiAofmIzNSAmIGIzNyk7XG4gICAgICBzWzQyXSA9IGI0MiBeICh+YjQ0ICYgYjQ2KTtcbiAgICAgIHNbNDNdID0gYjQzIF4gKH5iNDUgJiBiNDcpO1xuICAgICAgc1s0XSA9IGI0IF4gKH5iNiAmIGI4KTtcbiAgICAgIHNbNV0gPSBiNSBeICh+YjcgJiBiOSk7XG4gICAgICBzWzE0XSA9IGIxNCBeICh+YjE2ICYgYjE4KTtcbiAgICAgIHNbMTVdID0gYjE1IF4gKH5iMTcgJiBiMTkpO1xuICAgICAgc1syNF0gPSBiMjQgXiAofmIyNiAmIGIyOCk7XG4gICAgICBzWzI1XSA9IGIyNSBeICh+YjI3ICYgYjI5KTtcbiAgICAgIHNbMzRdID0gYjM0IF4gKH5iMzYgJiBiMzgpO1xuICAgICAgc1szNV0gPSBiMzUgXiAofmIzNyAmIGIzOSk7XG4gICAgICBzWzQ0XSA9IGI0NCBeICh+YjQ2ICYgYjQ4KTtcbiAgICAgIHNbNDVdID0gYjQ1IF4gKH5iNDcgJiBiNDkpO1xuICAgICAgc1s2XSA9IGI2IF4gKH5iOCAmIGIwKTtcbiAgICAgIHNbN10gPSBiNyBeICh+YjkgJiBiMSk7XG4gICAgICBzWzE2XSA9IGIxNiBeICh+YjE4ICYgYjEwKTtcbiAgICAgIHNbMTddID0gYjE3IF4gKH5iMTkgJiBiMTEpO1xuICAgICAgc1syNl0gPSBiMjYgXiAofmIyOCAmIGIyMCk7XG4gICAgICBzWzI3XSA9IGIyNyBeICh+YjI5ICYgYjIxKTtcbiAgICAgIHNbMzZdID0gYjM2IF4gKH5iMzggJiBiMzApO1xuICAgICAgc1szN10gPSBiMzcgXiAofmIzOSAmIGIzMSk7XG4gICAgICBzWzQ2XSA9IGI0NiBeICh+YjQ4ICYgYjQwKTtcbiAgICAgIHNbNDddID0gYjQ3IF4gKH5iNDkgJiBiNDEpO1xuICAgICAgc1s4XSA9IGI4IF4gKH5iMCAmIGIyKTtcbiAgICAgIHNbOV0gPSBiOSBeICh+YjEgJiBiMyk7XG4gICAgICBzWzE4XSA9IGIxOCBeICh+YjEwICYgYjEyKTtcbiAgICAgIHNbMTldID0gYjE5IF4gKH5iMTEgJiBiMTMpO1xuICAgICAgc1syOF0gPSBiMjggXiAofmIyMCAmIGIyMik7XG4gICAgICBzWzI5XSA9IGIyOSBeICh+YjIxICYgYjIzKTtcbiAgICAgIHNbMzhdID0gYjM4IF4gKH5iMzAgJiBiMzIpO1xuICAgICAgc1szOV0gPSBiMzkgXiAofmIzMSAmIGIzMyk7XG4gICAgICBzWzQ4XSA9IGI0OCBeICh+YjQwICYgYjQyKTtcbiAgICAgIHNbNDldID0gYjQ5IF4gKH5iNDEgJiBiNDMpO1xuXG4gICAgICBzWzBdIF49IFJDW25dO1xuICAgICAgc1sxXSBePSBSQ1tuICsgMV07XG4gICAgfVxuICB9O1xuXG4gIGlmIChDT01NT05fSlMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ldGhvZHM7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICByb290W21ldGhvZE5hbWVzW2ldXSA9IG1ldGhvZHNbbWV0aG9kTmFtZXNbaV1dO1xuICAgIH1cbiAgICBpZiAoQU1EKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWV0aG9kcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBrZWNjYWsyNTYgPSByZXF1aXJlKCdqcy1zaGEzJykua2VjY2FrMjU2O1xuXG5mdW5jdGlvbiBsaWJyYXJ5SGFzaFBsYWNlaG9sZGVyIChpbnB1dCkge1xuICByZXR1cm4gJyQnICsga2VjY2FrMjU2KGlucHV0KS5zbGljZSgwLCAzNCkgKyAnJCc7XG59XG5cbnZhciBsaW5rQnl0ZWNvZGUgPSBmdW5jdGlvbiAoYnl0ZWNvZGUsIGxpYnJhcmllcykge1xuICBhc3NlcnQodHlwZW9mIGJ5dGVjb2RlID09PSAnc3RyaW5nJyk7XG4gIGFzc2VydCh0eXBlb2YgbGlicmFyaWVzID09PSAnb2JqZWN0Jyk7XG4gIC8vIE5PVEU6IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBzdXBwb3J0IG9sZCBjb21waWxlciB3aGljaCBkaWRuJ3QgdXNlIGZpbGUgbmFtZXNcbiAgdmFyIGxpYnJhcmllc0NvbXBsZXRlID0ge307XG4gIGZvciAodmFyIGxpYnJhcnlOYW1lIGluIGxpYnJhcmllcykge1xuICAgIGlmICh0eXBlb2YgbGlicmFyaWVzW2xpYnJhcnlOYW1lXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIEFQSSBjb21wYXRpYmxlIHdpdGggdGhlIHN0YW5kYXJkIEpTT04gaS9vXG4gICAgICBmb3IgKHZhciBsaWIgaW4gbGlicmFyaWVzW2xpYnJhcnlOYW1lXSkge1xuICAgICAgICBsaWJyYXJpZXNDb21wbGV0ZVtsaWJdID0gbGlicmFyaWVzW2xpYnJhcnlOYW1lXVtsaWJdO1xuICAgICAgICBsaWJyYXJpZXNDb21wbGV0ZVtsaWJyYXJ5TmFtZSArICc6JyArIGxpYl0gPSBsaWJyYXJpZXNbbGlicmFyeU5hbWVdW2xpYl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIEFQSSBmb3IgZWFybHkgc29sYy1qcyB2ZXJzaW9uc1xuICAgICAgdmFyIHBhcnNlZCA9IGxpYnJhcnlOYW1lLm1hdGNoKC9eKFteOl0rKTooLispJC8pO1xuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBsaWJyYXJpZXNDb21wbGV0ZVtwYXJzZWRbMl1dID0gbGlicmFyaWVzW2xpYnJhcnlOYW1lXTtcbiAgICAgIH1cbiAgICAgIGxpYnJhcmllc0NvbXBsZXRlW2xpYnJhcnlOYW1lXSA9IGxpYnJhcmllc1tsaWJyYXJ5TmFtZV07XG4gICAgfVxuICB9XG5cbiAgZm9yIChsaWJyYXJ5TmFtZSBpbiBsaWJyYXJpZXNDb21wbGV0ZSkge1xuICAgIHZhciBoZXhBZGRyZXNzID0gbGlicmFyaWVzQ29tcGxldGVbbGlicmFyeU5hbWVdO1xuICAgIGlmIChoZXhBZGRyZXNzLnNsaWNlKDAsIDIpICE9PSAnMHgnIHx8IGhleEFkZHJlc3MubGVuZ3RoID4gNDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzIHNwZWNpZmllZCBmb3IgJyArIGxpYnJhcnlOYW1lKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIDB4IHByZWZpeFxuICAgIGhleEFkZHJlc3MgPSBoZXhBZGRyZXNzLnNsaWNlKDIpO1xuICAgIGhleEFkZHJlc3MgPSBBcnJheSg0MCAtIGhleEFkZHJlc3MubGVuZ3RoICsgMSkuam9pbignMCcpICsgaGV4QWRkcmVzcztcblxuICAgIC8vIFN1cHBvcnQgb2xkIChsaWJyYXJ5IG5hbWUpIGFuZCBuZXcgKGhhc2ggb2YgbGlicmFyeSBuYW1lKVxuICAgIC8vIHBsYWNlaG9sZGVycy5cbiAgICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAvLyB0cnVuY2F0ZSB0byAzNyBjaGFyYWN0ZXJzXG4gICAgICB2YXIgdHJ1bmNhdGVkTmFtZSA9IG5hbWUuc2xpY2UoMCwgMzYpO1xuICAgICAgdmFyIGxpYkxhYmVsID0gJ19fJyArIHRydW5jYXRlZE5hbWUgKyBBcnJheSgzNyAtIHRydW5jYXRlZE5hbWUubGVuZ3RoKS5qb2luKCdfJykgKyAnX18nO1xuICAgICAgd2hpbGUgKGJ5dGVjb2RlLmluZGV4T2YobGliTGFiZWwpID49IDApIHtcbiAgICAgICAgYnl0ZWNvZGUgPSBieXRlY29kZS5yZXBsYWNlKGxpYkxhYmVsLCBoZXhBZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVwbGFjZShsaWJyYXJ5TmFtZSk7XG4gICAgcmVwbGFjZShsaWJyYXJ5SGFzaFBsYWNlaG9sZGVyKGxpYnJhcnlOYW1lKSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZWNvZGU7XG59O1xuXG52YXIgZmluZExpbmtSZWZlcmVuY2VzID0gZnVuY3Rpb24gKGJ5dGVjb2RlKSB7XG4gIGFzc2VydCh0eXBlb2YgYnl0ZWNvZGUgPT09ICdzdHJpbmcnKTtcbiAgLy8gZmluZCA0MCBieXRlcyBpbiB0aGUgcGF0dGVybiBvZiBfXy4uLjwzNiBkaWdpdHM+Li4uX19cbiAgLy8gZS5nLiBfX0xpYi5zb2w6TF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fXG4gIHZhciBsaW5rUmVmZXJlbmNlcyA9IHt9O1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgZm91bmQgPSBieXRlY29kZS5tYXRjaCgvX18oLnszNn0pX18vKTtcbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBmb3VuZC5pbmRleDtcbiAgICAvLyB0cmltIHRyYWlsaW5nIHVuZGVyc2NvcmVzXG4gICAgLy8gTk9URTogdGhpcyBoYXMgbm8gd2F5IG9mIGtub3dpbmcgaWYgdGhlIHRyYWlsaW5nIHVuZGVyc2NvcmUgd2FzIHBhcnQgb2YgdGhlIG5hbWVcbiAgICB2YXIgbGlicmFyeU5hbWUgPSBmb3VuZFsxXS5yZXBsYWNlKC9fKyQvZ20sICcnKTtcblxuICAgIGlmICghbGlua1JlZmVyZW5jZXNbbGlicmFyeU5hbWVdKSB7XG4gICAgICBsaW5rUmVmZXJlbmNlc1tsaWJyYXJ5TmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBsaW5rUmVmZXJlbmNlc1tsaWJyYXJ5TmFtZV0ucHVzaCh7XG4gICAgICAvLyBvZmZzZXRzIGFyZSBpbiBieXRlcyBpbiBiaW5hcnkgcmVwcmVzZW50YXRpb24gKGFuZCBub3QgaGV4KVxuICAgICAgc3RhcnQ6IChvZmZzZXQgKyBzdGFydCkgLyAyLFxuICAgICAgbGVuZ3RoOiAyMFxuICAgIH0pO1xuXG4gICAgb2Zmc2V0ICs9IHN0YXJ0ICsgMjA7XG5cbiAgICBieXRlY29kZSA9IGJ5dGVjb2RlLnNsaWNlKHN0YXJ0ICsgMjApO1xuICB9XG4gIHJldHVybiBsaW5rUmVmZXJlbmNlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsaW5rQnl0ZWNvZGU6IGxpbmtCeXRlY29kZSxcbiAgZmluZExpbmtSZWZlcmVuY2VzOiBmaW5kTGlua1JlZmVyZW5jZXNcbn07XG4iLCJ2YXIgbGlua2VyID0gcmVxdWlyZSgnLi9saW5rZXIuanMnKTtcblxuLy8vIFRyYW5zbGF0ZSBvbGQgc3R5bGUgdmVyc2lvbiBudW1iZXJzIHRvIHNlbXZlci5cbi8vLyBPbGQgc3R5bGU6IDAuMy42LTNmYzY4ZGE1L1JlbGVhc2UtRW1zY3JpcHRlbi9jbGFuZ1xuLy8vICAgICAgICAgICAgMC4zLjUtMzcxNjkwZjAvUmVsZWFzZS1FbXNjcmlwdGVuL2NsYW5nL0ludGVycHJldGVyXG4vLy8gICAgICAgICAgICAwLjMuNS0wL1JlbGVhc2UtRW1zY3JpcHRlbi9jbGFuZy9JbnRlcnByZXRlclxuLy8vICAgICAgICAgICAgMC4yLjAtZTcwOTg5NTgvLi1FbXNjcmlwdGVuL2NsYW5nL2ludCBsaW5rZWQgdG8gbGliZXRoZXJldW0tMS4xLjEtYmJiODBhYjAvLi1FbXNjcmlwdGVuL2NsYW5nL2ludFxuLy8vICAgICAgICAgICAgMC4xLjMtMC8uLS9jbGFuZy9pbnQgbGlua2VkIHRvIGxpYmV0aGVyZXVtLTAuOS45Mi0wLy4tL2NsYW5nL2ludFxuLy8vICAgICAgICAgICAgMC4xLjItNWMzYmZkNGIqLy4tL2NsYW5nL2ludFxuLy8vICAgICAgICAgICAgMC4xLjEtNmZmNGNkNmIvUmVsV2l0aERlYkluZm8tRW1zY3JpcHRlbi9jbGFuZy9pbnRcbi8vLyBOZXcgc3R5bGU6IDAuNC41K2NvbW1pdC5iMzE4MzY2ZS5FbXNjcmlwdGVuLmNsYW5nXG5mdW5jdGlvbiB2ZXJzaW9uVG9TZW12ZXIgKHZlcnNpb24pIHtcbiAgLy8gRklYTUU6IHBhcnNlIG1vcmUgZGV0YWlsLCBidXQgdGhpcyBpcyBhIGdvb2Qgc3RhcnRcbiAgdmFyIHBhcnNlZCA9IHZlcnNpb24ubWF0Y2goL14oWzAtOV0rXFwuWzAtOV0rXFwuWzAtOV0rKS0oWzAtOWEtZl17OH0pWy8qXS4qJC8pO1xuICBpZiAocGFyc2VkKSB7XG4gICAgcmV0dXJuIHBhcnNlZFsxXSArICcrY29tbWl0LicgKyBwYXJzZWRbMl07XG4gIH1cbiAgaWYgKHZlcnNpb24uaW5kZXhPZignMC4xLjMtMCcpICE9PSAtMSkge1xuICAgIHJldHVybiAnMC4xLjMnO1xuICB9XG4gIGlmICh2ZXJzaW9uLmluZGV4T2YoJzAuMy41LTAnKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gJzAuMy41JztcbiAgfVxuICAvLyBhc3N1bWUgaXQgaXMgYWxyZWFkeSBzZW12ZXIgY29tcGF0aWJsZVxuICByZXR1cm4gdmVyc2lvbjtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlRXJyb3JzIChyZXQsIGVycm9ycykge1xuICBmb3IgKHZhciBlcnJvciBpbiBlcnJvcnMpIHtcbiAgICB2YXIgdHlwZSA9ICdlcnJvcic7XG4gICAgdmFyIGV4dHJhY3RUeXBlID0gL14oLiopOihcXGQrKTooXFxkKyk6KC4qKTovO1xuICAgIGV4dHJhY3RUeXBlID0gZXh0cmFjdFR5cGUuZXhlYyhlcnJvcnNbZXJyb3JdKTtcbiAgICBpZiAoZXh0cmFjdFR5cGUpIHtcbiAgICAgIHR5cGUgPSBleHRyYWN0VHlwZVs0XS50cmltKCk7XG4gICAgfSBlbHNlIGlmIChlcnJvcnNbZXJyb3JdLmluZGV4T2YoJzogV2FybmluZzonKSkge1xuICAgICAgdHlwZSA9ICdXYXJuaW5nJztcbiAgICB9IGVsc2UgaWYgKGVycm9yc1tlcnJvcl0uaW5kZXhPZignOiBFcnJvcjonKSkge1xuICAgICAgdHlwZSA9ICdFcnJvcic7XG4gICAgfVxuICAgIHJldC5wdXNoKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBjb21wb25lbnQ6ICdnZW5lcmFsJyxcbiAgICAgIHNldmVyaXR5OiAodHlwZSA9PT0gJ1dhcm5pbmcnKSA/ICd3YXJuaW5nJyA6ICdlcnJvcicsXG4gICAgICBtZXNzYWdlOiBlcnJvcnNbZXJyb3JdLFxuICAgICAgZm9ybWF0dGVkTWVzc2FnZTogZXJyb3JzW2Vycm9yXVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUdhc0VzdGltYXRlcyAoZ2FzRXN0aW1hdGVzKSB7XG4gIGlmIChnYXNFc3RpbWF0ZXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ2luZmluaXRlJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2FzRXN0aW1hdGVzID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBnYXNFc3RpbWF0ZXMudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHZhciBnYXNFc3RpbWF0ZXNUcmFuc2xhdGVkID0ge307XG4gIGZvciAodmFyIGZ1bmMgaW4gZ2FzRXN0aW1hdGVzKSB7XG4gICAgZ2FzRXN0aW1hdGVzVHJhbnNsYXRlZFtmdW5jXSA9IHRyYW5zbGF0ZUdhc0VzdGltYXRlcyhnYXNFc3RpbWF0ZXNbZnVuY10pO1xuICB9XG4gIHJldHVybiBnYXNFc3RpbWF0ZXNUcmFuc2xhdGVkO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVKc29uQ29tcGlsZXJPdXRwdXQgKG91dHB1dCwgbGlicmFyaWVzKSB7XG4gIHZhciByZXQgPSB7fTtcblxuICByZXRbJ2Vycm9ycyddID0gW107XG4gIHZhciBlcnJvcnM7XG4gIGlmIChvdXRwdXRbJ2Vycm9yJ10pIHtcbiAgICBlcnJvcnMgPSBbIG91dHB1dFsnZXJyb3InXSBdO1xuICB9IGVsc2Uge1xuICAgIGVycm9ycyA9IG91dHB1dFsnZXJyb3JzJ107XG4gIH1cbiAgdHJhbnNsYXRlRXJyb3JzKHJldFsnZXJyb3JzJ10sIGVycm9ycyk7XG5cbiAgcmV0Wydjb250cmFjdHMnXSA9IHt9O1xuICBmb3IgKHZhciBjb250cmFjdCBpbiBvdXRwdXRbJ2NvbnRyYWN0cyddKSB7XG4gICAgLy8gU3BsaXQgbmFtZSBmaXJzdCwgY2FuIGJlIGBjb250cmFjdGAsIGA6Y29udHJhY3RgIG9yIGBmaWxlbmFtZTpjb250cmFjdGBcbiAgICB2YXIgdG1wID0gY29udHJhY3QubWF0Y2goL14oKFteOl0qKTopPyhbXjpdKykkLyk7XG4gICAgaWYgKHRtcC5sZW5ndGggIT09IDQpIHtcbiAgICAgIC8vIEZvcmNlIGFib3J0XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGZpbGVOYW1lID0gdG1wWzJdO1xuICAgIGlmIChmaWxlTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0aGlzIGlzIHRoZSBjYXNlIG9mIGBjb250cmFjdGBcbiAgICAgIGZpbGVOYW1lID0gJyc7XG4gICAgfVxuICAgIHZhciBjb250cmFjdE5hbWUgPSB0bXBbM107XG5cbiAgICB2YXIgY29udHJhY3RJbnB1dCA9IG91dHB1dFsnY29udHJhY3RzJ11bY29udHJhY3RdO1xuXG4gICAgdmFyIGdhc0VzdGltYXRlcyA9IGNvbnRyYWN0SW5wdXRbJ2dhc0VzdGltYXRlcyddO1xuICAgIHZhciB0cmFuc2xhdGVkR2FzRXN0aW1hdGVzID0ge307XG5cbiAgICBpZiAoZ2FzRXN0aW1hdGVzWydjcmVhdGlvbiddKSB7XG4gICAgICB0cmFuc2xhdGVkR2FzRXN0aW1hdGVzWydjcmVhdGlvbiddID0ge1xuICAgICAgICAnY29kZURlcG9zaXRDb3N0JzogdHJhbnNsYXRlR2FzRXN0aW1hdGVzKGdhc0VzdGltYXRlc1snY3JlYXRpb24nXVsxXSksXG4gICAgICAgICdleGVjdXRpb25Db3N0JzogdHJhbnNsYXRlR2FzRXN0aW1hdGVzKGdhc0VzdGltYXRlc1snY3JlYXRpb24nXVswXSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChnYXNFc3RpbWF0ZXNbJ2ludGVybmFsJ10pIHtcbiAgICAgIHRyYW5zbGF0ZWRHYXNFc3RpbWF0ZXNbJ2ludGVybmFsJ10gPSB0cmFuc2xhdGVHYXNFc3RpbWF0ZXMoZ2FzRXN0aW1hdGVzWydpbnRlcm5hbCddKTtcbiAgICB9XG4gICAgaWYgKGdhc0VzdGltYXRlc1snZXh0ZXJuYWwnXSkge1xuICAgICAgdHJhbnNsYXRlZEdhc0VzdGltYXRlc1snZXh0ZXJuYWwnXSA9IHRyYW5zbGF0ZUdhc0VzdGltYXRlcyhnYXNFc3RpbWF0ZXNbJ2V4dGVybmFsJ10pO1xuICAgIH1cblxuICAgIHZhciBjb250cmFjdE91dHB1dCA9IHtcbiAgICAgICdhYmknOiBKU09OLnBhcnNlKGNvbnRyYWN0SW5wdXRbJ2ludGVyZmFjZSddKSxcbiAgICAgICdtZXRhZGF0YSc6IGNvbnRyYWN0SW5wdXRbJ21ldGFkYXRhJ10sXG4gICAgICAnZXZtJzoge1xuICAgICAgICAnbGVnYWN5QXNzZW1ibHknOiBjb250cmFjdElucHV0Wydhc3NlbWJseSddLFxuICAgICAgICAnYnl0ZWNvZGUnOiB7XG4gICAgICAgICAgJ29iamVjdCc6IGNvbnRyYWN0SW5wdXRbJ2J5dGVjb2RlJ10gJiYgbGlua2VyLmxpbmtCeXRlY29kZShjb250cmFjdElucHV0WydieXRlY29kZSddLCBsaWJyYXJpZXMgfHwge30pLFxuICAgICAgICAgICdvcGNvZGVzJzogY29udHJhY3RJbnB1dFsnb3Bjb2RlcyddLFxuICAgICAgICAgICdzb3VyY2VNYXAnOiBjb250cmFjdElucHV0WydzcmNtYXAnXSxcbiAgICAgICAgICAnbGlua1JlZmVyZW5jZXMnOiBjb250cmFjdElucHV0WydieXRlY29kZSddICYmIGxpbmtlci5maW5kTGlua1JlZmVyZW5jZXMoY29udHJhY3RJbnB1dFsnYnl0ZWNvZGUnXSlcbiAgICAgICAgfSxcbiAgICAgICAgJ2RlcGxveWVkQnl0ZWNvZGUnOiB7XG4gICAgICAgICAgJ29iamVjdCc6IGNvbnRyYWN0SW5wdXRbJ3J1bnRpbWVCeXRlY29kZSddICYmIGxpbmtlci5saW5rQnl0ZWNvZGUoY29udHJhY3RJbnB1dFsncnVudGltZUJ5dGVjb2RlJ10sIGxpYnJhcmllcyB8fCB7fSksXG4gICAgICAgICAgJ3NvdXJjZU1hcCc6IGNvbnRyYWN0SW5wdXRbJ3NyY21hcFJ1bnRpbWUnXSxcbiAgICAgICAgICAnbGlua1JlZmVyZW5jZXMnOiBjb250cmFjdElucHV0WydydW50aW1lQnl0ZWNvZGUnXSAmJiBsaW5rZXIuZmluZExpbmtSZWZlcmVuY2VzKGNvbnRyYWN0SW5wdXRbJ3J1bnRpbWVCeXRlY29kZSddKVxuICAgICAgICB9LFxuICAgICAgICAnbWV0aG9kSWRlbnRpZmllcnMnOiBjb250cmFjdElucHV0WydmdW5jdGlvbkhhc2hlcyddLFxuICAgICAgICAnZ2FzRXN0aW1hdGVzJzogdHJhbnNsYXRlZEdhc0VzdGltYXRlc1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIXJldFsnY29udHJhY3RzJ11bZmlsZU5hbWVdKSB7XG4gICAgICByZXRbJ2NvbnRyYWN0cyddW2ZpbGVOYW1lXSA9IHt9O1xuICAgIH1cblxuICAgIHJldFsnY29udHJhY3RzJ11bZmlsZU5hbWVdW2NvbnRyYWN0TmFtZV0gPSBjb250cmFjdE91dHB1dDtcbiAgfVxuXG4gIHZhciBzb3VyY2VNYXAgPSB7fTtcbiAgZm9yICh2YXIgc291cmNlSWQgaW4gb3V0cHV0Wydzb3VyY2VMaXN0J10pIHtcbiAgICBzb3VyY2VNYXBbb3V0cHV0Wydzb3VyY2VMaXN0J11bc291cmNlSWRdXSA9IHNvdXJjZUlkO1xuICB9XG5cbiAgcmV0Wydzb3VyY2VzJ10gPSB7fTtcbiAgZm9yICh2YXIgc291cmNlIGluIG91dHB1dFsnc291cmNlcyddKSB7XG4gICAgcmV0Wydzb3VyY2VzJ11bc291cmNlXSA9IHtcbiAgICAgIGlkOiBzb3VyY2VNYXBbc291cmNlXSxcbiAgICAgIGxlZ2FjeUFTVDogb3V0cHV0Wydzb3VyY2VzJ11bc291cmNlXS5BU1RcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJylcbiAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpO1xufVxuXG4vLyAnYXNtJyBjYW4gYmUgYW4gb2JqZWN0IG9yIGEgc3RyaW5nXG5mdW5jdGlvbiBmb3JtYXRBc3NlbWJseVRleHQgKGFzbSwgcHJlZml4LCBzb3VyY2UpIHtcbiAgaWYgKHR5cGVvZiBhc20gPT09ICdzdHJpbmcnIHx8IGFzbSA9PT0gbnVsbCB8fCBhc20gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcmVmaXggKyAoYXNtIHx8ICcnKSArICdcXG4nO1xuICB9XG4gIHZhciB0ZXh0ID0gcHJlZml4ICsgJy5jb2RlXFxuJztcbiAgYXNtWycuY29kZSddLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICB2YXIgdiA9IGl0ZW0udmFsdWUgPT09IHVuZGVmaW5lZCA/ICcnIDogaXRlbS52YWx1ZTtcbiAgICB2YXIgc3JjID0gJyc7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIGl0ZW0uYmVnaW4gIT09IHVuZGVmaW5lZCAmJiBpdGVtLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzcmMgPSBlc2NhcGVTdHJpbmcoc291cmNlLnNsaWNlKGl0ZW0uYmVnaW4sIGl0ZW0uZW5kKSk7XG4gICAgfVxuICAgIGlmIChzcmMubGVuZ3RoID4gMzApIHtcbiAgICAgIHNyYyA9IHNyYy5zbGljZSgwLCAzMCkgKyAnLi4uJztcbiAgICB9XG4gICAgaWYgKGl0ZW0ubmFtZSAhPT0gJ3RhZycpIHtcbiAgICAgIHRleHQgKz0gJyAgJztcbiAgICB9XG4gICAgdGV4dCArPSBwcmVmaXggKyBpdGVtLm5hbWUgKyAnICcgKyB2ICsgJ1xcdFxcdFxcdCcgKyBzcmMgKyAnXFxuJztcbiAgfSk7XG4gIHRleHQgKz0gcHJlZml4ICsgJy5kYXRhXFxuJztcbiAgdmFyIGFzbURhdGEgPSBhc21bJy5kYXRhJ10gfHwgW107XG4gIGZvciAodmFyIGkgaW4gYXNtRGF0YSkge1xuICAgIHZhciBpdGVtID0gYXNtRGF0YVtpXTtcbiAgICB0ZXh0ICs9ICcgICcgKyBwcmVmaXggKyAnJyArIGkgKyAnOlxcbic7XG4gICAgdGV4dCArPSBmb3JtYXRBc3NlbWJseVRleHQoaXRlbSwgcHJlZml4ICsgJyAgICAnLCBzb3VyY2UpO1xuICB9XG4gIHJldHVybiB0ZXh0O1xufVxuXG5mdW5jdGlvbiBwcmV0dHlQcmludExlZ2FjeUFzc2VtYmx5SlNPTiAoYXNzZW1ibHksIHNvdXJjZSkge1xuICByZXR1cm4gZm9ybWF0QXNzZW1ibHlUZXh0KGFzc2VtYmx5LCAnJywgc291cmNlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcnNpb25Ub1NlbXZlcjogdmVyc2lvblRvU2VtdmVyLFxuICB0cmFuc2xhdGVKc29uQ29tcGlsZXJPdXRwdXQ6IHRyYW5zbGF0ZUpzb25Db21waWxlck91dHB1dCxcbiAgcHJldHR5UHJpbnRMZWdhY3lBc3NlbWJseUpTT046IHByZXR0eVByaW50TGVnYWN5QXNzZW1ibHlKU09OXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQge307XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiAnLyc7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XG4gIHZhciBpc1BhdGhBYnNvbHV0ZSA9IGlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNQYXRoQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzUGF0aEFic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzUGF0aEFic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydCBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydCBmdW5jdGlvbiBqb2luKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gbm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn1cblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0IGZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gIGZyb20gPSByZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSByZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59XG5cbmV4cG9ydCB2YXIgc2VwID0gJy8nO1xuZXhwb3J0IHZhciBkZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRuYW1lKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn1cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZXh0bmFtZTogZXh0bmFtZSxcbiAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICBkaXJuYW1lOiBkaXJuYW1lLFxuICBzZXA6IHNlcCxcbiAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gIHJlbGF0aXZlOiByZWxhdGl2ZSxcbiAgam9pbjogam9pbixcbiAgaXNBYnNvbHV0ZTogaXNBYnNvbHV0ZSxcbiAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gIHJlc29sdmU6IHJlc29sdmVcbn07XG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJyA/XG4gICAgZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9IDpcbiAgICBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNb2R1bGUgPSByZXF1aXJlKCdtb2R1bGUnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVGcm9tU3RyaW5nKGNvZGUsIGZpbGVuYW1lLCBvcHRzKSB7XG5cdGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnKSB7XG5cdFx0b3B0cyA9IGZpbGVuYW1lO1xuXHRcdGZpbGVuYW1lID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0b3B0cyA9IG9wdHMgfHwge307XG5cdGZpbGVuYW1lID0gZmlsZW5hbWUgfHwgJyc7XG5cblx0b3B0cy5hcHBlbmRQYXRocyA9IG9wdHMuYXBwZW5kUGF0aHMgfHwgW107XG5cdG9wdHMucHJlcGVuZFBhdGhzID0gb3B0cy5wcmVwZW5kUGF0aHMgfHwgW107XG5cblx0aWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignY29kZSBtdXN0IGJlIGEgc3RyaW5nLCBub3QgJyArIHR5cGVvZiBjb2RlKTtcblx0fVxuXG5cdHZhciBwYXRocyA9IE1vZHVsZS5fbm9kZU1vZHVsZVBhdGhzKHBhdGguZGlybmFtZShmaWxlbmFtZSkpO1xuXG5cdHZhciBwYXJlbnQgPSBtb2R1bGUucGFyZW50O1xuXHR2YXIgbSA9IG5ldyBNb2R1bGUoZmlsZW5hbWUsIHBhcmVudCk7XG5cdG0uZmlsZW5hbWUgPSBmaWxlbmFtZTtcblx0bS5wYXRocyA9IFtdLmNvbmNhdChvcHRzLnByZXBlbmRQYXRocykuY29uY2F0KHBhdGhzKS5jb25jYXQob3B0cy5hcHBlbmRQYXRocyk7XG5cdG0uX2NvbXBpbGUoY29kZSwgZmlsZW5hbWUpO1xuXG5cdHZhciBleHBvcnRzID0gbS5leHBvcnRzO1xuXHRwYXJlbnQgJiYgcGFyZW50LmNoaWxkcmVuICYmIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UocGFyZW50LmNoaWxkcmVuLmluZGV4T2YobSksIDEpO1xuXG5cdHJldHVybiBleHBvcnRzO1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG5cblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xudmFyIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vOyAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG52YXIgZXJyb3JzID0ge1xuICAnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuICAnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuICAnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xufTtcblxuLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xudmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcbiAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcbn1cblxuLyoqXG4gKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG4gKiBpdGVtLlxuICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcbiAgdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG4gICAgLy8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cbiAgICByZXN1bHQgPSBwYXJ0c1swXSArICdAJztcbiAgICBzdHJpbmcgPSBwYXJ0c1sxXTtcbiAgfVxuICAvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG4gIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG4gIHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcbiAgdmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuICByZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcbiAgdmFyIG91dHB1dCA9IFtdLFxuICAgIGNvdW50ZXIgPSAwLFxuICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgdmFsdWUsXG4gICAgZXh0cmE7XG4gIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG4gICAgICAgIC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xuZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuICByZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICBpZiAodmFsdWUgPiAweEZGRkYpIHtcbiAgICAgIHZhbHVlIC09IDB4MTAwMDA7XG4gICAgICBvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcbiAgICB9XG4gICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSkuam9pbignJyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG4gKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuICBpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuICAgIHJldHVybiBjb2RlUG9pbnQgLSAyMjtcbiAgfVxuICBpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuICAgIHJldHVybiBjb2RlUG9pbnQgLSA2NTtcbiAgfVxuICBpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuICAgIHJldHVybiBjb2RlUG9pbnQgLSA5NztcbiAgfVxuICByZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3JcbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG4gKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcbiAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG4gKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuICovXG5mdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcbiAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcbiAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG4gIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgdmFyIGsgPSAwO1xuICBkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuICBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG4gIGZvciAoIC8qIG5vIGluaXRpYWxpemF0aW9uICovIDsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcbiAgICBkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG4gIH1cbiAgcmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAvLyBEb24ndCB1c2UgVUNTLTJcbiAgdmFyIG91dHB1dCA9IFtdLFxuICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuICAgIG91dCxcbiAgICBpID0gMCxcbiAgICBuID0gaW5pdGlhbE4sXG4gICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuICAgIGJhc2ljLFxuICAgIGosXG4gICAgaW5kZXgsXG4gICAgb2xkaSxcbiAgICB3LFxuICAgIGssXG4gICAgZGlnaXQsXG4gICAgdCxcbiAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cbiAgICBiYXNlTWludXNUO1xuXG4gIC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuICAvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuICAvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuICBiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG4gIGlmIChiYXNpYyA8IDApIHtcbiAgICBiYXNpYyA9IDA7XG4gIH1cblxuICBmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuICAgIC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcbiAgICAgIGVycm9yKCdub3QtYmFzaWMnKTtcbiAgICB9XG4gICAgb3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG4gIH1cblxuICAvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG4gIC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cbiAgZm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8gKSB7XG5cbiAgICAvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG4gICAgLy8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuICAgIC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG4gICAgLy8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcbiAgICAvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuICAgIGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovIDsgayArPSBiYXNlKSB7XG5cbiAgICAgIGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuICAgICAgICBlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuICAgICAgfVxuXG4gICAgICBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuICAgICAgaWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgIH1cblxuICAgICAgaSArPSBkaWdpdCAqIHc7XG4gICAgICB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuICAgICAgaWYgKGRpZ2l0IDwgdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuICAgICAgaWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgIH1cblxuICAgICAgdyAqPSBiYXNlTWludXNUO1xuXG4gICAgfVxuXG4gICAgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG4gICAgYmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cbiAgICAvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuICAgIC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG4gICAgaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgfVxuXG4gICAgbiArPSBmbG9vcihpIC8gb3V0KTtcbiAgICBpICU9IG91dDtcblxuICAgIC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cbiAgfVxuXG4gIHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICB2YXIgbixcbiAgICBkZWx0YSxcbiAgICBoYW5kbGVkQ1BDb3VudCxcbiAgICBiYXNpY0xlbmd0aCxcbiAgICBiaWFzLFxuICAgIGosXG4gICAgbSxcbiAgICBxLFxuICAgIGssXG4gICAgdCxcbiAgICBjdXJyZW50VmFsdWUsXG4gICAgb3V0cHV0ID0gW10sXG4gICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cbiAgICBpbnB1dExlbmd0aCxcbiAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cbiAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG4gICAgYmFzZU1pbnVzVCxcbiAgICBxTWludXNUO1xuXG4gIC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcbiAgaW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuICAvLyBDYWNoZSB0aGUgbGVuZ3RoXG4gIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG4gIG4gPSBpbml0aWFsTjtcbiAgZGVsdGEgPSAwO1xuICBiaWFzID0gaW5pdGlhbEJpYXM7XG5cbiAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuICAgIGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG4gICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cbiAgLy8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG4gIC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuICAvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcbiAgaWYgKGJhc2ljTGVuZ3RoKSB7XG4gICAgb3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcbiAgfVxuXG4gIC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcbiAgd2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcbiAgICAvLyBsYXJnZXIgb25lOlxuICAgIGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG4gICAgICAgIG0gPSBjdXJyZW50VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuICAgIC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG4gICAgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuICAgIGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG4gICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICB9XG5cbiAgICBkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuICAgIG4gPSBtO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG4gICAgICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG4gICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcbiAgICAgICAgLy8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcbiAgICAgICAgZm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi8gOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcbiAgICAgICAgICBpZiAocSA8IHQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuICAgICAgICAgIG91dHB1dC5wdXNoKFxuICAgICAgICAgICAgc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcbiAgICAgICAgYmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcbiAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICArK2hhbmRsZWRDUENvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgICsrZGVsdGE7XG4gICAgKytuO1xuXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG4gKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG4gKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcbiAqIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZykgP1xuICAgICAgZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKSA6XG4gICAgICBzdHJpbmc7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAqIEFTQ0lJLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICogVW5pY29kZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gKiBlbWFpbCBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgP1xuICAgICAgJ3huLS0nICsgZW5jb2RlKHN0cmluZykgOlxuICAgICAgc3RyaW5nO1xuICB9KTtcbn1cbmV4cG9ydCB2YXIgdmVyc2lvbiA9ICcxLjQuMSc7XG4vKipcbiAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEB0eXBlIE9iamVjdFxuICovXG5cbmV4cG9ydCB2YXIgdWNzMiA9IHtcbiAgZGVjb2RlOiB1Y3MyZGVjb2RlLFxuICBlbmNvZGU6IHVjczJlbmNvZGVcbn07XG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb246IHZlcnNpb24sXG4gIHVjczI6IHVjczIsXG4gIHRvQVNDSUk6IHRvQVNDSUksXG4gIHRvVW5pY29kZTogdG9Vbmljb2RlLFxuICBlbmNvZGU6IGVuY29kZSxcbiAgZGVjb2RlOiBkZWNvZGVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbmZ1bmN0aW9uIHN0cmluZ2lmeVByaW1pdGl2ZSh2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuZXhwb3J0IGRlZmF1bHQge1xuICBlbmNvZGU6IHN0cmluZ2lmeSxcbiAgc3RyaW5naWZ5OiBzdHJpbmdpZnksXG4gIGRlY29kZTogcGFyc2UsXG4gIHBhcnNlOiBwYXJzZVxufVxuZXhwb3J0IHtzdHJpbmdpZnkgYXMgZW5jb2RlLCBwYXJzZSBhcyBkZWNvZGV9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuaW1wb3J0IHt0b0FTQ0lJfSBmcm9tICdwdW55Y29kZSc7XG5pbXBvcnQge2lzT2JqZWN0LGlzU3RyaW5nLGlzTnVsbE9yVW5kZWZpbmVkLGlzTnVsbH0gZnJvbSAndXRpbCc7XG5pbXBvcnQge3BhcnNlIGFzIHFzUGFyc2Usc3RyaW5naWZ5IGFzIHFzU3RyaW5naWZ5fSBmcm9tICdxdWVyeXN0cmluZyc7XG5leHBvcnQge1xuICB1cmxQYXJzZSBhcyBwYXJzZSxcbiAgdXJsUmVzb2x2ZSBhcyByZXNvbHZlLFxuICB1cmxSZXNvbHZlT2JqZWN0IGFzIHJlc29sdmVPYmplY3QsXG4gIHVybEZvcm1hdCBhcyBmb3JtYXRcbn07XG5leHBvcnQgZGVmYXVsdCB7XG4gIHBhcnNlOiB1cmxQYXJzZSxcbiAgcmVzb2x2ZTogdXJsUmVzb2x2ZSxcbiAgcmVzb2x2ZU9iamVjdDogdXJsUmVzb2x2ZU9iamVjdCxcbiAgZm9ybWF0OiB1cmxGb3JtYXQsXG4gIFVybDogVXJsXG59XG5leHBvcnQgZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgLy8gdGhlbS5cbiAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgfSxcbiAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gIH0sXG4gIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgJ2h0dHAnOiB0cnVlLFxuICAgICdodHRwcyc6IHRydWUsXG4gICAgJ2Z0cCc6IHRydWUsXG4gICAgJ2dvcGhlcic6IHRydWUsXG4gICAgJ2ZpbGUnOiB0cnVlLFxuICAgICdodHRwOic6IHRydWUsXG4gICAgJ2h0dHBzOic6IHRydWUsXG4gICAgJ2Z0cDonOiB0cnVlLFxuICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAnZmlsZTonOiB0cnVlXG4gIH07XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgcmV0dXJuIHBhcnNlKHRoaXMsIHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzZWxmLCB1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBcXCd1cmxcXCcgbXVzdCBiZSBhIHN0cmluZywgbm90ICcgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgIHNwbGl0dGVyID1cbiAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICBzZWxmLnBhdGggPSByZXN0O1xuICAgICAgc2VsZi5ocmVmID0gcmVzdDtcbiAgICAgIHNlbGYucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgc2VsZi5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHNlbGYucXVlcnkgPSBxc1BhcnNlKHNlbGYuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5xdWVyeSA9IHNlbGYuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHNlbGYuc2VhcmNoID0gJyc7XG4gICAgICAgIHNlbGYucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICBzZWxmLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgc2VsZi5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdmFyIGksIGhlYywgbCwgcDtcbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHNlbGYuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgc2VsZi5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgcGFyc2VIb3N0KHNlbGYpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHNlbGYuaG9zdG5hbWUgPSBzZWxmLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gc2VsZi5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICBzZWxmLmhvc3RuYW1lW3NlbGYuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gc2VsZi5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxmLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICBzZWxmLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICBzZWxmLmhvc3RuYW1lID0gc2VsZi5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICBzZWxmLmhvc3RuYW1lID0gdG9BU0NJSShzZWxmLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICBwID0gc2VsZi5wb3J0ID8gJzonICsgc2VsZi5wb3J0IDogJyc7XG4gICAgdmFyIGggPSBzZWxmLmhvc3RuYW1lIHx8ICcnO1xuICAgIHNlbGYuaG9zdCA9IGggKyBwO1xuICAgIHNlbGYuaHJlZiArPSBzZWxmLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICBzZWxmLmhvc3RuYW1lID0gc2VsZi5ob3N0bmFtZS5zdWJzdHIoMSwgc2VsZi5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yIChpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgc2VsZi5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICBzZWxmLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICBzZWxmLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgc2VsZi5xdWVyeSA9IHFzUGFyc2Uoc2VsZi5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICBzZWxmLnNlYXJjaCA9ICcnO1xuICAgIHNlbGYucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgc2VsZi5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICBzZWxmLmhvc3RuYW1lICYmICFzZWxmLnBhdGhuYW1lKSB7XG4gICAgc2VsZi5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHNlbGYucGF0aG5hbWUgfHwgc2VsZi5zZWFyY2gpIHtcbiAgICBwID0gc2VsZi5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHNlbGYuc2VhcmNoIHx8ICcnO1xuICAgIHNlbGYucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHNlbGYuaHJlZiA9IGZvcm1hdChzZWxmKTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gcGFyc2Uoe30sIG9iaik7XG4gIHJldHVybiBmb3JtYXQob2JqKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KHNlbGYpIHtcbiAgdmFyIGF1dGggPSBzZWxmLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHNlbGYucHJvdG9jb2wgfHwgJycsXG4gICAgcGF0aG5hbWUgPSBzZWxmLnBhdGhuYW1lIHx8ICcnLFxuICAgIGhhc2ggPSBzZWxmLmhhc2ggfHwgJycsXG4gICAgaG9zdCA9IGZhbHNlLFxuICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHNlbGYuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgc2VsZi5ob3N0O1xuICB9IGVsc2UgaWYgKHNlbGYuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArIChzZWxmLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgc2VsZi5ob3N0bmFtZSA6XG4gICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAoc2VsZi5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHNlbGYucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5xdWVyeSAmJlxuICAgIGlzT2JqZWN0KHNlbGYucXVlcnkpICYmXG4gICAgT2JqZWN0LmtleXMoc2VsZi5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxc1N0cmluZ2lmeShzZWxmLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSBzZWxmLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAoc2VsZi5zbGFzaGVzIHx8XG4gICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZvcm1hdCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciByZWxQYXRoO1xuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICBpc1JlbEFicyA9IChcbiAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgKSxcbiAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG4gIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdO1xuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG4gIHZhciBhdXRoSW5Ib3N0O1xuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwYXJzZUhvc3QodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUhvc3Qoc2VsZikge1xuICB2YXIgaG9zdCA9IHNlbGYuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHNlbGYucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHNlbGYuaG9zdG5hbWUgPSBob3N0O1xufVxuIiwiZXhwb3J0IHZhciBoYXNGZXRjaCA9IGlzRnVuY3Rpb24oZ2xvYmFsLmZldGNoKSAmJiBpc0Z1bmN0aW9uKGdsb2JhbC5SZWFkYWJsZVN0cmVhbSlcblxudmFyIF9ibG9iQ29uc3RydWN0b3I7XG5leHBvcnQgZnVuY3Rpb24gYmxvYkNvbnN0cnVjdG9yKCkge1xuICBpZiAodHlwZW9mIF9ibG9iQ29uc3RydWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIF9ibG9iQ29uc3RydWN0b3I7XG4gIH1cbiAgdHJ5IHtcbiAgICBuZXcgZ2xvYmFsLkJsb2IoW25ldyBBcnJheUJ1ZmZlcigxKV0pXG4gICAgX2Jsb2JDb25zdHJ1Y3RvciA9IHRydWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIF9ibG9iQ29uc3RydWN0b3IgPSBmYWxzZVxuICB9XG4gIHJldHVybiBfYmxvYkNvbnN0cnVjdG9yXG59XG52YXIgeGhyO1xuXG5mdW5jdGlvbiBjaGVja1R5cGVTdXBwb3J0KHR5cGUpIHtcbiAgaWYgKCF4aHIpIHtcbiAgICB4aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcbiAgICAvLyBJZiBsb2NhdGlvbi5ob3N0IGlzIGVtcHR5LCBlLmcuIGlmIHRoaXMgcGFnZS93b3JrZXIgd2FzIGxvYWRlZFxuICAgIC8vIGZyb20gYSBCbG9iLCB0aGVuIHVzZSBleGFtcGxlLmNvbSB0byBhdm9pZCBhbiBlcnJvclxuICAgIHhoci5vcGVuKCdHRVQnLCBnbG9iYWwubG9jYXRpb24uaG9zdCA/ICcvJyA6ICdodHRwczovL2V4YW1wbGUuY29tJylcbiAgfVxuICB0cnkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0eXBlXG4gICAgcmV0dXJuIHhoci5yZXNwb25zZVR5cGUgPT09IHR5cGVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbn1cblxuLy8gRm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIFNhZmFyaSA3LjAgcmVwb3J0cyB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnb2JqZWN0Jy5cbi8vIFNhZmFyaSA3LjEgYXBwZWFycyB0byBoYXZlIGZpeGVkIHRoaXMgYnVnLlxudmFyIGhhdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnXG52YXIgaGF2ZVNsaWNlID0gaGF2ZUFycmF5QnVmZmVyICYmIGlzRnVuY3Rpb24oZ2xvYmFsLkFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSlcblxuZXhwb3J0IHZhciBhcnJheWJ1ZmZlciA9IGhhdmVBcnJheUJ1ZmZlciAmJiBjaGVja1R5cGVTdXBwb3J0KCdhcnJheWJ1ZmZlcicpXG4gIC8vIFRoZXNlIG5leHQgdHdvIHRlc3RzIHVuYXZvaWRhYmx5IHNob3cgd2FybmluZ3MgaW4gQ2hyb21lLiBTaW5jZSBmZXRjaCB3aWxsIGFsd2F5c1xuICAvLyBiZSB1c2VkIGlmIGl0J3MgYXZhaWxhYmxlLCBqdXN0IHJldHVybiBmYWxzZSBmb3IgdGhlc2UgdG8gYXZvaWQgdGhlIHdhcm5pbmdzLlxuZXhwb3J0IHZhciBtc3N0cmVhbSA9ICFoYXNGZXRjaCAmJiBoYXZlU2xpY2UgJiYgY2hlY2tUeXBlU3VwcG9ydCgnbXMtc3RyZWFtJylcbmV4cG9ydCB2YXIgbW96Y2h1bmtlZGFycmF5YnVmZmVyID0gIWhhc0ZldGNoICYmIGhhdmVBcnJheUJ1ZmZlciAmJlxuICBjaGVja1R5cGVTdXBwb3J0KCdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcicpXG5leHBvcnQgdmFyIG92ZXJyaWRlTWltZVR5cGUgPSBpc0Z1bmN0aW9uKHhoci5vdmVycmlkZU1pbWVUeXBlKVxuZXhwb3J0IHZhciB2YkFycmF5ID0gaXNGdW5jdGlvbihnbG9iYWwuVkJBcnJheSlcblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG59XG5cbnhociA9IG51bGwgLy8gSGVscCBnY1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tYWluO1xuXG4vLyBUaGlzIGNvbnN0cnVjdG9yIGlzIHVzZWQgdG8gc3RvcmUgZXZlbnQgaGFuZGxlcnMuIEluc3RhbnRpYXRpbmcgdGhpcyBpc1xuLy8gZmFzdGVyIHRoYW4gZXhwbGljaXRseSBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCB0byBnZXQgYSBcImNsZWFuXCIgZW1wdHlcbi8vIG9iamVjdCAodGVzdGVkIHdpdGggdjggdjQuOSkuXG5mdW5jdGlvbiBFdmVudEhhbmRsZXJzKCkge31cbkV2ZW50SGFuZGxlcnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuZXhwb3J0IHtFdmVudEVtaXR0ZXJ9O1xuXG4vLyBub2RlanMgb2RkaXR5XG4vLyByZXF1aXJlKCdldmVudHMnKSA9PT0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyXG5cbkV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMgPSBmYWxzZTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5kb21haW4gPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZG9tYWluID0gbnVsbDtcbiAgaWYgKEV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMpIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgZG9tYWluLCB0aGVuIGF0dGFjaCB0byBpdC5cbiAgICBpZiAoZG9tYWluLmFjdGl2ZSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBkb21haW4uRG9tYWluKSkge1xuICAgICAgdGhpcy5kb21haW4gPSBkb21haW4uYWN0aXZlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHMsIGRvbWFpbjtcbiAgdmFyIG5lZWREb21haW5FeGl0ID0gZmFsc2U7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZG9tYWluID0gdGhpcy5kb21haW47XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChkb21haW4pIHtcbiAgICAgIGlmICghZXIpXG4gICAgICAgIGVyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50Jyk7XG4gICAgICBlci5kb21haW5FbWl0dGVyID0gdGhpcztcbiAgICAgIGVyLmRvbWFpbiA9IGRvbWFpbjtcbiAgICAgIGVyLmRvbWFpblRocm93biA9IGZhbHNlO1xuICAgICAgZG9tYWluLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIGlmIChuZWVkRG9tYWluRXhpdClcbiAgICBkb21haW4uZXhpdCgpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIHR5cGUgKyAnIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0Jyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGVtaXRXYXJuaW5nKHcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBlbWl0V2FybmluZyhlKSB7XG4gIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicgPyBjb25zb2xlLndhcm4oZSkgOiBjb25zb2xlLmxvZyhlKTtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGZpcmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICByZXR1cm4gZztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgKGxpc3QubGlzdGVuZXIgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBsaXN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHM7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXk7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH0gd2hpbGUgKGxpc3RlbmVyc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgdmFyIGV2bGlzdGVuZXI7XG4gIHZhciByZXQ7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0ID0gW107XG4gIGVsc2Uge1xuICAgIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKCFldmxpc3RlbmVyKVxuICAgICAgcmV0ID0gW107XG4gICAgZWxzZSBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICByZXQgPSBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXTtcbiAgICBlbHNlXG4gICAgICByZXQgPSB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgaSkge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsImltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJMaXN0O1xuXG5mdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgLS10aGlzLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHMpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gIH1yZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKHApIHtcbiAgICBwLmRhdGEuY29weShyZXQsIGkpO1xuICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIid1c2Ugc3RyaWN0JztcblxuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7aW5oZXJpdHMsIGRlYnVnbG9nfSBmcm9tICd1dGlsJztcbmltcG9ydCBCdWZmZXJMaXN0IGZyb20gJy4vYnVmZmVyLWxpc3QnO1xuaW1wb3J0IHtTdHJpbmdEZWNvZGVyfSBmcm9tICdzdHJpbmdfZGVjb2Rlcic7XG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9kdXBsZXgnO1xuaW1wb3J0IHtuZXh0VGlja30gZnJvbSAncHJvY2Vzcyc7XG5cbnZhciBkZWJ1ZyA9IGRlYnVnbG9nKCdzdHJlYW0nKTtcbmluaGVyaXRzKFJlYWRhYmxlLCBFdmVudEVtaXR0ZXIpO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pXG4gICAgICBlbWl0dGVyLm9uKGV2ZW50LCBmbik7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSlcbiAgICAgIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7XG4gICAgZWxzZVxuICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQgKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgUmVhZGFibGU7XG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXG4gICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIG5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBuZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgbmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKGxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgc3JjLmxpc3RlbmVycygnZGF0YScpLmxlbmd0aCkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBuZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgbmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwiLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5cbmltcG9ydCB7aW5oZXJpdHMsIGRlcHJlY2F0ZX0gZnJvbSAndXRpbCc7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuaW1wb3J0IHtFdmVudEVtaXR0ZXJ9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9kdXBsZXgnO1xuaW1wb3J0IHtuZXh0VGlja30gZnJvbSAncHJvY2Vzcyc7XG5pbmhlcml0cyhXcml0YWJsZSwgRXZlbnRFbWl0dGVyKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1ZmZlcicsIHtcbiAgICBnZXQ6IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicpXG4gIH0pO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVHZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBXcml0YWJsZTtcbmV4cG9ydCBmdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgbmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcbiAgLy8gQWx3YXlzIHRocm93IGVycm9yIGlmIGEgbnVsbCBpcyB3cml0dGVuXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIG5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgbmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgICBuZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIG5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB2YXIgZW50cnkgPSBfdGhpcy5lbnRyeTtcbiAgICBfdGhpcy5lbnRyeSA9IG51bGw7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXJyKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBfdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gX3RoaXM7XG4gICAgfVxuICB9O1xufVxuIiwiXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcbmltcG9ydCB7bmV4dFRpY2t9IGZyb20gJ3Byb2Nlc3MnO1xuaW1wb3J0IHtSZWFkYWJsZX0gZnJvbSAnLi9yZWFkYWJsZSc7XG5pbXBvcnQge1dyaXRhYmxlfSBmcm9tICcuL3dyaXRhYmxlJztcblxuXG5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5leHBvcnQgZGVmYXVsdCBEdXBsZXg7XG5leHBvcnQgZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgbmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuIiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5cbmltcG9ydCB7RHVwbGV4fSBmcm9tICcuL2R1cGxleCc7XG5cblxuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybTtcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsIlxuaW1wb3J0IHtUcmFuc2Zvcm19IGZyb20gJy4vdHJhbnNmb3JtJztcblxuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcbmV4cG9ydCBkZWZhdWx0IFBhc3NUaHJvdWdoO1xuZXhwb3J0IGZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiaW1wb3J0IEVFIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcblxuaW1wb3J0IHtEdXBsZXh9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyc7XG5pbXBvcnQge1JlYWRhYmxlfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyc7XG5pbXBvcnQge1dyaXRhYmxlfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyc7XG5pbXBvcnQge1RyYW5zZm9ybX0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7UGFzc1Rocm91Z2h9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJztcbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gUmVhZGFibGU7XG5TdHJlYW0uV3JpdGFibGUgPSBXcml0YWJsZTtcblN0cmVhbS5EdXBsZXggPSBEdXBsZXg7XG5TdHJlYW0uVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gUGFzc1Rocm91Z2g7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5leHBvcnQgZGVmYXVsdCBTdHJlYW07XG5leHBvcnQge1JlYWRhYmxlLFdyaXRhYmxlLER1cGxleCxUcmFuc2Zvcm0sUGFzc1Rocm91Z2gsU3RyZWFtfVxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiaW1wb3J0IHtvdmVycmlkZU1pbWVUeXBlfSBmcm9tICcuL2NhcGFiaWxpdHknO1xuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5pbXBvcnQge1JlYWRhYmxlfSBmcm9tICdzdHJlYW0nO1xuXG52YXIgclN0YXRlcyA9IHtcbiAgVU5TRU5UOiAwLFxuICBPUEVORUQ6IDEsXG4gIEhFQURFUlNfUkVDRUlWRUQ6IDIsXG4gIExPQURJTkc6IDMsXG4gIERPTkU6IDRcbn1cbmV4cG9ydCB7XG4gIHJTdGF0ZXMgYXMgcmVhZHlTdGF0ZXNcbn07XG5leHBvcnQgZnVuY3Rpb24gSW5jb21pbmdNZXNzYWdlKHhociwgcmVzcG9uc2UsIG1vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIFJlYWRhYmxlLmNhbGwoc2VsZilcblxuICBzZWxmLl9tb2RlID0gbW9kZVxuICBzZWxmLmhlYWRlcnMgPSB7fVxuICBzZWxmLnJhd0hlYWRlcnMgPSBbXVxuICBzZWxmLnRyYWlsZXJzID0ge31cbiAgc2VsZi5yYXdUcmFpbGVycyA9IFtdXG5cbiAgLy8gRmFrZSB0aGUgJ2Nsb3NlJyBldmVudCwgYnV0IG9ubHkgb25jZSAnZW5kJyBmaXJlc1xuICBzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGUgbmV4dFRpY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgdGhlICdyZXF1ZXN0JyBtb2R1bGUgZnJvbSBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3BcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gICAgfSlcbiAgfSlcbiAgdmFyIHJlYWQ7XG4gIGlmIChtb2RlID09PSAnZmV0Y2gnKSB7XG4gICAgc2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cbiAgICBzZWxmLnVybCA9IHJlc3BvbnNlLnVybFxuICAgIHNlbGYuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c1xuICAgIHNlbGYuc3RhdHVzTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIHZlcnNpb24gb2YgZm9yICg8aXRlbT4gb2YgPGl0ZXJhYmxlPik6XG4gICAgICAvLyBmb3IgKHZhciA8aXRlbT4sX2ksX2l0ID0gPGl0ZXJhYmxlPltTeW1ib2wuaXRlcmF0b3JdKCk7IDxpdGVtPiA9IChfaSA9IF9pdC5uZXh0KCkpLnZhbHVlLCFfaS5kb25lOylcbiAgICBmb3IgKHZhciBoZWFkZXIsIF9pLCBfaXQgPSByZXNwb25zZS5oZWFkZXJzW1N5bWJvbC5pdGVyYXRvcl0oKTsgaGVhZGVyID0gKF9pID0gX2l0Lm5leHQoKSkudmFsdWUsICFfaS5kb25lOykge1xuICAgICAgc2VsZi5oZWFkZXJzW2hlYWRlclswXS50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlclsxXVxuICAgICAgc2VsZi5yYXdIZWFkZXJzLnB1c2goaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBkb2Vzbid0IHJlc3BlY3QgYmFja3ByZXNzdXJlLiBPbmNlIFdyaXRhYmxlU3RyZWFtIGlzIGF2YWlsYWJsZSwgdGhpcyBjYW4gYmUgZml4ZWRcbiAgICB2YXIgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKVxuXG4gICAgcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgaWYgKHNlbGYuX2Rlc3Ryb3llZClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgc2VsZi5wdXNoKG51bGwpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5wdXNoKG5ldyBCdWZmZXIocmVzdWx0LnZhbHVlKSlcbiAgICAgICAgcmVhZCgpXG4gICAgICB9KVxuICAgIH1cbiAgICByZWFkKClcblxuICB9IGVsc2Uge1xuICAgIHNlbGYuX3hociA9IHhoclxuICAgIHNlbGYuX3BvcyA9IDBcblxuICAgIHNlbGYudXJsID0geGhyLnJlc3BvbnNlVVJMXG4gICAgc2VsZi5zdGF0dXNDb2RlID0geGhyLnN0YXR1c1xuICAgIHNlbGYuc3RhdHVzTWVzc2FnZSA9IHhoci5zdGF0dXNUZXh0XG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoL1xccj9cXG4vKVxuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHZhciBtYXRjaGVzID0gaGVhZGVyLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pXG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIga2V5ID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICAgIGlmIChzZWxmLmhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLmhlYWRlcnNba2V5XSA9IFtdXG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuaGVhZGVyc1trZXldLnB1c2gobWF0Y2hlc1syXSlcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZi5oZWFkZXJzW2tleV0gKz0gJywgJyArIG1hdGNoZXNbMl1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmhlYWRlcnNba2V5XSA9IG1hdGNoZXNbMl1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLnJhd0hlYWRlcnMucHVzaChtYXRjaGVzWzFdLCBtYXRjaGVzWzJdKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBzZWxmLl9jaGFyc2V0ID0gJ3gtdXNlci1kZWZpbmVkJ1xuICAgIGlmICghb3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgICAgdmFyIG1pbWVUeXBlID0gc2VsZi5yYXdIZWFkZXJzWydtaW1lLXR5cGUnXVxuICAgICAgaWYgKG1pbWVUeXBlKSB7XG4gICAgICAgIHZhciBjaGFyc2V0TWF0Y2ggPSBtaW1lVHlwZS5tYXRjaCgvO1xccypjaGFyc2V0PShbXjtdKSg7fCQpLylcbiAgICAgICAgaWYgKGNoYXJzZXRNYXRjaCkge1xuICAgICAgICAgIHNlbGYuX2NoYXJzZXQgPSBjaGFyc2V0TWF0Y2hbMV0udG9Mb3dlckNhc2UoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXNlbGYuX2NoYXJzZXQpXG4gICAgICAgIHNlbGYuX2NoYXJzZXQgPSAndXRmLTgnIC8vIGJlc3QgZ3Vlc3NcbiAgICB9XG4gIH1cbn1cblxuaW5oZXJpdHMoSW5jb21pbmdNZXNzYWdlLCBSZWFkYWJsZSlcblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge31cblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgeGhyID0gc2VsZi5feGhyXG5cbiAgdmFyIHJlc3BvbnNlID0gbnVsbFxuICBzd2l0Y2ggKHNlbGYuX21vZGUpIHtcbiAgY2FzZSAndGV4dDp2YmFycmF5JzogLy8gRm9yIElFOVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5ET05FKVxuICAgICAgYnJlYWtcbiAgICB0cnkge1xuICAgICAgLy8gVGhpcyBmYWlscyBpbiBJRThcbiAgICAgIHJlc3BvbnNlID0gbmV3IGdsb2JhbC5WQkFycmF5KHhoci5yZXNwb25zZUJvZHkpLnRvQXJyYXkoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBhc3NcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlICE9PSBudWxsKSB7XG4gICAgICBzZWxmLnB1c2gobmV3IEJ1ZmZlcihyZXNwb25zZSkpXG4gICAgICBicmVha1xuICAgIH1cbiAgICAvLyBGYWxscyB0aHJvdWdoIGluIElFOFxuICBjYXNlICd0ZXh0JzpcbiAgICB0cnkgeyAvLyBUaGlzIHdpbGwgZmFpbCB3aGVuIHJlYWR5U3RhdGUgPSAzIGluIElFOS4gU3dpdGNoIG1vZGUgYW5kIHdhaXQgZm9yIHJlYWR5U3RhdGUgPSA0XG4gICAgICByZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHRcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZWxmLl9tb2RlID0gJ3RleHQ6dmJhcnJheSdcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5sZW5ndGggPiBzZWxmLl9wb3MpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gcmVzcG9uc2Uuc3Vic3RyKHNlbGYuX3BvcylcbiAgICAgIGlmIChzZWxmLl9jaGFyc2V0ID09PSAneC11c2VyLWRlZmluZWQnKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKG5ld0RhdGEubGVuZ3RoKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgYnVmZmVyW2ldID0gbmV3RGF0YS5jaGFyQ29kZUF0KGkpICYgMHhmZlxuXG4gICAgICAgIHNlbGYucHVzaChidWZmZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnB1c2gobmV3RGF0YSwgc2VsZi5fY2hhcnNldClcbiAgICAgIH1cbiAgICAgIHNlbGYuX3BvcyA9IHJlc3BvbnNlLmxlbmd0aFxuICAgIH1cbiAgICBicmVha1xuICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUgfHwgIXhoci5yZXNwb25zZSlcbiAgICAgIGJyZWFrXG4gICAgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2VcbiAgICBzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuICAgIGJyZWFrXG4gIGNhc2UgJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJzogLy8gdGFrZSB3aG9sZVxuICAgIHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG4gICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcgfHwgIXJlc3BvbnNlKVxuICAgICAgYnJlYWtcbiAgICBzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuICAgIGJyZWFrXG4gIGNhc2UgJ21zLXN0cmVhbSc6XG4gICAgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2VcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORylcbiAgICAgIGJyZWFrXG4gICAgdmFyIHJlYWRlciA9IG5ldyBnbG9iYWwuTVNTdHJlYW1SZWFkZXIoKVxuICAgIHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoID4gc2VsZi5fcG9zKSB7XG4gICAgICAgIHNlbGYucHVzaChuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQuc2xpY2Uoc2VsZi5fcG9zKSkpKVxuICAgICAgICBzZWxmLl9wb3MgPSByZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5wdXNoKG51bGwpXG4gICAgfVxuICAgICAgLy8gcmVhZGVyLm9uZXJyb3IgPSA/Pz8gLy8gVE9ETzogdGhpc1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihyZXNwb25zZSlcbiAgICBicmVha1xuICB9XG5cbiAgLy8gVGhlIG1zLXN0cmVhbSBjYXNlIGhhbmRsZXMgZW5kIHNlcGFyYXRlbHkgaW4gcmVhZGVyLm9ubG9hZCgpXG4gIGlmIChzZWxmLl94aHIucmVhZHlTdGF0ZSA9PT0gclN0YXRlcy5ET05FICYmIHNlbGYuX21vZGUgIT09ICdtcy1zdHJlYW0nKSB7XG4gICAgc2VsZi5wdXNoKG51bGwpXG4gIH1cbn1cbiIsIi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2poaWVzZXkvdG8tYXJyYXlidWZmZXIvYmxvYi82NTAyZDk4NTBlNzBiYTc5MzVhN2RmNGFkODZiMzU4ZmMyMTZmOWYwL2luZGV4LmpzXG5cbi8vIE1JVCBMaWNlbnNlXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgSm9obiBIaWVzZXlcbmltcG9ydCB7aXNCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYnVmKSB7XG4gIC8vIElmIHRoZSBidWZmZXIgaXMgYmFja2VkIGJ5IGEgVWludDhBcnJheSwgYSBmYXN0ZXIgdmVyc2lvbiB3aWxsIHdvcmtcbiAgaWYgKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAvLyBJZiB0aGUgYnVmZmVyIGlzbid0IGEgc3ViYXJyYXksIHJldHVybiB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlclxuICAgIGlmIChidWYuYnl0ZU9mZnNldCA9PT0gMCAmJiBidWYuYnl0ZUxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJ1Zi5idWZmZXIuc2xpY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGdldCBhIHByb3BlciBjb3B5XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNCdWZmZXIoYnVmKSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNsb3cgdmVyc2lvbiB0aGF0IHdpbGwgd29yayB3aXRoIGFueSBCdWZmZXJcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiAoZXZlbiBpbiBvbGQgYnJvd3NlcnMpXG4gICAgdmFyIGFycmF5Q29weSA9IG5ldyBVaW50OEFycmF5KGJ1Zi5sZW5ndGgpXG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcnJheUNvcHlbaV0gPSBidWZbaV1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5Q29weS5idWZmZXJcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBjYXBhYmlsaXR5IGZyb20gJy4vY2FwYWJpbGl0eSc7XG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcbmltcG9ydCB7SW5jb21pbmdNZXNzYWdlLCByZWFkeVN0YXRlcyBhcyByU3RhdGVzfSBmcm9tICcuL3Jlc3BvbnNlJztcbmltcG9ydCB7V3JpdGFibGV9IGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgdG9BcnJheUJ1ZmZlciBmcm9tICcuL3RvLWFycmF5YnVmZmVyJztcblxuZnVuY3Rpb24gZGVjaWRlTW9kZShwcmVmZXJCaW5hcnksIHVzZUZldGNoKSB7XG4gIGlmIChjYXBhYmlsaXR5Lmhhc0ZldGNoICYmIHVzZUZldGNoKSB7XG4gICAgcmV0dXJuICdmZXRjaCdcbiAgfSBlbHNlIGlmIChjYXBhYmlsaXR5Lm1vemNodW5rZWRhcnJheWJ1ZmZlcikge1xuICAgIHJldHVybiAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInXG4gIH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5tc3N0cmVhbSkge1xuICAgIHJldHVybiAnbXMtc3RyZWFtJ1xuICB9IGVsc2UgaWYgKGNhcGFiaWxpdHkuYXJyYXlidWZmZXIgJiYgcHJlZmVyQmluYXJ5KSB7XG4gICAgcmV0dXJuICdhcnJheWJ1ZmZlcidcbiAgfSBlbHNlIGlmIChjYXBhYmlsaXR5LnZiQXJyYXkgJiYgcHJlZmVyQmluYXJ5KSB7XG4gICAgcmV0dXJuICd0ZXh0OnZiYXJyYXknXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICd0ZXh0J1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBDbGllbnRSZXF1ZXN0O1xuXG5mdW5jdGlvbiBDbGllbnRSZXF1ZXN0KG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIFdyaXRhYmxlLmNhbGwoc2VsZilcblxuICBzZWxmLl9vcHRzID0gb3B0c1xuICBzZWxmLl9ib2R5ID0gW11cbiAgc2VsZi5faGVhZGVycyA9IHt9XG4gIGlmIChvcHRzLmF1dGgpXG4gICAgc2VsZi5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIG5ldyBCdWZmZXIob3B0cy5hdXRoKS50b1N0cmluZygnYmFzZTY0JykpXG4gIE9iamVjdC5rZXlzKG9wdHMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgc2VsZi5zZXRIZWFkZXIobmFtZSwgb3B0cy5oZWFkZXJzW25hbWVdKVxuICB9KVxuXG4gIHZhciBwcmVmZXJCaW5hcnlcbiAgdmFyIHVzZUZldGNoID0gdHJ1ZVxuICBpZiAob3B0cy5tb2RlID09PSAnZGlzYWJsZS1mZXRjaCcpIHtcbiAgICAvLyBJZiB0aGUgdXNlIG9mIFhIUiBzaG91bGQgYmUgcHJlZmVycmVkIGFuZCBpbmNsdWRlcyBwcmVzZXJ2aW5nIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXJcbiAgICB1c2VGZXRjaCA9IGZhbHNlXG4gICAgcHJlZmVyQmluYXJ5ID0gdHJ1ZVxuICB9IGVsc2UgaWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG4gICAgLy8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG4gICAgLy8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG4gICAgcHJlZmVyQmluYXJ5ID0gZmFsc2VcbiAgfSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG4gICAgLy8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG4gICAgcHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuICB9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG4gICAgLy8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcbiAgICBwcmVmZXJCaW5hcnkgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuICB9XG4gIHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpXG5cbiAgc2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fb25GaW5pc2goKVxuICB9KVxufVxuXG5pbmhlcml0cyhDbGllbnRSZXF1ZXN0LCBXcml0YWJsZSlcbi8vIFRha2VuIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3RoZS1zZXRyZXF1ZXN0aGVhZGVyJTI4JTI5LW1ldGhvZFxudmFyIHVuc2FmZUhlYWRlcnMgPSBbXG4gICdhY2NlcHQtY2hhcnNldCcsXG4gICdhY2NlcHQtZW5jb2RpbmcnLFxuICAnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzJyxcbiAgJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kJyxcbiAgJ2Nvbm5lY3Rpb24nLFxuICAnY29udGVudC1sZW5ndGgnLFxuICAnY29va2llJyxcbiAgJ2Nvb2tpZTInLFxuICAnZGF0ZScsXG4gICdkbnQnLFxuICAnZXhwZWN0JyxcbiAgJ2hvc3QnLFxuICAna2VlcC1hbGl2ZScsXG4gICdvcmlnaW4nLFxuICAncmVmZXJlcicsXG4gICd0ZScsXG4gICd0cmFpbGVyJyxcbiAgJ3RyYW5zZmVyLWVuY29kaW5nJyxcbiAgJ3VwZ3JhZGUnLFxuICAndXNlci1hZ2VudCcsXG4gICd2aWEnXG5dXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGxvd2VyTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbm90IG5lY2Vzc2FyeSwgYnV0IGl0IHByZXZlbnRzIHdhcm5pbmdzIGZyb20gYnJvd3NlcnMgYWJvdXQgc2V0dGluZyB1bnNhZmVcbiAgICAvLyBoZWFkZXJzLiBUbyBiZSBob25lc3QgSSdtIG5vdCBlbnRpcmVseSBzdXJlIGhpZGluZyB0aGVzZSB3YXJuaW5ncyBpcyBhIGdvb2QgdGhpbmcsIGJ1dFxuICAgIC8vIGh0dHAtYnJvd3NlcmlmeSBkaWQgaXQsIHNvIEkgd2lsbCB0b28uXG4gIGlmICh1bnNhZmVIZWFkZXJzLmluZGV4T2YobG93ZXJOYW1lKSAhPT0gLTEpXG4gICAgcmV0dXJuXG5cbiAgc2VsZi5faGVhZGVyc1tsb3dlck5hbWVdID0ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHNlbGYuX2hlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXS52YWx1ZVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWxldGUgc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoc2VsZi5fZGVzdHJveWVkKVxuICAgIHJldHVyblxuICB2YXIgb3B0cyA9IHNlbGYuX29wdHNcblxuICB2YXIgaGVhZGVyc09iaiA9IHNlbGYuX2hlYWRlcnNcbiAgdmFyIGJvZHlcbiAgaWYgKG9wdHMubWV0aG9kID09PSAnUE9TVCcgfHwgb3B0cy5tZXRob2QgPT09ICdQVVQnIHx8IG9wdHMubWV0aG9kID09PSAnUEFUQ0gnKSB7XG4gICAgaWYgKGNhcGFiaWxpdHkuYmxvYkNvbnN0cnVjdG9yKCkpIHtcbiAgICAgIGJvZHkgPSBuZXcgZ2xvYmFsLkJsb2Ioc2VsZi5fYm9keS5tYXAoZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB0b0FycmF5QnVmZmVyKGJ1ZmZlcilcbiAgICAgIH0pLCB7XG4gICAgICAgIHR5cGU6IChoZWFkZXJzT2JqWydjb250ZW50LXR5cGUnXSB8fCB7fSkudmFsdWUgfHwgJydcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldCB1dGY4IHN0cmluZ1xuICAgICAgYm9keSA9IEJ1ZmZlci5jb25jYXQoc2VsZi5fYm9keSkudG9TdHJpbmcoKVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxmLl9tb2RlID09PSAnZmV0Y2gnKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBPYmplY3Qua2V5cyhoZWFkZXJzT2JqKS5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIFtoZWFkZXJzT2JqW25hbWVdLm5hbWUsIGhlYWRlcnNPYmpbbmFtZV0udmFsdWVdXG4gICAgfSlcblxuICAgIGdsb2JhbC5mZXRjaChzZWxmLl9vcHRzLnVybCwge1xuICAgICAgbWV0aG9kOiBzZWxmLl9vcHRzLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBib2R5OiBib2R5LFxuICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgY3JlZGVudGlhbHM6IG9wdHMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJ1xuICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZVxuICAgICAgc2VsZi5fY29ubmVjdCgpXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgcmVhc29uKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdmFyIHhociA9IHNlbGYuX3hociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuICAgIHRyeSB7XG4gICAgICB4aHIub3BlbihzZWxmLl9vcHRzLm1ldGhvZCwgc2VsZi5fb3B0cy51cmwsIHRydWUpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIENhbid0IHNldCByZXNwb25zZVR5cGUgb24gcmVhbGx5IG9sZCBicm93c2Vyc1xuICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gc2VsZi5fbW9kZS5zcGxpdCgnOicpWzBdXG5cbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKVxuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0cy53aXRoQ3JlZGVudGlhbHNcblxuICAgIGlmIChzZWxmLl9tb2RlID09PSAndGV4dCcgJiYgJ292ZXJyaWRlTWltZVR5cGUnIGluIHhocilcbiAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJylcblxuICAgIE9iamVjdC5rZXlzKGhlYWRlcnNPYmopLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyc09ialtuYW1lXS5uYW1lLCBoZWFkZXJzT2JqW25hbWVdLnZhbHVlKVxuICAgIH0pXG5cbiAgICBzZWxmLl9yZXNwb25zZSA9IG51bGxcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIHJTdGF0ZXMuTE9BRElORzpcbiAgICAgIGNhc2UgclN0YXRlcy5ET05FOlxuICAgICAgICBzZWxmLl9vblhIUlByb2dyZXNzKClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgICAvLyBOZWNlc3NhcnkgZm9yIHN0cmVhbWluZyBpbiBGaXJlZm94LCBzaW5jZSB4aHIucmVzcG9uc2UgaXMgT05MWSBkZWZpbmVkXG4gICAgICAvLyBpbiBvbnByb2dyZXNzLCBub3QgaW4gb25yZWFkeXN0YXRlY2hhbmdlIHdpdGggeGhyLnJlYWR5U3RhdGUgPSAzXG4gICAgaWYgKHNlbGYuX21vZGUgPT09ICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcicpIHtcbiAgICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX29uWEhSUHJvZ3Jlc3MoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2VsZi5fZGVzdHJveWVkKVxuICAgICAgICByZXR1cm5cbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1hIUiBlcnJvcicpKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB4aHIuc2VuZChib2R5KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgeGhyLnN0YXR1cyBpcyByZWFkYWJsZSBhbmQgbm9uLXplcm8sIGluZGljYXRpbmcgbm8gZXJyb3IuXG4gKiBFdmVuIHRob3VnaCB0aGUgc3BlYyBzYXlzIGl0IHNob3VsZCBiZSBhdmFpbGFibGUgaW4gcmVhZHlTdGF0ZSAzLFxuICogYWNjZXNzaW5nIGl0IHRocm93cyBhbiBleGNlcHRpb24gaW4gSUU4XG4gKi9cbmZ1bmN0aW9uIHN0YXR1c1ZhbGlkKHhocikge1xuICB0cnkge1xuICAgIHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzXG4gICAgcmV0dXJuIChzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSAwKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKCFzdGF0dXNWYWxpZChzZWxmLl94aHIpIHx8IHNlbGYuX2Rlc3Ryb3llZClcbiAgICByZXR1cm5cblxuICBpZiAoIXNlbGYuX3Jlc3BvbnNlKVxuICAgIHNlbGYuX2Nvbm5lY3QoKVxuXG4gIHNlbGYuX3Jlc3BvbnNlLl9vblhIUlByb2dyZXNzKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYuX2Rlc3Ryb3llZClcbiAgICByZXR1cm5cblxuICBzZWxmLl9yZXNwb25zZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2Uoc2VsZi5feGhyLCBzZWxmLl9mZXRjaFJlc3BvbnNlLCBzZWxmLl9tb2RlKVxuICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgc2VsZi5fcmVzcG9uc2UpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgc2VsZi5fYm9keS5wdXNoKGNodW5rKVxuICBjYigpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVzdHJveWVkID0gdHJ1ZVxuICBpZiAoc2VsZi5fcmVzcG9uc2UpXG4gICAgc2VsZi5fcmVzcG9uc2UuX2Rlc3Ryb3llZCA9IHRydWVcbiAgaWYgKHNlbGYuX3hocilcbiAgICBzZWxmLl94aHIuYWJvcnQoKVxuICAgIC8vIEN1cnJlbnRseSwgdGhlcmUgaXNuJ3QgYSB3YXkgdG8gdHJ1bHkgYWJvcnQgYSBmZXRjaC5cbiAgICAvLyBJZiB5b3UgbGlrZSBiaWtlc2hlZGRpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8yN1xufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZGF0YVxuICAgIGRhdGEgPSB1bmRlZmluZWRcbiAgfVxuXG4gIFdyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbChzZWxmLCBkYXRhLCBlbmNvZGluZywgY2IpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmZsdXNoSGVhZGVycyA9IGZ1bmN0aW9uKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXROb0RlbGF5ID0gZnVuY3Rpb24oKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0U29ja2V0S2VlcEFsaXZlID0gZnVuY3Rpb24oKSB7fVxuIiwiLypcbnRoaXMgYW5kIGh0dHAtbGliIGZvbGRlclxuXG5UaGUgTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE1IEpvaG4gSGllc2V5XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLFxudG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kXG5hc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbm1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob21cbnRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG5zdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2VcbnNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG5PRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXG5BTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5TT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cbmltcG9ydCBDbGllbnRSZXF1ZXN0IGZyb20gJy4vaHR0cC1saWIvcmVxdWVzdCc7XG5pbXBvcnQge3BhcnNlfSBmcm9tICd1cmwnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdChvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKVxuICAgIG9wdHMgPSBwYXJzZShvcHRzKVxuXG5cbiAgLy8gTm9ybWFsbHksIHRoZSBwYWdlIGlzIGxvYWRlZCBmcm9tIGh0dHAgb3IgaHR0cHMsIHNvIG5vdCBzcGVjaWZ5aW5nIGEgcHJvdG9jb2xcbiAgLy8gd2lsbCByZXN1bHQgaW4gYSAodmFsaWQpIHByb3RvY29sLXJlbGF0aXZlIHVybC4gSG93ZXZlciwgdGhpcyB3b24ndCB3b3JrIGlmXG4gIC8vIHRoZSBwcm90b2NvbCBpcyBzb21ldGhpbmcgZWxzZSwgbGlrZSAnZmlsZTonXG4gIHZhciBkZWZhdWx0UHJvdG9jb2wgPSBnbG9iYWwubG9jYXRpb24ucHJvdG9jb2wuc2VhcmNoKC9eaHR0cHM/OiQvKSA9PT0gLTEgPyAnaHR0cDonIDogJydcblxuICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8IGRlZmF1bHRQcm90b2NvbFxuICB2YXIgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG4gIHZhciBwb3J0ID0gb3B0cy5wb3J0XG4gIHZhciBwYXRoID0gb3B0cy5wYXRoIHx8ICcvJ1xuXG4gIC8vIE5lY2Vzc2FyeSBmb3IgSVB2NiBhZGRyZXNzZXNcbiAgaWYgKGhvc3QgJiYgaG9zdC5pbmRleE9mKCc6JykgIT09IC0xKVxuICAgIGhvc3QgPSAnWycgKyBob3N0ICsgJ10nXG5cbiAgLy8gVGhpcyBtYXkgYmUgYSByZWxhdGl2ZSB1cmwuIFRoZSBicm93c2VyIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuICBvcHRzLnVybCA9IChob3N0ID8gKHByb3RvY29sICsgJy8vJyArIGhvc3QpIDogJycpICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpICsgcGF0aFxuICBvcHRzLm1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge31cblxuICAvLyBBbHNvIHZhbGlkIG9wdHMuYXV0aCwgb3B0cy5tb2RlXG5cbiAgdmFyIHJlcSA9IG5ldyBDbGllbnRSZXF1ZXN0KG9wdHMpXG4gIGlmIChjYilcbiAgICByZXEub24oJ3Jlc3BvbnNlJywgY2IpXG4gIHJldHVybiByZXFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldChvcHRzLCBjYikge1xuICB2YXIgcmVxID0gcmVxdWVzdChvcHRzLCBjYilcbiAgcmVxLmVuZCgpXG4gIHJldHVybiByZXFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEFnZW50KCkge31cbkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNFxuXG5leHBvcnQgdmFyIE1FVEhPRFMgPSBbXG4gICdDSEVDS09VVCcsXG4gICdDT05ORUNUJyxcbiAgJ0NPUFknLFxuICAnREVMRVRFJyxcbiAgJ0dFVCcsXG4gICdIRUFEJyxcbiAgJ0xPQ0snLFxuICAnTS1TRUFSQ0gnLFxuICAnTUVSR0UnLFxuICAnTUtBQ1RJVklUWScsXG4gICdNS0NPTCcsXG4gICdNT1ZFJyxcbiAgJ05PVElGWScsXG4gICdPUFRJT05TJyxcbiAgJ1BBVENIJyxcbiAgJ1BPU1QnLFxuICAnUFJPUEZJTkQnLFxuICAnUFJPUFBBVENIJyxcbiAgJ1BVUkdFJyxcbiAgJ1BVVCcsXG4gICdSRVBPUlQnLFxuICAnU0VBUkNIJyxcbiAgJ1NVQlNDUklCRScsXG4gICdUUkFDRScsXG4gICdVTkxPQ0snLFxuICAnVU5TVUJTQ1JJQkUnXG5dXG5leHBvcnQgdmFyIFNUQVRVU19DT0RFUyA9IHtcbiAgMTAwOiAnQ29udGludWUnLFxuICAxMDE6ICdTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgMTAyOiAnUHJvY2Vzc2luZycsIC8vIFJGQyAyNTE4LCBvYnNvbGV0ZWQgYnkgUkZDIDQ5MThcbiAgMjAwOiAnT0snLFxuICAyMDE6ICdDcmVhdGVkJyxcbiAgMjAyOiAnQWNjZXB0ZWQnLFxuICAyMDM6ICdOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvbicsXG4gIDIwNDogJ05vIENvbnRlbnQnLFxuICAyMDU6ICdSZXNldCBDb250ZW50JyxcbiAgMjA2OiAnUGFydGlhbCBDb250ZW50JyxcbiAgMjA3OiAnTXVsdGktU3RhdHVzJywgLy8gUkZDIDQ5MThcbiAgMzAwOiAnTXVsdGlwbGUgQ2hvaWNlcycsXG4gIDMwMTogJ01vdmVkIFBlcm1hbmVudGx5JyxcbiAgMzAyOiAnTW92ZWQgVGVtcG9yYXJpbHknLFxuICAzMDM6ICdTZWUgT3RoZXInLFxuICAzMDQ6ICdOb3QgTW9kaWZpZWQnLFxuICAzMDU6ICdVc2UgUHJveHknLFxuICAzMDc6ICdUZW1wb3JhcnkgUmVkaXJlY3QnLFxuICA0MDA6ICdCYWQgUmVxdWVzdCcsXG4gIDQwMTogJ1VuYXV0aG9yaXplZCcsXG4gIDQwMjogJ1BheW1lbnQgUmVxdWlyZWQnLFxuICA0MDM6ICdGb3JiaWRkZW4nLFxuICA0MDQ6ICdOb3QgRm91bmQnLFxuICA0MDU6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuICA0MDY6ICdOb3QgQWNjZXB0YWJsZScsXG4gIDQwNzogJ1Byb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJyxcbiAgNDA4OiAnUmVxdWVzdCBUaW1lLW91dCcsXG4gIDQwOTogJ0NvbmZsaWN0JyxcbiAgNDEwOiAnR29uZScsXG4gIDQxMTogJ0xlbmd0aCBSZXF1aXJlZCcsXG4gIDQxMjogJ1ByZWNvbmRpdGlvbiBGYWlsZWQnLFxuICA0MTM6ICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnLFxuICA0MTQ6ICdSZXF1ZXN0LVVSSSBUb28gTGFyZ2UnLFxuICA0MTU6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcbiAgNDE2OiAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZScsXG4gIDQxNzogJ0V4cGVjdGF0aW9uIEZhaWxlZCcsXG4gIDQxODogJ0lcXCdtIGEgdGVhcG90JywgLy8gUkZDIDIzMjRcbiAgNDIyOiAnVW5wcm9jZXNzYWJsZSBFbnRpdHknLCAvLyBSRkMgNDkxOFxuICA0MjM6ICdMb2NrZWQnLCAvLyBSRkMgNDkxOFxuICA0MjQ6ICdGYWlsZWQgRGVwZW5kZW5jeScsIC8vIFJGQyA0OTE4XG4gIDQyNTogJ1Vub3JkZXJlZCBDb2xsZWN0aW9uJywgLy8gUkZDIDQ5MThcbiAgNDI2OiAnVXBncmFkZSBSZXF1aXJlZCcsIC8vIFJGQyAyODE3XG4gIDQyODogJ1ByZWNvbmRpdGlvbiBSZXF1aXJlZCcsIC8vIFJGQyA2NTg1XG4gIDQyOTogJ1RvbyBNYW55IFJlcXVlc3RzJywgLy8gUkZDIDY1ODVcbiAgNDMxOiAnUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZScsIC8vIFJGQyA2NTg1XG4gIDUwMDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gIDUwMTogJ05vdCBJbXBsZW1lbnRlZCcsXG4gIDUwMjogJ0JhZCBHYXRld2F5JyxcbiAgNTAzOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG4gIDUwNDogJ0dhdGV3YXkgVGltZS1vdXQnLFxuICA1MDU6ICdIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZCcsXG4gIDUwNjogJ1ZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzJywgLy8gUkZDIDIyOTVcbiAgNTA3OiAnSW5zdWZmaWNpZW50IFN0b3JhZ2UnLCAvLyBSRkMgNDkxOFxuICA1MDk6ICdCYW5kd2lkdGggTGltaXQgRXhjZWVkZWQnLFxuICA1MTA6ICdOb3QgRXh0ZW5kZWQnLCAvLyBSRkMgMjc3NFxuICA1MTE6ICdOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJyAvLyBSRkMgNjU4NVxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICByZXF1ZXN0LFxuICBnZXQsXG4gIEFnZW50LFxuICBNRVRIT0RTLFxuICBTVEFUVVNfQ09ERVNcbn1cbiIsInZhciBkZWJ1ZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghZGVidWcpIHtcbiAgICB0cnkge1xuICAgICAgLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiBvZmYgKi9cbiAgICAgIGRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpKFwiZm9sbG93LXJlZGlyZWN0c1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IC8qICovIH1cbiAgICBpZiAodHlwZW9mIGRlYnVnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRlYnVnID0gZnVuY3Rpb24gKCkgeyAvKiAqLyB9O1xuICAgIH1cbiAgfVxuICBkZWJ1Zy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbiIsInZhciB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xudmFyIFVSTCA9IHVybC5VUkw7XG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xudmFyIGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZShcInN0cmVhbVwiKS5Xcml0YWJsZTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIGRlYnVnID0gcmVxdWlyZShcIi4vZGVidWdcIik7XG5cbi8vIENyZWF0ZSBoYW5kbGVycyB0aGF0IHBhc3MgZXZlbnRzIGZyb20gbmF0aXZlIHJlcXVlc3RzXG52YXIgZXZlbnRzID0gW1wiYWJvcnRcIiwgXCJhYm9ydGVkXCIsIFwiY29ubmVjdFwiLCBcImVycm9yXCIsIFwic29ja2V0XCIsIFwidGltZW91dFwiXTtcbnZhciBldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICBldmVudEhhbmRsZXJzW2V2ZW50XSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgdGhpcy5fcmVkaXJlY3RhYmxlLmVtaXQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9O1xufSk7XG5cbi8vIEVycm9yIHR5cGVzIHdpdGggY29kZXNcbnZhciBSZWRpcmVjdGlvbkVycm9yID0gY3JlYXRlRXJyb3JUeXBlKFxuICBcIkVSUl9GUl9SRURJUkVDVElPTl9GQUlMVVJFXCIsXG4gIFwiUmVkaXJlY3RlZCByZXF1ZXN0IGZhaWxlZFwiXG4pO1xudmFyIFRvb01hbnlSZWRpcmVjdHNFcnJvciA9IGNyZWF0ZUVycm9yVHlwZShcbiAgXCJFUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTXCIsXG4gIFwiTWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzIGV4Y2VlZGVkXCJcbik7XG52YXIgTWF4Qm9keUxlbmd0aEV4Y2VlZGVkRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXG4gIFwiRVJSX0ZSX01BWF9CT0RZX0xFTkdUSF9FWENFRURFRFwiLFxuICBcIlJlcXVlc3QgYm9keSBsYXJnZXIgdGhhbiBtYXhCb2R5TGVuZ3RoIGxpbWl0XCJcbik7XG52YXIgV3JpdGVBZnRlckVuZEVycm9yID0gY3JlYXRlRXJyb3JUeXBlKFxuICBcIkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EXCIsXG4gIFwid3JpdGUgYWZ0ZXIgZW5kXCJcbik7XG5cbi8vIEFuIEhUVFAoUykgcmVxdWVzdCB0aGF0IGNhbiBiZSByZWRpcmVjdGVkXG5mdW5jdGlvbiBSZWRpcmVjdGFibGVSZXF1ZXN0KG9wdGlvbnMsIHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVxdWVzdFxuICBXcml0YWJsZS5jYWxsKHRoaXMpO1xuICB0aGlzLl9zYW5pdGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICB0aGlzLl9lbmRpbmcgPSBmYWxzZTtcbiAgdGhpcy5fcmVkaXJlY3RDb3VudCA9IDA7XG4gIHRoaXMuX3JlZGlyZWN0cyA9IFtdO1xuICB0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCA9IDA7XG4gIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xuXG4gIC8vIEF0dGFjaCBhIGNhbGxiYWNrIGlmIHBhc3NlZFxuICBpZiAocmVzcG9uc2VDYWxsYmFjaykge1xuICAgIHRoaXMub24oXCJyZXNwb25zZVwiLCByZXNwb25zZUNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFJlYWN0IHRvIHJlc3BvbnNlcyBvZiBuYXRpdmUgcmVxdWVzdHNcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9vbk5hdGl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgc2VsZi5fcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIHRoZSBmaXJzdCByZXF1ZXN0XG4gIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KCk7XG59XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGUucHJvdG90eXBlKTtcblxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIGFib3J0UmVxdWVzdCh0aGlzLl9jdXJyZW50UmVxdWVzdCk7XG4gIHRoaXMuZW1pdChcImFib3J0XCIpO1xufTtcblxuLy8gV3JpdGVzIGJ1ZmZlcmVkIGRhdGEgdG8gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAvLyBXcml0aW5nIGlzIG5vdCBhbGxvd2VkIGlmIGVuZCBoYXMgYmVlbiBjYWxsZWRcbiAgaWYgKHRoaXMuX2VuZGluZykge1xuICAgIHRocm93IG5ldyBXcml0ZUFmdGVyRW5kRXJyb3IoKTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGlucHV0IGFuZCBzaGlmdCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxuICBpZiAoISh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAoXCJsZW5ndGhcIiBpbiBkYXRhKSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSBzaG91bGQgYmUgYSBzdHJpbmcsIEJ1ZmZlciBvciBVaW50OEFycmF5XCIpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhbGxiYWNrID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgLy8gSWdub3JlIGVtcHR5IGJ1ZmZlcnMsIHNpbmNlIHdyaXRpbmcgdGhlbSBkb2Vzbid0IGludm9rZSB0aGUgY2FsbGJhY2tcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yMjA2NlxuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAvLyBPbmx5IHdyaXRlIHdoZW4gd2UgZG9uJ3QgZXhjZWVkIHRoZSBtYXhpbXVtIGJvZHkgbGVuZ3RoXG4gIGlmICh0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCArIGRhdGEubGVuZ3RoIDw9IHRoaXMuX29wdGlvbnMubWF4Qm9keUxlbmd0aCkge1xuICAgIHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycy5wdXNoKHsgZGF0YTogZGF0YSwgZW5jb2Rpbmc6IGVuY29kaW5nIH0pO1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LndyaXRlKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gIH1cbiAgLy8gRXJyb3Igd2hlbiB3ZSBleGNlZWQgdGhlIG1heGltdW0gYm9keSBsZW5ndGhcbiAgZWxzZSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IE1heEJvZHlMZW5ndGhFeGNlZWRlZEVycm9yKCkpO1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgfVxufTtcblxuLy8gRW5kcyB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAvLyBTaGlmdCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICBkYXRhID0gZW5jb2RpbmcgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICAvLyBXcml0ZSBkYXRhIGlmIG5lZWRlZCBhbmQgZW5kXG4gIGlmICghZGF0YSkge1xuICAgIHRoaXMuX2VuZGVkID0gdGhpcy5fZW5kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9jdXJyZW50UmVxdWVzdC5lbmQobnVsbCwgbnVsbCwgY2FsbGJhY2spO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudFJlcXVlc3QgPSB0aGlzLl9jdXJyZW50UmVxdWVzdDtcbiAgICB0aGlzLndyaXRlKGRhdGEsIGVuY29kaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWU7XG4gICAgICBjdXJyZW50UmVxdWVzdC5lbmQobnVsbCwgbnVsbCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIHRoaXMuX2VuZGluZyA9IHRydWU7XG4gIH1cbn07XG5cbi8vIFNldHMgYSBoZWFkZXIgdmFsdWUgb24gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB0aGlzLl9vcHRpb25zLmhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgdGhpcy5fY3VycmVudFJlcXVlc3Quc2V0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbn07XG5cbi8vIENsZWFycyBhIGhlYWRlciB2YWx1ZSBvbiB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMuX29wdGlvbnMuaGVhZGVyc1tuYW1lXTtcbiAgdGhpcy5fY3VycmVudFJlcXVlc3QucmVtb3ZlSGVhZGVyKG5hbWUpO1xufTtcblxuLy8gR2xvYmFsIHRpbWVvdXQgZm9yIGFsbCB1bmRlcmx5aW5nIHJlcXVlc3RzXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKG1zZWNzLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gRGVzdHJveXMgdGhlIHNvY2tldCBvbiB0aW1lb3V0XG4gIGZ1bmN0aW9uIGRlc3Ryb3lPblRpbWVvdXQoc29ja2V0KSB7XG4gICAgc29ja2V0LnNldFRpbWVvdXQobXNlY3MpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcihcInRpbWVvdXRcIiwgc29ja2V0LmRlc3Ryb3kpO1xuICAgIHNvY2tldC5hZGRMaXN0ZW5lcihcInRpbWVvdXRcIiwgc29ja2V0LmRlc3Ryb3kpO1xuICB9XG5cbiAgLy8gU2V0cyB1cCBhIHRpbWVyIHRvIHRyaWdnZXIgYSB0aW1lb3V0IGV2ZW50XG4gIGZ1bmN0aW9uIHN0YXJ0VGltZXIoc29ja2V0KSB7XG4gICAgaWYgKHNlbGYuX3RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcbiAgICB9XG4gICAgc2VsZi5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KFwidGltZW91dFwiKTtcbiAgICAgIGNsZWFyVGltZXIoKTtcbiAgICB9LCBtc2Vjcyk7XG4gICAgZGVzdHJveU9uVGltZW91dChzb2NrZXQpO1xuICB9XG5cbiAgLy8gU3RvcHMgYSB0aW1lb3V0IGZyb20gdHJpZ2dlcmluZ1xuICBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgIC8vIENsZWFyIHRoZSB0aW1lb3V0XG4gICAgaWYgKHNlbGYuX3RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcbiAgICAgIHNlbGYuX3RpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGFsbCBhdHRhY2hlZCBsaXN0ZW5lcnNcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwiYWJvcnRcIiwgY2xlYXJUaW1lcik7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIGNsZWFyVGltZXIpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoXCJyZXNwb25zZVwiLCBjbGVhclRpbWVyKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoXCJ0aW1lb3V0XCIsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKCFzZWxmLnNvY2tldCkge1xuICAgICAgc2VsZi5fY3VycmVudFJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoXCJzb2NrZXRcIiwgc3RhcnRUaW1lcik7XG4gICAgfVxuICB9XG5cbiAgLy8gQXR0YWNoIGNhbGxiYWNrIGlmIHBhc3NlZFxuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9uKFwidGltZW91dFwiLCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTdGFydCB0aGUgdGltZXIgaWYgb3Igd2hlbiB0aGUgc29ja2V0IGlzIG9wZW5lZFxuICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICBzdGFydFRpbWVyKHRoaXMuc29ja2V0KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLl9jdXJyZW50UmVxdWVzdC5vbmNlKFwic29ja2V0XCIsIHN0YXJ0VGltZXIpO1xuICB9XG5cbiAgLy8gQ2xlYW4gdXAgb24gZXZlbnRzXG4gIHRoaXMub24oXCJzb2NrZXRcIiwgZGVzdHJveU9uVGltZW91dCk7XG4gIHRoaXMub24oXCJhYm9ydFwiLCBjbGVhclRpbWVyKTtcbiAgdGhpcy5vbihcImVycm9yXCIsIGNsZWFyVGltZXIpO1xuICB0aGlzLm9uKFwicmVzcG9uc2VcIiwgY2xlYXJUaW1lcik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQcm94eSBhbGwgb3RoZXIgcHVibGljIENsaWVudFJlcXVlc3QgbWV0aG9kc1xuW1xuICBcImZsdXNoSGVhZGVyc1wiLCBcImdldEhlYWRlclwiLFxuICBcInNldE5vRGVsYXlcIiwgXCJzZXRTb2NrZXRLZWVwQWxpdmVcIixcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIFJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFttZXRob2RdKGEsIGIpO1xuICB9O1xufSk7XG5cbi8vIFByb3h5IGFsbCBwdWJsaWMgQ2xpZW50UmVxdWVzdCBwcm9wZXJ0aWVzXG5bXCJhYm9ydGVkXCIsIFwiY29ubmVjdGlvblwiLCBcInNvY2tldFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFtwcm9wZXJ0eV07IH0sXG4gIH0pO1xufSk7XG5cblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLl9zYW5pdGl6ZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyBFbnN1cmUgaGVhZGVycyBhcmUgYWx3YXlzIHByZXNlbnRcbiAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgfVxuXG4gIC8vIFNpbmNlIGh0dHAucmVxdWVzdCB0cmVhdHMgaG9zdCBhcyBhbiBhbGlhcyBvZiBob3N0bmFtZSxcbiAgLy8gYnV0IHRoZSB1cmwgbW9kdWxlIGludGVycHJldHMgaG9zdCBhcyBob3N0bmFtZSBwbHVzIHBvcnQsXG4gIC8vIGVsaW1pbmF0ZSB0aGUgaG9zdCBwcm9wZXJ0eSB0byBhdm9pZCBjb25mdXNpb24uXG4gIGlmIChvcHRpb25zLmhvc3QpIHtcbiAgICAvLyBVc2UgaG9zdG5hbWUgaWYgc2V0LCBiZWNhdXNlIGl0IGhhcyBwcmVjZWRlbmNlXG4gICAgaWYgKCFvcHRpb25zLmhvc3RuYW1lKSB7XG4gICAgICBvcHRpb25zLmhvc3RuYW1lID0gb3B0aW9ucy5ob3N0O1xuICAgIH1cbiAgICBkZWxldGUgb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgLy8gQ29tcGxldGUgdGhlIFVSTCBvYmplY3Qgd2hlbiBuZWNlc3NhcnlcbiAgaWYgKCFvcHRpb25zLnBhdGhuYW1lICYmIG9wdGlvbnMucGF0aCkge1xuICAgIHZhciBzZWFyY2hQb3MgPSBvcHRpb25zLnBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaFBvcyA8IDApIHtcbiAgICAgIG9wdGlvbnMucGF0aG5hbWUgPSBvcHRpb25zLnBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucy5wYXRobmFtZSA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoMCwgc2VhcmNoUG9zKTtcbiAgICAgIG9wdGlvbnMuc2VhcmNoID0gb3B0aW9ucy5wYXRoLnN1YnN0cmluZyhzZWFyY2hQb3MpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vLyBFeGVjdXRlcyB0aGUgbmV4dCBuYXRpdmUgcmVxdWVzdCAoaW5pdGlhbCBvciByZWRpcmVjdClcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLl9wZXJmb3JtUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gTG9hZCB0aGUgbmF0aXZlIHByb3RvY29sXG4gIHZhciBwcm90b2NvbCA9IHRoaXMuX29wdGlvbnMucHJvdG9jb2w7XG4gIHZhciBuYXRpdmVQcm90b2NvbCA9IHRoaXMuX29wdGlvbnMubmF0aXZlUHJvdG9jb2xzW3Byb3RvY29sXTtcbiAgaWYgKCFuYXRpdmVQcm90b2NvbCkge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBwcm90b2NvbCBcIiArIHByb3RvY29sKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgc3BlY2lmaWVkLCB1c2UgdGhlIGFnZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3RvY29sXG4gIC8vIChIVFRQIGFuZCBIVFRQUyB1c2UgZGlmZmVyZW50IHR5cGVzIG9mIGFnZW50cylcbiAgaWYgKHRoaXMuX29wdGlvbnMuYWdlbnRzKSB7XG4gICAgdmFyIHNjaGVtZSA9IHByb3RvY29sLnN1YnN0cigwLCBwcm90b2NvbC5sZW5ndGggLSAxKTtcbiAgICB0aGlzLl9vcHRpb25zLmFnZW50ID0gdGhpcy5fb3B0aW9ucy5hZ2VudHNbc2NoZW1lXTtcbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgbmF0aXZlIHJlcXVlc3RcbiAgdmFyIHJlcXVlc3QgPSB0aGlzLl9jdXJyZW50UmVxdWVzdCA9XG4gICAgICAgIG5hdGl2ZVByb3RvY29sLnJlcXVlc3QodGhpcy5fb3B0aW9ucywgdGhpcy5fb25OYXRpdmVSZXNwb25zZSk7XG4gIHRoaXMuX2N1cnJlbnRVcmwgPSB1cmwuZm9ybWF0KHRoaXMuX29wdGlvbnMpO1xuXG4gIC8vIFNldCB1cCBldmVudCBoYW5kbGVyc1xuICByZXF1ZXN0Ll9yZWRpcmVjdGFibGUgPSB0aGlzO1xuICBmb3IgKHZhciBlID0gMDsgZSA8IGV2ZW50cy5sZW5ndGg7IGUrKykge1xuICAgIHJlcXVlc3Qub24oZXZlbnRzW2VdLCBldmVudEhhbmRsZXJzW2V2ZW50c1tlXV0pO1xuICB9XG5cbiAgLy8gRW5kIGEgcmVkaXJlY3RlZCByZXF1ZXN0XG4gIC8vIChUaGUgZmlyc3QgcmVxdWVzdCBtdXN0IGJlIGVuZGVkIGV4cGxpY2l0bHkgd2l0aCBSZWRpcmVjdGFibGVSZXF1ZXN0I2VuZClcbiAgaWYgKHRoaXMuX2lzUmVkaXJlY3QpIHtcbiAgICAvLyBXcml0ZSB0aGUgcmVxdWVzdCBlbnRpdHkgYW5kIGVuZC5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBidWZmZXJzID0gdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzO1xuICAgIChmdW5jdGlvbiB3cml0ZU5leHQoZXJyb3IpIHtcbiAgICAgIC8vIE9ubHkgd3JpdGUgaWYgdGhpcyByZXF1ZXN0IGhhcyBub3QgYmVlbiByZWRpcmVjdGVkIHlldFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChyZXF1ZXN0ID09PSBzZWxmLl9jdXJyZW50UmVxdWVzdCkge1xuICAgICAgICAvLyBSZXBvcnQgYW55IHdyaXRlIGVycm9yc1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIHRoZSBuZXh0IGJ1ZmZlciBpZiB0aGVyZSBhcmUgc3RpbGwgbGVmdFxuICAgICAgICBlbHNlIGlmIChpIDwgYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpKytdO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKCFyZXF1ZXN0LmZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXF1ZXN0LndyaXRlKGJ1ZmZlci5kYXRhLCBidWZmZXIuZW5jb2RpbmcsIHdyaXRlTmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVuZCB0aGUgcmVxdWVzdCBpZiBgZW5kYCBoYXMgYmVlbiBjYWxsZWQgb24gdXNcbiAgICAgICAgZWxzZSBpZiAoc2VsZi5fZW5kZWQpIHtcbiAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSgpKTtcbiAgfVxufTtcblxuLy8gUHJvY2Vzc2VzIGEgcmVzcG9uc2UgZnJvbSB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3Byb2Nlc3NSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAvLyBTdG9yZSB0aGUgcmVkaXJlY3RlZCByZXNwb25zZVxuICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gIGlmICh0aGlzLl9vcHRpb25zLnRyYWNrUmVkaXJlY3RzKSB7XG4gICAgdGhpcy5fcmVkaXJlY3RzLnB1c2goe1xuICAgICAgdXJsOiB0aGlzLl9jdXJyZW50VXJsLFxuICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsXG4gICAgfSk7XG4gIH1cblxuICAvLyBSRkM3MjMxwqc2LjQ6IFRoZSAzeHggKFJlZGlyZWN0aW9uKSBjbGFzcyBvZiBzdGF0dXMgY29kZSBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBmdXJ0aGVyIGFjdGlvbiBuZWVkcyB0byBiZSB0YWtlbiBieSB0aGUgdXNlciBhZ2VudCBpbiBvcmRlciB0b1xuICAvLyBmdWxmaWxsIHRoZSByZXF1ZXN0LiBJZiBhIExvY2F0aW9uIGhlYWRlciBmaWVsZCBpcyBwcm92aWRlZCxcbiAgLy8gdGhlIHVzZXIgYWdlbnQgTUFZIGF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaXRzIHJlcXVlc3QgdG8gdGhlIFVSSVxuICAvLyByZWZlcmVuY2VkIGJ5IHRoZSBMb2NhdGlvbiBmaWVsZCB2YWx1ZSxcbiAgLy8gZXZlbiBpZiB0aGUgc3BlY2lmaWMgc3RhdHVzIGNvZGUgaXMgbm90IHVuZGVyc3Rvb2QuXG5cbiAgLy8gSWYgdGhlIHJlc3BvbnNlIGlzIG5vdCBhIHJlZGlyZWN0OyByZXR1cm4gaXQgYXMtaXNcbiAgdmFyIGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbjtcbiAgaWYgKCFsb2NhdGlvbiB8fCB0aGlzLl9vcHRpb25zLmZvbGxvd1JlZGlyZWN0cyA9PT0gZmFsc2UgfHxcbiAgICAgIHN0YXR1c0NvZGUgPCAzMDAgfHwgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICByZXNwb25zZS5yZXNwb25zZVVybCA9IHRoaXMuX2N1cnJlbnRVcmw7XG4gICAgcmVzcG9uc2UucmVkaXJlY3RzID0gdGhpcy5fcmVkaXJlY3RzO1xuICAgIHRoaXMuZW1pdChcInJlc3BvbnNlXCIsIHJlc3BvbnNlKTtcblxuICAgIC8vIENsZWFuIHVwXG4gICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QsIHNvIGFib3J0IHRoZSBjdXJyZW50IHJlcXVlc3RcbiAgYWJvcnRSZXF1ZXN0KHRoaXMuX2N1cnJlbnRSZXF1ZXN0KTtcbiAgLy8gRGlzY2FyZCB0aGUgcmVtYWluZGVyIG9mIHRoZSByZXNwb25zZSB0byBhdm9pZCB3YWl0aW5nIGZvciBkYXRhXG4gIHJlc3BvbnNlLmRlc3Ryb3koKTtcblxuICAvLyBSRkM3MjMxwqc2LjQ6IEEgY2xpZW50IFNIT1VMRCBkZXRlY3QgYW5kIGludGVydmVuZVxuICAvLyBpbiBjeWNsaWNhbCByZWRpcmVjdGlvbnMgKGkuZS4sIFwiaW5maW5pdGVcIiByZWRpcmVjdGlvbiBsb29wcykuXG4gIGlmICgrK3RoaXMuX3JlZGlyZWN0Q291bnQgPiB0aGlzLl9vcHRpb25zLm1heFJlZGlyZWN0cykge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBUb29NYW55UmVkaXJlY3RzRXJyb3IoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUkZDNzIzMcKnNi40OiBBdXRvbWF0aWMgcmVkaXJlY3Rpb24gbmVlZHMgdG8gZG9uZSB3aXRoXG4gIC8vIGNhcmUgZm9yIG1ldGhvZHMgbm90IGtub3duIHRvIGJlIHNhZmUsIFvigKZdXG4gIC8vIFJGQzcyMzHCpzYuNC4y4oCTMzogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgYSB1c2VyIGFnZW50IE1BWSBjaGFuZ2VcbiAgLy8gdGhlIHJlcXVlc3QgbWV0aG9kIGZyb20gUE9TVCB0byBHRVQgZm9yIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3QuXG4gIGlmICgoc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHN0YXR1c0NvZGUgPT09IDMwMikgJiYgdGhpcy5fb3B0aW9ucy5tZXRob2QgPT09IFwiUE9TVFwiIHx8XG4gICAgICAvLyBSRkM3MjMxwqc2LjQuNDogVGhlIDMwMyAoU2VlIE90aGVyKSBzdGF0dXMgY29kZSBpbmRpY2F0ZXMgdGhhdFxuICAgICAgLy8gdGhlIHNlcnZlciBpcyByZWRpcmVjdGluZyB0aGUgdXNlciBhZ2VudCB0byBhIGRpZmZlcmVudCByZXNvdXJjZSBb4oCmXVxuICAgICAgLy8gQSB1c2VyIGFnZW50IGNhbiBwZXJmb3JtIGEgcmV0cmlldmFsIHJlcXVlc3QgdGFyZ2V0aW5nIHRoYXQgVVJJXG4gICAgICAvLyAoYSBHRVQgb3IgSEVBRCByZXF1ZXN0IGlmIHVzaW5nIEhUVFApIFvigKZdXG4gICAgICAoc3RhdHVzQ29kZSA9PT0gMzAzKSAmJiAhL14oPzpHRVR8SEVBRCkkLy50ZXN0KHRoaXMuX29wdGlvbnMubWV0aG9kKSkge1xuICAgIHRoaXMuX29wdGlvbnMubWV0aG9kID0gXCJHRVRcIjtcbiAgICAvLyBEcm9wIGEgcG9zc2libGUgZW50aXR5IGFuZCBoZWFkZXJzIHJlbGF0ZWQgdG8gaXRcbiAgICB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnMgPSBbXTtcbiAgICByZW1vdmVNYXRjaGluZ0hlYWRlcnMoL15jb250ZW50LS9pLCB0aGlzLl9vcHRpb25zLmhlYWRlcnMpO1xuICB9XG5cbiAgLy8gRHJvcCB0aGUgSG9zdCBoZWFkZXIsIGFzIHRoZSByZWRpcmVjdCBtaWdodCBsZWFkIHRvIGEgZGlmZmVyZW50IGhvc3RcbiAgdmFyIGN1cnJlbnRIb3N0SGVhZGVyID0gcmVtb3ZlTWF0Y2hpbmdIZWFkZXJzKC9eaG9zdCQvaSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTtcblxuICAvLyBJZiB0aGUgcmVkaXJlY3QgaXMgcmVsYXRpdmUsIGNhcnJ5IG92ZXIgdGhlIGhvc3Qgb2YgdGhlIGxhc3QgcmVxdWVzdFxuICB2YXIgY3VycmVudFVybFBhcnRzID0gdXJsLnBhcnNlKHRoaXMuX2N1cnJlbnRVcmwpO1xuICB2YXIgY3VycmVudEhvc3QgPSBjdXJyZW50SG9zdEhlYWRlciB8fCBjdXJyZW50VXJsUGFydHMuaG9zdDtcbiAgdmFyIGN1cnJlbnRVcmwgPSAvXlxcdys6Ly50ZXN0KGxvY2F0aW9uKSA/IHRoaXMuX2N1cnJlbnRVcmwgOlxuICAgIHVybC5mb3JtYXQoT2JqZWN0LmFzc2lnbihjdXJyZW50VXJsUGFydHMsIHsgaG9zdDogY3VycmVudEhvc3QgfSkpO1xuXG4gIC8vIERldGVybWluZSB0aGUgVVJMIG9mIHRoZSByZWRpcmVjdGlvblxuICB2YXIgcmVkaXJlY3RVcmw7XG4gIHRyeSB7XG4gICAgcmVkaXJlY3RVcmwgPSB1cmwucmVzb2x2ZShjdXJyZW50VXJsLCBsb2NhdGlvbik7XG4gIH1cbiAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IFJlZGlyZWN0aW9uRXJyb3IoY2F1c2UpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIHJlZGlyZWN0ZWQgcmVxdWVzdFxuICBkZWJ1ZyhcInJlZGlyZWN0aW5nIHRvXCIsIHJlZGlyZWN0VXJsKTtcbiAgdGhpcy5faXNSZWRpcmVjdCA9IHRydWU7XG4gIHZhciByZWRpcmVjdFVybFBhcnRzID0gdXJsLnBhcnNlKHJlZGlyZWN0VXJsKTtcbiAgT2JqZWN0LmFzc2lnbih0aGlzLl9vcHRpb25zLCByZWRpcmVjdFVybFBhcnRzKTtcblxuICAvLyBEcm9wIGNvbmZpZGVudGlhbCBoZWFkZXJzIHdoZW4gcmVkaXJlY3RpbmcgdG8gYSBsZXNzIHNlY3VyZSBwcm90b2NvbFxuICAvLyBvciB0byBhIGRpZmZlcmVudCBkb21haW4gdGhhdCBpcyBub3QgYSBzdXBlcmRvbWFpblxuICBpZiAocmVkaXJlY3RVcmxQYXJ0cy5wcm90b2NvbCAhPT0gY3VycmVudFVybFBhcnRzLnByb3RvY29sICYmXG4gICAgIHJlZGlyZWN0VXJsUGFydHMucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIgfHxcbiAgICAgcmVkaXJlY3RVcmxQYXJ0cy5ob3N0ICE9PSBjdXJyZW50SG9zdCAmJlxuICAgICAhaXNTdWJkb21haW4ocmVkaXJlY3RVcmxQYXJ0cy5ob3N0LCBjdXJyZW50SG9zdCkpIHtcbiAgICByZW1vdmVNYXRjaGluZ0hlYWRlcnMoL14oPzphdXRob3JpemF0aW9ufGNvb2tpZSkkL2ksIHRoaXMuX29wdGlvbnMuaGVhZGVycyk7XG4gIH1cblxuICAvLyBFdmFsdWF0ZSB0aGUgYmVmb3JlUmVkaXJlY3QgY2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmJlZm9yZVJlZGlyZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgcmVzcG9uc2VEZXRhaWxzID0geyBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzIH07XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX29wdGlvbnMuYmVmb3JlUmVkaXJlY3QuY2FsbChudWxsLCB0aGlzLl9vcHRpb25zLCByZXNwb25zZURldGFpbHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zYW5pdGl6ZU9wdGlvbnModGhpcy5fb3B0aW9ucyk7XG4gIH1cblxuICAvLyBQZXJmb3JtIHRoZSByZWRpcmVjdGVkIHJlcXVlc3RcbiAgdHJ5IHtcbiAgICB0aGlzLl9wZXJmb3JtUmVxdWVzdCgpO1xuICB9XG4gIGNhdGNoIChjYXVzZSkge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBSZWRpcmVjdGlvbkVycm9yKGNhdXNlKSk7XG4gIH1cbn07XG5cbi8vIFdyYXBzIHRoZSBrZXkvdmFsdWUgb2JqZWN0IG9mIHByb3RvY29scyB3aXRoIHJlZGlyZWN0IGZ1bmN0aW9uYWxpdHlcbmZ1bmN0aW9uIHdyYXAocHJvdG9jb2xzKSB7XG4gIC8vIERlZmF1bHQgc2V0dGluZ3NcbiAgdmFyIGV4cG9ydHMgPSB7XG4gICAgbWF4UmVkaXJlY3RzOiAyMSxcbiAgICBtYXhCb2R5TGVuZ3RoOiAxMCAqIDEwMjQgKiAxMDI0LFxuICB9O1xuXG4gIC8vIFdyYXAgZWFjaCBwcm90b2NvbFxuICB2YXIgbmF0aXZlUHJvdG9jb2xzID0ge307XG4gIE9iamVjdC5rZXlzKHByb3RvY29scykuZm9yRWFjaChmdW5jdGlvbiAoc2NoZW1lKSB7XG4gICAgdmFyIHByb3RvY29sID0gc2NoZW1lICsgXCI6XCI7XG4gICAgdmFyIG5hdGl2ZVByb3RvY29sID0gbmF0aXZlUHJvdG9jb2xzW3Byb3RvY29sXSA9IHByb3RvY29sc1tzY2hlbWVdO1xuICAgIHZhciB3cmFwcGVkUHJvdG9jb2wgPSBleHBvcnRzW3NjaGVtZV0gPSBPYmplY3QuY3JlYXRlKG5hdGl2ZVByb3RvY29sKTtcblxuICAgIC8vIEV4ZWN1dGVzIGEgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xuICAgIGZ1bmN0aW9uIHJlcXVlc3QoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBQYXJzZSBwYXJhbWV0ZXJzXG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciB1cmxTdHIgPSBpbnB1dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbnB1dCA9IHVybFRvT3B0aW9ucyhuZXcgVVJMKHVybFN0cikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGlucHV0ID0gdXJsLnBhcnNlKHVybFN0cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKFVSTCAmJiAoaW5wdXQgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIGlucHV0ID0gdXJsVG9PcHRpb25zKGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBpbnB1dDtcbiAgICAgICAgaW5wdXQgPSB7IHByb3RvY29sOiBwcm90b2NvbCB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG1heFJlZGlyZWN0czogZXhwb3J0cy5tYXhSZWRpcmVjdHMsXG4gICAgICAgIG1heEJvZHlMZW5ndGg6IGV4cG9ydHMubWF4Qm9keUxlbmd0aCxcbiAgICAgIH0sIGlucHV0LCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMubmF0aXZlUHJvdG9jb2xzID0gbmF0aXZlUHJvdG9jb2xzO1xuXG4gICAgICBhc3NlcnQuZXF1YWwob3B0aW9ucy5wcm90b2NvbCwgcHJvdG9jb2wsIFwicHJvdG9jb2wgbWlzbWF0Y2hcIik7XG4gICAgICBkZWJ1ZyhcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbmV3IFJlZGlyZWN0YWJsZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8vIEV4ZWN1dGVzIGEgR0VUIHJlcXVlc3QsIGZvbGxvd2luZyByZWRpcmVjdHNcbiAgICBmdW5jdGlvbiBnZXQoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgd3JhcHBlZFJlcXVlc3QgPSB3cmFwcGVkUHJvdG9jb2wucmVxdWVzdChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgd3JhcHBlZFJlcXVlc3QuZW5kKCk7XG4gICAgICByZXR1cm4gd3JhcHBlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSB3cmFwcGVkIHByb3RvY29sXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZFByb3RvY29sLCB7XG4gICAgICByZXF1ZXN0OiB7IHZhbHVlOiByZXF1ZXN0LCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgICBnZXQ6IHsgdmFsdWU6IGdldCwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGV4cG9ydHM7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBub29wKCkgeyAvKiBlbXB0eSAqLyB9XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC91cmwuanNcbmZ1bmN0aW9uIHVybFRvT3B0aW9ucyh1cmxPYmplY3QpIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgcHJvdG9jb2w6IHVybE9iamVjdC5wcm90b2NvbCxcbiAgICBob3N0bmFtZTogdXJsT2JqZWN0Lmhvc3RuYW1lLnN0YXJ0c1dpdGgoXCJbXCIpID9cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB1cmxPYmplY3QuaG9zdG5hbWUuc2xpY2UoMSwgLTEpIDpcbiAgICAgIHVybE9iamVjdC5ob3N0bmFtZSxcbiAgICBoYXNoOiB1cmxPYmplY3QuaGFzaCxcbiAgICBzZWFyY2g6IHVybE9iamVjdC5zZWFyY2gsXG4gICAgcGF0aG5hbWU6IHVybE9iamVjdC5wYXRobmFtZSxcbiAgICBwYXRoOiB1cmxPYmplY3QucGF0aG5hbWUgKyB1cmxPYmplY3Quc2VhcmNoLFxuICAgIGhyZWY6IHVybE9iamVjdC5ocmVmLFxuICB9O1xuICBpZiAodXJsT2JqZWN0LnBvcnQgIT09IFwiXCIpIHtcbiAgICBvcHRpb25zLnBvcnQgPSBOdW1iZXIodXJsT2JqZWN0LnBvcnQpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNYXRjaGluZ0hlYWRlcnMocmVnZXgsIGhlYWRlcnMpIHtcbiAgdmFyIGxhc3RWYWx1ZTtcbiAgZm9yICh2YXIgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICBpZiAocmVnZXgudGVzdChoZWFkZXIpKSB7XG4gICAgICBsYXN0VmFsdWUgPSBoZWFkZXJzW2hlYWRlcl07XG4gICAgICBkZWxldGUgaGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGxhc3RWYWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgbGFzdFZhbHVlID09PSBcInVuZGVmaW5lZFwiKSA/XG4gICAgdW5kZWZpbmVkIDogU3RyaW5nKGxhc3RWYWx1ZSkudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IoY2F1c2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICBpZiAoIWNhdXNlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBkZWZhdWx0TWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBkZWZhdWx0TWVzc2FnZSArIFwiOiBcIiArIGNhdXNlLm1lc3NhZ2U7XG4gICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxuICB9XG4gIEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBDdXN0b21FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjtcbiAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIkVycm9yIFtcIiArIGNvZGUgKyBcIl1cIjtcbiAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbmZ1bmN0aW9uIGFib3J0UmVxdWVzdChyZXF1ZXN0KSB7XG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZXZlbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcihldmVudHNbZV0sIGV2ZW50SGFuZGxlcnNbZXZlbnRzW2VdXSk7XG4gIH1cbiAgcmVxdWVzdC5vbihcImVycm9yXCIsIG5vb3ApO1xuICByZXF1ZXN0LmFib3J0KCk7XG59XG5cbmZ1bmN0aW9uIGlzU3ViZG9tYWluKHN1YmRvbWFpbiwgZG9tYWluKSB7XG4gIGNvbnN0IGRvdCA9IHN1YmRvbWFpbi5sZW5ndGggLSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGRvdCA+IDAgJiYgc3ViZG9tYWluW2RvdF0gPT09IFwiLlwiICYmIHN1YmRvbWFpbi5lbmRzV2l0aChkb21haW4pO1xufVxuXG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXAoeyBodHRwOiBodHRwLCBodHRwczogaHR0cHMgfSk7XG5tb2R1bGUuZXhwb3J0cy53cmFwID0gd3JhcDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNUUkVBTSA9IHJlcXVpcmUoJ3N0cmVhbScpLFxuICAgIFVUSUwgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlcjtcblxuZnVuY3Rpb24gTWVtb3J5UmVhZGFibGVTdHJlYW0oZGF0YSwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNZW1vcnlSZWFkYWJsZVN0cmVhbSkpXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5UmVhZGFibGVTdHJlYW0oZGF0YSwgb3B0aW9ucyk7XG4gICAgTWVtb3J5UmVhZGFibGVTdHJlYW0uc3VwZXJfLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5pbml0KGRhdGEsIG9wdGlvbnMpO1xufVxuVVRJTC5pbmhlcml0cyhNZW1vcnlSZWFkYWJsZVN0cmVhbSwgU1RSRUFNLlJlYWRhYmxlKTtcblxuXG5mdW5jdGlvbiBNZW1vcnlXcml0YWJsZVN0cmVhbShkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1lbW9yeVdyaXRhYmxlU3RyZWFtKSlcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlXcml0YWJsZVN0cmVhbShkYXRhLCBvcHRpb25zKTtcbiAgICBNZW1vcnlXcml0YWJsZVN0cmVhbS5zdXBlcl8uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLmluaXQoZGF0YSwgb3B0aW9ucyk7XG59XG5VVElMLmluaGVyaXRzKE1lbW9yeVdyaXRhYmxlU3RyZWFtLCBTVFJFQU0uV3JpdGFibGUpO1xuXG5cbmZ1bmN0aW9uIE1lbW9yeUR1cGxleFN0cmVhbShkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1lbW9yeUR1cGxleFN0cmVhbSkpXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5RHVwbGV4U3RyZWFtKGRhdGEsIG9wdGlvbnMpO1xuICAgIE1lbW9yeUR1cGxleFN0cmVhbS5zdXBlcl8uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLmluaXQoZGF0YSwgb3B0aW9ucyk7XG59XG5VVElMLmluaGVyaXRzKE1lbW9yeUR1cGxleFN0cmVhbSwgU1RSRUFNLkR1cGxleCk7XG5cblxuTWVtb3J5UmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLmluaXQgPVxuTWVtb3J5V3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmluaXQgPVxuTWVtb3J5RHVwbGV4U3RyZWFtLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnF1ZXVlID0gW107XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbIGRhdGEgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGlmICghKGNodW5rIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnF1ZXVlLnB1c2goY2h1bmspO1xuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBcbiAgICB0aGlzLm1heGJ1ZnNpemUgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdtYXhidWZzaXplJykgPyBvcHRpb25zLm1heGJ1ZnNpemVcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB0aGlzLmJ1Zm92ZXJmbG93ID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnYnVmb3ZlcmZsb3cnKSA/IG9wdGlvbnMuYnVmb3ZlcmZsb3dcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB0aGlzLmZyZXF1ZW5jZSA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2ZyZXF1ZW5jZScpID8gb3B0aW9ucy5mcmVxdWVuY2VcbiAgICAgICAgICAgIDogbnVsbDtcbn07XG5cbmZ1bmN0aW9uIE1lbW9yeVN0cmVhbSAoZGF0YSwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNZW1vcnlTdHJlYW0pKVxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVN0cmVhbShkYXRhLCBvcHRpb25zKTtcbiAgICBcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBcbiAgICB2YXIgcmVhZGFibGUgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdyZWFkYWJsZScpID8gb3B0aW9ucy5yZWFkYWJsZSA6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnd3JpdGFibGUnKSA/IG9wdGlvbnMud3JpdGFibGUgOiB0cnVlO1xuICAgIFxuICAgIGlmIChyZWFkYWJsZSAmJiB3cml0YWJsZSkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeUR1cGxleFN0cmVhbShkYXRhLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHJlYWRhYmxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5UmVhZGFibGVTdHJlYW0oZGF0YSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh3cml0YWJsZSkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVdyaXRhYmxlU3RyZWFtKGRhdGEsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3RyZWFtIHR5cGUgIFJlYWRhYmxlLCBXcml0YWJsZSBvciBEdXBsZXggXCIpO1xuICAgIH1cbn1cblxuXG5NZW1vcnlTdHJlYW0uY3JlYXRlUmVhZFN0cmVhbSA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5yZWFkYWJsZSA9IHRydWU7XG4gICAgb3B0aW9ucy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIG5ldyBNZW1vcnlTdHJlYW0oZGF0YSwgb3B0aW9ucyk7XG59O1xuXG5cbk1lbW9yeVN0cmVhbS5jcmVhdGVXcml0ZVN0cmVhbSA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIG9wdGlvbnMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5ldyBNZW1vcnlTdHJlYW0oZGF0YSwgb3B0aW9ucyk7XG59O1xuXG5cbk1lbW9yeVJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9XG5NZW1vcnlEdXBsZXhTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gX3JlYWQgKG4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGZyZXF1ZW5jZSA9IHNlbGYuZnJlcXVlbmNlIHx8IDAsXG4gICAgICAgIHdhaXRfZGF0YSA9IHRoaXMgaW5zdGFuY2VvZiBTVFJFQU0uRHVwbGV4ICYmICEgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA/IHRydWUgOiBmYWxzZTtcbiAgICBpZiAoICEgdGhpcy5xdWV1ZS5sZW5ndGggJiYgISB3YWl0X2RhdGEpIHtcbiAgICAgICAgdGhpcy5wdXNoKG51bGwpOy8vIGZpbmlzaCBzdHJlYW1cbiAgICB9IGVsc2UgaWYgKHRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYucXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rID0gc2VsZi5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaHVuayAmJiAhIHNlbGYuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhIHNlbGYucHVzaChjaHVuaykgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnF1ZXVlLnVuc2hpZnQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmcmVxdWVuY2UpO1xuICAgIH1cbn07XG5cblxuTWVtb3J5V3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9XG5NZW1vcnlEdXBsZXhTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIHZhciBkZWNvZGVyID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBkZWNvZGVyID0gdGhpcy5kZWNvZGVTdHJpbmdzICYmIGVuY29kaW5nID8gbmV3IFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIDogbnVsbDtcbiAgICB9IGNhdGNoIChlcnIpe1xuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGRlY29kZWRfY2h1bmsgPSBkZWNvZGVyID8gZGVjb2Rlci53cml0ZShjaHVuaykgOiBjaHVuayxcbiAgICAgICAgcXVldWVfc2l6ZSA9IHRoaXMuX2dldFF1ZXVlU2l6ZSgpLFxuICAgICAgICBjaHVua19zaXplID0gZGVjb2RlZF9jaHVuay5sZW5ndGg7XG4gICAgXG4gICAgaWYgKHRoaXMubWF4YnVmc2l6ZSAmJiAocXVldWVfc2l6ZSArIGNodW5rX3NpemUpID4gdGhpcy5tYXhidWZzaXplICkge1xuICAgICAgICBpZiAodGhpcy5idWZvdmVyZmxvdykge1xuICAgICAgICAgICAgcmV0dXJuIGNiKFwiQnVmZmVyIG92ZXJmbG93ZWQgKFwiICsgdGhpcy5idWZvdmVyZmxvdyArIFwiL1wiICsgcXVldWVfc2l6ZSArIFwiKVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU1RSRUFNLkR1cGxleCkge1xuICAgICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLnF1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVzaChkZWNvZGVkX2NodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2goZGVjb2RlZF9jaHVuayk7XG4gICAgfVxuICAgIGNiKCk7XG59O1xuXG5cbk1lbW9yeUR1cGxleFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIE1lbW9yeUR1cGxleFN0cmVhbS5zdXBlcl8ucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnB1c2gobnVsbCk7Ly9maW5pc2ggcmVhZGJsZSBzdHJlYW0gdG9vXG4gICAgICAgIGlmIChjYikgY2IoKTtcbiAgICB9KTtcbn07XG5cblxuTWVtb3J5UmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLl9nZXRRdWV1ZVNpemUgPSAgXG5NZW1vcnlXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuX2dldFF1ZXVlU2l6ZSA9IFxuTWVtb3J5RHVwbGV4U3RyZWFtLnByb3RvdHlwZS5fZ2V0UXVldWVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWV1ZXNpemUgPSAwLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlc2l6ZSArPSBBcnJheS5pc0FycmF5KHRoaXMucXVldWVbaV0pID8gdGhpcy5xdWV1ZVtpXVswXS5sZW5ndGhcbiAgICAgICAgICAgICAgICA6IHRoaXMucXVldWVbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcXVldWVzaXplO1xufTtcblxuXG5NZW1vcnlXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUudG9TdHJpbmcgPSBcbk1lbW9yeUR1cGxleFN0cmVhbS5wcm90b3R5cGUudG9TdHJpbmcgPSBcbk1lbW9yeVJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS50b1N0cmluZyA9IFxuTWVtb3J5V3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmdldEFsbCA9IFxuTWVtb3J5RHVwbGV4U3RyZWFtLnByb3RvdHlwZS5nZXRBbGwgPSBcbk1lbW9yeVJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICByZXQgPSAnJztcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0ICs9IGRhdGE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblxuTWVtb3J5V3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLnRvQnVmZmVyID0gXG5NZW1vcnlEdXBsZXhTdHJlYW0ucHJvdG90eXBlLnRvQnVmZmVyID0gXG5NZW1vcnlSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5fZ2V0UXVldWVTaXplKCkpLFxuICAgICAgICBjdXJyZW50T2Zmc2V0ID0gMDtcblxuICAgIHRoaXMucXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZGF0YV9idWZmZXIgPSBkYXRhIGluc3RhbmNlb2YgQnVmZmVyID8gZGF0YSA6IG5ldyBCdWZmZXIoZGF0YSk7XG4gICAgICAgIGRhdGFfYnVmZmVyLmNvcHkoYnVmZmVyLCBjdXJyZW50T2Zmc2V0KTtcbiAgICAgICAgY3VycmVudE9mZnNldCArPSBkYXRhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lbW9yeVN0cmVhbTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNlbVZlclxuXG52YXIgZGVidWdcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgcHJvY2Vzcy5lbnYgJiZcbiAgICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gICAgL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykpIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG4gICAgYXJncy51bnNoaWZ0KCdTRU1WRVInKVxuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpXG4gIH1cbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge31cbn1cblxuLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuZXhwb3J0cy5TRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG52YXIgTUFYX0xFTkdUSCA9IDI1NlxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbnZhciBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTZcblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbnZhciByZSA9IGV4cG9ydHMucmUgPSBbXVxudmFyIHNyYyA9IGV4cG9ydHMuc3JjID0gW11cbnZhciBSID0gMFxuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG52YXIgTlVNRVJJQ0lERU5USUZJRVIgPSBSKytcbnNyY1tOVU1FUklDSURFTlRJRklFUl0gPSAnMHxbMS05XVxcXFxkKidcbnZhciBOVU1FUklDSURFTlRJRklFUkxPT1NFID0gUisrXG5zcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gPSAnWzAtOV0rJ1xuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG52YXIgTk9OTlVNRVJJQ0lERU5USUZJRVIgPSBSKytcbnNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gPSAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKidcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbnZhciBNQUlOVkVSU0lPTiA9IFIrK1xuc3JjW01BSU5WRVJTSU9OXSA9ICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJyknXG5cbnZhciBNQUlOVkVSU0lPTkxPT1NFID0gUisrXG5zcmNbTUFJTlZFUlNJT05MT09TRV0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKSdcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG52YXIgUFJFUkVMRUFTRUlERU5USUZJRVIgPSBSKytcbnNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSdcblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UgPSBSKytcbnNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSdcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgUFJFUkVMRUFTRSA9IFIrK1xuc3JjW1BSRVJFTEVBU0VdID0gJyg/Oi0oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gKyAnKSopKSdcblxudmFyIFBSRVJFTEVBU0VMT09TRSA9IFIrK1xuc3JjW1BSRVJFTEVBU0VMT09TRV0gPSAnKD86LT8oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gKyAnKSopKSdcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxudmFyIEJVSUxESURFTlRJRklFUiA9IFIrK1xuc3JjW0JVSUxESURFTlRJRklFUl0gPSAnWzAtOUEtWmEtei1dKydcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbnZhciBCVUlMRCA9IFIrK1xuc3JjW0JVSUxEXSA9ICcoPzpcXFxcKygnICsgc3JjW0JVSUxESURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbQlVJTERJREVOVElGSUVSXSArICcpKikpJ1xuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxudmFyIEZVTEwgPSBSKytcbnZhciBGVUxMUExBSU4gPSAndj8nICsgc3JjW01BSU5WRVJTSU9OXSArXG4gICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nXG5cbnNyY1tGVUxMXSA9ICdeJyArIEZVTExQTEFJTiArICckJ1xuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG52YXIgTE9PU0VQTEFJTiA9ICdbdj1cXFxcc10qJyArIHNyY1tNQUlOVkVSU0lPTkxPT1NFXSArXG4gICAgICAgICAgICAgICAgIHNyY1tQUkVSRUxFQVNFTE9PU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/J1xuXG52YXIgTE9PU0UgPSBSKytcbnNyY1tMT09TRV0gPSAnXicgKyBMT09TRVBMQUlOICsgJyQnXG5cbnZhciBHVExUID0gUisrXG5zcmNbR1RMVF0gPSAnKCg/Ojx8Pik/PT8pJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG52YXIgWFJBTkdFSURFTlRJRklFUkxPT1NFID0gUisrXG5zcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSA9IHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICd8eHxYfFxcXFwqJ1xudmFyIFhSQU5HRUlERU5USUZJRVIgPSBSKytcbnNyY1tYUkFOR0VJREVOVElGSUVSXSA9IHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnfHh8WHxcXFxcKidcblxudmFyIFhSQU5HRVBMQUlOID0gUisrXG5zcmNbWFJBTkdFUExBSU5dID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICcpPyk/J1xuXG52YXIgWFJBTkdFUExBSU5MT09TRSA9IFIrK1xuc3JjW1hSQU5HRVBMQUlOTE9PU0VdID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFTE9PU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpPyk/J1xuXG52YXIgWFJBTkdFID0gUisrXG5zcmNbWFJBTkdFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyonICsgc3JjW1hSQU5HRVBMQUlOXSArICckJ1xudmFyIFhSQU5HRUxPT1NFID0gUisrXG5zcmNbWFJBTkdFTE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKicgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCdcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG52YXIgQ09FUkNFID0gUisrXG5zcmNbQ09FUkNFXSA9ICcoPzpefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSknICtcbiAgICAgICAgICAgICAgJyg/OlxcXFwuKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSkpPycgK1xuICAgICAgICAgICAgICAnKD86XFxcXC4oXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KSk/JyArXG4gICAgICAgICAgICAgICcoPzokfFteXFxcXGRdKSdcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbnZhciBMT05FVElMREUgPSBSKytcbnNyY1tMT05FVElMREVdID0gJyg/On4+PyknXG5cbnZhciBUSUxERVRSSU0gPSBSKytcbnNyY1tUSUxERVRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FVElMREVdICsgJ1xcXFxzKydcbnJlW1RJTERFVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tUSUxERVRSSU1dLCAnZycpXG52YXIgdGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbnZhciBUSUxERSA9IFIrK1xuc3JjW1RJTERFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJ1xudmFyIFRJTERFTE9PU0UgPSBSKytcbnNyY1tUSUxERUxPT1NFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG52YXIgTE9ORUNBUkVUID0gUisrXG5zcmNbTE9ORUNBUkVUXSA9ICcoPzpcXFxcXiknXG5cbnZhciBDQVJFVFRSSU0gPSBSKytcbnNyY1tDQVJFVFRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FQ0FSRVRdICsgJ1xcXFxzKydcbnJlW0NBUkVUVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tDQVJFVFRSSU1dLCAnZycpXG52YXIgY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbnZhciBDQVJFVCA9IFIrK1xuc3JjW0NBUkVUXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJ1xudmFyIENBUkVUTE9PU0UgPSBSKytcbnNyY1tDQVJFVExPT1NFXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG52YXIgQ09NUEFSQVRPUkxPT1NFID0gUisrXG5zcmNbQ09NUEFSQVRPUkxPT1NFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIExPT1NFUExBSU4gKyAnKSR8XiQnXG52YXIgQ09NUEFSQVRPUiA9IFIrK1xuc3JjW0NPTVBBUkFUT1JdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKignICsgRlVMTFBMQUlOICsgJykkfF4kJ1xuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxudmFyIENPTVBBUkFUT1JUUklNID0gUisrXG5zcmNbQ09NUEFSQVRPUlRSSU1dID0gJyhcXFxccyopJyArIHNyY1tHVExUXSArXG4gICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICd8JyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKSdcblxuLy8gdGhpcyBvbmUgaGFzIHRvIHVzZSB0aGUgL2cgZmxhZ1xucmVbQ09NUEFSQVRPUlRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ09NUEFSQVRPUlRSSU1dLCAnZycpXG52YXIgY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbnZhciBIWVBIRU5SQU5HRSA9IFIrK1xuc3JjW0hZUEhFTlJBTkdFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccyokJ1xuXG52YXIgSFlQSEVOUkFOR0VMT09TRSA9IFIrK1xuc3JjW0hZUEhFTlJBTkdFTE9PU0VdID0gJ15cXFxccyooJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccyokJ1xuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG52YXIgU1RBUiA9IFIrK1xuc3JjW1NUQVJdID0gJyg8fD4pPz0/XFxcXHMqXFxcXConXG5cbi8vIENvbXBpbGUgdG8gYWN0dWFsIHJlZ2V4cCBvYmplY3RzLlxuLy8gQWxsIGFyZSBmbGFnLWZyZWUsIHVubGVzcyB0aGV5IHdlcmUgY3JlYXRlZCBhYm92ZSB3aXRoIGEgZmxhZy5cbmZvciAodmFyIGkgPSAwOyBpIDwgUjsgaSsrKSB7XG4gIGRlYnVnKGksIHNyY1tpXSlcbiAgaWYgKCFyZVtpXSkge1xuICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pXG4gIH1cbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG5mdW5jdGlvbiBwYXJzZSAodmVyc2lvbiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF1cbiAgaWYgKCFyLnRlc3QodmVyc2lvbikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0cy52YWxpZCA9IHZhbGlkXG5mdW5jdGlvbiB2YWxpZCAodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbFxufVxuXG5leHBvcnRzLmNsZWFuID0gY2xlYW5cbmZ1bmN0aW9uIGNsZWFuICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHZhciBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cblxuZXhwb3J0cy5TZW1WZXIgPSBTZW1WZXJcblxuZnVuY3Rpb24gU2VtVmVyICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH1cbiAgfVxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSBvcHRpb25zLmxvb3NlKSB7XG4gICAgICByZXR1cm4gdmVyc2lvblxuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmVyc2lvbiBpcyBsb25nZXIgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpXG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIH1cblxuICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG5cbiAgdmFyIG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF0pXG5cbiAgaWYgKCFtKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbilcbiAgfVxuXG4gIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gIC8vIHRoZXNlIGFyZSBhY3R1YWxseSBudW1iZXJzXG4gIHRoaXMubWFqb3IgPSArbVsxXVxuICB0aGlzLm1pbm9yID0gK21bMl1cbiAgdGhpcy5wYXRjaCA9ICttWzNdXG5cbiAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgfVxuXG4gIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gIH1cblxuICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICB9XG5cbiAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gIGlmICghbVs0XSkge1xuICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgIHZhciBudW0gPSAraWRcbiAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZFxuICAgIH0pXG4gIH1cblxuICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gIHRoaXMuZm9ybWF0KClcbn1cblxuU2VtVmVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudmVyc2lvbiA9IHRoaXMubWFqb3IgKyAnLicgKyB0aGlzLm1pbm9yICsgJy4nICsgdGhpcy5wYXRjaFxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgIHRoaXMudmVyc2lvbiArPSAnLScgKyB0aGlzLnByZXJlbGVhc2Uuam9pbignLicpXG4gIH1cbiAgcmV0dXJuIHRoaXMudmVyc2lvblxufVxuXG5TZW1WZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52ZXJzaW9uXG59XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbn1cblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlTWFpbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG59XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZVByZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTFcbiAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgIHJldHVybiAxXG4gIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIHZhciBpID0gMFxuICBkbyB7XG4gICAgdmFyIGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICB2YXIgYiA9IG90aGVyLnByZXJlbGVhc2VbaV1cbiAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgfVxuICB9IHdoaWxlICgrK2kpXG59XG5cbi8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbi8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cblNlbVZlci5wcm90b3R5cGUuaW5jID0gZnVuY3Rpb24gKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgdGhpcy5tYWpvcisrXG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICB0aGlzLm1pbm9yKytcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgYnJlYWtcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAvLyBwcmVwYXRjaC5cbiAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdtYWpvcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgaWYgKHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgIH1cbiAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbWlub3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICB9XG4gICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnBhdGNoKytcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICBicmVha1xuICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgLy8gMS4wLjAgXCJwcmVcIiB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aFxuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrXG4gICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICcgKyByZWxlYXNlKVxuICB9XG4gIHRoaXMuZm9ybWF0KClcbiAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb25cbiAgcmV0dXJuIHRoaXNcbn1cblxuZXhwb3J0cy5pbmMgPSBpbmNcbmZ1bmN0aW9uIGluYyAodmVyc2lvbiwgcmVsZWFzZSwgbG9vc2UsIGlkZW50aWZpZXIpIHtcbiAgaWYgKHR5cGVvZiAobG9vc2UpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBsb29zZVxuICAgIGxvb3NlID0gdW5kZWZpbmVkXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0cy5kaWZmID0gZGlmZlxuZnVuY3Rpb24gZGlmZiAodmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICB2YXIgdjEgPSBwYXJzZSh2ZXJzaW9uMSlcbiAgICB2YXIgdjIgPSBwYXJzZSh2ZXJzaW9uMilcbiAgICB2YXIgcHJlZml4ID0gJydcbiAgICBpZiAodjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHByZWZpeCA9ICdwcmUnXG4gICAgICB2YXIgZGVmYXVsdFJlc3VsdCA9ICdwcmVyZWxlYXNlJ1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdCAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gIH1cbn1cblxuZXhwb3J0cy5jb21wYXJlSWRlbnRpZmllcnMgPSBjb21wYXJlSWRlbnRpZmllcnNcblxudmFyIG51bWVyaWMgPSAvXlswLTldKyQvXG5mdW5jdGlvbiBjb21wYXJlSWRlbnRpZmllcnMgKGEsIGIpIHtcbiAgdmFyIGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgdmFyIGJudW0gPSBudW1lcmljLnRlc3QoYilcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthXG4gICAgYiA9ICtiXG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IDBcbiAgICA6IChhbnVtICYmICFibnVtKSA/IC0xXG4gICAgOiAoYm51bSAmJiAhYW51bSkgPyAxXG4gICAgOiBhIDwgYiA/IC0xXG4gICAgOiAxXG59XG5cbmV4cG9ydHMucmNvbXBhcmVJZGVudGlmaWVycyA9IHJjb21wYXJlSWRlbnRpZmllcnNcbmZ1bmN0aW9uIHJjb21wYXJlSWRlbnRpZmllcnMgKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKVxufVxuXG5leHBvcnRzLm1ham9yID0gbWFqb3JcbmZ1bmN0aW9uIG1ham9yIChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWFqb3Jcbn1cblxuZXhwb3J0cy5taW5vciA9IG1pbm9yXG5mdW5jdGlvbiBtaW5vciAoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG59XG5cbmV4cG9ydHMucGF0Y2ggPSBwYXRjaFxuZnVuY3Rpb24gcGF0Y2ggKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxufVxuXG5leHBvcnRzLmNvbXBhcmUgPSBjb21wYXJlXG5mdW5jdGlvbiBjb21wYXJlIChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcbn1cblxuZXhwb3J0cy5jb21wYXJlTG9vc2UgPSBjb21wYXJlTG9vc2VcbmZ1bmN0aW9uIGNvbXBhcmVMb29zZSAoYSwgYikge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCB0cnVlKVxufVxuXG5leHBvcnRzLnJjb21wYXJlID0gcmNvbXBhcmVcbmZ1bmN0aW9uIHJjb21wYXJlIChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShiLCBhLCBsb29zZSlcbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydFxuZnVuY3Rpb24gc29ydCAobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLmNvbXBhcmUoYSwgYiwgbG9vc2UpXG4gIH0pXG59XG5cbmV4cG9ydHMucnNvcnQgPSByc29ydFxuZnVuY3Rpb24gcnNvcnQgKGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5yY29tcGFyZShhLCBiLCBsb29zZSlcbiAgfSlcbn1cblxuZXhwb3J0cy5ndCA9IGd0XG5mdW5jdGlvbiBndCAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxufVxuXG5leHBvcnRzLmx0ID0gbHRcbmZ1bmN0aW9uIGx0IChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwXG59XG5cbmV4cG9ydHMuZXEgPSBlcVxuZnVuY3Rpb24gZXEgKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMFxufVxuXG5leHBvcnRzLm5lcSA9IG5lcVxuZnVuY3Rpb24gbmVxIChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDBcbn1cblxuZXhwb3J0cy5ndGUgPSBndGVcbmZ1bmN0aW9uIGd0ZSAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbn1cblxuZXhwb3J0cy5sdGUgPSBsdGVcbmZ1bmN0aW9uIGx0ZSAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbn1cblxuZXhwb3J0cy5jbXAgPSBjbXBcbmZ1bmN0aW9uIGNtcCAoYSwgb3AsIGIsIGxvb3NlKSB7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JylcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSAhPT0gYlxuXG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+PSc6XG4gICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3I6ICcgKyBvcClcbiAgfVxufVxuXG5leHBvcnRzLkNvbXBhcmF0b3IgPSBDb21wYXJhdG9yXG5mdW5jdGlvbiBDb21wYXJhdG9yIChjb21wLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgIHJldHVybiBjb21wXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgfVxuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIG9wdGlvbnMpXG4gIH1cblxuICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICB0aGlzLnBhcnNlKGNvbXApXG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICB0aGlzLnZhbHVlID0gJydcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgfVxuXG4gIGRlYnVnKCdjb21wJywgdGhpcylcbn1cblxudmFyIEFOWSA9IHt9XG5Db21wYXJhdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb21wKSB7XG4gIHZhciByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdXG4gIHZhciBtID0gY29tcC5tYXRjaChyKVxuXG4gIGlmICghbSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY29tcGFyYXRvcjogJyArIGNvbXApXG4gIH1cblxuICB0aGlzLm9wZXJhdG9yID0gbVsxXVxuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gIH1cblxuICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgaWYgKCFtWzJdKSB7XG4gICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICB9XG59XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52YWx1ZVxufVxuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSlcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxufVxuXG5Db21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKGNvbXAsIG9wdGlvbnMpIHtcbiAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHZhciByYW5nZVRtcFxuXG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHNhdGlzZmllcyh0aGlzLnZhbHVlLCByYW5nZVRtcCwgb3B0aW9ucylcbiAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHNhdGlzZmllcyhjb21wLnNlbXZlciwgcmFuZ2VUbXAsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpXG4gIHZhciBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JylcbiAgdmFyIHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uXG4gIHZhciBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpXG4gIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9XG4gICAgY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICgodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKSlcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpKVxuXG4gIHJldHVybiBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHwgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW5cbn1cblxuZXhwb3J0cy5SYW5nZSA9IFJhbmdlXG5mdW5jdGlvbiBSYW5nZSAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gcmFuZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UudmFsdWUsIG9wdGlvbnMpXG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgdGhpcy5yYXcgPSByYW5nZVxuICB0aGlzLnNldCA9IHJhbmdlLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pLm1hcChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSlcbiAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgLy8gdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgcmVsZXZhbnQgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgIHJldHVybiBjLmxlbmd0aFxuICB9KVxuXG4gIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSlcbiAgfVxuXG4gIHRoaXMuZm9ybWF0KClcbn1cblxuUmFuZ2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0Lm1hcChmdW5jdGlvbiAoY29tcHMpIHtcbiAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKVxuICB9KS5qb2luKCd8fCcpLnRyaW0oKVxuICByZXR1cm4gdGhpcy5yYW5nZVxufVxuXG5SYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlXG59XG5cblJhbmdlLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIHZhciBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZVxuICByYW5nZSA9IHJhbmdlLnRyaW0oKVxuICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgdmFyIGhyID0gbG9vc2UgPyByZVtIWVBIRU5SQU5HRUxPT1NFXSA6IHJlW0hZUEhFTlJBTkdFXVxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UpXG4gIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW0NPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW0NPTVBBUkFUT1JUUklNXSlcblxuICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW1RJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG5cbiAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuXG4gIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgdmFyIGNvbXBSZSA9IGxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdXG4gIHZhciBzZXQgPSByYW5nZS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKVxuICB9LCB0aGlzKS5qb2luKCcgJykuc3BsaXQoL1xccysvKVxuICBpZiAodGhpcy5vcHRpb25zLmxvb3NlKSB7XG4gICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICByZXR1cm4gISFjb21wLm1hdGNoKGNvbXBSZSlcbiAgICB9KVxuICB9XG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKVxuICB9LCB0aGlzKVxuXG4gIHJldHVybiBzZXRcbn1cblxuUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIHJldHVybiB0aGlzLnNldC5zb21lKGZ1bmN0aW9uICh0aGlzQ29tcGFyYXRvcnMpIHtcbiAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uICh0aGlzQ29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJhbmdlLnNldC5zb21lKGZ1bmN0aW9uIChyYW5nZUNvbXBhcmF0b3JzKSB7XG4gICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uIChyYW5nZUNvbXBhcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIE1vc3RseSBqdXN0IGZvciB0ZXN0aW5nIGFuZCBsZWdhY3kgQVBJIHJlYXNvbnNcbmV4cG9ydHMudG9Db21wYXJhdG9ycyA9IHRvQ29tcGFyYXRvcnNcbmZ1bmN0aW9uIHRvQ29tcGFyYXRvcnMgKHJhbmdlLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldC5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlXG4gICAgfSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpXG4gIH0pXG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvciAoY29tcCwgb3B0aW9ucykge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuZnVuY3Rpb24gaXNYIChpZCkge1xuICByZXR1cm4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG59XG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wXG5mdW5jdGlvbiByZXBsYWNlVGlsZGVzIChjb21wLCBvcHRpb25zKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZSAoY29tcCwgb3B0aW9ucykge1xuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVtUSUxERUxPT1NFXSA6IHJlW1RJTERFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uIChfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIHZhciByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJ1xuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnXG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKVxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgIH1cblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjBcbmZ1bmN0aW9uIHJlcGxhY2VDYXJldHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0IChjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW0NBUkVUTE9PU0VdIDogcmVbQ0FSRVRdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgdmFyIHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCdcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJy0nICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJy0nICsgcHIgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCdcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJylcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCdcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlcyAoY29tcCwgb3B0aW9ucykge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlIChjb21wLCBvcHRpb25zKSB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVtYUkFOR0VMT09TRV0gOiByZVtYUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICB2YXIgeE0gPSBpc1goTSlcbiAgICB2YXIgeG0gPSB4TSB8fCBpc1gobSlcbiAgICB2YXIgeHAgPSB4bSB8fCBpc1gocClcbiAgICB2YXIgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gd2Uga25vdyBwYXRjaCBpcyBhbiB4LCBiZWNhdXNlIHdlIGhhdmUgYW55IHggYXQgYWxsLlxuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKSB7XG4gICAgICAgIG0gPSAwXG4gICAgICB9XG4gICAgICBwID0gMFxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIC8vID4xLjIuMyA9PiA+PSAxLjIuNFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXQgPSBndGx0ICsgTSArICcuJyArIG0gKyAnLicgKyBwXG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnXG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KVxuXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuZnVuY3Rpb24gcmVwbGFjZVN0YXJzIChjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbU1RBUl0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVtIWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMFxuZnVuY3Rpb24gaHlwaGVuUmVwbGFjZSAoJDAsXG4gIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSB7XG4gIGlmIChpc1goZk0pKSB7XG4gICAgZnJvbSA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLjAuMCdcbiAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuJyArIGZtICsgJy4wJ1xuICB9IGVsc2Uge1xuICAgIGZyb20gPSAnPj0nICsgZnJvbVxuICB9XG5cbiAgaWYgKGlzWCh0TSkpIHtcbiAgICB0byA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKHRtKSkge1xuICAgIHRvID0gJzwnICsgKCt0TSArIDEpICsgJy4wLjAnXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gJzwnICsgdE0gKyAnLicgKyAoK3RtICsgMSkgKyAnLjAnXG4gIH0gZWxzZSBpZiAodHByKSB7XG4gICAgdG8gPSAnPD0nICsgdE0gKyAnLicgKyB0bSArICcuJyArIHRwICsgJy0nICsgdHByXG4gIH0gZWxzZSB7XG4gICAgdG8gPSAnPD0nICsgdG9cbiAgfVxuXG4gIHJldHVybiAoZnJvbSArICcgJyArIHRvKS50cmltKClcbn1cblxuLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuUmFuZ2UucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICBpZiAoIXZlcnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiB0ZXN0U2V0IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnRzLnNhdGlzZmllcyA9IHNhdGlzZmllc1xuZnVuY3Rpb24gc2F0aXNmaWVzICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5cbmV4cG9ydHMubWF4U2F0aXNmeWluZyA9IG1heFNhdGlzZnlpbmdcbmZ1bmN0aW9uIG1heFNhdGlzZnlpbmcgKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykge1xuICB2YXIgbWF4ID0gbnVsbFxuICB2YXIgbWF4U1YgPSBudWxsXG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdlxuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heFxufVxuXG5leHBvcnRzLm1pblNhdGlzZnlpbmcgPSBtaW5TYXRpc2Z5aW5nXG5mdW5jdGlvbiBtaW5TYXRpc2Z5aW5nICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgdmFyIG1pbiA9IG51bGxcbiAgdmFyIG1pblNWID0gbnVsbFxuICB0cnkge1xuICAgIHZhciByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxuXG5leHBvcnRzLm1pblZlcnNpb24gPSBtaW5WZXJzaW9uXG5mdW5jdGlvbiBtaW5WZXJzaW9uIChyYW5nZSwgbG9vc2UpIHtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKVxuXG4gIHZhciBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMC0wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG51bGxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICB2YXIgY29tcHZlciA9IG5ldyBTZW1WZXIoY29tcGFyYXRvci5zZW12ZXIudmVyc2lvbilcbiAgICAgIHN3aXRjaCAoY29tcGFyYXRvci5vcGVyYXRvcikge1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpZiAoY29tcHZlci5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29tcHZlci5wYXRjaCsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB2ZXIucmF3ID0gY29tcHZlci5mb3JtYXQoKVxuICAgICAgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICBpZiAoIW1pbnZlciB8fCBndChtaW52ZXIsIGNvbXB2ZXIpKSB7XG4gICAgICAgICAgICBtaW52ZXIgPSBjb21wdmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgLyogSWdub3JlIG1heGltdW0gdmVyc2lvbnMgKi9cbiAgICAgICAgICBicmVha1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBvcGVyYXRpb246ICcgKyBjb21wYXJhdG9yLm9wZXJhdG9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpZiAobWludmVyICYmIHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydHMudmFsaWRSYW5nZSA9IHZhbGlkUmFuZ2VcbmZ1bmN0aW9uIHZhbGlkUmFuZ2UgKHJhbmdlLCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnJhbmdlIHx8ICcqJ1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5leHBvcnRzLmx0ciA9IGx0clxuZnVuY3Rpb24gbHRyICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBvcHRpb25zKVxufVxuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5leHBvcnRzLmd0ciA9IGd0clxuZnVuY3Rpb24gZ3RyICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxufVxuXG5leHBvcnRzLm91dHNpZGUgPSBvdXRzaWRlXG5mdW5jdGlvbiBvdXRzaWRlICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICB2YXIgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNpZmVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgdmFyIGhpZ2ggPSBudWxsXG4gICAgdmFyIGxvdyA9IG51bGxcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yXG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvclxuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvclxuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZVxuZnVuY3Rpb24gcHJlcmVsZWFzZSAodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxuXG5leHBvcnRzLmludGVyc2VjdHMgPSBpbnRlcnNlY3RzXG5mdW5jdGlvbiBpbnRlcnNlY3RzIChyMSwgcjIsIG9wdGlvbnMpIHtcbiAgcjEgPSBuZXcgUmFuZ2UocjEsIG9wdGlvbnMpXG4gIHIyID0gbmV3IFJhbmdlKHIyLCBvcHRpb25zKVxuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMilcbn1cblxuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2VcbmZ1bmN0aW9uIGNvZXJjZSAodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbQ09FUkNFXSlcblxuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gcGFyc2UobWF0Y2hbMV0gK1xuICAgICcuJyArIChtYXRjaFsyXSB8fCAnMCcpICtcbiAgICAnLicgKyAobWF0Y2hbM10gfHwgJzAnKSlcbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciB0cmFuc2xhdGUgPSByZXF1aXJlKCcuL3RyYW5zbGF0ZS5qcycpO1xudmFyIHJlcXVpcmVGcm9tU3RyaW5nID0gcmVxdWlyZSgncmVxdWlyZS1mcm9tLXN0cmluZycpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnZm9sbG93LXJlZGlyZWN0cycpLmh0dHBzO1xudmFyIE1lbW9yeVN0cmVhbSA9IHJlcXVpcmUoJ21lbW9yeXN0cmVhbScpO1xudmFyIHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuXG5mdW5jdGlvbiBzZXR1cE1ldGhvZHMgKHNvbGpzb24pIHtcbiAgdmFyIHZlcnNpb247XG4gIGlmICgnX3NvbGlkaXR5X3ZlcnNpb24nIGluIHNvbGpzb24pIHtcbiAgICB2ZXJzaW9uID0gc29sanNvbi5jd3JhcCgnc29saWRpdHlfdmVyc2lvbicsICdzdHJpbmcnLCBbXSk7XG4gIH0gZWxzZSB7XG4gICAgdmVyc2lvbiA9IHNvbGpzb24uY3dyYXAoJ3ZlcnNpb24nLCAnc3RyaW5nJywgW10pO1xuICB9XG5cbiAgdmFyIHZlcnNpb25Ub1NlbXZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhbnNsYXRlLnZlcnNpb25Ub1NlbXZlcih2ZXJzaW9uKCkpO1xuICB9O1xuXG4gIHZhciBpc1ZlcnNpb242ID0gc2VtdmVyLmd0KHZlcnNpb25Ub1NlbXZlcigpLCAnMC41Ljk5Jyk7XG5cbiAgdmFyIGxpY2Vuc2U7XG4gIGlmICgnX3NvbGlkaXR5X2xpY2Vuc2UnIGluIHNvbGpzb24pIHtcbiAgICBsaWNlbnNlID0gc29sanNvbi5jd3JhcCgnc29saWRpdHlfbGljZW5zZScsICdzdHJpbmcnLCBbXSk7XG4gIH0gZWxzZSBpZiAoJ19saWNlbnNlJyBpbiBzb2xqc29uKSB7XG4gICAgbGljZW5zZSA9IHNvbGpzb24uY3dyYXAoJ2xpY2Vuc2UnLCAnc3RyaW5nJywgW10pO1xuICB9IGVsc2Uge1xuICAgIC8vIHByZSAwLjQuMTRcbiAgICBsaWNlbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcmV0dXJuIHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICB2YXIgYWxsb2M7XG4gIGlmICgnX3NvbGlkaXR5X2FsbG9jJyBpbiBzb2xqc29uKSB7XG4gICAgYWxsb2MgPSBzb2xqc29uLmN3cmFwKCdzb2xpZGl0eV9hbGxvYycsICdudW1iZXInLCBbICdudW1iZXInIF0pO1xuICB9IGVsc2Uge1xuICAgIGFsbG9jID0gc29sanNvbi5fbWFsbG9jO1xuICAgIGFzc2VydChhbGxvYywgJ0V4cGVjdGVkIG1hbGxvYyB0byBiZSBwcmVzZW50LicpO1xuICB9XG5cbiAgdmFyIHJlc2V0O1xuICBpZiAoJ19zb2xpZGl0eV9yZXNldCcgaW4gc29sanNvbikge1xuICAgIHJlc2V0ID0gc29sanNvbi5jd3JhcCgnc29saWRpdHlfcmVzZXQnLCBudWxsLCBbXSk7XG4gIH1cblxuICB2YXIgY29weVRvQ1N0cmluZyA9IGZ1bmN0aW9uIChzdHIsIHB0cikge1xuICAgIHZhciBsZW5ndGggPSBzb2xqc29uLmxlbmd0aEJ5dGVzVVRGOChzdHIpO1xuICAgIC8vIFRoaXMgaXMgYWxsb2NhdGluZyBtZW1vcnkgdXNpbmcgc29sYydzIGFsbG9jYXRvci5cbiAgICAvL1xuICAgIC8vIEJlZm9yZSAwLjYuMDpcbiAgICAvLyAgIEFzc3VtaW5nIGNvcHlUb0NTdHJpbmcgaXMgb25seSB1c2VkIGluIHRoZSBjb250ZXh0IG9mIHdyYXBDYWxsYmFjaywgc29sYyB3aWxsIGZyZWUgdGhlc2UgcG9pbnRlcnMuXG4gICAgLy8gICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3NvbGlkaXR5L2Jsb2IvdjAuNS4xMy9saWJzb2xjL2xpYnNvbGMuaCNMMzctTDQwXG4gICAgLy9cbiAgICAvLyBBZnRlciAwLjYuMDpcbiAgICAvLyAgIFRoZSBkdXR5IGlzIG9uIHNvbGMtanMgdG8gZnJlZSB0aGVzZSBwb2ludGVycy4gV2UgYWNjb21wbGlzaCB0aGF0IGJ5IGNhbGxpbmcgYHJlc2V0YCBhdCB0aGUgZW5kLlxuICAgIHZhciBidWZmZXIgPSBhbGxvYyhsZW5ndGggKyAxKTtcbiAgICBzb2xqc29uLnN0cmluZ1RvVVRGOChzdHIsIGJ1ZmZlciwgbGVuZ3RoICsgMSk7XG4gICAgc29sanNvbi5zZXRWYWx1ZShwdHIsIGJ1ZmZlciwgJyonKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgbXVsdGlwbGUgdmVyc2lvbnMgb2YgRW1zY3JpcHRlbi5cbiAgLy8gVGFrZSBhIHNpbmdsZSBgcHRyYCBhbmQgcmV0dXJucyBhIGBzdHJgLlxuICB2YXIgY29weUZyb21DU3RyaW5nID0gc29sanNvbi5VVEY4VG9TdHJpbmcgfHwgc29sanNvbi5Qb2ludGVyX3N0cmluZ2lmeTtcblxuICB2YXIgd3JhcENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgY2FsbGJhY2sgc3BlY2lmaWVkLicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgY29udGVudHMsIGVycm9yKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soY29weUZyb21DU3RyaW5nKGRhdGEpKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmNvbnRlbnRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb3B5VG9DU3RyaW5nKHJlc3VsdC5jb250ZW50cywgY29udGVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQuZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvcHlUb0NTdHJpbmcocmVzdWx0LmVycm9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgd3JhcENhbGxiYWNrV2l0aEtpbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBhc3NlcnQodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBjYWxsYmFjayBzcGVjaWZpZWQuJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBraW5kLCBkYXRhLCBjb250ZW50cywgZXJyb3IpIHtcbiAgICAgIC8vIE11c3QgYmUgYSBudWxsIHBvaW50ZXIuXG4gICAgICBhc3NlcnQoY29udGV4dCA9PT0gMCwgJ0NhbGxiYWNrIGNvbnRleHQgbXVzdCBiZSBudWxsLicpO1xuICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKGNvcHlGcm9tQ1N0cmluZyhraW5kKSwgY29weUZyb21DU3RyaW5nKGRhdGEpKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmNvbnRlbnRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb3B5VG9DU3RyaW5nKHJlc3VsdC5jb250ZW50cywgY29udGVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQuZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvcHlUb0NTdHJpbmcocmVzdWx0LmVycm9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGNhbGxzIGNvbXBpbGUoKSB3aXRoIGFyZ3MgfHwgY2JcbiAgdmFyIHJ1bldpdGhDYWxsYmFja3MgPSBmdW5jdGlvbiAoY2FsbGJhY2tzLCBjb21waWxlLCBhcmdzKSB7XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgYXNzZXJ0KHR5cGVvZiBjYWxsYmFja3MgPT09ICdvYmplY3QnLCAnSW52YWxpZCBjYWxsYmFjayBvYmplY3Qgc3BlY2lmaWVkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFja3MgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcmVhZENhbGxiYWNrID0gY2FsbGJhY2tzLmltcG9ydDtcbiAgICBpZiAocmVhZENhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlYWRDYWxsYmFjayA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyb3I6ICdGaWxlIGltcG9ydCBjYWxsYmFjayBub3Qgc3VwcG9ydGVkJ1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc2luZ2xlQ2FsbGJhY2s7XG4gICAgaWYgKGlzVmVyc2lvbjYpIHtcbiAgICAgIC8vIEFmdGVyIDAuNi54IG11bHRpcGxlIGtpbmQgb2YgY2FsbGJhY2tzIGFyZSBzdXBwb3J0ZWQuXG4gICAgICB2YXIgc210U29sdmVyQ2FsbGJhY2sgPSBjYWxsYmFja3Muc210U29sdmVyO1xuICAgICAgaWYgKHNtdFNvbHZlckNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc210U29sdmVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcjogJ1NNVCBzb2x2ZXIgY2FsbGJhY2sgbm90IHN1cHBvcnRlZCdcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBzaW5nbGVDYWxsYmFjayA9IGZ1bmN0aW9uIChraW5kLCBkYXRhKSB7XG4gICAgICAgIGlmIChraW5kID09PSAnc291cmNlJykge1xuICAgICAgICAgIHJldHVybiByZWFkQ2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3NtdC1xdWVyeScpIHtcbiAgICAgICAgICByZXR1cm4gc210U29sdmVyQ2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCAnSW52YWxpZCBjYWxsYmFjayBraW5kIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2luZ2xlQ2FsbGJhY2sgPSB3cmFwQ2FsbGJhY2tXaXRoS2luZChzaW5nbGVDYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9sZCBTb2xpZGl0eSB2ZXJzaW9uIG9ubHkgc3VwcG9ydGVkIGltcG9ydHMuXG4gICAgICBzaW5nbGVDYWxsYmFjayA9IHdyYXBDYWxsYmFjayhyZWFkQ2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBFbXNjcmlwdGVuLlxuICAgIHZhciBhZGRGdW5jdGlvbiA9IHNvbGpzb24uYWRkRnVuY3Rpb24gfHwgc29sanNvbi5SdW50aW1lLmFkZEZ1bmN0aW9uO1xuICAgIHZhciByZW1vdmVGdW5jdGlvbiA9IHNvbGpzb24ucmVtb3ZlRnVuY3Rpb24gfHwgc29sanNvbi5SdW50aW1lLnJlbW92ZUZ1bmN0aW9uO1xuXG4gICAgdmFyIGNiID0gYWRkRnVuY3Rpb24oc2luZ2xlQ2FsbGJhY2ssICd2aWlpaWknKTtcbiAgICB2YXIgb3V0cHV0O1xuICAgIHRyeSB7XG4gICAgICBhcmdzLnB1c2goY2IpO1xuICAgICAgaWYgKGlzVmVyc2lvbjYpIHtcbiAgICAgICAgLy8gQ2FsbGJhY2sgY29udGV4dC5cbiAgICAgICAgYXJncy5wdXNoKG51bGwpO1xuICAgICAgfVxuICAgICAgb3V0cHV0ID0gY29tcGlsZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlbW92ZUZ1bmN0aW9uKGNiKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJlbW92ZUZ1bmN0aW9uKGNiKTtcbiAgICBpZiAocmVzZXQpIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgZnJlZSBtZW1vcnkuXG4gICAgICAvL1xuICAgICAgLy8gTk9URTogY3dyYXAoKSBvZiBcImNvbXBpbGVcIiB3aWxsIGNvcHkgdGhlIHJldHVybmVkIHBvaW50ZXIgaW50byBhXG4gICAgICAvLyAgICAgICBKYXZhc2NyaXB0IHN0cmluZyBhbmQgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGNhbGwgZnJlZSgpIG9uIGl0LlxuICAgICAgLy8gICAgICAgcmVzZXQoKSBob3dldmVyIHdpbGwgY2xlYXIgdXAgYWxsIGFsbG9jYXRpb25zLlxuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICB2YXIgY29tcGlsZUpTT04gPSBudWxsO1xuICBpZiAoJ19jb21waWxlSlNPTicgaW4gc29sanNvbikge1xuICAgIC8vIGlucHV0ICh0ZXh0KSwgb3B0aW1pemUgKGJvb2wpIC0+IG91dHB1dCAoanNvbnRleHQpXG4gICAgY29tcGlsZUpTT04gPSBzb2xqc29uLmN3cmFwKCdjb21waWxlSlNPTicsICdzdHJpbmcnLCBbJ3N0cmluZycsICdudW1iZXInXSk7XG4gIH1cblxuICB2YXIgY29tcGlsZUpTT05NdWx0aSA9IG51bGw7XG4gIGlmICgnX2NvbXBpbGVKU09OTXVsdGknIGluIHNvbGpzb24pIHtcbiAgICAvLyBpbnB1dCAoanNvbnRleHQpLCBvcHRpbWl6ZSAoYm9vbCkgLT4gb3V0cHV0IChqc29udGV4dClcbiAgICBjb21waWxlSlNPTk11bHRpID0gc29sanNvbi5jd3JhcCgnY29tcGlsZUpTT05NdWx0aScsICdzdHJpbmcnLCBbJ3N0cmluZycsICdudW1iZXInXSk7XG4gIH1cblxuICB2YXIgY29tcGlsZUpTT05DYWxsYmFjayA9IG51bGw7XG4gIGlmICgnX2NvbXBpbGVKU09OQ2FsbGJhY2snIGluIHNvbGpzb24pIHtcbiAgICAvLyBpbnB1dCAoanNvbnRleHQpLCBvcHRpbWl6ZSAoYm9vbCksIGNhbGxiYWNrIChwdHIpIC0+IG91dHB1dCAoanNvbnRleHQpXG4gICAgdmFyIGNvbXBpbGVJbnRlcm5hbCA9IHNvbGpzb24uY3dyYXAoJ2NvbXBpbGVKU09OQ2FsbGJhY2snLCAnc3RyaW5nJywgWydzdHJpbmcnLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICBjb21waWxlSlNPTkNhbGxiYWNrID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpbWl6ZSwgcmVhZENhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcnVuV2l0aENhbGxiYWNrcyhyZWFkQ2FsbGJhY2ssIGNvbXBpbGVJbnRlcm5hbCwgWyBpbnB1dCwgb3B0aW1pemUgXSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjb21waWxlU3RhbmRhcmQgPSBudWxsO1xuICBpZiAoJ19jb21waWxlU3RhbmRhcmQnIGluIHNvbGpzb24pIHtcbiAgICAvLyBpbnB1dCAoanNvbnRleHQpLCBjYWxsYmFjayAocHRyKSAtPiBvdXRwdXQgKGpzb250ZXh0KVxuICAgIHZhciBjb21waWxlU3RhbmRhcmRJbnRlcm5hbCA9IHNvbGpzb24uY3dyYXAoJ2NvbXBpbGVTdGFuZGFyZCcsICdzdHJpbmcnLCBbJ3N0cmluZycsICdudW1iZXInXSk7XG4gICAgY29tcGlsZVN0YW5kYXJkID0gZnVuY3Rpb24gKGlucHV0LCByZWFkQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBydW5XaXRoQ2FsbGJhY2tzKHJlYWRDYWxsYmFjaywgY29tcGlsZVN0YW5kYXJkSW50ZXJuYWwsIFsgaW5wdXQgXSk7XG4gICAgfTtcbiAgfVxuICBpZiAoJ19zb2xpZGl0eV9jb21waWxlJyBpbiBzb2xqc29uKSB7XG4gICAgdmFyIHNvbGlkaXR5Q29tcGlsZTtcbiAgICBpZiAoaXNWZXJzaW9uNikge1xuICAgICAgLy8gaW5wdXQgKGpzb250ZXh0KSwgY2FsbGJhY2sgKHB0ciksIGNhbGxiYWNrX2NvbnRleHQgKHB0cikgLT4gb3V0cHV0IChqc29udGV4dClcbiAgICAgIHNvbGlkaXR5Q29tcGlsZSA9IHNvbGpzb24uY3dyYXAoJ3NvbGlkaXR5X2NvbXBpbGUnLCAnc3RyaW5nJywgWydzdHJpbmcnLCAnbnVtYmVyJywgJ251bWJlciddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5wdXQgKGpzb250ZXh0KSwgY2FsbGJhY2sgKHB0cikgLT4gb3V0cHV0IChqc29udGV4dClcbiAgICAgIHNvbGlkaXR5Q29tcGlsZSA9IHNvbGpzb24uY3dyYXAoJ3NvbGlkaXR5X2NvbXBpbGUnLCAnc3RyaW5nJywgWydzdHJpbmcnLCAnbnVtYmVyJ10pO1xuICAgIH1cbiAgICBjb21waWxlU3RhbmRhcmQgPSBmdW5jdGlvbiAoaW5wdXQsIGNhbGxiYWNrcykge1xuICAgICAgcmV0dXJuIHJ1bldpdGhDYWxsYmFja3MoY2FsbGJhY2tzLCBzb2xpZGl0eUNvbXBpbGUsIFsgaW5wdXQgXSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cGVjdHMgYSBTdGFuZGFyZCBKU09OIEkvTyBidXQgc3VwcG9ydHMgb2xkIGNvbXBpbGVyc1xuICB2YXIgY29tcGlsZVN0YW5kYXJkV3JhcHBlciA9IGZ1bmN0aW9uIChpbnB1dCwgcmVhZENhbGxiYWNrKSB7XG4gICAgaWYgKGNvbXBpbGVTdGFuZGFyZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbXBpbGVTdGFuZGFyZChpbnB1dCwgcmVhZENhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRGYXRhbEVycm9yIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBlcnJvcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAndHlwZSc6ICdKU09ORXJyb3InLFxuICAgICAgICAgICAgJ2NvbXBvbmVudCc6ICdzb2xjanMnLFxuICAgICAgICAgICAgJ3NldmVyaXR5JzogJ2Vycm9yJyxcbiAgICAgICAgICAgICdtZXNzYWdlJzogbWVzc2FnZSxcbiAgICAgICAgICAgICdmb3JtYXR0ZWRNZXNzYWdlJzogJ0Vycm9yOiAnICsgbWVzc2FnZVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlucHV0ID0gSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEZhdGFsRXJyb3IoJ0ludmFsaWQgSlNPTiBzdXBwbGllZDogJyArIGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0WydsYW5ndWFnZSddICE9PSAnU29saWRpdHknKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RmF0YWxFcnJvcignT25seSBcIlNvbGlkaXR5XCIgaXMgc3VwcG9ydGVkIGFzIGEgbGFuZ3VhZ2UuJyk7XG4gICAgfVxuXG4gICAgLy8gTk9URTogdGhpcyBpcyBkZWxpYmVyYXRlbHkgYD09IG51bGxgXG4gICAgaWYgKGlucHV0Wydzb3VyY2VzJ10gPT0gbnVsbCB8fCBpbnB1dFsnc291cmNlcyddLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZvcm1hdEZhdGFsRXJyb3IoJ05vIGlucHV0IHNvdXJjZXMgc3BlY2lmaWVkLicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT3B0aW1pemVyRW5hYmxlZCAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dFsnc2V0dGluZ3MnXSAmJiBpbnB1dFsnc2V0dGluZ3MnXVsnb3B0aW1pemVyJ10gJiYgaW5wdXRbJ3NldHRpbmdzJ11bJ29wdGltaXplciddWydlbmFibGVkJ107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlU291cmNlcyAoaW5wdXQpIHtcbiAgICAgIHZhciBzb3VyY2VzID0ge307XG4gICAgICBmb3IgKHZhciBzb3VyY2UgaW4gaW5wdXRbJ3NvdXJjZXMnXSkge1xuICAgICAgICBpZiAoaW5wdXRbJ3NvdXJjZXMnXVtzb3VyY2VdWydjb250ZW50J10gIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VzW3NvdXJjZV0gPSBpbnB1dFsnc291cmNlcyddW3NvdXJjZV1bJ2NvbnRlbnQnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmb3JjZSBmYWlsdXJlXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3VyY2VzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYnJhcmllc1N1cHBsaWVkIChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0WydzZXR0aW5ncyddKSB7XG4gICAgICAgIHJldHVybiBpbnB1dFsnc2V0dGluZ3MnXVsnbGlicmFyaWVzJ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlT3V0cHV0IChvdXRwdXQsIGxpYnJhcmllcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0cHV0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0RmF0YWxFcnJvcignQ29tcGlsZXIgcmV0dXJuZWQgaW52YWxpZCBKU09OOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dCA9IHRyYW5zbGF0ZS50cmFuc2xhdGVKc29uQ29tcGlsZXJPdXRwdXQob3V0cHV0LCBsaWJyYXJpZXMpO1xuICAgICAgaWYgKG91dHB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRGYXRhbEVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyBvdXRwdXQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IHRyYW5zbGF0ZVNvdXJjZXMoaW5wdXQpO1xuICAgIGlmIChzb3VyY2VzID09PSBudWxsIHx8IE9iamVjdC5rZXlzKHNvdXJjZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZvcm1hdEZhdGFsRXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIHNvdXJjZXMuJyk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IGxpbmtpbmcgaWYgbGlicmFyaWVzIHdlcmUgc3VwcGxpZWRcbiAgICB2YXIgbGlicmFyaWVzID0gbGlicmFyaWVzU3VwcGxpZWQoaW5wdXQpO1xuXG4gICAgLy8gVHJ5IHRvIHdyYXAgYXJvdW5kIG9sZCB2ZXJzaW9uc1xuICAgIGlmIChjb21waWxlSlNPTkNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlT3V0cHV0KGNvbXBpbGVKU09OQ2FsbGJhY2soSlNPTi5zdHJpbmdpZnkoeyAnc291cmNlcyc6IHNvdXJjZXMgfSksIGlzT3B0aW1pemVyRW5hYmxlZChpbnB1dCksIHJlYWRDYWxsYmFjayksIGxpYnJhcmllcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBpbGVKU09OTXVsdGkgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGVPdXRwdXQoY29tcGlsZUpTT05NdWx0aShKU09OLnN0cmluZ2lmeSh7ICdzb3VyY2VzJzogc291cmNlcyB9KSwgaXNPcHRpbWl6ZXJFbmFibGVkKGlucHV0KSksIGxpYnJhcmllcyk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IG91ciBsdWNrIHdpdGggYW4gYW5jaWVudCBjb21waWxlclxuICAgIGlmIChjb21waWxlSlNPTiAhPT0gbnVsbCkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZXMpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0RmF0YWxFcnJvcignTXVsdGlwbGUgc291cmNlcyBwcm92aWRlZCwgYnV0IGNvbXBpbGVyIG9ubHkgc3VwcG9ydHMgc2luZ2xlIGlucHV0LicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZU91dHB1dChjb21waWxlSlNPTihzb3VyY2VzW09iamVjdC5rZXlzKHNvdXJjZXMpWzBdXSwgaXNPcHRpbWl6ZXJFbmFibGVkKGlucHV0KSksIGxpYnJhcmllcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdEZhdGFsRXJyb3IoJ0NvbXBpbGVyIGRvZXMgbm90IHN1cHBvcnQgYW55IGtub3duIGludGVyZmFjZS4nKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgc2VtdmVyOiB2ZXJzaW9uVG9TZW12ZXIsXG4gICAgbGljZW5zZTogbGljZW5zZSxcbiAgICBsb3dsZXZlbDoge1xuICAgICAgY29tcGlsZVNpbmdsZTogY29tcGlsZUpTT04sXG4gICAgICBjb21waWxlTXVsdGk6IGNvbXBpbGVKU09OTXVsdGksXG4gICAgICBjb21waWxlQ2FsbGJhY2s6IGNvbXBpbGVKU09OQ2FsbGJhY2ssXG4gICAgICBjb21waWxlU3RhbmRhcmQ6IGNvbXBpbGVTdGFuZGFyZFxuICAgIH0sXG4gICAgZmVhdHVyZXM6IHtcbiAgICAgIGxlZ2FjeVNpbmdsZUlucHV0OiBjb21waWxlSlNPTiAhPT0gbnVsbCxcbiAgICAgIG11bHRpcGxlSW5wdXRzOiBjb21waWxlSlNPTk11bHRpICE9PSBudWxsIHx8IGNvbXBpbGVTdGFuZGFyZCAhPT0gbnVsbCxcbiAgICAgIGltcG9ydENhbGxiYWNrOiBjb21waWxlSlNPTkNhbGxiYWNrICE9PSBudWxsIHx8IGNvbXBpbGVTdGFuZGFyZCAhPT0gbnVsbCxcbiAgICAgIG5hdGl2ZVN0YW5kYXJkSlNPTjogY29tcGlsZVN0YW5kYXJkICE9PSBudWxsXG4gICAgfSxcbiAgICBjb21waWxlOiBjb21waWxlU3RhbmRhcmRXcmFwcGVyLFxuICAgIC8vIExvYWRzIHRoZSBjb21waWxlciBvZiB0aGUgZ2l2ZW4gdmVyc2lvbiBmcm9tIHRoZSBnaXRodWIgcmVwb3NpdG9yeVxuICAgIC8vIGluc3RlYWQgb2YgZnJvbSB0aGUgbG9jYWwgZmlsZXN5c3RlbS5cbiAgICBsb2FkUmVtb3RlVmVyc2lvbjogZnVuY3Rpb24gKHZlcnNpb25TdHJpbmcsIGNiKSB7XG4gICAgICB2YXIgbWVtID0gbmV3IE1lbW9yeVN0cmVhbShudWxsLCB7cmVhZGFibGU6IGZhbHNlfSk7XG4gICAgICB2YXIgdXJsID0gJ2h0dHBzOi8vYmluYXJpZXMuc29saWRpdHlsYW5nLm9yZy9iaW4vc29sanNvbi0nICsgdmVyc2lvblN0cmluZyArICcuanMnO1xuICAgICAgaHR0cHMuZ2V0KHVybCwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICBjYihuZXcgRXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgYmluYXJ5OiAnICsgcmVzcG9uc2Uuc3RhdHVzTWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3BvbnNlLnBpcGUobWVtKTtcbiAgICAgICAgICByZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2IobnVsbCwgc2V0dXBNZXRob2RzKHJlcXVpcmVGcm9tU3RyaW5nKG1lbS50b1N0cmluZygpLCAnc29sanNvbi0nICsgdmVyc2lvblN0cmluZyArICcuanMnKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBVc2UgdGhpcyBpZiB5b3Ugd2FudCB0byBhZGQgd3JhcHBlciBmdW5jdGlvbnMgYXJvdW5kIHRoZSBwdXJlIG1vZHVsZS5cbiAgICBzZXR1cE1ldGhvZHM6IHNldHVwTWV0aG9kc1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwTWV0aG9kcztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF93cmFwcGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwic29sYy93cmFwcGVyXCIpKTtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qIGdsb2JhbHMgaW1wb3J0U2NyaXB0cyAqL1xuaW1wb3J0U2NyaXB0cyhcImh0dHBzOi8vYmluYXJpZXMuc29saWRpdHlsYW5nLm9yZy9iaW4vc29sanNvbi12MC44LjkrY29tbWl0LmU1ZWVkNjNhLmpzXCIpO1xudmFyIGNvbXBpbGVyID0gKDAsIF93cmFwcGVyW1wiZGVmYXVsdFwiXSkoc2VsZi5Nb2R1bGUpO1xuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZGF0YSA9IF9yZWYuZGF0YTtcblxuICBpZiAoXCJjb21waWxlXCIgPT09IGRhdGEudHlwZSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgcGF5bG9hZDogY29tcGlsZXIuY29tcGlsZShkYXRhLnBheWxvYWQpLFxuICAgICAgdHlwZTogXCJjb21waWxlX3Jlc3VsdFwiXG4gICAgfSk7XG4gIH1cbn0pO1xuc2VsZi5wb3N0TWVzc2FnZSh7XG4gIHR5cGU6IFwibG9hZGVkXCJcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U29saWRpdHlDb21waWxlci53b3JrZXIuanMubWFwIl0sIm5hbWVzIjpbImlzQXJyYXkiLCJCdWZmZXIiLCJnbG9iYWwiLCJpc0J1ZmZlciIsIm5vb3AiLCJmb3JtYXQiLCJpbnNwZWN0IiwiaXNGdW5jdGlvbiIsImhhc093blByb3BlcnR5IiwiaW5oZXJpdHMiLCJvYmplY3RLZXlzIiwiYXNzZXJ0IiwidXRpbEluc3BlY3QiLCJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMSIsImxpbmtlciIsInRyYW5zbGF0ZSIsImRlbGltaXRlciIsIm1hcCIsInBhcnNlIiwicXNQYXJzZSIsInFzU3RyaW5naWZ5IiwibGlzdGVuZXJDb3VudCIsIlN0cmluZ0RlY29kZXIiLCJkZWJ1ZyIsIldyaXRhYmxlIiwiRUUiLCJjYXBhYmlsaXR5Lmhhc0ZldGNoIiwiY2FwYWJpbGl0eS5tb3pjaHVua2VkYXJyYXlidWZmZXIiLCJjYXBhYmlsaXR5Lm1zc3RyZWFtIiwiY2FwYWJpbGl0eS5hcnJheWJ1ZmZlciIsImNhcGFiaWxpdHkudmJBcnJheSIsImNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZSIsImNhcGFiaWxpdHkuYmxvYkNvbnN0cnVjdG9yIiwiaHR0cHMiLCJyZXF1aXJlJCQzIiwicmVxdWlyZSQkNCIsInJlcXVpcmUkJDUiLCJmb2xsb3dSZWRpcmVjdHNNb2R1bGUiLCJyZXF1aXJlJCQyIiwiTWVtb3J5U3RyZWFtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0NBQUEsU0FBUyxzQkFBc0IsQ0FBQyxHQUFHLEVBQUU7Q0FDckMsRUFBRSxPQUFPLEdBQUcsSUFBSSxHQUFHLENBQUMsVUFBVSxHQUFHLEdBQUcsR0FBRztDQUN2QyxJQUFJLFNBQVMsRUFBRSxHQUFHO0NBQ2xCLEdBQUcsQ0FBQztDQUNKLENBQUM7QUFDRDtDQUNBLGlCQUFpQixzQkFBc0IsRUFBRSw0QkFBNEIsSUFBSSxFQUFFLE1BQU0sQ0FB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Q0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDdkssSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDO0NBQ2xDLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQztDQUNqQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7Q0FDMUIsR0FBRztBQUNIO0NBQ0EsRUFBRSxJQUFJLFlBQVksS0FBSyxDQUFDLEVBQUU7Q0FDMUIsSUFBSSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUN4RixJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7Q0FDMUIsR0FBRyxNQUFNLElBQUksWUFBWSxLQUFLLENBQUMsRUFBRTtDQUNqQyxJQUFJLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENB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QUM7Q0FDeEIsRUFBRSxJQUFJLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzlEO0NBQ0EsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxQjtDQUNBLEVBQUUsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxLQUFLLFFBQVEsRUFBRTtDQUMxQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUM3QixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7Q0FDYixHQUFHLE1BQU07Q0FDVCxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQy9DLElBQUksSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7Q0FDM0MsTUFBTSxDQUFDLEVBQUUsQ0FBQztDQUNWLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNiLEtBQUs7Q0FDTCxJQUFJLElBQUksQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLEVBQUU7Q0FDeEIsTUFBTSxLQUFLLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztDQUN0QixLQUFLLE1BQU07Q0FDWCxNQUFNLEtBQUssSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0NBQzNDLEtBQUs7Q0FDTCxJQUFJLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7Q0FDeEIsTUFBTSxDQUFDLEVBQUUsQ0FBQztD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LFFBQVEsRUFBRTtDQUNqRSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0NBQ3JELEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztDQUNuRCxFQUFFLFFBQVEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUN6QyxDQUFDLENBQUM7QUFDRjtBQUNBQSxTQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLFdBQVcsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0NBQ3ZFLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDckQsRUFBRSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUNuRCxFQUFFLE9BQU8sQ0FBQyxHQUFHLEdBQUcsTUFBTSxJQUFJLEdBQUcsR0FBRyxVQUFVLEdBQUcsR0FBRztDQUNoRCxDQUFDLENBQUM7QUFDRjtBQUNBQSxTQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLFdBQVcsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0NBQ3ZFLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDckQsRUFBRSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUNuRCxF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LENBQUMsS0FBSyxDQUFDLENBQUM7QUFDM0M7Q0FDQTtDQUNBO0NBQ0EsR0FBRyxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtDQUNqRCxJQUFJLE9BQU8sTUFBTSxDQUFDLE9BQU8sRUFBRSxLQUFLLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUNuRDtDQUNBO0NBQ0E7Q0FDQTtDQUNBLEdBQUcsTUFBTSxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7Q0FDckQsSUFBSSxPQUFPLE1BQU0sQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDLE1BQU07Q0FDNUMsV0FBVyxNQUFNLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxNQUFNO0NBQzVDLFdBQVcsTUFBTSxDQUFDLFNBQVMsS0FBSyxRQUFRLENBQUMsU0FBUztDQUNsRCxXQUFXLE1BQU0sQ0FBQyxTQUFTLEtBQUssUUFBUSxDQUFDLFNBQVM7Q0FDbEQsV0FBVyxNQUFNLENBQUMsVUFBVSxLQUFLLFFBQVEsQ0FBQyxVQUFVLENBQUM7QUFDckQ7Q0FDQTtDQUNBO0NBQ0EsR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLEtBQUssSUFBSSxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVE7Q0FDM0QsY0FBYyxRQUFRLEtBQUssSUFBSSxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsQ0FBQyxFQUFFO0NBQ2xFLElBQUksT0FBTyxNQUFNLEdBQUcsTUFBTSxLQUFLLFFBQVEsR0FBRyxNQUFNLElBQUksUUFBUSxDQUFDO0FBQzdEO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsR0FBRyxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUM7Q0FDL0MsYUFBYSxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssU0FBUyxDQUFDLFFBQVEsQ0FBQztDQUN0RCxhQUFhLEVBQUUsTUFBTSxZQUFZLFlBQVk7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LElBQUksRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDN0MsRUFBRSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0NBQzdCLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsVUFBVTtDQUMzRixJQUFJLENBQUMsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxDQUFDO0NBQy9FLElBQUksVUFBVSxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxLQUFLO0NBQzNFLElBQUksVUFBVSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxVQUFVO0NBQ3BGLElBQUksVUFBVSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxDQUFDLEVBQUUsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0NBQ3RGLEVBQUUsSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztDQUNsQyxFQUFFLElBQUksVUFBVSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0NBQzlCLEVBQUUsSUFBSSxZQUFZLEdBQUcsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7Q0FDekUsRUFBRSxJQUFJLGNBQWMsR0FBRztDQUN2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QyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7Q0FDN0QsU0FBUztDQUNULE9BQU8sTUFBTTtDQUNiLFFBQVEsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxTQUFTLEVBQUUsRUFBRSxLQUFLLEVBQUU7Q0FDdkUsVUFBVSxJQUFJLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUMzQyxVQUFVLElBQUksSUFBSSxHQUFHLElBQUksRUFBRTtDQUMzQixZQUFZLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztDQUNyRCxXQUFXLE1BQU0sSUFBSSxJQUFJLEdBQUcsS0FBSyxFQUFFO0NBQ25DLFlBQVksTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0NBQ3JFLFlBQVksTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0NBQ3ZFLFdBQVcsTUFBTSxJQUFJLElBQUksR0FBRyxNQUFNLElBQUksSUFBSSxJQUFJLE1BQU0sRUFBRTtDQUN0RCxZQUFZLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUUsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztDQUN0RSxZQUFZLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksQ0FB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QUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0NBQ3ZELE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHO0NBQ3BGLE1BQU0sR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztDQUNwRixNQUFNLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztDQUNyRixJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7Q0FDaEMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUNoRCxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ2hELE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Q0FDaEQsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUNoRCxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ2hELE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Q0FDaEQsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUNoRCxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ2hELE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Q0FDaEQsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNoRDtDQUNBLE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7Q0FDekMsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztDQUN6QyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDaEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2hCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztDQUN6QyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQ3pDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNoQixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDaEIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQ3pDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7Q0FDekMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2hCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNoQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7Q0FDekMsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztDQUN6QyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDaEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2hCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztDQUN6QyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQ3pDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNoQixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDaEIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQjtDQUNBLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNoQixNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDaEIsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMxQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMxQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMzQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzNDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDeEMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUN4QyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMzQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzNDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDM0MsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMzQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztDQUN4QyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0NBQ3hDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMxQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMzQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzNDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztDQUMxQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0NBQ3hDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDeEMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztDQUMxQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztDQUMxQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztDQUMxQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDeEMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztDQUN4QyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzNDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDM0MsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMxQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMxQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7QUFDMUM7Q0FDQSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7Q0FDN0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0NBQzdCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0NBQzdCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztDQUM3QixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztDQUM3QixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7Q0FDN0IsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7Q0FDN0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0NBQzdCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ2pDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztDQUNqQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDakMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0NBQzdCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztDQUM3QixNQUFNLENBQUMsQ0FBQyxFQUFF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Q0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDOUIsR0FBRztBQUNIO0NBQ0E7Q0FDQTtDQUNBLEVBQUUsTUFBTSxDQUFDLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQzlCO0NBQ0E7Q0FDQSxFQUFFLElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxFQUFFLEVBQUU7Q0FDNUIsSUFBSSxNQUFNLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztDQUNsQyxJQUFJLE9BQU8sTUFBTSxDQUFDO0NBQ2xCLEdBQUc7QUFDSDtDQUNBO0NBQ0EsRUFBRSxJQUFJLFFBQVEsQ0FBQyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFO0NBQzlDO0NBQ0EsSUFBSSxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0NBQ3RDLElBQUksS0FBSyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUU7Q0FDOUMsTUFBTSxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7Q0FDM0IsTUFBTSxJQUFJLElBQUksS0FBSyxVQUFVO0NBQzdCLFFBQVEsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUN0QyxLQUFLO0FBQ0w7Q0FDQTtDQUNBLElBQUksSUFBSSxlQUFlLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztDQUN4QyxNQUFNLE1BQU0sQ0FBQyxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFO0NBQzNDLE1BQU0sTUFBTSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQztDQUMxQyxLQUFLO0FBQ0w7Q0FDQSxJQUFJLE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0NBQ2xDLElBQUks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dEQ7Q0FDQTtDQUNBO0NBQ0EsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQUksSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0NBQzlELFFBQVEsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO0NBQ3ZDLE1BQU0sSUFBSSxVQUFVLEVBQUU7Q0FDdEIsUUFBUSxNQUFNLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztDQUN6QyxRQUFRLE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7Q0FDM0QsT0FBTztDQUNQLEtBQUs7Q0FDTCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztDQUNwQyxJQUFJLE1BQU0sQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQztDQUNsQztDQUNBLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0NBQzVELE1BQU0sTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsR0FBRyxFQUFFO0NBQzNELFNBQVMsTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0NBQzdDLEtBQUs7Q0FDTCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0NBQ2xDLElBQUksT0FBTyxNQUFNLENBQUM7Q0FDbEIsR0FBRztBQUNIO0NBQ0EsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtDQUN2QjtDQUNBO0NBQ0EsSUFBSSxNQUFNLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztDQUMz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QUMsSUFBSSxFQUFFO0NBQzdCLEVBQUUsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQy9JLEVBQUUsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztDQUN0QyxDQUFDO0FBQ0Q7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxTQUFTLG1CQUFtQixDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFO0NBQzNDLEVBQUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7Q0FDekIsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDdEIsRUFBRSxJQUFJLEVBQUUsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDakMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUU7Q0FDZixJQUFJLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7Q0FDdkMsSUFBSSxPQUFPLEVBQUUsQ0FBQztDQUNkLEdBQUc7Q0FDSCxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztDQUNyQyxFQUFFLEVBQUUsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDN0IsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUU7Q0FDZixJQUFJLElBQUks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QSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQ3JDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQzdDLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7Q0FDMUM7Q0FDQSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7Q0FDdkIsR0FBRyxNQUFNO0NBQ1Q7Q0FDQSxJQUFJLEdBQUcsR0FBRyxVQUFVLEdBQUcsb0JBQW9CLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7Q0FDL0UsR0FBRztDQUNILEVBQUUsT0FBTyxHQUFHLENBQUM7Q0FDYixDQUFDO0FBQ0Q7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLFNBQVMsb0JBQW9CLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRTtDQUN2QyxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7Q0FDcEIsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDWixFQUFFLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7Q0FDbkIsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQztDQUNsQixFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUU7Q0FDckIsSUFBSSxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO0NBQ3JCLElBQUksSUFBSSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7Q0FDN0MsSUFBSSxJQUFJLEVB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QVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQU87Q0FDcEQsR0FBRztBQUNIO0NBQ0EsRUFBRSxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksRUFBQztDQUNyQixDQUFDO0FBQ0Q7Q0FDQSxJQUFJLEdBQUcsR0FBRyxHQUFFO0NBQ1osVUFBVSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsVUFBVSxJQUFJLEVBQUU7Q0FDN0MsRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBRSxDQUFDLFVBQVUsRUFBQztDQUNuRSxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFDO0FBQ3ZCO0NBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFO0NBQ1YsSUFBSSxNQUFNLElBQUksU0FBUyxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQztDQUN0RCxHQUFHO0FBQ0g7Q0FDQSxFQUFFLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztDQUN0QixFQUFFLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxHQUFHLEVBQUU7Q0FDN0IsSUFBSSxJQUFJLENBQUMsUUFBUSxHQUFHLEdBQUU7Q0FDdEIsR0FBRztBQUNIO0NBQ0E7Q0FDQSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Q0FDYixJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBRztDQUNyQixHQUFHLE1BQU07Q0FDVCxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFDO0NBQ3RELEdBQUc7Q0FDSCxFQUFDO0FBQ0Q7Q0FDQSxVQUFVLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxZQUFZO0NBQzVDLEVBQUUsT0FBTyxJQUFJLENBQUMsS0FBSztDQUNuQixFQUFDO0FBQ0Q7Q0FDQSxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxVQUFVLE9BQU8sRUFBRTtDQUMvQyxFQUFFLEtBQUssQ0FBQyxpQkFBaUIsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUM7QUFDdkQ7Q0FDQSxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7Q0FDM0IsSUFBSSxPQUFPLElBQUk7Q0FDZixHQUFHO0FBQ0g7Q0FDQSxFQUFFLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO0NBQ25DLElBQUksT0FBTyxHQUFHLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFDO0NBQy9DLEdBQUc7QUFDSDtDQUNBLEVBQUUsT0FBTyxHQUFHLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDO0NBQy9ELEVBQUM7QUFDRDtDQUNBLFVBQVUsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxFQUFFLE9BQU8sRUFBRTtDQUMzRCxFQUFFLElBQUksRUFBRSxJQUFJLFlBQVksVUFBVSxDQUFDLEVBQUU7Q0FDckMsSUFBSSxNQUFNLElBQUksU0FBUyxDQUFDLDBCQUEwQixDQUFDO0NBQ25ELEdBQUc7QUFDSDtDQUNBLEVBQUUsSUFBSSxDQUFDLE9BQU8sSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUU7Q0FDL0MsSUFBSSxPQUFPLEdBQUc7Q0FDZCxNQUFNLEtBQUssRUFBRSxDQUFDLENBQUMsT0FBTztDQUN0QixNQUFNLGlCQUFpQixFQUFFLEtBQUs7Q0FDOUIsTUFBSztDQUNMLEdBQUc7QUFDSDtDQUNBLEVBQUUsSUFBSSxTQUFRO0FBQ2Q7Q0FDQSxFQUFFLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxFQUFFLEVBQUU7Q0FDNUIsSUFBSSxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUM7Q0FDN0MsSUFBSSxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUM7Q0FDbkQsR0FBRyxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxFQUFFLEVBQUU7Q0FDbkMsSUFBSSxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUM7Q0FDN0MsSUFBSSxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUM7Q0FDcEQsR0FBRztBQUNIO0NBQ0EsRUFBRSxJQUFJLHVCQUF1QjtDQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxHQUFHO0NBQ3BELEtBQUssSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxHQUFHLEVBQUM7Q0FDckQsRUFBRSxJQUFJLHVCQUF1QjtDQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxHQUFHO0NBQ3BELEtBQUssSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxHQUFHLEVBQUM7Q0FDckQsRUFBRSxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQU87Q0FDOUQsRUFBRSxJQUFJLDRCQUE0QjtDQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJO0NBQ3JELEtBQUssSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQUM7Q0FDdEQsRUFBRSxJQUFJLDBCQUEwQjtDQUNoQyxJQUFJLEdBQUcsQ0FBQyxJQUFJ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QztDQUN0QztDQUNBLEVBQUUsT0FBTyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7Q0FDMUMsQ0FBQztBQUNEO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLFNBQVMsYUFBYSxFQUFFLEVBQUU7Q0FDMUIsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUU7Q0FDM0IsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRTtDQUMzQixFQUFFLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0NBQ2YsSUFBSSxJQUFJLEdBQUcsR0FBRTtDQUNiLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtDQUN0QixJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHLE9BQU07Q0FDN0IsR0FBRyxNQUFNLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0NBQ3RCLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxLQUFJO0NBQ3RDLEdBQUcsTUFBTTtDQUNULElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxLQUFJO0NBQ3RCLEdBQUc7QUFDSDtDQUNBLEVBQUUsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7Q0FDZixJQUFJLEVBQUUsR0FBRyxHQUFFO0NBQ1gsR0FBRyxNQUFNLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0NBQ3RCLElBQUksRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFNO0NBQ2pDLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtDQUN0QixJQUFJLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcs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', false);
/* eslint-enable */

var SolidityCompiler_worker = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': WorkerFactory
});

var require$$4 = /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(SolidityCompiler_worker);

var require$$5 = /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(ContractsInFileStorage);

var _interopRequireDefault = interopRequireDefault.exports;

Object.defineProperty(SolidityCompiler$1, "__esModule", {
  value: true
});
var VIRTUAL_SOURCE_CONTRACT_FILE_NAME_1 = SolidityCompiler$1.VIRTUAL_SOURCE_CONTRACT_FILE_NAME = SolidityCompiler_2 = SolidityCompiler$1.SolidityCompiler = void 0;

var _classCallCheck2 = _interopRequireDefault(classCallCheck.exports);

var _createClass2 = _interopRequireDefault(createClass.exports);

var _defineProperty2 = _interopRequireDefault(defineProperty.exports);

var _SolidityCompilerWorker = _interopRequireDefault(require$$4);

var _ContractsInFileStorage = _interopRequireDefault(require$$5);

// @ts-ignore: Provided by bundler
// Note: keep this as a js extension. Babel doesn't map this to a js automatically.
//       That's ok since it's not meant to be executed directy anyway.
// @ts-ignore: Provided by bundler

/* eslint-disable no-undef */
var VIRTUAL_SOURCE_CONTRACT_FILE_NAME = "__contract__.sol";
VIRTUAL_SOURCE_CONTRACT_FILE_NAME_1 = SolidityCompiler$1.VIRTUAL_SOURCE_CONTRACT_FILE_NAME = VIRTUAL_SOURCE_CONTRACT_FILE_NAME;
var compilerWorker = null;
var hasCompilerLoaded = false;

function triggerCompile(code) {
  var solInput = {
    language: "Solidity",
    settings: {
      metadata: {
        // disabling metadata hash embedding to make the bytecode generation predictable at test-time
        // see https://docs.soliditylang.org/en/latest/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode
        bytecodeHash: "ipfs"
      },
      outputSelection: {
        "*": {
          "*": ["*"]
        }
      }
    },
    sources: (0, _defineProperty2["default"])({}, VIRTUAL_SOURCE_CONTRACT_FILE_NAME, {
      content: code
    })
  };

  if (!compilerWorker) {
    throw new Error("First initialize the compile web-worker.");
  }

  compilerWorker.postMessage({
    payload: JSON.stringify(solInput),
    type: "compile"
  });
}

var SolidityCompiler = /*#__PURE__*/function () {
  function SolidityCompiler() {
    (0, _classCallCheck2["default"])(this, SolidityCompiler);
  }

  (0, _createClass2["default"])(SolidityCompiler, null, [{
    key: "compile",
    value: function compile(_ref) {
      var code = _ref.code,
          path = _ref.path;

      if (!window.Worker) {
        throw new Error("Your browser does not support WebWorkers therefore Contract compilation is not available.");
      }

      if (path !== undefined) {
        if (path.startsWith("..")) {
          throw new Error("Cannot load contracts which are outside the bundled designated folder from which the 'ContractsInFileStorage' is constructed.");
        } else if (path.startsWith("./")) {
          path = path.substring(2);
        }

        if (_ContractsInFileStorage["default"][path] !== undefined) {
          code = _ContractsInFileStorage["default"][path];
        } else if (!code || path !== undefined) {
          throw new Error("Only direct code compilation is fully supported by the browser at this point. Path loading is limited to the pre-bundled contracts stored in 'ContractsInFileStorage'.");
        }
      }

      if (!compilerWorker) {
        compilerWorker = new _SolidityCompilerWorker["default"]();
      } else {
        triggerCompile(code);
      }

      return new Promise(function (accept, reject) {
        compilerWorker.onmessage = function (_ref2) {
          var data = _ref2.data;

          if (data.type === "compile_result") {
            accept(data.payload);
          } else if (data.type === "loaded" || hasCompilerLoaded) {
            hasCompilerLoaded = true;
            triggerCompile(code);
            return;
          } else {
            console.log("Unhandled message received from web-worker:", data);
          }
        };

        compilerWorker.onerror = function (e) {
          reject(e);
        };
      });
    }
  }]);
  return SolidityCompiler;
}();

var SolidityCompiler_2 = SolidityCompiler$1.SolidityCompiler = SolidityCompiler;

class CompileIssues extends Error {
  static tryThrowingIfErrorsIn({
    compileResult = null,
    ignoreWarnings = true
  }) {
    if (null != compileResult && Array.isArray(compileResult.errors)) {
      const issuesReported = compileResult.errors.filter(err => ignoreWarnings && err.type !== 'Warning' || !ignoreWarnings);

      if (issuesReported.length != 0) {
        throw new CompileIssues(issuesReported);
      }
    }
  }

  static _listOfSimpleIssueMessagesFor(rawIssues) {
    return rawIssues.map(rIssue => `[ ${rIssue.sourceLocation.start}:${rIssue.sourceLocation.end} ] ${rIssue.message}`);
  }
  /**
   * @private
   */


  constructor(issues) {
    super(`There are issues with the contract code:\n${CompileIssues._listOfSimpleIssueMessagesFor(issues).join('\n')}`);
    this.issues = issues;
  }

}

/**
 * The Solidity-backed, non-deployed, data-holder for a Smart Contract logic.
 */
class Contract extends BasicUploadableEntity {
  /**
   * Given an index or a name, this returns a specific {@link Contract} following the successful compilation of 
   * either the contract code itself ({@link options.code}) or the solidity file located at the provided {@link options.path}
   * 
   * In terms of precedence, it first checks to see if the {@link options.name} is provided and, if so, it uses that otherwise
   * it looks at the {@link options.index} one and goes with that.
   * 
   * @param {Object} options - Provides a source and controls various {@see Contract} construction settings
   * @returns {Promise<Contract>}
   */
  static async newFrom({
    code,
    index = 0,
    ignoreWarnings = false,
    name,
    path
  }) {
    if (!code && !path) {
      throw new Error("In order to continue, either provide the direct solidity code or a file path where the top-level code resides.");
    }

    if (!name && (!!index || Number.isInteger(index) && index < 0)) {
      throw new Error("Please provide either a non-negative index or the actual name of the contract to reference the Contract instance with.");
    }

    const contracts = await Contract.allFrom({
      code,
      ignoreWarnings,
      path
    });

    if (name) {
      const contractOfInterest = contracts.find(contract => contract.name === name);

      if (!contractOfInterest) {
        throw new Error(`There is no such contract named '${name}' present in the referenced code.`);
      }

      return contractOfInterest;
    } else if (index >= contracts.length) {
      throw new Error(`Index out of range. Your requested contract-id ${index} is not in range of the ${contracts.length} contracts present in the given code.`);
    }

    return contracts[index];
  }
  /**
   * Returns all the contracts present in the given 'options' (either from 'path' or from 'code').
   * 
   * @param {Object} options - Provides a source and controls various {@see Contract} construction settings.
   * @returns {Promise<Array<Contract>>} - A list of {@link Contract}s parsed via Hedera's officially supported solidity version compiler (`solc`) from the code
   */


  static async allFrom({
    code,
    ignoreWarnings = false,
    path
  }) {
    if (!code && !path) {
      throw new Error("Can only retrieve contracts if either the direct solidity code is provided or a file path where that top-level code resides.");
    }

    const rawCompileResult = await SolidityCompiler_2.compile({
      code,
      path
    });

    const compileResult = Contract._tryParsingCompileResultFrom({
      ignoreWarnings,
      rawCompileResult
    });

    const compiledContractsInfo = compileResult.contracts[VIRTUAL_SOURCE_CONTRACT_FILE_NAME_1];
    const contracts = [];

    for (const contractName of Object.keys(compiledContractsInfo)) {
      const solo = compiledContractsInfo[contractName];
      contracts.push(new Contract({
        abi: solo.abi,
        byteCode: solo.evm.bytecode.object,
        name: contractName
      }));
    }

    return contracts;
  }
  /**
   * Deserializes the provided Contract representation which is assumed to be the output of the {@link Contract.serialize} method call.
   */


  static deserialize(what) {
    let jWhat = {};

    try {
      jWhat = JSON.parse(what);
    } catch (e) {
      throw new Error("Please provide something valid to be deserialized.");
    }

    return new Contract(jWhat);
  }

  static _tryParsingCompileResultFrom({
    rawCompileResult,
    ignoreWarnings
  }) {
    const compileResult = JSON.parse(rawCompileResult);
    CompileIssues.tryThrowingIfErrorsIn({
      compileResult,
      ignoreWarnings
    });
    return compileResult;
  }
  /**
   * The name of the referenced Solidity contract. 
   * Note: this can be different then the source-file used to host it.
   */


  constructor({
    name,
    abi,
    byteCode
  }) {
    if (!name) {
      throw new Error("Please provide a name for the Contract instance.");
    } else if (!abi) {
      throw new Error("Please provide a, valid, EthersProject-compatible, ABI definition for the Contract instance.");
    } else if (typeof byteCode === 'string' && byteCode.length !== 0) {
      if (/.*__\$.*\$__.*/.test(byteCode)) {
        throw new Error("Library linking is not currently supported. Please follow issue #38 for more info.");
      } else if (!/^[0-9a-f]+$/.test(byteCode)) {
        throw new Error("Please provide the valid formatted byte-code definition for the Contract in order to instantiate it.");
      }
    } else ;

    super(`${name}-Contract`);
    this.name = name;
    this.byteCode = byteCode;
    this.interface = new Interface(abi);
  }
  /**
   * Tests if this contract is the same (functionally speaking) as another one.
   */


  equals(other) {
    if (other instanceof Contract === false) {
      return false;
    }

    const thisFragments = this.interface.fragments;
    const otherFragments = other.interface.fragments;

    if (thisFragments.length !== otherFragments.length) {
      return false;
    }

    let areAbisTheSame = true;

    for (const thisFragment of thisFragments) {
      if (!otherFragments.find(otherFragment => otherFragment.format() === thisFragment.format())) {
        areAbisTheSame = false;
        break;
      }
    }

    return this.byteCode === other.byteCode && areAbisTheSame;
  }
  /**
   * Serializes the current entity. This then can be reversed via calling {@link Contract.deserialize}.
   * 
   * Note: when de-serializing, the properties exported here should allow for a complete re-instantiation of the original {@link Contract}. 
   * 
   * @returns {string} - The serialized representation of the current instance
   */


  serialize() {
    return JSON.stringify({
      abi: this.interface.format(),
      byteCode: this.byteCode,
      name: this.name
    });
  }

  async getContent() {
    if (!this.byteCode) {
      throw new Error("Won't upload contract to network because it's lacking the required byte-code data.");
    }

    return this.byteCode;
  }
  /**
   * Having a file-create {@link receipt} provided, this function uses it to create a contract via the Hedera Contract Service (HCS). The provided {@link args}
   * are used both to populate the {@link ContractCreateTransaction} constructor (if the first object from the list has a '_contract' property) and to pass along
   * as constructor arguments when publishing the Contract. 
   * If there is a constructor config object present (first args from list if it has the '_contract' property) this is consumed and the remainder of the arguments 
   * are passed to the Contract constructor.
   */


  async onFileUploaded({
    session,
    receipt,
    args = []
  }) {
    const {
      createContractOptions,
      emitConstructorLogs
    } = await this._getContractCreateOptionsFor({
      args,
      receipt,
      session
    });
    const createContractTransaction = new ContractCreateTransaction(createContractOptions);
    return await LiveContract.newFollowingUpload({
      contract: this,
      emitConstructorLogs,
      session,
      transaction: createContractTransaction
    });
  }

  async _getContractCreateOptionsFor({
    session,
    receipt,
    args = []
  }) {
    const contractFileId = receipt.fileId;
    const constructorDefinition = this.interface.deploy;
    let contractCreationOverrides = {};
    let emitConstructorLogs = session.defaults.emitConstructorLogs;

    if (args.length > 0 && Object.keys(args[0]).length !== 0 && Object.keys(args[0])[0] === '_contract') {
      const contractCreationArgs = args[0]._contract; // try locking onto library-controlling behaviour flags

      emitConstructorLogs = contractCreationArgs.emitConstructorLogs !== undefined ? contractCreationArgs.emitConstructorLogs : emitConstructorLogs;
      delete contractCreationArgs.emitConstructorLogs; // consider everything else as contract-creation constructor arguments

      contractCreationOverrides = contractCreationArgs;
      args = args.slice(1);
    }

    return {
      createContractOptions: Object.assign({}, {
        adminKey: session.wallet.account.publicKey,
        bytecodeFileId: contractFileId,
        constructorParameters: await ContractFunctionParameters.newFor(constructorDefinition, args),
        gas: session.defaults.contractCreationGas,
        ...contractCreationOverrides
      }),
      emitConstructorLogs
    };
  }

}

var _hederaStrato_ContractRegistry = {
    "HelloWorld": ["function greet() view returns (string)"]
  };

export { AVAILABLE_NETWORK_NAMES, Account, ApiSession, Contract, _hederaStrato_ContractRegistry as ContractRegistry, File, HEDERA_CUSTOM_NET_NAME, HederaNetwork, Json, KeyType, LiveAccount, LiveAccountWithPrivateKey, LiveContract, LiveContractWithLogs, LiveFile, LiveJson, LiveToken, LiveTopic, Token, TokenType, TokenTypes, Topic, TypeOfExecutionReturn };
//# sourceMappingURL=hedera-strato.js.map
